#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Fri Feb 22 20:59:45 2019 by generateDS.py version 2.29.25.
# Python 2.7.3 (default, Oct 26 2016, 21:01:49)  [GCC 4.6.3]
#
# Command line options:
#   ('-m', '')
#   ('-f', '')
#   ('--always-export-default', '')
#   ('--export', 'write literal etree')
#   ('-u', 'core_ui.user_methods')
#   ('-p', 'create')
#   ('--post-attrib-setter', "update_node(self,self.troot,'directions')")
#   ('--pre-ctor', "self.troot=get_gs_troot('directions','{classname}')")
#   ('--post-ctor', "update_node(self,self.troot,'directions')")
#   ('--imports', 'from pytools4dart.core_ui.utils import get_gs_troot, update_node, get_path, findpaths, subpaths, set_nodes')
#   ('-o', '/media/DATA/Florian/IRSTEA/Scripts/pytools4dartMTD/pytools4dart/core_ui/directions.py')
#
# Command line arguments:
#   /media/DATA/Florian/IRSTEA/Scripts/pytools4dartMTD/pytools4dart/xsdschemas/directions.xsd
#
# Command line:
#   /media/DATA/Florian/IRSTEA/Scripts/pytools4dartMTD/venv/bin/generateDS.py -m -f --always-export-default --export="write literal etree" -u "core_ui.user_methods" -p "create" --post-attrib-setter="update_node(self,self.troot,'directions')" --pre-ctor="self.troot=get_gs_troot('directions','{classname}')" --post-ctor="update_node(self,self.troot,'directions')" --imports="from pytools4dart.core_ui.utils import get_gs_troot, update_node, get_path, findpaths, subpaths, set_nodes" -o "/media/DATA/Florian/IRSTEA/Scripts/pytools4dartMTD/pytools4dart/core_ui/directions.py" /media/DATA/Florian/IRSTEA/Scripts/pytools4dartMTD/pytools4dart/xsdschemas/directions.xsd
#
# Current working directory (os.getcwd()):
#   pytools4dart
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_
from pytools4dart.core_ui.utils import get_gs_troot, update_node, get_path, findpaths, subpaths, set_nodes


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#

def checkclass(value, cl):
    if isinstance(value, list):
        for v in value:
            if not isinstance(v, cl):
                raise ValueError("invalid class")
    else:
        if not isinstance(value, cl):
            raise ValueError("invalid class")

def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class createDartFile(GeneratedsSuper):
    """Version of the plots.xml file. Depends of the version on DART
    itself. Version of the plots.xml file. Depends of the version on
    DART itself."""
    member_data_items_ = [
        MemberSpec_('version', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('build_', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('Directions', '_Directions', 0, 0, {u'maxOccurs': u'1', u'type': u'_Directions', u'name': u'Directions', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, version='5.7.4', build_='0', Directions=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('directions','DartFile')
        self.attrib = ['version', 'build_']
        self.children = ['Directions']
        self.parent = None
        self._version = _cast(None, version)
        self._build_ = _cast(None, build_)
        self._Directions = Directions
        update_node(self,self.troot,'directions')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, createDartFile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if createDartFile.subclass:
            return createDartFile.subclass(*args_, **kwargs_)
        else:
            return createDartFile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Directions(self): return self._Directions
    def set_Directions(self, value):
        if value is not None:
            checkclass(value, create_Directions)
            value.parent = self
        self._Directions = value
    Directions = property(get_Directions, set_Directions)
    def get_version(self): return self._version
    def set_version(self, value):
        self._version = value
        update_node(self,self.troot,'directions')
    version = property(get_version, set_version)
    def get_build(self): return self._build_
    def set_build(self, value):
        self._build_ = value
        update_node(self,self.troot,'directions')
    build_ = property(get_build, set_build)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Directions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='DartFile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DartFile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DartFile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='DartFile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DartFile'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
        if self.build_ is not None and 'build_' not in already_processed:
            already_processed.add('build_')
            outfile.write(' build=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.build_), input_name='build')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='DartFile', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Directions is not None:
            self.Directions.export(outfile, level, namespaceprefix_, name_='Directions', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='DartFile', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.version is not None:
            element.set('version', self.gds_format_string(self.version))
        if self.build_ is not None:
            element.set('build', self.gds_format_string(self.build_))
        if self.Directions is not None:
            Directions_ = self.Directions
            Directions_.to_etree(element, name_='Directions', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='DartFile'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.build_ is not None and 'build_' not in already_processed:
            already_processed.add('build_')
            showIndent(outfile, level)
            outfile.write('build_="%s",\n' % (self.build_,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Directions is not None:
            showIndent(outfile, level)
            outfile.write('Directions=model_._Directions(\n')
            self.Directions.exportLiteral(outfile, level, name_='Directions')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('build', node)
        if value is not None and 'build' not in already_processed:
            already_processed.add('build')
            self.build_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Directions':
            obj_ = create_Directions.factory()
            obj_.build(child_)
            self.set_Directions(obj_)
            obj_.original_tagname_ = 'Directions'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class createDartFile


class create_Directions(GeneratedsSuper):
    """Cosine Weighted Cosine Weighted Approximate number of directions
    that sample the 4.Pi space Approximate number of directions that
    sample the 4.Pi space DART provides 3 way to indicate the sun
    angles:\nBy giving the Downward Solar Angles (Sun to Ground)\nBy
    giving the Viewing Solar Angle (Ground to Sun)\nSolar angles
    calculated from the localisation of the scene (longitude and
    latitude) and the exact (local) date (YY/MM/DD and HH/MM/SS)
    DART provides 3 way to indicate the sun angles:\nBy giving the
    Downward Solar Angles (Sun to Ground)\nBy giving the Viewing
    Solar Angle (Ground to Sun)\nSolar angles calculated from the
    localisation of the scene (longitude and latitude) and the exact
    (local) date (YY/MM/DD and HH/MM/SS)"""
    member_data_items_ = [
        MemberSpec_('ifCosWeighted', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('numberOfPropagationDirections', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('exactDate', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('AddedDirections', '_AddedDirections', 1, 1, {u'maxOccurs': u'unbounded', u'type': u'_AddedDirections', u'name': u'AddedDirections', u'minOccurs': u'0'}, None),
        MemberSpec_('Region', '_Region', 1, 1, {u'maxOccurs': u'unbounded', u'type': u'_Region', u'name': u'Region', u'minOccurs': u'0'}, None),
        MemberSpec_('OversampledPlane', '_OversampledPlane', 1, 1, {u'maxOccurs': u'unbounded', u'type': u'_OversampledPlane', u'name': u'OversampledPlane', u'minOccurs': u'0'}, None),
        MemberSpec_('Sun', '_Sun', 0, 0, {u'maxOccurs': u'1', u'type': u'_Sun', u'name': u'Sun', u'minOccurs': u'1'}, None),
        MemberSpec_('ExactDateHour', '_ExactDateHour', 0, 0, {u'maxOccurs': u'1', u'type': u'_ExactDateHour', u'name': u'ExactDateHour', u'minOccurs': u'1'}, None),
        MemberSpec_('SunViewingAngles', '_SunViewingAngles', 0, 0, {u'maxOccurs': u'1', u'type': u'_SunViewingAngles', u'name': u'SunViewingAngles', u'minOccurs': u'1'}, None),
        MemberSpec_('HotSpotProperties', '_HotSpotProperties', 0, 0, {u'maxOccurs': u'1', u'type': u'_HotSpotProperties', u'name': u'HotSpotProperties', u'minOccurs': u'1'}, None),
        MemberSpec_('Penumbra', '_Penumbra', 0, 0, {u'maxOccurs': u'1', u'type': u'_Penumbra', u'name': u'Penumbra', u'minOccurs': u'1'}, None),
        MemberSpec_('AzimuthalOffset', '_AzimuthalOffset', 0, 0, {u'maxOccurs': u'1', u'type': u'_AzimuthalOffset', u'name': u'AzimuthalOffset', u'minOccurs': u'1'}, None),
        MemberSpec_('ExpertModeZone', '_ExpertModeZone', 0, 0, {u'maxOccurs': u'1', u'type': u'_ExpertModeZone', u'name': u'ExpertModeZone', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ifCosWeighted=0, numberOfPropagationDirections=100, exactDate=2, AddedDirections=None, Region=None, OversampledPlane=None, Sun=None, ExactDateHour=None, SunViewingAngles=None, HotSpotProperties=None, Penumbra=None, AzimuthalOffset=None, ExpertModeZone=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('directions','_Directions')
        self.attrib = ['ifCosWeighted', 'numberOfPropagationDirections', 'exactDate']
        self.children = ['AddedDirections', 'Region', 'OversampledPlane', 'Sun', 'ExactDateHour', 'SunViewingAngles', 'HotSpotProperties', 'Penumbra', 'AzimuthalOffset', 'ExpertModeZone']
        self.parent = None
        self._ifCosWeighted = _cast(int, ifCosWeighted)
        self._numberOfPropagationDirections = _cast(int, numberOfPropagationDirections)
        self._exactDate = _cast(int, exactDate)
        if AddedDirections is None:
            self._AddedDirections = []
        else:
            self._AddedDirections = AddedDirections
        if Region is None:
            self._Region = []
        else:
            self._Region = Region
        if OversampledPlane is None:
            self._OversampledPlane = []
        else:
            self._OversampledPlane = OversampledPlane
        self._Sun = Sun
        self._ExactDateHour = ExactDateHour
        self._SunViewingAngles = SunViewingAngles
        self._HotSpotProperties = HotSpotProperties
        self._Penumbra = Penumbra
        self._AzimuthalOffset = AzimuthalOffset
        self._ExpertModeZone = ExpertModeZone
        update_node(self,self.troot,'directions')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Directions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Directions.subclass:
            return create_Directions.subclass(*args_, **kwargs_)
        else:
            return create_Directions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AddedDirections(self): return self._AddedDirections
    def set_AddedDirections(self, value):
        if value is not None:
            checkclass(value, create_AddedDirections)
            for v in value:
                v.parent = self
        self._AddedDirections = value
    def add_AddedDirections(self, value):
        value.parent = self
        self._AddedDirections.append(value)
    def insert_AddedDirections_at(self, index, value):
        value.parent = self
        self.AddedDirections.insert(index, value)
    def replace_AddedDirections_at(self, index, value):
        value.parent = self
        self.AddedDirections[index] = value
    AddedDirections = property(get_AddedDirections, set_AddedDirections)
    def get_Region(self): return self._Region
    def set_Region(self, value):
        if value is not None:
            checkclass(value, create_Region)
            for v in value:
                v.parent = self
        self._Region = value
    def add_Region(self, value):
        value.parent = self
        self._Region.append(value)
    def insert_Region_at(self, index, value):
        value.parent = self
        self.Region.insert(index, value)
    def replace_Region_at(self, index, value):
        value.parent = self
        self.Region[index] = value
    Region = property(get_Region, set_Region)
    def get_OversampledPlane(self): return self._OversampledPlane
    def set_OversampledPlane(self, value):
        if value is not None:
            checkclass(value, create_OversampledPlane)
            for v in value:
                v.parent = self
        self._OversampledPlane = value
    def add_OversampledPlane(self, value):
        value.parent = self
        self._OversampledPlane.append(value)
    def insert_OversampledPlane_at(self, index, value):
        value.parent = self
        self.OversampledPlane.insert(index, value)
    def replace_OversampledPlane_at(self, index, value):
        value.parent = self
        self.OversampledPlane[index] = value
    OversampledPlane = property(get_OversampledPlane, set_OversampledPlane)
    def get_Sun(self): return self._Sun
    def set_Sun(self, value):
        if value is not None:
            checkclass(value, create_Sun)
            value.parent = self
        self._Sun = value
    Sun = property(get_Sun, set_Sun)
    def get_ExactDateHour(self): return self._ExactDateHour
    def set_ExactDateHour(self, value):
        if value is not None:
            checkclass(value, create_ExactDateHour)
            value.parent = self
        self._ExactDateHour = value
    ExactDateHour = property(get_ExactDateHour, set_ExactDateHour)
    def get_SunViewingAngles(self): return self._SunViewingAngles
    def set_SunViewingAngles(self, value):
        if value is not None:
            checkclass(value, create_SunViewingAngles)
            value.parent = self
        self._SunViewingAngles = value
    SunViewingAngles = property(get_SunViewingAngles, set_SunViewingAngles)
    def get_HotSpotProperties(self): return self._HotSpotProperties
    def set_HotSpotProperties(self, value):
        if value is not None:
            checkclass(value, create_HotSpotProperties)
            value.parent = self
        self._HotSpotProperties = value
    HotSpotProperties = property(get_HotSpotProperties, set_HotSpotProperties)
    def get_Penumbra(self): return self._Penumbra
    def set_Penumbra(self, value):
        if value is not None:
            checkclass(value, create_Penumbra)
            value.parent = self
        self._Penumbra = value
    Penumbra = property(get_Penumbra, set_Penumbra)
    def get_AzimuthalOffset(self): return self._AzimuthalOffset
    def set_AzimuthalOffset(self, value):
        if value is not None:
            checkclass(value, create_AzimuthalOffset)
            value.parent = self
        self._AzimuthalOffset = value
    AzimuthalOffset = property(get_AzimuthalOffset, set_AzimuthalOffset)
    def get_ExpertModeZone(self): return self._ExpertModeZone
    def set_ExpertModeZone(self, value):
        if value is not None:
            checkclass(value, create_ExpertModeZone)
            value.parent = self
        self._ExpertModeZone = value
    ExpertModeZone = property(get_ExpertModeZone, set_ExpertModeZone)
    def get_ifCosWeighted(self): return self._ifCosWeighted
    def set_ifCosWeighted(self, value):
        self._ifCosWeighted = value
        update_node(self,self.troot,'directions')
    ifCosWeighted = property(get_ifCosWeighted, set_ifCosWeighted)
    def get_numberOfPropagationDirections(self): return self._numberOfPropagationDirections
    def set_numberOfPropagationDirections(self, value):
        self._numberOfPropagationDirections = value
        update_node(self,self.troot,'directions')
    numberOfPropagationDirections = property(get_numberOfPropagationDirections, set_numberOfPropagationDirections)
    def get_exactDate(self): return self._exactDate
    def set_exactDate(self, value):
        self._exactDate = value
        update_node(self,self.troot,'directions')
    exactDate = property(get_exactDate, set_exactDate)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.AddedDirections or
            self.Region or
            self.OversampledPlane or
            self.Sun is not None or
            self.ExactDateHour is not None or
            self.SunViewingAngles is not None or
            self.HotSpotProperties is not None or
            self.Penumbra is not None or
            self.AzimuthalOffset is not None or
            self.ExpertModeZone is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Directions', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Directions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Directions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Directions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Directions'):
        if self.ifCosWeighted is not None and 'ifCosWeighted' not in already_processed:
            already_processed.add('ifCosWeighted')
            outfile.write(' ifCosWeighted="%s"' % self.gds_format_integer(self.ifCosWeighted, input_name='ifCosWeighted'))
        if self.numberOfPropagationDirections is not None and 'numberOfPropagationDirections' not in already_processed:
            already_processed.add('numberOfPropagationDirections')
            outfile.write(' numberOfPropagationDirections="%s"' % self.gds_format_integer(self.numberOfPropagationDirections, input_name='numberOfPropagationDirections'))
        if self.exactDate is not None and 'exactDate' not in already_processed:
            already_processed.add('exactDate')
            outfile.write(' exactDate="%s"' % self.gds_format_integer(self.exactDate, input_name='exactDate'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Directions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AddedDirections_ in self.AddedDirections:
            AddedDirections_.export(outfile, level, namespaceprefix_, name_='AddedDirections', pretty_print=pretty_print)
        for Region_ in self.Region:
            Region_.export(outfile, level, namespaceprefix_, name_='Region', pretty_print=pretty_print)
        for OversampledPlane_ in self.OversampledPlane:
            OversampledPlane_.export(outfile, level, namespaceprefix_, name_='OversampledPlane', pretty_print=pretty_print)
        if self.Sun is not None:
            self.Sun.export(outfile, level, namespaceprefix_, name_='Sun', pretty_print=pretty_print)
        if self.ExactDateHour is not None:
            self.ExactDateHour.export(outfile, level, namespaceprefix_, name_='ExactDateHour', pretty_print=pretty_print)
        if self.SunViewingAngles is not None:
            self.SunViewingAngles.export(outfile, level, namespaceprefix_, name_='SunViewingAngles', pretty_print=pretty_print)
        if self.HotSpotProperties is not None:
            self.HotSpotProperties.export(outfile, level, namespaceprefix_, name_='HotSpotProperties', pretty_print=pretty_print)
        if self.Penumbra is not None:
            self.Penumbra.export(outfile, level, namespaceprefix_, name_='Penumbra', pretty_print=pretty_print)
        if self.AzimuthalOffset is not None:
            self.AzimuthalOffset.export(outfile, level, namespaceprefix_, name_='AzimuthalOffset', pretty_print=pretty_print)
        if self.ExpertModeZone is not None:
            self.ExpertModeZone.export(outfile, level, namespaceprefix_, name_='ExpertModeZone', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Directions', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ifCosWeighted is not None:
            element.set('ifCosWeighted', self.gds_format_integer(self.ifCosWeighted))
        if self.numberOfPropagationDirections is not None:
            element.set('numberOfPropagationDirections', self.gds_format_integer(self.numberOfPropagationDirections))
        if self.exactDate is not None:
            element.set('exactDate', self.gds_format_integer(self.exactDate))
        for AddedDirections_ in self.AddedDirections:
            AddedDirections_.to_etree(element, name_='AddedDirections', mapping_=mapping_)
        for Region_ in self.Region:
            Region_.to_etree(element, name_='Region', mapping_=mapping_)
        for OversampledPlane_ in self.OversampledPlane:
            OversampledPlane_.to_etree(element, name_='OversampledPlane', mapping_=mapping_)
        if self.Sun is not None:
            Sun_ = self.Sun
            Sun_.to_etree(element, name_='Sun', mapping_=mapping_)
        if self.ExactDateHour is not None:
            ExactDateHour_ = self.ExactDateHour
            ExactDateHour_.to_etree(element, name_='ExactDateHour', mapping_=mapping_)
        if self.SunViewingAngles is not None:
            SunViewingAngles_ = self.SunViewingAngles
            SunViewingAngles_.to_etree(element, name_='SunViewingAngles', mapping_=mapping_)
        if self.HotSpotProperties is not None:
            HotSpotProperties_ = self.HotSpotProperties
            HotSpotProperties_.to_etree(element, name_='HotSpotProperties', mapping_=mapping_)
        if self.Penumbra is not None:
            Penumbra_ = self.Penumbra
            Penumbra_.to_etree(element, name_='Penumbra', mapping_=mapping_)
        if self.AzimuthalOffset is not None:
            AzimuthalOffset_ = self.AzimuthalOffset
            AzimuthalOffset_.to_etree(element, name_='AzimuthalOffset', mapping_=mapping_)
        if self.ExpertModeZone is not None:
            ExpertModeZone_ = self.ExpertModeZone
            ExpertModeZone_.to_etree(element, name_='ExpertModeZone', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Directions'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ifCosWeighted is not None and 'ifCosWeighted' not in already_processed:
            already_processed.add('ifCosWeighted')
            showIndent(outfile, level)
            outfile.write('ifCosWeighted=%d,\n' % (self.ifCosWeighted,))
        if self.numberOfPropagationDirections is not None and 'numberOfPropagationDirections' not in already_processed:
            already_processed.add('numberOfPropagationDirections')
            showIndent(outfile, level)
            outfile.write('numberOfPropagationDirections=%d,\n' % (self.numberOfPropagationDirections,))
        if self.exactDate is not None and 'exactDate' not in already_processed:
            already_processed.add('exactDate')
            showIndent(outfile, level)
            outfile.write('exactDate=%d,\n' % (self.exactDate,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('AddedDirections=[\n')
        level += 1
        for AddedDirections_ in self.AddedDirections:
            showIndent(outfile, level)
            outfile.write('model_._AddedDirections(\n')
            AddedDirections_.exportLiteral(outfile, level, name_='_AddedDirections')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Region=[\n')
        level += 1
        for Region_ in self.Region:
            showIndent(outfile, level)
            outfile.write('model_._Region(\n')
            Region_.exportLiteral(outfile, level, name_='_Region')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('OversampledPlane=[\n')
        level += 1
        for OversampledPlane_ in self.OversampledPlane:
            showIndent(outfile, level)
            outfile.write('model_._OversampledPlane(\n')
            OversampledPlane_.exportLiteral(outfile, level, name_='_OversampledPlane')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Sun is not None:
            showIndent(outfile, level)
            outfile.write('Sun=model_._Sun(\n')
            self.Sun.exportLiteral(outfile, level, name_='Sun')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ExactDateHour is not None:
            showIndent(outfile, level)
            outfile.write('ExactDateHour=model_._ExactDateHour(\n')
            self.ExactDateHour.exportLiteral(outfile, level, name_='ExactDateHour')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SunViewingAngles is not None:
            showIndent(outfile, level)
            outfile.write('SunViewingAngles=model_._SunViewingAngles(\n')
            self.SunViewingAngles.exportLiteral(outfile, level, name_='SunViewingAngles')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HotSpotProperties is not None:
            showIndent(outfile, level)
            outfile.write('HotSpotProperties=model_._HotSpotProperties(\n')
            self.HotSpotProperties.exportLiteral(outfile, level, name_='HotSpotProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Penumbra is not None:
            showIndent(outfile, level)
            outfile.write('Penumbra=model_._Penumbra(\n')
            self.Penumbra.exportLiteral(outfile, level, name_='Penumbra')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AzimuthalOffset is not None:
            showIndent(outfile, level)
            outfile.write('AzimuthalOffset=model_._AzimuthalOffset(\n')
            self.AzimuthalOffset.exportLiteral(outfile, level, name_='AzimuthalOffset')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ExpertModeZone is not None:
            showIndent(outfile, level)
            outfile.write('ExpertModeZone=model_._ExpertModeZone(\n')
            self.ExpertModeZone.exportLiteral(outfile, level, name_='ExpertModeZone')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.AddedDirections = []
        self.Region = []
        self.OversampledPlane = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ifCosWeighted', node)
        if value is not None and 'ifCosWeighted' not in already_processed:
            already_processed.add('ifCosWeighted')
            try:
                self.ifCosWeighted = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('numberOfPropagationDirections', node)
        if value is not None and 'numberOfPropagationDirections' not in already_processed:
            already_processed.add('numberOfPropagationDirections')
            try:
                self.numberOfPropagationDirections = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('exactDate', node)
        if value is not None and 'exactDate' not in already_processed:
            already_processed.add('exactDate')
            try:
                self.exactDate = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AddedDirections':
            obj_ = create_AddedDirections.factory()
            obj_.build(child_)
            self.add_AddedDirections(obj_)
            obj_.original_tagname_ = 'AddedDirections'
        elif nodeName_ == 'Region':
            obj_ = create_Region.factory()
            obj_.build(child_)
            self.add_Region(obj_)
            obj_.original_tagname_ = 'Region'
        elif nodeName_ == 'OversampledPlane':
            obj_ = create_OversampledPlane.factory()
            obj_.build(child_)
            self.add_OversampledPlane(obj_)
            obj_.original_tagname_ = 'OversampledPlane'
        elif nodeName_ == 'Sun':
            obj_ = create_Sun.factory()
            obj_.build(child_)
            self.set_Sun(obj_)
            obj_.original_tagname_ = 'Sun'
        elif nodeName_ == 'ExactDateHour':
            obj_ = create_ExactDateHour.factory()
            obj_.build(child_)
            self.set_ExactDateHour(obj_)
            obj_.original_tagname_ = 'ExactDateHour'
        elif nodeName_ == 'SunViewingAngles':
            obj_ = create_SunViewingAngles.factory()
            obj_.build(child_)
            self.set_SunViewingAngles(obj_)
            obj_.original_tagname_ = 'SunViewingAngles'
        elif nodeName_ == 'HotSpotProperties':
            obj_ = create_HotSpotProperties.factory()
            obj_.build(child_)
            self.set_HotSpotProperties(obj_)
            obj_.original_tagname_ = 'HotSpotProperties'
        elif nodeName_ == 'Penumbra':
            obj_ = create_Penumbra.factory()
            obj_.build(child_)
            self.set_Penumbra(obj_)
            obj_.original_tagname_ = 'Penumbra'
        elif nodeName_ == 'AzimuthalOffset':
            obj_ = create_AzimuthalOffset.factory()
            obj_.build(child_)
            self.set_AzimuthalOffset(obj_)
            obj_.original_tagname_ = 'AzimuthalOffset'
        elif nodeName_ == 'ExpertModeZone':
            obj_ = create_ExpertModeZone.factory()
            obj_.build(child_)
            self.set_ExpertModeZone(obj_)
            obj_.original_tagname_ = 'ExpertModeZone'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_Directions


class create_AddedDirections(GeneratedsSuper):
    """If checked, images will be systematically generated in this
    direction, unless images production has been totally disable in
    the product tab. If checked, images will be systematically
    generated in this direction, unless images production has been
    totally disable in the product tab. The shape used to described
    the opening of the direction cone The shape used to described
    the opening of the direction cone To enter directly the angles
    of the direction, choose "Zenith+Azimuth".\nDart is also able to
    automaticaly determinate the angles of a direction given the
    LatLon coordinates of the (theorical) sensor and the scene,
    while taking in account the curves of the Earth.\nTo do this,
    choose "LatLon Coordinates". To enter directly the angles of the
    direction, choose "Zenith+Azimuth".\nDart is also able to
    automaticaly determinate the angles of a direction given the
    LatLon coordinates of the (theorical) sensor and the scene,
    while taking in account the curves of the Earth.\nTo do this,
    choose "LatLon Coordinates". The oversampling directions are
    used only in the calculation of phase functions, which in DART
    module, are used to increase the directional sampling for
    selection of instant directional phase function during
    scattering event. The directions are essentially virtual. The
    oversampling directions are used only in the calculation of
    phase functions, which in DART module, are used to increase the
    directional sampling for selection of instant directional phase
    function during scattering event. The directions are essentially
    virtual."""
    member_data_items_ = [
        MemberSpec_('imageDirection', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('ifSquareShape', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('directionType', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('ifPhaseOnly', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('ZenithAzimuth', '_ZenithAzimuth', 0, 0, {u'maxOccurs': u'1', u'type': u'_ZenithAzimuth', u'name': u'ZenithAzimuth', u'minOccurs': u'1'}, None),
        MemberSpec_('LatLon', '_LatLon', 0, 0, {u'maxOccurs': u'1', u'type': u'_LatLon', u'name': u'LatLon', u'minOccurs': u'1'}, None),
        MemberSpec_('Rectangle', '_Rectangle', 0, 0, {u'maxOccurs': u'1', u'type': u'_Rectangle', u'name': u'Rectangle', u'minOccurs': u'1'}, None),
        MemberSpec_('Square', '_Square', 0, 0, {u'maxOccurs': u'1', u'type': u'_Square', u'name': u'Square', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, imageDirection=1, ifSquareShape=1, directionType=0, ifPhaseOnly=0, ZenithAzimuth=None, LatLon=None, Rectangle=None, Square=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('directions','_AddedDirections')
        self.attrib = ['imageDirection', 'ifSquareShape', 'directionType', 'ifPhaseOnly']
        self.children = ['ZenithAzimuth', 'LatLon', 'Rectangle', 'Square']
        self.parent = None
        self._imageDirection = _cast(int, imageDirection)
        self._ifSquareShape = _cast(int, ifSquareShape)
        self._directionType = _cast(int, directionType)
        self._ifPhaseOnly = _cast(int, ifPhaseOnly)
        self._ZenithAzimuth = ZenithAzimuth
        self._LatLon = LatLon
        self._Rectangle = Rectangle
        self._Square = Square
        update_node(self,self.troot,'directions')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_AddedDirections)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_AddedDirections.subclass:
            return create_AddedDirections.subclass(*args_, **kwargs_)
        else:
            return create_AddedDirections(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ZenithAzimuth(self): return self._ZenithAzimuth
    def set_ZenithAzimuth(self, value):
        if value is not None:
            checkclass(value, create_ZenithAzimuth)
            value.parent = self
        self._ZenithAzimuth = value
    ZenithAzimuth = property(get_ZenithAzimuth, set_ZenithAzimuth)
    def get_LatLon(self): return self._LatLon
    def set_LatLon(self, value):
        if value is not None:
            checkclass(value, create_LatLon)
            value.parent = self
        self._LatLon = value
    LatLon = property(get_LatLon, set_LatLon)
    def get_Rectangle(self): return self._Rectangle
    def set_Rectangle(self, value):
        if value is not None:
            checkclass(value, create_Rectangle)
            value.parent = self
        self._Rectangle = value
    Rectangle = property(get_Rectangle, set_Rectangle)
    def get_Square(self): return self._Square
    def set_Square(self, value):
        if value is not None:
            checkclass(value, create_Square)
            value.parent = self
        self._Square = value
    Square = property(get_Square, set_Square)
    def get_imageDirection(self): return self._imageDirection
    def set_imageDirection(self, value):
        self._imageDirection = value
        update_node(self,self.troot,'directions')
    imageDirection = property(get_imageDirection, set_imageDirection)
    def get_ifSquareShape(self): return self._ifSquareShape
    def set_ifSquareShape(self, value):
        self._ifSquareShape = value
        update_node(self,self.troot,'directions')
    ifSquareShape = property(get_ifSquareShape, set_ifSquareShape)
    def get_directionType(self): return self._directionType
    def set_directionType(self, value):
        self._directionType = value
        update_node(self,self.troot,'directions')
    directionType = property(get_directionType, set_directionType)
    def get_ifPhaseOnly(self): return self._ifPhaseOnly
    def set_ifPhaseOnly(self, value):
        self._ifPhaseOnly = value
        update_node(self,self.troot,'directions')
    ifPhaseOnly = property(get_ifPhaseOnly, set_ifPhaseOnly)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.ZenithAzimuth is not None or
            self.LatLon is not None or
            self.Rectangle is not None or
            self.Square is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_AddedDirections', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_AddedDirections')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_AddedDirections')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_AddedDirections', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_AddedDirections'):
        if self.imageDirection is not None and 'imageDirection' not in already_processed:
            already_processed.add('imageDirection')
            outfile.write(' imageDirection="%s"' % self.gds_format_integer(self.imageDirection, input_name='imageDirection'))
        if self.ifSquareShape is not None and 'ifSquareShape' not in already_processed:
            already_processed.add('ifSquareShape')
            outfile.write(' ifSquareShape="%s"' % self.gds_format_integer(self.ifSquareShape, input_name='ifSquareShape'))
        if self.directionType is not None and 'directionType' not in already_processed:
            already_processed.add('directionType')
            outfile.write(' directionType="%s"' % self.gds_format_integer(self.directionType, input_name='directionType'))
        if self.ifPhaseOnly is not None and 'ifPhaseOnly' not in already_processed:
            already_processed.add('ifPhaseOnly')
            outfile.write(' ifPhaseOnly="%s"' % self.gds_format_integer(self.ifPhaseOnly, input_name='ifPhaseOnly'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_AddedDirections', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ZenithAzimuth is not None:
            self.ZenithAzimuth.export(outfile, level, namespaceprefix_, name_='ZenithAzimuth', pretty_print=pretty_print)
        if self.LatLon is not None:
            self.LatLon.export(outfile, level, namespaceprefix_, name_='LatLon', pretty_print=pretty_print)
        if self.Rectangle is not None:
            self.Rectangle.export(outfile, level, namespaceprefix_, name_='Rectangle', pretty_print=pretty_print)
        if self.Square is not None:
            self.Square.export(outfile, level, namespaceprefix_, name_='Square', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_AddedDirections', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.imageDirection is not None:
            element.set('imageDirection', self.gds_format_integer(self.imageDirection))
        if self.ifSquareShape is not None:
            element.set('ifSquareShape', self.gds_format_integer(self.ifSquareShape))
        if self.directionType is not None:
            element.set('directionType', self.gds_format_integer(self.directionType))
        if self.ifPhaseOnly is not None:
            element.set('ifPhaseOnly', self.gds_format_integer(self.ifPhaseOnly))
        if self.ZenithAzimuth is not None:
            ZenithAzimuth_ = self.ZenithAzimuth
            ZenithAzimuth_.to_etree(element, name_='ZenithAzimuth', mapping_=mapping_)
        if self.LatLon is not None:
            LatLon_ = self.LatLon
            LatLon_.to_etree(element, name_='LatLon', mapping_=mapping_)
        if self.Rectangle is not None:
            Rectangle_ = self.Rectangle
            Rectangle_.to_etree(element, name_='Rectangle', mapping_=mapping_)
        if self.Square is not None:
            Square_ = self.Square
            Square_.to_etree(element, name_='Square', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_AddedDirections'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.imageDirection is not None and 'imageDirection' not in already_processed:
            already_processed.add('imageDirection')
            showIndent(outfile, level)
            outfile.write('imageDirection=%d,\n' % (self.imageDirection,))
        if self.ifSquareShape is not None and 'ifSquareShape' not in already_processed:
            already_processed.add('ifSquareShape')
            showIndent(outfile, level)
            outfile.write('ifSquareShape=%d,\n' % (self.ifSquareShape,))
        if self.directionType is not None and 'directionType' not in already_processed:
            already_processed.add('directionType')
            showIndent(outfile, level)
            outfile.write('directionType=%d,\n' % (self.directionType,))
        if self.ifPhaseOnly is not None and 'ifPhaseOnly' not in already_processed:
            already_processed.add('ifPhaseOnly')
            showIndent(outfile, level)
            outfile.write('ifPhaseOnly=%d,\n' % (self.ifPhaseOnly,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ZenithAzimuth is not None:
            showIndent(outfile, level)
            outfile.write('ZenithAzimuth=model_._ZenithAzimuth(\n')
            self.ZenithAzimuth.exportLiteral(outfile, level, name_='ZenithAzimuth')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LatLon is not None:
            showIndent(outfile, level)
            outfile.write('LatLon=model_._LatLon(\n')
            self.LatLon.exportLiteral(outfile, level, name_='LatLon')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Rectangle is not None:
            showIndent(outfile, level)
            outfile.write('Rectangle=model_._Rectangle(\n')
            self.Rectangle.exportLiteral(outfile, level, name_='Rectangle')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Square is not None:
            showIndent(outfile, level)
            outfile.write('Square=model_._Square(\n')
            self.Square.exportLiteral(outfile, level, name_='Square')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('imageDirection', node)
        if value is not None and 'imageDirection' not in already_processed:
            already_processed.add('imageDirection')
            try:
                self.imageDirection = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ifSquareShape', node)
        if value is not None and 'ifSquareShape' not in already_processed:
            already_processed.add('ifSquareShape')
            try:
                self.ifSquareShape = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('directionType', node)
        if value is not None and 'directionType' not in already_processed:
            already_processed.add('directionType')
            try:
                self.directionType = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ifPhaseOnly', node)
        if value is not None and 'ifPhaseOnly' not in already_processed:
            already_processed.add('ifPhaseOnly')
            try:
                self.ifPhaseOnly = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ZenithAzimuth':
            obj_ = create_ZenithAzimuth.factory()
            obj_.build(child_)
            self.set_ZenithAzimuth(obj_)
            obj_.original_tagname_ = 'ZenithAzimuth'
        elif nodeName_ == 'LatLon':
            obj_ = create_LatLon.factory()
            obj_.build(child_)
            self.set_LatLon(obj_)
            obj_.original_tagname_ = 'LatLon'
        elif nodeName_ == 'Rectangle':
            obj_ = create_Rectangle.factory()
            obj_.build(child_)
            self.set_Rectangle(obj_)
            obj_.original_tagname_ = 'Rectangle'
        elif nodeName_ == 'Square':
            obj_ = create_Square.factory()
            obj_.build(child_)
            self.set_Square(obj_)
            obj_.original_tagname_ = 'Square'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_AddedDirections


class create_ZenithAzimuth(GeneratedsSuper):
    """Azimuth angle of the added direction (between O\u00B0 and 360\u00B0)
    Azimuth angle of the added direction (between O\u00B0 and
    360\u00B0) Zenith angle of the added direction: \n- value in
    [0\u00B0, 90\u00B0[ adds an upward region. \n- value in
    ]90\u00B0, 180\u00B0] adds a downward region. Zenith angle of
    the added direction: \n- value in [0\u00B0, 90\u00B0[ adds an
    upward region. \n- value in ]90\u00B0, 180\u00B0] adds a
    downward region."""
    member_data_items_ = [
        MemberSpec_('directionAzimuthalAngle', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('directionZenithalAngle', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, directionAzimuthalAngle=0, directionZenithalAngle=40.0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('directions','_ZenithAzimuth')
        self.attrib = ['directionAzimuthalAngle', 'directionZenithalAngle']
        self.children = []
        self.parent = None
        self._directionAzimuthalAngle = _cast(float, directionAzimuthalAngle)
        self._directionZenithalAngle = _cast(float, directionZenithalAngle)
        update_node(self,self.troot,'directions')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ZenithAzimuth)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ZenithAzimuth.subclass:
            return create_ZenithAzimuth.subclass(*args_, **kwargs_)
        else:
            return create_ZenithAzimuth(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_directionAzimuthalAngle(self): return self._directionAzimuthalAngle
    def set_directionAzimuthalAngle(self, value):
        self._directionAzimuthalAngle = value
        update_node(self,self.troot,'directions')
    directionAzimuthalAngle = property(get_directionAzimuthalAngle, set_directionAzimuthalAngle)
    def get_directionZenithalAngle(self): return self._directionZenithalAngle
    def set_directionZenithalAngle(self, value):
        self._directionZenithalAngle = value
        update_node(self,self.troot,'directions')
    directionZenithalAngle = property(get_directionZenithalAngle, set_directionZenithalAngle)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ZenithAzimuth', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ZenithAzimuth')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ZenithAzimuth')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ZenithAzimuth', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ZenithAzimuth'):
        if self.directionAzimuthalAngle is not None and 'directionAzimuthalAngle' not in already_processed:
            already_processed.add('directionAzimuthalAngle')
            outfile.write(' directionAzimuthalAngle="%s"' % self.gds_format_double(self.directionAzimuthalAngle, input_name='directionAzimuthalAngle'))
        if self.directionZenithalAngle is not None and 'directionZenithalAngle' not in already_processed:
            already_processed.add('directionZenithalAngle')
            outfile.write(' directionZenithalAngle="%s"' % self.gds_format_double(self.directionZenithalAngle, input_name='directionZenithalAngle'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ZenithAzimuth', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_ZenithAzimuth', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.directionAzimuthalAngle is not None:
            element.set('directionAzimuthalAngle', self.gds_format_double(self.directionAzimuthalAngle))
        if self.directionZenithalAngle is not None:
            element.set('directionZenithalAngle', self.gds_format_double(self.directionZenithalAngle))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ZenithAzimuth'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.directionAzimuthalAngle is not None and 'directionAzimuthalAngle' not in already_processed:
            already_processed.add('directionAzimuthalAngle')
            showIndent(outfile, level)
            outfile.write('directionAzimuthalAngle=%e,\n' % (self.directionAzimuthalAngle,))
        if self.directionZenithalAngle is not None and 'directionZenithalAngle' not in already_processed:
            already_processed.add('directionZenithalAngle')
            showIndent(outfile, level)
            outfile.write('directionZenithalAngle=%e,\n' % (self.directionZenithalAngle,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('directionAzimuthalAngle', node)
        if value is not None and 'directionAzimuthalAngle' not in already_processed:
            already_processed.add('directionAzimuthalAngle')
            try:
                self.directionAzimuthalAngle = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (directionAzimuthalAngle): %s' % exp)
        value = find_attr_value_('directionZenithalAngle', node)
        if value is not None and 'directionZenithalAngle' not in already_processed:
            already_processed.add('directionZenithalAngle')
            try:
                self.directionZenithalAngle = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (directionZenithalAngle): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_ZenithAzimuth


class create_LatLon(GeneratedsSuper):
    """Latitude Latitude Altitude Altitude Longitude Longitude"""
    member_data_items_ = [
        MemberSpec_('latitude', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('altitude', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('longitude', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, latitude=0, altitude=35600.0, longitude=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('directions','_LatLon')
        self.attrib = ['latitude', 'altitude', 'longitude']
        self.children = []
        self.parent = None
        self._latitude = _cast(float, latitude)
        self._altitude = _cast(float, altitude)
        self._longitude = _cast(float, longitude)
        update_node(self,self.troot,'directions')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_LatLon)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_LatLon.subclass:
            return create_LatLon.subclass(*args_, **kwargs_)
        else:
            return create_LatLon(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_latitude(self): return self._latitude
    def set_latitude(self, value):
        self._latitude = value
        update_node(self,self.troot,'directions')
    latitude = property(get_latitude, set_latitude)
    def get_altitude(self): return self._altitude
    def set_altitude(self, value):
        self._altitude = value
        update_node(self,self.troot,'directions')
    altitude = property(get_altitude, set_altitude)
    def get_longitude(self): return self._longitude
    def set_longitude(self, value):
        self._longitude = value
        update_node(self,self.troot,'directions')
    longitude = property(get_longitude, set_longitude)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_LatLon', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_LatLon')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_LatLon')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_LatLon', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_LatLon'):
        if self.latitude is not None and 'latitude' not in already_processed:
            already_processed.add('latitude')
            outfile.write(' latitude="%s"' % self.gds_format_double(self.latitude, input_name='latitude'))
        if self.altitude is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            outfile.write(' altitude="%s"' % self.gds_format_double(self.altitude, input_name='altitude'))
        if self.longitude is not None and 'longitude' not in already_processed:
            already_processed.add('longitude')
            outfile.write(' longitude="%s"' % self.gds_format_double(self.longitude, input_name='longitude'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_LatLon', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_LatLon', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.latitude is not None:
            element.set('latitude', self.gds_format_double(self.latitude))
        if self.altitude is not None:
            element.set('altitude', self.gds_format_double(self.altitude))
        if self.longitude is not None:
            element.set('longitude', self.gds_format_double(self.longitude))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_LatLon'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.latitude is not None and 'latitude' not in already_processed:
            already_processed.add('latitude')
            showIndent(outfile, level)
            outfile.write('latitude=%e,\n' % (self.latitude,))
        if self.altitude is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            showIndent(outfile, level)
            outfile.write('altitude=%e,\n' % (self.altitude,))
        if self.longitude is not None and 'longitude' not in already_processed:
            already_processed.add('longitude')
            showIndent(outfile, level)
            outfile.write('longitude=%e,\n' % (self.longitude,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('latitude', node)
        if value is not None and 'latitude' not in already_processed:
            already_processed.add('latitude')
            try:
                self.latitude = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (latitude): %s' % exp)
        value = find_attr_value_('altitude', node)
        if value is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            try:
                self.altitude = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (altitude): %s' % exp)
        value = find_attr_value_('longitude', node)
        if value is not None and 'longitude' not in already_processed:
            already_processed.add('longitude')
            try:
                self.longitude = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (longitude): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_LatLon


class create_Rectangle(GeneratedsSuper):
    """Zenithal width of the region in the [0\u00B0, 180\u00B0] range
    Zenithal width of the region in the [0\u00B0, 180\u00B0] range
    Azimuthal width of the region in the [0\u00B0, 360\u00B0] range
    Azimuthal width of the region in the [0\u00B0, 360\u00B0] range"""
    member_data_items_ = [
        MemberSpec_('deltaTheta', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('deltaPhi', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, deltaTheta=2, deltaPhi=2):
        self.original_tagname_ = None
        self.troot=get_gs_troot('directions','_Rectangle')
        self.attrib = ['deltaTheta', 'deltaPhi']
        self.children = []
        self.parent = None
        self._deltaTheta = _cast(float, deltaTheta)
        self._deltaPhi = _cast(float, deltaPhi)
        update_node(self,self.troot,'directions')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Rectangle)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Rectangle.subclass:
            return create_Rectangle.subclass(*args_, **kwargs_)
        else:
            return create_Rectangle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deltaTheta(self): return self._deltaTheta
    def set_deltaTheta(self, value):
        self._deltaTheta = value
        update_node(self,self.troot,'directions')
    deltaTheta = property(get_deltaTheta, set_deltaTheta)
    def get_deltaPhi(self): return self._deltaPhi
    def set_deltaPhi(self, value):
        self._deltaPhi = value
        update_node(self,self.troot,'directions')
    deltaPhi = property(get_deltaPhi, set_deltaPhi)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Rectangle', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Rectangle')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Rectangle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Rectangle', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Rectangle'):
        if self.deltaTheta is not None and 'deltaTheta' not in already_processed:
            already_processed.add('deltaTheta')
            outfile.write(' deltaTheta="%s"' % self.gds_format_double(self.deltaTheta, input_name='deltaTheta'))
        if self.deltaPhi is not None and 'deltaPhi' not in already_processed:
            already_processed.add('deltaPhi')
            outfile.write(' deltaPhi="%s"' % self.gds_format_double(self.deltaPhi, input_name='deltaPhi'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Rectangle', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_Rectangle', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.deltaTheta is not None:
            element.set('deltaTheta', self.gds_format_double(self.deltaTheta))
        if self.deltaPhi is not None:
            element.set('deltaPhi', self.gds_format_double(self.deltaPhi))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Rectangle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.deltaTheta is not None and 'deltaTheta' not in already_processed:
            already_processed.add('deltaTheta')
            showIndent(outfile, level)
            outfile.write('deltaTheta=%e,\n' % (self.deltaTheta,))
        if self.deltaPhi is not None and 'deltaPhi' not in already_processed:
            already_processed.add('deltaPhi')
            showIndent(outfile, level)
            outfile.write('deltaPhi=%e,\n' % (self.deltaPhi,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('deltaTheta', node)
        if value is not None and 'deltaTheta' not in already_processed:
            already_processed.add('deltaTheta')
            try:
                self.deltaTheta = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (deltaTheta): %s' % exp)
        value = find_attr_value_('deltaPhi', node)
        if value is not None and 'deltaPhi' not in already_processed:
            already_processed.add('deltaPhi')
            try:
                self.deltaPhi = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (deltaPhi): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_Rectangle


class create_Square(GeneratedsSuper):
    """The parameter used to described the width of the square. The
    parameter used to described the width of the square."""
    member_data_items_ = [
        MemberSpec_('widthDefinition', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('DefineOmega', '_DefineOmega', 0, 0, {u'maxOccurs': u'1', u'type': u'_DefineOmega', u'name': u'DefineOmega', u'minOccurs': u'1'}, None),
        MemberSpec_('DefineDeltaPhi', '_DefineDeltaPhi', 0, 0, {u'maxOccurs': u'1', u'type': u'_DefineDeltaPhi', u'name': u'DefineDeltaPhi', u'minOccurs': u'1'}, None),
        MemberSpec_('DefineDeltaTheta', '_DefineDeltaTheta', 0, 0, {u'maxOccurs': u'1', u'type': u'_DefineDeltaTheta', u'name': u'DefineDeltaTheta', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, widthDefinition=0, DefineOmega=None, DefineDeltaPhi=None, DefineDeltaTheta=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('directions','_Square')
        self.attrib = ['widthDefinition']
        self.children = ['DefineOmega', 'DefineDeltaPhi', 'DefineDeltaTheta']
        self.parent = None
        self._widthDefinition = _cast(int, widthDefinition)
        self._DefineOmega = DefineOmega
        self._DefineDeltaPhi = DefineDeltaPhi
        self._DefineDeltaTheta = DefineDeltaTheta
        update_node(self,self.troot,'directions')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Square)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Square.subclass:
            return create_Square.subclass(*args_, **kwargs_)
        else:
            return create_Square(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DefineOmega(self): return self._DefineOmega
    def set_DefineOmega(self, value):
        if value is not None:
            checkclass(value, create_DefineOmega)
            value.parent = self
        self._DefineOmega = value
    DefineOmega = property(get_DefineOmega, set_DefineOmega)
    def get_DefineDeltaPhi(self): return self._DefineDeltaPhi
    def set_DefineDeltaPhi(self, value):
        if value is not None:
            checkclass(value, create_DefineDeltaPhi)
            value.parent = self
        self._DefineDeltaPhi = value
    DefineDeltaPhi = property(get_DefineDeltaPhi, set_DefineDeltaPhi)
    def get_DefineDeltaTheta(self): return self._DefineDeltaTheta
    def set_DefineDeltaTheta(self, value):
        if value is not None:
            checkclass(value, create_DefineDeltaTheta)
            value.parent = self
        self._DefineDeltaTheta = value
    DefineDeltaTheta = property(get_DefineDeltaTheta, set_DefineDeltaTheta)
    def get_widthDefinition(self): return self._widthDefinition
    def set_widthDefinition(self, value):
        self._widthDefinition = value
        update_node(self,self.troot,'directions')
    widthDefinition = property(get_widthDefinition, set_widthDefinition)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.DefineOmega is not None or
            self.DefineDeltaPhi is not None or
            self.DefineDeltaTheta is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Square', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Square')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Square')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Square', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Square'):
        if self.widthDefinition is not None and 'widthDefinition' not in already_processed:
            already_processed.add('widthDefinition')
            outfile.write(' widthDefinition="%s"' % self.gds_format_integer(self.widthDefinition, input_name='widthDefinition'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Square', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DefineOmega is not None:
            self.DefineOmega.export(outfile, level, namespaceprefix_, name_='DefineOmega', pretty_print=pretty_print)
        if self.DefineDeltaPhi is not None:
            self.DefineDeltaPhi.export(outfile, level, namespaceprefix_, name_='DefineDeltaPhi', pretty_print=pretty_print)
        if self.DefineDeltaTheta is not None:
            self.DefineDeltaTheta.export(outfile, level, namespaceprefix_, name_='DefineDeltaTheta', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Square', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.widthDefinition is not None:
            element.set('widthDefinition', self.gds_format_integer(self.widthDefinition))
        if self.DefineOmega is not None:
            DefineOmega_ = self.DefineOmega
            DefineOmega_.to_etree(element, name_='DefineOmega', mapping_=mapping_)
        if self.DefineDeltaPhi is not None:
            DefineDeltaPhi_ = self.DefineDeltaPhi
            DefineDeltaPhi_.to_etree(element, name_='DefineDeltaPhi', mapping_=mapping_)
        if self.DefineDeltaTheta is not None:
            DefineDeltaTheta_ = self.DefineDeltaTheta
            DefineDeltaTheta_.to_etree(element, name_='DefineDeltaTheta', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Square'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.widthDefinition is not None and 'widthDefinition' not in already_processed:
            already_processed.add('widthDefinition')
            showIndent(outfile, level)
            outfile.write('widthDefinition=%d,\n' % (self.widthDefinition,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DefineOmega is not None:
            showIndent(outfile, level)
            outfile.write('DefineOmega=model_._DefineOmega(\n')
            self.DefineOmega.exportLiteral(outfile, level, name_='DefineOmega')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DefineDeltaPhi is not None:
            showIndent(outfile, level)
            outfile.write('DefineDeltaPhi=model_._DefineDeltaPhi(\n')
            self.DefineDeltaPhi.exportLiteral(outfile, level, name_='DefineDeltaPhi')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DefineDeltaTheta is not None:
            showIndent(outfile, level)
            outfile.write('DefineDeltaTheta=model_._DefineDeltaTheta(\n')
            self.DefineDeltaTheta.exportLiteral(outfile, level, name_='DefineDeltaTheta')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('widthDefinition', node)
        if value is not None and 'widthDefinition' not in already_processed:
            already_processed.add('widthDefinition')
            try:
                self.widthDefinition = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DefineOmega':
            obj_ = create_DefineOmega.factory()
            obj_.build(child_)
            self.set_DefineOmega(obj_)
            obj_.original_tagname_ = 'DefineOmega'
        elif nodeName_ == 'DefineDeltaPhi':
            obj_ = create_DefineDeltaPhi.factory()
            obj_.build(child_)
            self.set_DefineDeltaPhi(obj_)
            obj_.original_tagname_ = 'DefineDeltaPhi'
        elif nodeName_ == 'DefineDeltaTheta':
            obj_ = create_DefineDeltaTheta.factory()
            obj_.build(child_)
            self.set_DefineDeltaTheta(obj_)
            obj_.original_tagname_ = 'DefineDeltaTheta'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_Square


class create_DefineOmega(GeneratedsSuper):
    """Solid Angle (steradians) Solid Angle (steradians)"""
    member_data_items_ = [
        MemberSpec_('omega', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, omega=0.001):
        self.original_tagname_ = None
        self.troot=get_gs_troot('directions','_DefineOmega')
        self.attrib = ['omega']
        self.children = []
        self.parent = None
        self._omega = _cast(float, omega)
        update_node(self,self.troot,'directions')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_DefineOmega)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_DefineOmega.subclass:
            return create_DefineOmega.subclass(*args_, **kwargs_)
        else:
            return create_DefineOmega(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_omega(self): return self._omega
    def set_omega(self, value):
        self._omega = value
        update_node(self,self.troot,'directions')
    omega = property(get_omega, set_omega)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_DefineOmega', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_DefineOmega')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_DefineOmega')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_DefineOmega', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_DefineOmega'):
        if self.omega is not None and 'omega' not in already_processed:
            already_processed.add('omega')
            outfile.write(' omega="%s"' % self.gds_format_double(self.omega, input_name='omega'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_DefineOmega', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_DefineOmega', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.omega is not None:
            element.set('omega', self.gds_format_double(self.omega))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_DefineOmega'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.omega is not None and 'omega' not in already_processed:
            already_processed.add('omega')
            showIndent(outfile, level)
            outfile.write('omega=%e,\n' % (self.omega,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('omega', node)
        if value is not None and 'omega' not in already_processed:
            already_processed.add('omega')
            try:
                self.omega = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (omega): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_DefineOmega


class create_DefineDeltaPhi(GeneratedsSuper):
    """Azimuthal width of the region in the [0\u00B0, 360\u00B0] range
    Azimuthal width of the region in the [0\u00B0, 360\u00B0] range"""
    member_data_items_ = [
        MemberSpec_('deltaPhi', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, deltaPhi=2):
        self.original_tagname_ = None
        self.troot=get_gs_troot('directions','_DefineDeltaPhi')
        self.attrib = ['deltaPhi']
        self.children = []
        self.parent = None
        self._deltaPhi = _cast(float, deltaPhi)
        update_node(self,self.troot,'directions')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_DefineDeltaPhi)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_DefineDeltaPhi.subclass:
            return create_DefineDeltaPhi.subclass(*args_, **kwargs_)
        else:
            return create_DefineDeltaPhi(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deltaPhi(self): return self._deltaPhi
    def set_deltaPhi(self, value):
        self._deltaPhi = value
        update_node(self,self.troot,'directions')
    deltaPhi = property(get_deltaPhi, set_deltaPhi)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_DefineDeltaPhi', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_DefineDeltaPhi')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_DefineDeltaPhi')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_DefineDeltaPhi', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_DefineDeltaPhi'):
        if self.deltaPhi is not None and 'deltaPhi' not in already_processed:
            already_processed.add('deltaPhi')
            outfile.write(' deltaPhi="%s"' % self.gds_format_double(self.deltaPhi, input_name='deltaPhi'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_DefineDeltaPhi', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_DefineDeltaPhi', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.deltaPhi is not None:
            element.set('deltaPhi', self.gds_format_double(self.deltaPhi))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_DefineDeltaPhi'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.deltaPhi is not None and 'deltaPhi' not in already_processed:
            already_processed.add('deltaPhi')
            showIndent(outfile, level)
            outfile.write('deltaPhi=%e,\n' % (self.deltaPhi,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('deltaPhi', node)
        if value is not None and 'deltaPhi' not in already_processed:
            already_processed.add('deltaPhi')
            try:
                self.deltaPhi = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (deltaPhi): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_DefineDeltaPhi


class create_DefineDeltaTheta(GeneratedsSuper):
    """Zenithal width of the region in the [0\u00B0, 180\u00B0] range
    Zenithal width of the region in the [0\u00B0, 180\u00B0] range"""
    member_data_items_ = [
        MemberSpec_('deltaTheta', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, deltaTheta=2):
        self.original_tagname_ = None
        self.troot=get_gs_troot('directions','_DefineDeltaTheta')
        self.attrib = ['deltaTheta']
        self.children = []
        self.parent = None
        self._deltaTheta = _cast(float, deltaTheta)
        update_node(self,self.troot,'directions')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_DefineDeltaTheta)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_DefineDeltaTheta.subclass:
            return create_DefineDeltaTheta.subclass(*args_, **kwargs_)
        else:
            return create_DefineDeltaTheta(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deltaTheta(self): return self._deltaTheta
    def set_deltaTheta(self, value):
        self._deltaTheta = value
        update_node(self,self.troot,'directions')
    deltaTheta = property(get_deltaTheta, set_deltaTheta)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_DefineDeltaTheta', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_DefineDeltaTheta')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_DefineDeltaTheta')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_DefineDeltaTheta', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_DefineDeltaTheta'):
        if self.deltaTheta is not None and 'deltaTheta' not in already_processed:
            already_processed.add('deltaTheta')
            outfile.write(' deltaTheta="%s"' % self.gds_format_double(self.deltaTheta, input_name='deltaTheta'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_DefineDeltaTheta', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_DefineDeltaTheta', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.deltaTheta is not None:
            element.set('deltaTheta', self.gds_format_double(self.deltaTheta))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_DefineDeltaTheta'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.deltaTheta is not None and 'deltaTheta' not in already_processed:
            already_processed.add('deltaTheta')
            showIndent(outfile, level)
            outfile.write('deltaTheta=%e,\n' % (self.deltaTheta,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('deltaTheta', node)
        if value is not None and 'deltaTheta' not in already_processed:
            already_processed.add('deltaTheta')
            try:
                self.deltaTheta = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (deltaTheta): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_DefineDeltaTheta


class create_Region(GeneratedsSuper):
    """Number of directions in region. Automatically rounded to the nearest
    squared integer. Number of directions in region. Automatically
    rounded to the nearest squared integer. The oversampling
    directions are used only in the calculation of phase functions,
    which in DART module, are used to increase the directional
    sampling for selection of instant directional phase function
    during scattering event. The directions are essentially virtual.
    The oversampling directions are used only in the calculation of
    phase functions, which in DART module, are used to increase the
    directional sampling for selection of instant directional phase
    function during scattering event. The directions are essentially
    virtual. If checked, images will be systematically generated for
    all the directions in this region, unless images production has
    been totally disable in the product tab. If checked, images will
    be systematically generated for all the directions in this
    region, unless images production has been totally disable in the
    product tab. The shape used to described the region The shape
    used to described the region To enter directly the central
    angles of the region, choose "Zenith+Azimuth".\nDart is also
    able to automaticaly determinate the central angles of a region
    given the LatLon coordinates of the (theorical) sensor and the
    scene, while taking in account the curves of the Earth.\nTo do
    this, choose "LatLon Coordinates". To enter directly the central
    angles of the region, choose "Zenith+Azimuth".\nDart is also
    able to automaticaly determinate the central angles of a region
    given the LatLon coordinates of the (theorical) sensor and the
    scene, while taking in account the curves of the Earth.\nTo do
    this, choose "LatLon Coordinates". All the oversampled direction
    have virtual property All the oversampled direction have virtual
    property"""
    member_data_items_ = [
        MemberSpec_('numberOfDirections', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('ifPhaseOnly', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('imageDirection', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('ifSquareShape', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('regionType', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('ifVirtual', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('ZenithAzimuth', '_ZenithAzimuth', 0, 0, {u'maxOccurs': u'1', u'type': u'_ZenithAzimuth', u'name': u'ZenithAzimuth', u'minOccurs': u'1'}, None),
        MemberSpec_('LatLon', '_LatLon', 0, 0, {u'maxOccurs': u'1', u'type': u'_LatLon', u'name': u'LatLon', u'minOccurs': u'1'}, None),
        MemberSpec_('Rectangle', '_Rectangle', 0, 0, {u'maxOccurs': u'1', u'type': u'_Rectangle', u'name': u'Rectangle', u'minOccurs': u'1'}, None),
        MemberSpec_('Square', '_Square', 0, 0, {u'maxOccurs': u'1', u'type': u'_Square', u'name': u'Square', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, numberOfDirections=25, ifPhaseOnly=0, imageDirection=1, ifSquareShape=1, regionType=0, ifVirtual=0, ZenithAzimuth=None, LatLon=None, Rectangle=None, Square=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('directions','_Region')
        self.attrib = ['numberOfDirections', 'ifPhaseOnly', 'imageDirection', 'ifSquareShape', 'regionType', 'ifVirtual']
        self.children = ['ZenithAzimuth', 'LatLon', 'Rectangle', 'Square']
        self.parent = None
        self._numberOfDirections = _cast(int, numberOfDirections)
        self._ifPhaseOnly = _cast(int, ifPhaseOnly)
        self._imageDirection = _cast(int, imageDirection)
        self._ifSquareShape = _cast(int, ifSquareShape)
        self._regionType = _cast(int, regionType)
        self._ifVirtual = _cast(int, ifVirtual)
        self._ZenithAzimuth = ZenithAzimuth
        self._LatLon = LatLon
        self._Rectangle = Rectangle
        self._Square = Square
        update_node(self,self.troot,'directions')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Region)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Region.subclass:
            return create_Region.subclass(*args_, **kwargs_)
        else:
            return create_Region(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ZenithAzimuth(self): return self._ZenithAzimuth
    def set_ZenithAzimuth(self, value):
        if value is not None:
            checkclass(value, create_ZenithAzimuth)
            value.parent = self
        self._ZenithAzimuth = value
    ZenithAzimuth = property(get_ZenithAzimuth, set_ZenithAzimuth)
    def get_LatLon(self): return self._LatLon
    def set_LatLon(self, value):
        if value is not None:
            checkclass(value, create_LatLon)
            value.parent = self
        self._LatLon = value
    LatLon = property(get_LatLon, set_LatLon)
    def get_Rectangle(self): return self._Rectangle
    def set_Rectangle(self, value):
        if value is not None:
            checkclass(value, create_Rectangle)
            value.parent = self
        self._Rectangle = value
    Rectangle = property(get_Rectangle, set_Rectangle)
    def get_Square(self): return self._Square
    def set_Square(self, value):
        if value is not None:
            checkclass(value, create_Square)
            value.parent = self
        self._Square = value
    Square = property(get_Square, set_Square)
    def get_numberOfDirections(self): return self._numberOfDirections
    def set_numberOfDirections(self, value):
        self._numberOfDirections = value
        update_node(self,self.troot,'directions')
    numberOfDirections = property(get_numberOfDirections, set_numberOfDirections)
    def get_ifPhaseOnly(self): return self._ifPhaseOnly
    def set_ifPhaseOnly(self, value):
        self._ifPhaseOnly = value
        update_node(self,self.troot,'directions')
    ifPhaseOnly = property(get_ifPhaseOnly, set_ifPhaseOnly)
    def get_imageDirection(self): return self._imageDirection
    def set_imageDirection(self, value):
        self._imageDirection = value
        update_node(self,self.troot,'directions')
    imageDirection = property(get_imageDirection, set_imageDirection)
    def get_ifSquareShape(self): return self._ifSquareShape
    def set_ifSquareShape(self, value):
        self._ifSquareShape = value
        update_node(self,self.troot,'directions')
    ifSquareShape = property(get_ifSquareShape, set_ifSquareShape)
    def get_regionType(self): return self._regionType
    def set_regionType(self, value):
        self._regionType = value
        update_node(self,self.troot,'directions')
    regionType = property(get_regionType, set_regionType)
    def get_ifVirtual(self): return self._ifVirtual
    def set_ifVirtual(self, value):
        self._ifVirtual = value
        update_node(self,self.troot,'directions')
    ifVirtual = property(get_ifVirtual, set_ifVirtual)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.ZenithAzimuth is not None or
            self.LatLon is not None or
            self.Rectangle is not None or
            self.Square is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Region', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Region')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Region')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Region', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Region'):
        if self.numberOfDirections is not None and 'numberOfDirections' not in already_processed:
            already_processed.add('numberOfDirections')
            outfile.write(' numberOfDirections="%s"' % self.gds_format_integer(self.numberOfDirections, input_name='numberOfDirections'))
        if self.ifPhaseOnly is not None and 'ifPhaseOnly' not in already_processed:
            already_processed.add('ifPhaseOnly')
            outfile.write(' ifPhaseOnly="%s"' % self.gds_format_integer(self.ifPhaseOnly, input_name='ifPhaseOnly'))
        if self.imageDirection is not None and 'imageDirection' not in already_processed:
            already_processed.add('imageDirection')
            outfile.write(' imageDirection="%s"' % self.gds_format_integer(self.imageDirection, input_name='imageDirection'))
        if self.ifSquareShape is not None and 'ifSquareShape' not in already_processed:
            already_processed.add('ifSquareShape')
            outfile.write(' ifSquareShape="%s"' % self.gds_format_integer(self.ifSquareShape, input_name='ifSquareShape'))
        if self.regionType is not None and 'regionType' not in already_processed:
            already_processed.add('regionType')
            outfile.write(' regionType="%s"' % self.gds_format_integer(self.regionType, input_name='regionType'))
        if self.ifVirtual is not None and 'ifVirtual' not in already_processed:
            already_processed.add('ifVirtual')
            outfile.write(' ifVirtual="%s"' % self.gds_format_integer(self.ifVirtual, input_name='ifVirtual'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Region', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ZenithAzimuth is not None:
            self.ZenithAzimuth.export(outfile, level, namespaceprefix_, name_='ZenithAzimuth', pretty_print=pretty_print)
        if self.LatLon is not None:
            self.LatLon.export(outfile, level, namespaceprefix_, name_='LatLon', pretty_print=pretty_print)
        if self.Rectangle is not None:
            self.Rectangle.export(outfile, level, namespaceprefix_, name_='Rectangle', pretty_print=pretty_print)
        if self.Square is not None:
            self.Square.export(outfile, level, namespaceprefix_, name_='Square', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Region', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.numberOfDirections is not None:
            element.set('numberOfDirections', self.gds_format_integer(self.numberOfDirections))
        if self.ifPhaseOnly is not None:
            element.set('ifPhaseOnly', self.gds_format_integer(self.ifPhaseOnly))
        if self.imageDirection is not None:
            element.set('imageDirection', self.gds_format_integer(self.imageDirection))
        if self.ifSquareShape is not None:
            element.set('ifSquareShape', self.gds_format_integer(self.ifSquareShape))
        if self.regionType is not None:
            element.set('regionType', self.gds_format_integer(self.regionType))
        if self.ifVirtual is not None:
            element.set('ifVirtual', self.gds_format_integer(self.ifVirtual))
        if self.ZenithAzimuth is not None:
            ZenithAzimuth_ = self.ZenithAzimuth
            ZenithAzimuth_.to_etree(element, name_='ZenithAzimuth', mapping_=mapping_)
        if self.LatLon is not None:
            LatLon_ = self.LatLon
            LatLon_.to_etree(element, name_='LatLon', mapping_=mapping_)
        if self.Rectangle is not None:
            Rectangle_ = self.Rectangle
            Rectangle_.to_etree(element, name_='Rectangle', mapping_=mapping_)
        if self.Square is not None:
            Square_ = self.Square
            Square_.to_etree(element, name_='Square', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Region'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numberOfDirections is not None and 'numberOfDirections' not in already_processed:
            already_processed.add('numberOfDirections')
            showIndent(outfile, level)
            outfile.write('numberOfDirections=%d,\n' % (self.numberOfDirections,))
        if self.ifPhaseOnly is not None and 'ifPhaseOnly' not in already_processed:
            already_processed.add('ifPhaseOnly')
            showIndent(outfile, level)
            outfile.write('ifPhaseOnly=%d,\n' % (self.ifPhaseOnly,))
        if self.imageDirection is not None and 'imageDirection' not in already_processed:
            already_processed.add('imageDirection')
            showIndent(outfile, level)
            outfile.write('imageDirection=%d,\n' % (self.imageDirection,))
        if self.ifSquareShape is not None and 'ifSquareShape' not in already_processed:
            already_processed.add('ifSquareShape')
            showIndent(outfile, level)
            outfile.write('ifSquareShape=%d,\n' % (self.ifSquareShape,))
        if self.regionType is not None and 'regionType' not in already_processed:
            already_processed.add('regionType')
            showIndent(outfile, level)
            outfile.write('regionType=%d,\n' % (self.regionType,))
        if self.ifVirtual is not None and 'ifVirtual' not in already_processed:
            already_processed.add('ifVirtual')
            showIndent(outfile, level)
            outfile.write('ifVirtual=%d,\n' % (self.ifVirtual,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ZenithAzimuth is not None:
            showIndent(outfile, level)
            outfile.write('ZenithAzimuth=model_._ZenithAzimuth(\n')
            self.ZenithAzimuth.exportLiteral(outfile, level, name_='ZenithAzimuth')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LatLon is not None:
            showIndent(outfile, level)
            outfile.write('LatLon=model_._LatLon(\n')
            self.LatLon.exportLiteral(outfile, level, name_='LatLon')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Rectangle is not None:
            showIndent(outfile, level)
            outfile.write('Rectangle=model_._Rectangle(\n')
            self.Rectangle.exportLiteral(outfile, level, name_='Rectangle')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Square is not None:
            showIndent(outfile, level)
            outfile.write('Square=model_._Square(\n')
            self.Square.exportLiteral(outfile, level, name_='Square')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfDirections', node)
        if value is not None and 'numberOfDirections' not in already_processed:
            already_processed.add('numberOfDirections')
            try:
                self.numberOfDirections = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ifPhaseOnly', node)
        if value is not None and 'ifPhaseOnly' not in already_processed:
            already_processed.add('ifPhaseOnly')
            try:
                self.ifPhaseOnly = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('imageDirection', node)
        if value is not None and 'imageDirection' not in already_processed:
            already_processed.add('imageDirection')
            try:
                self.imageDirection = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ifSquareShape', node)
        if value is not None and 'ifSquareShape' not in already_processed:
            already_processed.add('ifSquareShape')
            try:
                self.ifSquareShape = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('regionType', node)
        if value is not None and 'regionType' not in already_processed:
            already_processed.add('regionType')
            try:
                self.regionType = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ifVirtual', node)
        if value is not None and 'ifVirtual' not in already_processed:
            already_processed.add('ifVirtual')
            try:
                self.ifVirtual = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ZenithAzimuth':
            obj_ = create_ZenithAzimuth.factory()
            obj_.build(child_)
            self.set_ZenithAzimuth(obj_)
            obj_.original_tagname_ = 'ZenithAzimuth'
        elif nodeName_ == 'LatLon':
            obj_ = create_LatLon.factory()
            obj_.build(child_)
            self.set_LatLon(obj_)
            obj_.original_tagname_ = 'LatLon'
        elif nodeName_ == 'Rectangle':
            obj_ = create_Rectangle.factory()
            obj_.build(child_)
            self.set_Rectangle(obj_)
            obj_.original_tagname_ = 'Rectangle'
        elif nodeName_ == 'Square':
            obj_ = create_Square.factory()
            obj_.build(child_)
            self.set_Square(obj_)
            obj_.original_tagname_ = 'Square'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_Region


class create_OversampledPlane(GeneratedsSuper):
    """Zenith step between each direction in the oversampled plane in the
    [0\u00B0, 90\u00B0] range. Zenith step between each direction in
    the oversampled plane in the [0\u00B0, 90\u00B0] range. Solid
    angle for each direction in the oversampled plane (in
    steradians). Solid angle for each direction in the oversampled
    plane (in steradians). Plane Azimuth Plane Azimuth Define Zenith
    Angle range Define Zenith Angle range"""
    member_data_items_ = [
        MemberSpec_('deltaTheta', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('omega', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('phi', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('defRange', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('thetaRange', '_thetaRange', 0, 0, {u'maxOccurs': u'1', u'type': u'_thetaRange', u'name': u'thetaRange', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, deltaTheta=10.0, omega=0.001, phi=65.0, defRange=0, thetaRange=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('directions','_OversampledPlane')
        self.attrib = ['deltaTheta', 'omega', 'phi', 'defRange']
        self.children = ['thetaRange']
        self.parent = None
        self._deltaTheta = _cast(float, deltaTheta)
        self._omega = _cast(float, omega)
        self._phi = _cast(float, phi)
        self._defRange = _cast(int, defRange)
        self._thetaRange = thetaRange
        update_node(self,self.troot,'directions')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_OversampledPlane)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_OversampledPlane.subclass:
            return create_OversampledPlane.subclass(*args_, **kwargs_)
        else:
            return create_OversampledPlane(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_thetaRange(self): return self._thetaRange
    def set_thetaRange(self, value):
        if value is not None:
            checkclass(value, create_thetaRange)
            value.parent = self
        self._thetaRange = value
    thetaRange = property(get_thetaRange, set_thetaRange)
    def get_deltaTheta(self): return self._deltaTheta
    def set_deltaTheta(self, value):
        self._deltaTheta = value
        update_node(self,self.troot,'directions')
    deltaTheta = property(get_deltaTheta, set_deltaTheta)
    def get_omega(self): return self._omega
    def set_omega(self, value):
        self._omega = value
        update_node(self,self.troot,'directions')
    omega = property(get_omega, set_omega)
    def get_phi(self): return self._phi
    def set_phi(self, value):
        self._phi = value
        update_node(self,self.troot,'directions')
    phi = property(get_phi, set_phi)
    def get_defRange(self): return self._defRange
    def set_defRange(self, value):
        self._defRange = value
        update_node(self,self.troot,'directions')
    defRange = property(get_defRange, set_defRange)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.thetaRange is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_OversampledPlane', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_OversampledPlane')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_OversampledPlane')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_OversampledPlane', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_OversampledPlane'):
        if self.deltaTheta is not None and 'deltaTheta' not in already_processed:
            already_processed.add('deltaTheta')
            outfile.write(' deltaTheta="%s"' % self.gds_format_double(self.deltaTheta, input_name='deltaTheta'))
        if self.omega is not None and 'omega' not in already_processed:
            already_processed.add('omega')
            outfile.write(' omega="%s"' % self.gds_format_double(self.omega, input_name='omega'))
        if self.phi is not None and 'phi' not in already_processed:
            already_processed.add('phi')
            outfile.write(' phi="%s"' % self.gds_format_double(self.phi, input_name='phi'))
        if self.defRange is not None and 'defRange' not in already_processed:
            already_processed.add('defRange')
            outfile.write(' defRange="%s"' % self.gds_format_integer(self.defRange, input_name='defRange'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_OversampledPlane', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.thetaRange is not None:
            self.thetaRange.export(outfile, level, namespaceprefix_, name_='thetaRange', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_OversampledPlane', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.deltaTheta is not None:
            element.set('deltaTheta', self.gds_format_double(self.deltaTheta))
        if self.omega is not None:
            element.set('omega', self.gds_format_double(self.omega))
        if self.phi is not None:
            element.set('phi', self.gds_format_double(self.phi))
        if self.defRange is not None:
            element.set('defRange', self.gds_format_integer(self.defRange))
        if self.thetaRange is not None:
            thetaRange_ = self.thetaRange
            thetaRange_.to_etree(element, name_='thetaRange', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_OversampledPlane'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.deltaTheta is not None and 'deltaTheta' not in already_processed:
            already_processed.add('deltaTheta')
            showIndent(outfile, level)
            outfile.write('deltaTheta=%e,\n' % (self.deltaTheta,))
        if self.omega is not None and 'omega' not in already_processed:
            already_processed.add('omega')
            showIndent(outfile, level)
            outfile.write('omega=%e,\n' % (self.omega,))
        if self.phi is not None and 'phi' not in already_processed:
            already_processed.add('phi')
            showIndent(outfile, level)
            outfile.write('phi=%e,\n' % (self.phi,))
        if self.defRange is not None and 'defRange' not in already_processed:
            already_processed.add('defRange')
            showIndent(outfile, level)
            outfile.write('defRange=%d,\n' % (self.defRange,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.thetaRange is not None:
            showIndent(outfile, level)
            outfile.write('thetaRange=model_._thetaRange(\n')
            self.thetaRange.exportLiteral(outfile, level, name_='thetaRange')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('deltaTheta', node)
        if value is not None and 'deltaTheta' not in already_processed:
            already_processed.add('deltaTheta')
            try:
                self.deltaTheta = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (deltaTheta): %s' % exp)
        value = find_attr_value_('omega', node)
        if value is not None and 'omega' not in already_processed:
            already_processed.add('omega')
            try:
                self.omega = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (omega): %s' % exp)
        value = find_attr_value_('phi', node)
        if value is not None and 'phi' not in already_processed:
            already_processed.add('phi')
            try:
                self.phi = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (phi): %s' % exp)
        value = find_attr_value_('defRange', node)
        if value is not None and 'defRange' not in already_processed:
            already_processed.add('defRange')
            try:
                self.defRange = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'thetaRange':
            obj_ = create_thetaRange.factory()
            obj_.build(child_)
            self.set_thetaRange(obj_)
            obj_.original_tagname_ = 'thetaRange'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_OversampledPlane


class create_thetaRange(GeneratedsSuper):
    """Zenith Angle range Zenith Angle range Begin [\u00B0] Begin [\u00B0]
    End [\u00B0] End [\u00B0]"""
    member_data_items_ = [
        MemberSpec_('theta__0', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('theta__1', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, theta__0=-90, theta__1=90):
        self.original_tagname_ = None
        self.troot=get_gs_troot('directions','_thetaRange')
        self.attrib = ['theta__0', 'theta__1']
        self.children = []
        self.parent = None
        self._theta__0 = _cast(float, theta__0)
        self._theta__1 = _cast(float, theta__1)
        update_node(self,self.troot,'directions')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_thetaRange)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_thetaRange.subclass:
            return create_thetaRange.subclass(*args_, **kwargs_)
        else:
            return create_thetaRange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_theta__0(self): return self._theta__0
    def set_theta__0(self, value):
        self._theta__0 = value
        update_node(self,self.troot,'directions')
    theta__0 = property(get_theta__0, set_theta__0)
    def get_theta__1(self): return self._theta__1
    def set_theta__1(self, value):
        self._theta__1 = value
        update_node(self,self.troot,'directions')
    theta__1 = property(get_theta__1, set_theta__1)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_thetaRange', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_thetaRange')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_thetaRange')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_thetaRange', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_thetaRange'):
        if self.theta__0 is not None and 'theta__0' not in already_processed:
            already_processed.add('theta__0')
            outfile.write(' theta__0="%s"' % self.gds_format_double(self.theta__0, input_name='theta__0'))
        if self.theta__1 is not None and 'theta__1' not in already_processed:
            already_processed.add('theta__1')
            outfile.write(' theta__1="%s"' % self.gds_format_double(self.theta__1, input_name='theta__1'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_thetaRange', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_thetaRange', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.theta__0 is not None:
            element.set('theta__0', self.gds_format_double(self.theta__0))
        if self.theta__1 is not None:
            element.set('theta__1', self.gds_format_double(self.theta__1))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_thetaRange'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.theta__0 is not None and 'theta__0' not in already_processed:
            already_processed.add('theta__0')
            showIndent(outfile, level)
            outfile.write('theta__0=%e,\n' % (self.theta__0,))
        if self.theta__1 is not None and 'theta__1' not in already_processed:
            already_processed.add('theta__1')
            showIndent(outfile, level)
            outfile.write('theta__1=%e,\n' % (self.theta__1,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('theta__0', node)
        if value is not None and 'theta__0' not in already_processed:
            already_processed.add('theta__0')
            try:
                self.theta__0 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (theta__0): %s' % exp)
        value = find_attr_value_('theta__1', node)
        if value is not None and 'theta__1' not in already_processed:
            already_processed.add('theta__1')
            try:
                self.theta__1 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (theta__1): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_thetaRange


class create_Sun(GeneratedsSuper):
    """Azimuth angle of the sun downward direction in [0\u00B0, 360\u00B0],
    anticlockwise from the reference direction. \nThe Ox direction
    (vertical on the 2D display of the scene) is the reference
    direction in the xy plane. Azimuth angle of the sun downward
    direction in [0\u00B0, 360\u00B0], anticlockwise from the
    reference direction. \nThe Ox direction (vertical on the 2D
    display of the scene) is the reference direction in the xy
    plane. Zenith angle of the sun direction in the ]90\u00B0,
    180\u00B0] range (Sun to Ground) Zenith angle of the sun
    direction in the ]90\u00B0, 180\u00B0] range (Sun to Ground) Day
    of the year (from 1 to 365). Set it to -1 to ignore. Used to
    compute the Sun-Earth distance and the subsequent correction to
    apply to the solar illumination. Day of the year (from 1 to
    365). Set it to -1 to ignore. Used to compute the Sun-Earth
    distance and the subsequent correction to apply to the solar
    illumination."""
    member_data_items_ = [
        MemberSpec_('sunAzimuthAngle', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('sunZenithAngle', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('dayOfTheYear', 'xsd:int', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, sunAzimuthAngle=45.0, sunZenithAngle=150.0, dayOfTheYear=-1):
        self.original_tagname_ = None
        self.troot=get_gs_troot('directions','_Sun')
        self.attrib = ['sunAzimuthAngle', 'sunZenithAngle', 'dayOfTheYear']
        self.children = []
        self.parent = None
        self._sunAzimuthAngle = _cast(float, sunAzimuthAngle)
        self._sunZenithAngle = _cast(float, sunZenithAngle)
        self._dayOfTheYear = _cast(int, dayOfTheYear)
        update_node(self,self.troot,'directions')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Sun)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Sun.subclass:
            return create_Sun.subclass(*args_, **kwargs_)
        else:
            return create_Sun(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sunAzimuthAngle(self): return self._sunAzimuthAngle
    def set_sunAzimuthAngle(self, value):
        self._sunAzimuthAngle = value
        update_node(self,self.troot,'directions')
    sunAzimuthAngle = property(get_sunAzimuthAngle, set_sunAzimuthAngle)
    def get_sunZenithAngle(self): return self._sunZenithAngle
    def set_sunZenithAngle(self, value):
        self._sunZenithAngle = value
        update_node(self,self.troot,'directions')
    sunZenithAngle = property(get_sunZenithAngle, set_sunZenithAngle)
    def get_dayOfTheYear(self): return self._dayOfTheYear
    def set_dayOfTheYear(self, value):
        self._dayOfTheYear = value
        update_node(self,self.troot,'directions')
    dayOfTheYear = property(get_dayOfTheYear, set_dayOfTheYear)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Sun', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Sun')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Sun')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Sun', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Sun'):
        if self.sunAzimuthAngle is not None and 'sunAzimuthAngle' not in already_processed:
            already_processed.add('sunAzimuthAngle')
            outfile.write(' sunAzimuthAngle="%s"' % self.gds_format_double(self.sunAzimuthAngle, input_name='sunAzimuthAngle'))
        if self.sunZenithAngle is not None and 'sunZenithAngle' not in already_processed:
            already_processed.add('sunZenithAngle')
            outfile.write(' sunZenithAngle="%s"' % self.gds_format_double(self.sunZenithAngle, input_name='sunZenithAngle'))
        if self.dayOfTheYear is not None and 'dayOfTheYear' not in already_processed:
            already_processed.add('dayOfTheYear')
            outfile.write(' dayOfTheYear="%s"' % self.gds_format_integer(self.dayOfTheYear, input_name='dayOfTheYear'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Sun', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_Sun', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.sunAzimuthAngle is not None:
            element.set('sunAzimuthAngle', self.gds_format_double(self.sunAzimuthAngle))
        if self.sunZenithAngle is not None:
            element.set('sunZenithAngle', self.gds_format_double(self.sunZenithAngle))
        if self.dayOfTheYear is not None:
            element.set('dayOfTheYear', self.gds_format_integer(self.dayOfTheYear))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Sun'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sunAzimuthAngle is not None and 'sunAzimuthAngle' not in already_processed:
            already_processed.add('sunAzimuthAngle')
            showIndent(outfile, level)
            outfile.write('sunAzimuthAngle=%e,\n' % (self.sunAzimuthAngle,))
        if self.sunZenithAngle is not None and 'sunZenithAngle' not in already_processed:
            already_processed.add('sunZenithAngle')
            showIndent(outfile, level)
            outfile.write('sunZenithAngle=%e,\n' % (self.sunZenithAngle,))
        if self.dayOfTheYear is not None and 'dayOfTheYear' not in already_processed:
            already_processed.add('dayOfTheYear')
            showIndent(outfile, level)
            outfile.write('dayOfTheYear=%d,\n' % (self.dayOfTheYear,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sunAzimuthAngle', node)
        if value is not None and 'sunAzimuthAngle' not in already_processed:
            already_processed.add('sunAzimuthAngle')
            try:
                self.sunAzimuthAngle = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sunAzimuthAngle): %s' % exp)
        value = find_attr_value_('sunZenithAngle', node)
        if value is not None and 'sunZenithAngle' not in already_processed:
            already_processed.add('sunZenithAngle')
            try:
                self.sunZenithAngle = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sunZenithAngle): %s' % exp)
        value = find_attr_value_('dayOfTheYear', node)
        if value is not None and 'dayOfTheYear' not in already_processed:
            already_processed.add('dayOfTheYear')
            try:
                self.dayOfTheYear = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_Sun


class create_ExactDateHour(GeneratedsSuper):
    """Hours into the day Hours into the day Click this if the simulated
    area is observing DST at the given date. Click this if the
    simulated area is observing DST at the given date. Month into
    the year Month into the year Seconds into the minute Seconds
    into the minute Year (From 1400 to 10 000) Year (From 1400 to 10
    000) Local Time Zone (UTC) : if the time is given as local time,
    this must be the time difference with UTC. If the time is given
    as UTC time, this must be 0 Local Time Zone (UTC) : if the time
    is given as local time, this must be the time difference with
    UTC. If the time is given as UTC time, this must be 0 Day of the
    month Day of the month Minutes into the hour Minutes into the
    hour Local time Local time"""
    member_data_items_ = [
        MemberSpec_('hour', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('daylightSavingTime', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('month', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('second', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('year', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('timezone', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('day', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('minute', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('localTime', 'xsd:int', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, hour=12, daylightSavingTime=0, month=1, second=0, year=2012, timezone=0, day=1, minute=0, localTime=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('directions','_ExactDateHour')
        self.attrib = ['hour', 'daylightSavingTime', 'month', 'second', 'year', 'timezone', 'day', 'minute', 'localTime']
        self.children = []
        self.parent = None
        self._hour = _cast(int, hour)
        self._daylightSavingTime = _cast(int, daylightSavingTime)
        self._month = _cast(int, month)
        self._second = _cast(int, second)
        self._year = _cast(int, year)
        self._timezone = _cast(float, timezone)
        self._day = _cast(int, day)
        self._minute = _cast(int, minute)
        self._localTime = _cast(int, localTime)
        update_node(self,self.troot,'directions')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ExactDateHour)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ExactDateHour.subclass:
            return create_ExactDateHour.subclass(*args_, **kwargs_)
        else:
            return create_ExactDateHour(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hour(self): return self._hour
    def set_hour(self, value):
        self._hour = value
        update_node(self,self.troot,'directions')
    hour = property(get_hour, set_hour)
    def get_daylightSavingTime(self): return self._daylightSavingTime
    def set_daylightSavingTime(self, value):
        self._daylightSavingTime = value
        update_node(self,self.troot,'directions')
    daylightSavingTime = property(get_daylightSavingTime, set_daylightSavingTime)
    def get_month(self): return self._month
    def set_month(self, value):
        self._month = value
        update_node(self,self.troot,'directions')
    month = property(get_month, set_month)
    def get_second(self): return self._second
    def set_second(self, value):
        self._second = value
        update_node(self,self.troot,'directions')
    second = property(get_second, set_second)
    def get_year(self): return self._year
    def set_year(self, value):
        self._year = value
        update_node(self,self.troot,'directions')
    year = property(get_year, set_year)
    def get_timezone(self): return self._timezone
    def set_timezone(self, value):
        self._timezone = value
        update_node(self,self.troot,'directions')
    timezone = property(get_timezone, set_timezone)
    def get_day(self): return self._day
    def set_day(self, value):
        self._day = value
        update_node(self,self.troot,'directions')
    day = property(get_day, set_day)
    def get_minute(self): return self._minute
    def set_minute(self, value):
        self._minute = value
        update_node(self,self.troot,'directions')
    minute = property(get_minute, set_minute)
    def get_localTime(self): return self._localTime
    def set_localTime(self, value):
        self._localTime = value
        update_node(self,self.troot,'directions')
    localTime = property(get_localTime, set_localTime)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ExactDateHour', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ExactDateHour')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ExactDateHour')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ExactDateHour', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ExactDateHour'):
        if self.hour is not None and 'hour' not in already_processed:
            already_processed.add('hour')
            outfile.write(' hour="%s"' % self.gds_format_integer(self.hour, input_name='hour'))
        if self.daylightSavingTime is not None and 'daylightSavingTime' not in already_processed:
            already_processed.add('daylightSavingTime')
            outfile.write(' daylightSavingTime="%s"' % self.gds_format_integer(self.daylightSavingTime, input_name='daylightSavingTime'))
        if self.month is not None and 'month' not in already_processed:
            already_processed.add('month')
            outfile.write(' month="%s"' % self.gds_format_integer(self.month, input_name='month'))
        if self.second is not None and 'second' not in already_processed:
            already_processed.add('second')
            outfile.write(' second="%s"' % self.gds_format_integer(self.second, input_name='second'))
        if self.year is not None and 'year' not in already_processed:
            already_processed.add('year')
            outfile.write(' year="%s"' % self.gds_format_integer(self.year, input_name='year'))
        if self.timezone is not None and 'timezone' not in already_processed:
            already_processed.add('timezone')
            outfile.write(' timezone="%s"' % self.gds_format_double(self.timezone, input_name='timezone'))
        if self.day is not None and 'day' not in already_processed:
            already_processed.add('day')
            outfile.write(' day="%s"' % self.gds_format_integer(self.day, input_name='day'))
        if self.minute is not None and 'minute' not in already_processed:
            already_processed.add('minute')
            outfile.write(' minute="%s"' % self.gds_format_integer(self.minute, input_name='minute'))
        if self.localTime is not None and 'localTime' not in already_processed:
            already_processed.add('localTime')
            outfile.write(' localTime="%s"' % self.gds_format_integer(self.localTime, input_name='localTime'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ExactDateHour', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_ExactDateHour', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.hour is not None:
            element.set('hour', self.gds_format_integer(self.hour))
        if self.daylightSavingTime is not None:
            element.set('daylightSavingTime', self.gds_format_integer(self.daylightSavingTime))
        if self.month is not None:
            element.set('month', self.gds_format_integer(self.month))
        if self.second is not None:
            element.set('second', self.gds_format_integer(self.second))
        if self.year is not None:
            element.set('year', self.gds_format_integer(self.year))
        if self.timezone is not None:
            element.set('timezone', self.gds_format_double(self.timezone))
        if self.day is not None:
            element.set('day', self.gds_format_integer(self.day))
        if self.minute is not None:
            element.set('minute', self.gds_format_integer(self.minute))
        if self.localTime is not None:
            element.set('localTime', self.gds_format_integer(self.localTime))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ExactDateHour'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.hour is not None and 'hour' not in already_processed:
            already_processed.add('hour')
            showIndent(outfile, level)
            outfile.write('hour=%d,\n' % (self.hour,))
        if self.daylightSavingTime is not None and 'daylightSavingTime' not in already_processed:
            already_processed.add('daylightSavingTime')
            showIndent(outfile, level)
            outfile.write('daylightSavingTime=%d,\n' % (self.daylightSavingTime,))
        if self.month is not None and 'month' not in already_processed:
            already_processed.add('month')
            showIndent(outfile, level)
            outfile.write('month=%d,\n' % (self.month,))
        if self.second is not None and 'second' not in already_processed:
            already_processed.add('second')
            showIndent(outfile, level)
            outfile.write('second=%d,\n' % (self.second,))
        if self.year is not None and 'year' not in already_processed:
            already_processed.add('year')
            showIndent(outfile, level)
            outfile.write('year=%d,\n' % (self.year,))
        if self.timezone is not None and 'timezone' not in already_processed:
            already_processed.add('timezone')
            showIndent(outfile, level)
            outfile.write('timezone=%e,\n' % (self.timezone,))
        if self.day is not None and 'day' not in already_processed:
            already_processed.add('day')
            showIndent(outfile, level)
            outfile.write('day=%d,\n' % (self.day,))
        if self.minute is not None and 'minute' not in already_processed:
            already_processed.add('minute')
            showIndent(outfile, level)
            outfile.write('minute=%d,\n' % (self.minute,))
        if self.localTime is not None and 'localTime' not in already_processed:
            already_processed.add('localTime')
            showIndent(outfile, level)
            outfile.write('localTime=%d,\n' % (self.localTime,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hour', node)
        if value is not None and 'hour' not in already_processed:
            already_processed.add('hour')
            try:
                self.hour = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('daylightSavingTime', node)
        if value is not None and 'daylightSavingTime' not in already_processed:
            already_processed.add('daylightSavingTime')
            try:
                self.daylightSavingTime = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('month', node)
        if value is not None and 'month' not in already_processed:
            already_processed.add('month')
            try:
                self.month = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('second', node)
        if value is not None and 'second' not in already_processed:
            already_processed.add('second')
            try:
                self.second = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('year', node)
        if value is not None and 'year' not in already_processed:
            already_processed.add('year')
            try:
                self.year = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('timezone', node)
        if value is not None and 'timezone' not in already_processed:
            already_processed.add('timezone')
            try:
                self.timezone = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (timezone): %s' % exp)
        value = find_attr_value_('day', node)
        if value is not None and 'day' not in already_processed:
            already_processed.add('day')
            try:
                self.day = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('minute', node)
        if value is not None and 'minute' not in already_processed:
            already_processed.add('minute')
            try:
                self.minute = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('localTime', node)
        if value is not None and 'localTime' not in already_processed:
            already_processed.add('localTime')
            try:
                self.localTime = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_ExactDateHour


class create_SunViewingAngles(GeneratedsSuper):
    """Azimuth angle of the sun downward direction in [0\u00B0, 360\u00B0],
    anticlockwise from the reference direction. \nThe Ox direction
    (vertical on the 2D display of the scene) is the reference
    direction in the xy plane. Azimuth angle of the sun downward
    direction in [0\u00B0, 360\u00B0], anticlockwise from the
    reference direction. \nThe Ox direction (vertical on the 2D
    display of the scene) is the reference direction in the xy
    plane. Zenith angle of the sun direction in the [0\u00B0,
    90\u00B0[ range (Ground to Sun) Zenith angle of the sun
    direction in the [0\u00B0, 90\u00B0[ range (Ground to Sun) Day
    of the year (from 1 to 365). Set it to -1 to ignore. Used to
    compute the Sun-Earth distance and the subsequent correction to
    apply to the solar illumination. Day of the year (from 1 to
    365). Set it to -1 to ignore. Used to compute the Sun-Earth
    distance and the subsequent correction to apply to the solar
    illumination."""
    member_data_items_ = [
        MemberSpec_('sunViewingAzimuthAngle', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('sunViewingZenithAngle', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('dayOfTheYear', 'xsd:int', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, sunViewingAzimuthAngle=225.0, sunViewingZenithAngle=30.0, dayOfTheYear=-1):
        self.original_tagname_ = None
        self.troot=get_gs_troot('directions','_SunViewingAngles')
        self.attrib = ['sunViewingAzimuthAngle', 'sunViewingZenithAngle', 'dayOfTheYear']
        self.children = []
        self.parent = None
        self._sunViewingAzimuthAngle = _cast(float, sunViewingAzimuthAngle)
        self._sunViewingZenithAngle = _cast(float, sunViewingZenithAngle)
        self._dayOfTheYear = _cast(int, dayOfTheYear)
        update_node(self,self.troot,'directions')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_SunViewingAngles)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_SunViewingAngles.subclass:
            return create_SunViewingAngles.subclass(*args_, **kwargs_)
        else:
            return create_SunViewingAngles(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sunViewingAzimuthAngle(self): return self._sunViewingAzimuthAngle
    def set_sunViewingAzimuthAngle(self, value):
        self._sunViewingAzimuthAngle = value
        update_node(self,self.troot,'directions')
    sunViewingAzimuthAngle = property(get_sunViewingAzimuthAngle, set_sunViewingAzimuthAngle)
    def get_sunViewingZenithAngle(self): return self._sunViewingZenithAngle
    def set_sunViewingZenithAngle(self, value):
        self._sunViewingZenithAngle = value
        update_node(self,self.troot,'directions')
    sunViewingZenithAngle = property(get_sunViewingZenithAngle, set_sunViewingZenithAngle)
    def get_dayOfTheYear(self): return self._dayOfTheYear
    def set_dayOfTheYear(self, value):
        self._dayOfTheYear = value
        update_node(self,self.troot,'directions')
    dayOfTheYear = property(get_dayOfTheYear, set_dayOfTheYear)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_SunViewingAngles', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_SunViewingAngles')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_SunViewingAngles')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_SunViewingAngles', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_SunViewingAngles'):
        if self.sunViewingAzimuthAngle is not None and 'sunViewingAzimuthAngle' not in already_processed:
            already_processed.add('sunViewingAzimuthAngle')
            outfile.write(' sunViewingAzimuthAngle="%s"' % self.gds_format_double(self.sunViewingAzimuthAngle, input_name='sunViewingAzimuthAngle'))
        if self.sunViewingZenithAngle is not None and 'sunViewingZenithAngle' not in already_processed:
            already_processed.add('sunViewingZenithAngle')
            outfile.write(' sunViewingZenithAngle="%s"' % self.gds_format_double(self.sunViewingZenithAngle, input_name='sunViewingZenithAngle'))
        if self.dayOfTheYear is not None and 'dayOfTheYear' not in already_processed:
            already_processed.add('dayOfTheYear')
            outfile.write(' dayOfTheYear="%s"' % self.gds_format_integer(self.dayOfTheYear, input_name='dayOfTheYear'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_SunViewingAngles', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_SunViewingAngles', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.sunViewingAzimuthAngle is not None:
            element.set('sunViewingAzimuthAngle', self.gds_format_double(self.sunViewingAzimuthAngle))
        if self.sunViewingZenithAngle is not None:
            element.set('sunViewingZenithAngle', self.gds_format_double(self.sunViewingZenithAngle))
        if self.dayOfTheYear is not None:
            element.set('dayOfTheYear', self.gds_format_integer(self.dayOfTheYear))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_SunViewingAngles'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sunViewingAzimuthAngle is not None and 'sunViewingAzimuthAngle' not in already_processed:
            already_processed.add('sunViewingAzimuthAngle')
            showIndent(outfile, level)
            outfile.write('sunViewingAzimuthAngle=%e,\n' % (self.sunViewingAzimuthAngle,))
        if self.sunViewingZenithAngle is not None and 'sunViewingZenithAngle' not in already_processed:
            already_processed.add('sunViewingZenithAngle')
            showIndent(outfile, level)
            outfile.write('sunViewingZenithAngle=%e,\n' % (self.sunViewingZenithAngle,))
        if self.dayOfTheYear is not None and 'dayOfTheYear' not in already_processed:
            already_processed.add('dayOfTheYear')
            showIndent(outfile, level)
            outfile.write('dayOfTheYear=%d,\n' % (self.dayOfTheYear,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sunViewingAzimuthAngle', node)
        if value is not None and 'sunViewingAzimuthAngle' not in already_processed:
            already_processed.add('sunViewingAzimuthAngle')
            try:
                self.sunViewingAzimuthAngle = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sunViewingAzimuthAngle): %s' % exp)
        value = find_attr_value_('sunViewingZenithAngle', node)
        if value is not None and 'sunViewingZenithAngle' not in already_processed:
            already_processed.add('sunViewingZenithAngle')
            try:
                self.sunViewingZenithAngle = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sunViewingZenithAngle): %s' % exp)
        value = find_attr_value_('dayOfTheYear', node)
        if value is not None and 'dayOfTheYear' not in already_processed:
            already_processed.add('dayOfTheYear')
            try:
                self.dayOfTheYear = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_SunViewingAngles


class create_HotSpotProperties(GeneratedsSuper):
    """Adds directions around the downward hot spot direction, with very
    small solid angles Adds directions around the downward hot spot
    direction, with very small solid angles Oversample the plane
    perpendicular to the solar plane (directions with same azimuth).
    Oversample the plane perpendicular to the solar plane
    (directions with same azimuth). Oversample the solar plane
    (directions with sun direction azimuth). Oversample the solar
    plane (directions with sun direction azimuth). Adds directions
    around the upward hot spot direction, with very small solid
    angles Adds directions around the upward hot spot direction,
    with very small solid angles"""
    member_data_items_ = [
        MemberSpec_('oversampleDownwardRegion', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('hotSpotPerpendicularPlane', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('hotSpotParallelPlane', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('oversampleUpwardRegion', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('HotSpotUpwardRegion', '_HotSpotUpwardRegion', 0, 0, {u'maxOccurs': u'1', u'type': u'_HotSpotUpwardRegion', u'name': u'HotSpotUpwardRegion', u'minOccurs': u'1'}, None),
        MemberSpec_('HotSpotDownwardRegion', '_HotSpotDownwardRegion', 0, 0, {u'maxOccurs': u'1', u'type': u'_HotSpotDownwardRegion', u'name': u'HotSpotDownwardRegion', u'minOccurs': u'1'}, None),
        MemberSpec_('HotSpotOversampledPlane', '_HotSpotOversampledPlane', 0, 0, {u'maxOccurs': u'1', u'type': u'_HotSpotOversampledPlane', u'name': u'HotSpotOversampledPlane', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, oversampleDownwardRegion=0, hotSpotPerpendicularPlane=0, hotSpotParallelPlane=0, oversampleUpwardRegion=0, HotSpotUpwardRegion=None, HotSpotDownwardRegion=None, HotSpotOversampledPlane=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('directions','_HotSpotProperties')
        self.attrib = ['oversampleDownwardRegion', 'hotSpotPerpendicularPlane', 'hotSpotParallelPlane', 'oversampleUpwardRegion']
        self.children = ['HotSpotUpwardRegion', 'HotSpotDownwardRegion', 'HotSpotOversampledPlane']
        self.parent = None
        self._oversampleDownwardRegion = _cast(int, oversampleDownwardRegion)
        self._hotSpotPerpendicularPlane = _cast(int, hotSpotPerpendicularPlane)
        self._hotSpotParallelPlane = _cast(int, hotSpotParallelPlane)
        self._oversampleUpwardRegion = _cast(int, oversampleUpwardRegion)
        self._HotSpotUpwardRegion = HotSpotUpwardRegion
        self._HotSpotDownwardRegion = HotSpotDownwardRegion
        self._HotSpotOversampledPlane = HotSpotOversampledPlane
        update_node(self,self.troot,'directions')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_HotSpotProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_HotSpotProperties.subclass:
            return create_HotSpotProperties.subclass(*args_, **kwargs_)
        else:
            return create_HotSpotProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HotSpotUpwardRegion(self): return self._HotSpotUpwardRegion
    def set_HotSpotUpwardRegion(self, value):
        if value is not None:
            checkclass(value, create_HotSpotUpwardRegion)
            value.parent = self
        self._HotSpotUpwardRegion = value
    HotSpotUpwardRegion = property(get_HotSpotUpwardRegion, set_HotSpotUpwardRegion)
    def get_HotSpotDownwardRegion(self): return self._HotSpotDownwardRegion
    def set_HotSpotDownwardRegion(self, value):
        if value is not None:
            checkclass(value, create_HotSpotDownwardRegion)
            value.parent = self
        self._HotSpotDownwardRegion = value
    HotSpotDownwardRegion = property(get_HotSpotDownwardRegion, set_HotSpotDownwardRegion)
    def get_HotSpotOversampledPlane(self): return self._HotSpotOversampledPlane
    def set_HotSpotOversampledPlane(self, value):
        if value is not None:
            checkclass(value, create_HotSpotOversampledPlane)
            value.parent = self
        self._HotSpotOversampledPlane = value
    HotSpotOversampledPlane = property(get_HotSpotOversampledPlane, set_HotSpotOversampledPlane)
    def get_oversampleDownwardRegion(self): return self._oversampleDownwardRegion
    def set_oversampleDownwardRegion(self, value):
        self._oversampleDownwardRegion = value
        update_node(self,self.troot,'directions')
    oversampleDownwardRegion = property(get_oversampleDownwardRegion, set_oversampleDownwardRegion)
    def get_hotSpotPerpendicularPlane(self): return self._hotSpotPerpendicularPlane
    def set_hotSpotPerpendicularPlane(self, value):
        self._hotSpotPerpendicularPlane = value
        update_node(self,self.troot,'directions')
    hotSpotPerpendicularPlane = property(get_hotSpotPerpendicularPlane, set_hotSpotPerpendicularPlane)
    def get_hotSpotParallelPlane(self): return self._hotSpotParallelPlane
    def set_hotSpotParallelPlane(self, value):
        self._hotSpotParallelPlane = value
        update_node(self,self.troot,'directions')
    hotSpotParallelPlane = property(get_hotSpotParallelPlane, set_hotSpotParallelPlane)
    def get_oversampleUpwardRegion(self): return self._oversampleUpwardRegion
    def set_oversampleUpwardRegion(self, value):
        self._oversampleUpwardRegion = value
        update_node(self,self.troot,'directions')
    oversampleUpwardRegion = property(get_oversampleUpwardRegion, set_oversampleUpwardRegion)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.HotSpotUpwardRegion is not None or
            self.HotSpotDownwardRegion is not None or
            self.HotSpotOversampledPlane is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_HotSpotProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_HotSpotProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_HotSpotProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_HotSpotProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_HotSpotProperties'):
        if self.oversampleDownwardRegion is not None and 'oversampleDownwardRegion' not in already_processed:
            already_processed.add('oversampleDownwardRegion')
            outfile.write(' oversampleDownwardRegion="%s"' % self.gds_format_integer(self.oversampleDownwardRegion, input_name='oversampleDownwardRegion'))
        if self.hotSpotPerpendicularPlane is not None and 'hotSpotPerpendicularPlane' not in already_processed:
            already_processed.add('hotSpotPerpendicularPlane')
            outfile.write(' hotSpotPerpendicularPlane="%s"' % self.gds_format_integer(self.hotSpotPerpendicularPlane, input_name='hotSpotPerpendicularPlane'))
        if self.hotSpotParallelPlane is not None and 'hotSpotParallelPlane' not in already_processed:
            already_processed.add('hotSpotParallelPlane')
            outfile.write(' hotSpotParallelPlane="%s"' % self.gds_format_integer(self.hotSpotParallelPlane, input_name='hotSpotParallelPlane'))
        if self.oversampleUpwardRegion is not None and 'oversampleUpwardRegion' not in already_processed:
            already_processed.add('oversampleUpwardRegion')
            outfile.write(' oversampleUpwardRegion="%s"' % self.gds_format_integer(self.oversampleUpwardRegion, input_name='oversampleUpwardRegion'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_HotSpotProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HotSpotUpwardRegion is not None:
            self.HotSpotUpwardRegion.export(outfile, level, namespaceprefix_, name_='HotSpotUpwardRegion', pretty_print=pretty_print)
        if self.HotSpotDownwardRegion is not None:
            self.HotSpotDownwardRegion.export(outfile, level, namespaceprefix_, name_='HotSpotDownwardRegion', pretty_print=pretty_print)
        if self.HotSpotOversampledPlane is not None:
            self.HotSpotOversampledPlane.export(outfile, level, namespaceprefix_, name_='HotSpotOversampledPlane', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_HotSpotProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.oversampleDownwardRegion is not None:
            element.set('oversampleDownwardRegion', self.gds_format_integer(self.oversampleDownwardRegion))
        if self.hotSpotPerpendicularPlane is not None:
            element.set('hotSpotPerpendicularPlane', self.gds_format_integer(self.hotSpotPerpendicularPlane))
        if self.hotSpotParallelPlane is not None:
            element.set('hotSpotParallelPlane', self.gds_format_integer(self.hotSpotParallelPlane))
        if self.oversampleUpwardRegion is not None:
            element.set('oversampleUpwardRegion', self.gds_format_integer(self.oversampleUpwardRegion))
        if self.HotSpotUpwardRegion is not None:
            HotSpotUpwardRegion_ = self.HotSpotUpwardRegion
            HotSpotUpwardRegion_.to_etree(element, name_='HotSpotUpwardRegion', mapping_=mapping_)
        if self.HotSpotDownwardRegion is not None:
            HotSpotDownwardRegion_ = self.HotSpotDownwardRegion
            HotSpotDownwardRegion_.to_etree(element, name_='HotSpotDownwardRegion', mapping_=mapping_)
        if self.HotSpotOversampledPlane is not None:
            HotSpotOversampledPlane_ = self.HotSpotOversampledPlane
            HotSpotOversampledPlane_.to_etree(element, name_='HotSpotOversampledPlane', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_HotSpotProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.oversampleDownwardRegion is not None and 'oversampleDownwardRegion' not in already_processed:
            already_processed.add('oversampleDownwardRegion')
            showIndent(outfile, level)
            outfile.write('oversampleDownwardRegion=%d,\n' % (self.oversampleDownwardRegion,))
        if self.hotSpotPerpendicularPlane is not None and 'hotSpotPerpendicularPlane' not in already_processed:
            already_processed.add('hotSpotPerpendicularPlane')
            showIndent(outfile, level)
            outfile.write('hotSpotPerpendicularPlane=%d,\n' % (self.hotSpotPerpendicularPlane,))
        if self.hotSpotParallelPlane is not None and 'hotSpotParallelPlane' not in already_processed:
            already_processed.add('hotSpotParallelPlane')
            showIndent(outfile, level)
            outfile.write('hotSpotParallelPlane=%d,\n' % (self.hotSpotParallelPlane,))
        if self.oversampleUpwardRegion is not None and 'oversampleUpwardRegion' not in already_processed:
            already_processed.add('oversampleUpwardRegion')
            showIndent(outfile, level)
            outfile.write('oversampleUpwardRegion=%d,\n' % (self.oversampleUpwardRegion,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.HotSpotUpwardRegion is not None:
            showIndent(outfile, level)
            outfile.write('HotSpotUpwardRegion=model_._HotSpotUpwardRegion(\n')
            self.HotSpotUpwardRegion.exportLiteral(outfile, level, name_='HotSpotUpwardRegion')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HotSpotDownwardRegion is not None:
            showIndent(outfile, level)
            outfile.write('HotSpotDownwardRegion=model_._HotSpotDownwardRegion(\n')
            self.HotSpotDownwardRegion.exportLiteral(outfile, level, name_='HotSpotDownwardRegion')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HotSpotOversampledPlane is not None:
            showIndent(outfile, level)
            outfile.write('HotSpotOversampledPlane=model_._HotSpotOversampledPlane(\n')
            self.HotSpotOversampledPlane.exportLiteral(outfile, level, name_='HotSpotOversampledPlane')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('oversampleDownwardRegion', node)
        if value is not None and 'oversampleDownwardRegion' not in already_processed:
            already_processed.add('oversampleDownwardRegion')
            try:
                self.oversampleDownwardRegion = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('hotSpotPerpendicularPlane', node)
        if value is not None and 'hotSpotPerpendicularPlane' not in already_processed:
            already_processed.add('hotSpotPerpendicularPlane')
            try:
                self.hotSpotPerpendicularPlane = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('hotSpotParallelPlane', node)
        if value is not None and 'hotSpotParallelPlane' not in already_processed:
            already_processed.add('hotSpotParallelPlane')
            try:
                self.hotSpotParallelPlane = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('oversampleUpwardRegion', node)
        if value is not None and 'oversampleUpwardRegion' not in already_processed:
            already_processed.add('oversampleUpwardRegion')
            try:
                self.oversampleUpwardRegion = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HotSpotUpwardRegion':
            obj_ = create_HotSpotUpwardRegion.factory()
            obj_.build(child_)
            self.set_HotSpotUpwardRegion(obj_)
            obj_.original_tagname_ = 'HotSpotUpwardRegion'
        elif nodeName_ == 'HotSpotDownwardRegion':
            obj_ = create_HotSpotDownwardRegion.factory()
            obj_.build(child_)
            self.set_HotSpotDownwardRegion(obj_)
            obj_.original_tagname_ = 'HotSpotDownwardRegion'
        elif nodeName_ == 'HotSpotOversampledPlane':
            obj_ = create_HotSpotOversampledPlane.factory()
            obj_.build(child_)
            self.set_HotSpotOversampledPlane(obj_)
            obj_.original_tagname_ = 'HotSpotOversampledPlane'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_HotSpotProperties


class create_HotSpotUpwardRegion(GeneratedsSuper):
    """Region Solid Angle (steradians) Region Solid Angle (steradians)
    Number of directions in region. Automatically rounded to the
    nearest squared integer. Number of directions in region.
    Automatically rounded to the nearest squared integer."""
    member_data_items_ = [
        MemberSpec_('omega', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('numberOfDirections', 'xsd:int', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, omega=0.01, numberOfDirections=25):
        self.original_tagname_ = None
        self.troot=get_gs_troot('directions','_HotSpotUpwardRegion')
        self.attrib = ['omega', 'numberOfDirections']
        self.children = []
        self.parent = None
        self._omega = _cast(float, omega)
        self._numberOfDirections = _cast(int, numberOfDirections)
        update_node(self,self.troot,'directions')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_HotSpotUpwardRegion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_HotSpotUpwardRegion.subclass:
            return create_HotSpotUpwardRegion.subclass(*args_, **kwargs_)
        else:
            return create_HotSpotUpwardRegion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_omega(self): return self._omega
    def set_omega(self, value):
        self._omega = value
        update_node(self,self.troot,'directions')
    omega = property(get_omega, set_omega)
    def get_numberOfDirections(self): return self._numberOfDirections
    def set_numberOfDirections(self, value):
        self._numberOfDirections = value
        update_node(self,self.troot,'directions')
    numberOfDirections = property(get_numberOfDirections, set_numberOfDirections)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_HotSpotUpwardRegion', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_HotSpotUpwardRegion')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_HotSpotUpwardRegion')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_HotSpotUpwardRegion', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_HotSpotUpwardRegion'):
        if self.omega is not None and 'omega' not in already_processed:
            already_processed.add('omega')
            outfile.write(' omega="%s"' % self.gds_format_double(self.omega, input_name='omega'))
        if self.numberOfDirections is not None and 'numberOfDirections' not in already_processed:
            already_processed.add('numberOfDirections')
            outfile.write(' numberOfDirections="%s"' % self.gds_format_integer(self.numberOfDirections, input_name='numberOfDirections'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_HotSpotUpwardRegion', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_HotSpotUpwardRegion', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.omega is not None:
            element.set('omega', self.gds_format_double(self.omega))
        if self.numberOfDirections is not None:
            element.set('numberOfDirections', self.gds_format_integer(self.numberOfDirections))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_HotSpotUpwardRegion'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.omega is not None and 'omega' not in already_processed:
            already_processed.add('omega')
            showIndent(outfile, level)
            outfile.write('omega=%e,\n' % (self.omega,))
        if self.numberOfDirections is not None and 'numberOfDirections' not in already_processed:
            already_processed.add('numberOfDirections')
            showIndent(outfile, level)
            outfile.write('numberOfDirections=%d,\n' % (self.numberOfDirections,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('omega', node)
        if value is not None and 'omega' not in already_processed:
            already_processed.add('omega')
            try:
                self.omega = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (omega): %s' % exp)
        value = find_attr_value_('numberOfDirections', node)
        if value is not None and 'numberOfDirections' not in already_processed:
            already_processed.add('numberOfDirections')
            try:
                self.numberOfDirections = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_HotSpotUpwardRegion


class create_HotSpotDownwardRegion(GeneratedsSuper):
    """Region Solid Angle (steradians) Region Solid Angle (steradians)
    Number of directions in region. Automatically rounded to the
    nearest squared integer. Number of directions in region.
    Automatically rounded to the nearest squared integer."""
    member_data_items_ = [
        MemberSpec_('omega', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('numberOfDirections', 'xsd:int', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, omega=0.01, numberOfDirections=25):
        self.original_tagname_ = None
        self.troot=get_gs_troot('directions','_HotSpotDownwardRegion')
        self.attrib = ['omega', 'numberOfDirections']
        self.children = []
        self.parent = None
        self._omega = _cast(float, omega)
        self._numberOfDirections = _cast(int, numberOfDirections)
        update_node(self,self.troot,'directions')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_HotSpotDownwardRegion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_HotSpotDownwardRegion.subclass:
            return create_HotSpotDownwardRegion.subclass(*args_, **kwargs_)
        else:
            return create_HotSpotDownwardRegion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_omega(self): return self._omega
    def set_omega(self, value):
        self._omega = value
        update_node(self,self.troot,'directions')
    omega = property(get_omega, set_omega)
    def get_numberOfDirections(self): return self._numberOfDirections
    def set_numberOfDirections(self, value):
        self._numberOfDirections = value
        update_node(self,self.troot,'directions')
    numberOfDirections = property(get_numberOfDirections, set_numberOfDirections)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_HotSpotDownwardRegion', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_HotSpotDownwardRegion')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_HotSpotDownwardRegion')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_HotSpotDownwardRegion', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_HotSpotDownwardRegion'):
        if self.omega is not None and 'omega' not in already_processed:
            already_processed.add('omega')
            outfile.write(' omega="%s"' % self.gds_format_double(self.omega, input_name='omega'))
        if self.numberOfDirections is not None and 'numberOfDirections' not in already_processed:
            already_processed.add('numberOfDirections')
            outfile.write(' numberOfDirections="%s"' % self.gds_format_integer(self.numberOfDirections, input_name='numberOfDirections'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_HotSpotDownwardRegion', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_HotSpotDownwardRegion', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.omega is not None:
            element.set('omega', self.gds_format_double(self.omega))
        if self.numberOfDirections is not None:
            element.set('numberOfDirections', self.gds_format_integer(self.numberOfDirections))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_HotSpotDownwardRegion'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.omega is not None and 'omega' not in already_processed:
            already_processed.add('omega')
            showIndent(outfile, level)
            outfile.write('omega=%e,\n' % (self.omega,))
        if self.numberOfDirections is not None and 'numberOfDirections' not in already_processed:
            already_processed.add('numberOfDirections')
            showIndent(outfile, level)
            outfile.write('numberOfDirections=%d,\n' % (self.numberOfDirections,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('omega', node)
        if value is not None and 'omega' not in already_processed:
            already_processed.add('omega')
            try:
                self.omega = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (omega): %s' % exp)
        value = find_attr_value_('numberOfDirections', node)
        if value is not None and 'numberOfDirections' not in already_processed:
            already_processed.add('numberOfDirections')
            try:
                self.numberOfDirections = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_HotSpotDownwardRegion


class create_HotSpotOversampledPlane(GeneratedsSuper):
    """Zenith step in the oversampled plane (solar plane or perpendicular
    to solar plane). Zenith step in the oversampled plane (solar
    plane or perpendicular to solar plane). Solid angle for each
    direction in the Hot Spot oversampled plane (in steradians).
    Solid angle for each direction in the Hot Spot oversampled plane
    (in steradians)."""
    member_data_items_ = [
        MemberSpec_('deltaTheta', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('omega', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, deltaTheta=10.0, omega=0.001):
        self.original_tagname_ = None
        self.troot=get_gs_troot('directions','_HotSpotOversampledPlane')
        self.attrib = ['deltaTheta', 'omega']
        self.children = []
        self.parent = None
        self._deltaTheta = _cast(float, deltaTheta)
        self._omega = _cast(float, omega)
        update_node(self,self.troot,'directions')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_HotSpotOversampledPlane)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_HotSpotOversampledPlane.subclass:
            return create_HotSpotOversampledPlane.subclass(*args_, **kwargs_)
        else:
            return create_HotSpotOversampledPlane(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deltaTheta(self): return self._deltaTheta
    def set_deltaTheta(self, value):
        self._deltaTheta = value
        update_node(self,self.troot,'directions')
    deltaTheta = property(get_deltaTheta, set_deltaTheta)
    def get_omega(self): return self._omega
    def set_omega(self, value):
        self._omega = value
        update_node(self,self.troot,'directions')
    omega = property(get_omega, set_omega)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_HotSpotOversampledPlane', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_HotSpotOversampledPlane')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_HotSpotOversampledPlane')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_HotSpotOversampledPlane', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_HotSpotOversampledPlane'):
        if self.deltaTheta is not None and 'deltaTheta' not in already_processed:
            already_processed.add('deltaTheta')
            outfile.write(' deltaTheta="%s"' % self.gds_format_double(self.deltaTheta, input_name='deltaTheta'))
        if self.omega is not None and 'omega' not in already_processed:
            already_processed.add('omega')
            outfile.write(' omega="%s"' % self.gds_format_double(self.omega, input_name='omega'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_HotSpotOversampledPlane', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_HotSpotOversampledPlane', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.deltaTheta is not None:
            element.set('deltaTheta', self.gds_format_double(self.deltaTheta))
        if self.omega is not None:
            element.set('omega', self.gds_format_double(self.omega))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_HotSpotOversampledPlane'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.deltaTheta is not None and 'deltaTheta' not in already_processed:
            already_processed.add('deltaTheta')
            showIndent(outfile, level)
            outfile.write('deltaTheta=%e,\n' % (self.deltaTheta,))
        if self.omega is not None and 'omega' not in already_processed:
            already_processed.add('omega')
            showIndent(outfile, level)
            outfile.write('omega=%e,\n' % (self.omega,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('deltaTheta', node)
        if value is not None and 'deltaTheta' not in already_processed:
            already_processed.add('deltaTheta')
            try:
                self.deltaTheta = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (deltaTheta): %s' % exp)
        value = find_attr_value_('omega', node)
        if value is not None and 'omega' not in already_processed:
            already_processed.add('omega')
            try:
                self.omega = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (omega): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_HotSpotOversampledPlane


class create_Penumbra(GeneratedsSuper):
    """The sun penumbra is the region in which only a portion of the sun is
    obscured by the occluding body. The sun penumbra is the region
    in which only a portion of the sun is obscured by the occluding
    body."""
    member_data_items_ = [
        MemberSpec_('mode', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('SunSphere', '_SunSphere', 0, 0, {u'maxOccurs': u'1', u'type': u'_SunSphere', u'name': u'SunSphere', u'minOccurs': u'1'}, None),
        MemberSpec_('SunIcoSphere', '_SunIcoSphere', 0, 0, {u'maxOccurs': u'1', u'type': u'_SunIcoSphere', u'name': u'SunIcoSphere', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, mode=0, SunSphere=None, SunIcoSphere=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('directions','_Penumbra')
        self.attrib = ['mode']
        self.children = ['SunSphere', 'SunIcoSphere']
        self.parent = None
        self._mode = _cast(int, mode)
        self._SunSphere = SunSphere
        self._SunIcoSphere = SunIcoSphere
        update_node(self,self.troot,'directions')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Penumbra)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Penumbra.subclass:
            return create_Penumbra.subclass(*args_, **kwargs_)
        else:
            return create_Penumbra(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SunSphere(self): return self._SunSphere
    def set_SunSphere(self, value):
        if value is not None:
            checkclass(value, create_SunSphere)
            value.parent = self
        self._SunSphere = value
    SunSphere = property(get_SunSphere, set_SunSphere)
    def get_SunIcoSphere(self): return self._SunIcoSphere
    def set_SunIcoSphere(self, value):
        if value is not None:
            checkclass(value, create_SunIcoSphere)
            value.parent = self
        self._SunIcoSphere = value
    SunIcoSphere = property(get_SunIcoSphere, set_SunIcoSphere)
    def get_mode(self): return self._mode
    def set_mode(self, value):
        self._mode = value
        update_node(self,self.troot,'directions')
    mode = property(get_mode, set_mode)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.SunSphere is not None or
            self.SunIcoSphere is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Penumbra', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Penumbra')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Penumbra')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Penumbra', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Penumbra'):
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            outfile.write(' mode="%s"' % self.gds_format_integer(self.mode, input_name='mode'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Penumbra', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SunSphere is not None:
            self.SunSphere.export(outfile, level, namespaceprefix_, name_='SunSphere', pretty_print=pretty_print)
        if self.SunIcoSphere is not None:
            self.SunIcoSphere.export(outfile, level, namespaceprefix_, name_='SunIcoSphere', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Penumbra', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.mode is not None:
            element.set('mode', self.gds_format_integer(self.mode))
        if self.SunSphere is not None:
            SunSphere_ = self.SunSphere
            SunSphere_.to_etree(element, name_='SunSphere', mapping_=mapping_)
        if self.SunIcoSphere is not None:
            SunIcoSphere_ = self.SunIcoSphere
            SunIcoSphere_.to_etree(element, name_='SunIcoSphere', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Penumbra'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            showIndent(outfile, level)
            outfile.write('mode=%d,\n' % (self.mode,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SunSphere is not None:
            showIndent(outfile, level)
            outfile.write('SunSphere=model_._SunSphere(\n')
            self.SunSphere.exportLiteral(outfile, level, name_='SunSphere')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SunIcoSphere is not None:
            showIndent(outfile, level)
            outfile.write('SunIcoSphere=model_._SunIcoSphere(\n')
            self.SunIcoSphere.exportLiteral(outfile, level, name_='SunIcoSphere')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mode', node)
        if value is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            try:
                self.mode = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SunSphere':
            obj_ = create_SunSphere.factory()
            obj_.build(child_)
            self.set_SunSphere(obj_)
            obj_.original_tagname_ = 'SunSphere'
        elif nodeName_ == 'SunIcoSphere':
            obj_ = create_SunIcoSphere.factory()
            obj_.build(child_)
            self.set_SunIcoSphere(obj_)
            obj_.original_tagname_ = 'SunIcoSphere'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_Penumbra


class create_SunSphere(GeneratedsSuper):
    """Defines the numbers of points to be randomly sampled on the sun
    surface IN ADDITION of the central position.\n Multiply linearly
    the computation time of the direct illumination phase. Defines
    the numbers of points to be randomly sampled on the sun surface
    IN ADDITION of the central position.\n Multiply linearly the
    computation time of the direct illumination phase."""
    member_data_items_ = [
        MemberSpec_('nbPointsOnSphere', 'xsd:int', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, nbPointsOnSphere=4):
        self.original_tagname_ = None
        self.troot=get_gs_troot('directions','_SunSphere')
        self.attrib = ['nbPointsOnSphere']
        self.children = []
        self.parent = None
        self._nbPointsOnSphere = _cast(int, nbPointsOnSphere)
        update_node(self,self.troot,'directions')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_SunSphere)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_SunSphere.subclass:
            return create_SunSphere.subclass(*args_, **kwargs_)
        else:
            return create_SunSphere(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nbPointsOnSphere(self): return self._nbPointsOnSphere
    def set_nbPointsOnSphere(self, value):
        self._nbPointsOnSphere = value
        update_node(self,self.troot,'directions')
    nbPointsOnSphere = property(get_nbPointsOnSphere, set_nbPointsOnSphere)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_SunSphere', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_SunSphere')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_SunSphere')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_SunSphere', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_SunSphere'):
        if self.nbPointsOnSphere is not None and 'nbPointsOnSphere' not in already_processed:
            already_processed.add('nbPointsOnSphere')
            outfile.write(' nbPointsOnSphere="%s"' % self.gds_format_integer(self.nbPointsOnSphere, input_name='nbPointsOnSphere'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_SunSphere', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_SunSphere', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.nbPointsOnSphere is not None:
            element.set('nbPointsOnSphere', self.gds_format_integer(self.nbPointsOnSphere))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_SunSphere'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nbPointsOnSphere is not None and 'nbPointsOnSphere' not in already_processed:
            already_processed.add('nbPointsOnSphere')
            showIndent(outfile, level)
            outfile.write('nbPointsOnSphere=%d,\n' % (self.nbPointsOnSphere,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nbPointsOnSphere', node)
        if value is not None and 'nbPointsOnSphere' not in already_processed:
            already_processed.add('nbPointsOnSphere')
            try:
                self.nbPointsOnSphere = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_SunSphere


class create_SunIcoSphere(GeneratedsSuper):
    """Total number of points will be: ~10 * 4 ^ (nb_subdivisions)\nThe sun
    is defined as an Icosahedron: a regular polyhedron with 20
    equilateral triangles of same area. Each subdivision multiply by
    4 the number of triangles. Half the faces are going to
    illuminate the scene. Total number of points will be: ~10 * 4 ^
    (nb_subdivisions)\nThe sun is defined as an Icosahedron: a
    regular polyhedron with 20 equilateral triangles of same area.
    Each subdivision multiply by 4 the number of triangles. Half the
    faces are going to illuminate the scene."""
    member_data_items_ = [
        MemberSpec_('nbSudivisions', 'xsd:int', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, nbSudivisions=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('directions','_SunIcoSphere')
        self.attrib = ['nbSudivisions']
        self.children = []
        self.parent = None
        self._nbSudivisions = _cast(int, nbSudivisions)
        update_node(self,self.troot,'directions')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_SunIcoSphere)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_SunIcoSphere.subclass:
            return create_SunIcoSphere.subclass(*args_, **kwargs_)
        else:
            return create_SunIcoSphere(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nbSudivisions(self): return self._nbSudivisions
    def set_nbSudivisions(self, value):
        self._nbSudivisions = value
        update_node(self,self.troot,'directions')
    nbSudivisions = property(get_nbSudivisions, set_nbSudivisions)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_SunIcoSphere', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_SunIcoSphere')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_SunIcoSphere')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_SunIcoSphere', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_SunIcoSphere'):
        if self.nbSudivisions is not None and 'nbSudivisions' not in already_processed:
            already_processed.add('nbSudivisions')
            outfile.write(' nbSudivisions="%s"' % self.gds_format_integer(self.nbSudivisions, input_name='nbSudivisions'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_SunIcoSphere', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_SunIcoSphere', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.nbSudivisions is not None:
            element.set('nbSudivisions', self.gds_format_integer(self.nbSudivisions))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_SunIcoSphere'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nbSudivisions is not None and 'nbSudivisions' not in already_processed:
            already_processed.add('nbSudivisions')
            showIndent(outfile, level)
            outfile.write('nbSudivisions=%d,\n' % (self.nbSudivisions,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nbSudivisions', node)
        if value is not None and 'nbSudivisions' not in already_processed:
            already_processed.add('nbSudivisions')
            try:
                self.nbSudivisions = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_SunIcoSphere


class create_AzimuthalOffset(GeneratedsSuper):
    """Example: to get a 30deg scene azimuth rotation, the offsets of sun
    and viewing directions must be equal to 30deg Example: to get a
    30deg scene azimuth rotation, the offsets of sun and viewing
    directions must be equal to 30deg Example: to get a 30deg scene
    azimuth rotation, the offsets of sun and viewing directions must
    be equal to 30deg Example: to get a 30deg scene azimuth
    rotation, the offsets of sun and viewing directions must be
    equal to 30deg"""
    member_data_items_ = [
        MemberSpec_('directionalAzimuthalOffset', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('sunAzimuthalOffset', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, directionalAzimuthalOffset=0, sunAzimuthalOffset=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('directions','_AzimuthalOffset')
        self.attrib = ['directionalAzimuthalOffset', 'sunAzimuthalOffset']
        self.children = []
        self.parent = None
        self._directionalAzimuthalOffset = _cast(float, directionalAzimuthalOffset)
        self._sunAzimuthalOffset = _cast(float, sunAzimuthalOffset)
        update_node(self,self.troot,'directions')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_AzimuthalOffset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_AzimuthalOffset.subclass:
            return create_AzimuthalOffset.subclass(*args_, **kwargs_)
        else:
            return create_AzimuthalOffset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_directionalAzimuthalOffset(self): return self._directionalAzimuthalOffset
    def set_directionalAzimuthalOffset(self, value):
        self._directionalAzimuthalOffset = value
        update_node(self,self.troot,'directions')
    directionalAzimuthalOffset = property(get_directionalAzimuthalOffset, set_directionalAzimuthalOffset)
    def get_sunAzimuthalOffset(self): return self._sunAzimuthalOffset
    def set_sunAzimuthalOffset(self, value):
        self._sunAzimuthalOffset = value
        update_node(self,self.troot,'directions')
    sunAzimuthalOffset = property(get_sunAzimuthalOffset, set_sunAzimuthalOffset)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_AzimuthalOffset', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_AzimuthalOffset')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_AzimuthalOffset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_AzimuthalOffset', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_AzimuthalOffset'):
        if self.directionalAzimuthalOffset is not None and 'directionalAzimuthalOffset' not in already_processed:
            already_processed.add('directionalAzimuthalOffset')
            outfile.write(' directionalAzimuthalOffset="%s"' % self.gds_format_double(self.directionalAzimuthalOffset, input_name='directionalAzimuthalOffset'))
        if self.sunAzimuthalOffset is not None and 'sunAzimuthalOffset' not in already_processed:
            already_processed.add('sunAzimuthalOffset')
            outfile.write(' sunAzimuthalOffset="%s"' % self.gds_format_double(self.sunAzimuthalOffset, input_name='sunAzimuthalOffset'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_AzimuthalOffset', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_AzimuthalOffset', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.directionalAzimuthalOffset is not None:
            element.set('directionalAzimuthalOffset', self.gds_format_double(self.directionalAzimuthalOffset))
        if self.sunAzimuthalOffset is not None:
            element.set('sunAzimuthalOffset', self.gds_format_double(self.sunAzimuthalOffset))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_AzimuthalOffset'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.directionalAzimuthalOffset is not None and 'directionalAzimuthalOffset' not in already_processed:
            already_processed.add('directionalAzimuthalOffset')
            showIndent(outfile, level)
            outfile.write('directionalAzimuthalOffset=%e,\n' % (self.directionalAzimuthalOffset,))
        if self.sunAzimuthalOffset is not None and 'sunAzimuthalOffset' not in already_processed:
            already_processed.add('sunAzimuthalOffset')
            showIndent(outfile, level)
            outfile.write('sunAzimuthalOffset=%e,\n' % (self.sunAzimuthalOffset,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('directionalAzimuthalOffset', node)
        if value is not None and 'directionalAzimuthalOffset' not in already_processed:
            already_processed.add('directionalAzimuthalOffset')
            try:
                self.directionalAzimuthalOffset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (directionalAzimuthalOffset): %s' % exp)
        value = find_attr_value_('sunAzimuthalOffset', node)
        if value is not None and 'sunAzimuthalOffset' not in already_processed:
            already_processed.add('sunAzimuthalOffset')
            try:
                self.sunAzimuthalOffset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sunAzimuthalOffset): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_AzimuthalOffset


class create_ExpertModeZone(GeneratedsSuper):
    """Enter the n number of angular sectors.\nIn iterations 1, the angular
    distribution of intercepted radiation is stored in n angular
    sectors, for improving further scattering accuracy.\nThe maximal
    number of sectors is the actual number of directions.\nThe
    sector value of a direction is stored in the 4th column of the
    direction file. Enter the n number of angular sectors.\nIn
    iterations 1, the angular distribution of intercepted radiation
    is stored in n angular sectors, for improving further scattering
    accuracy.\nThe maximal number of sectors is the actual number of
    directions.\nThe sector value of a direction is stored in the
    4th column of the direction file. 0 for default value generated
    by sphere directions, or enter a positive integer for the number
    of layers to generate the directions in one hemisphere. 0 for
    default value generated by sphere directions, or enter a
    positive integer for the number of layers to generate the
    directions in one hemisphere."""
    member_data_items_ = [
        MemberSpec_('numberOfAngularSector', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('numberOfLayers', 'xsd:int', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, numberOfAngularSector=10, numberOfLayers=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('directions','_ExpertModeZone')
        self.attrib = ['numberOfAngularSector', 'numberOfLayers']
        self.children = []
        self.parent = None
        self._numberOfAngularSector = _cast(int, numberOfAngularSector)
        self._numberOfLayers = _cast(int, numberOfLayers)
        update_node(self,self.troot,'directions')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ExpertModeZone)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ExpertModeZone.subclass:
            return create_ExpertModeZone.subclass(*args_, **kwargs_)
        else:
            return create_ExpertModeZone(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_numberOfAngularSector(self): return self._numberOfAngularSector
    def set_numberOfAngularSector(self, value):
        self._numberOfAngularSector = value
        update_node(self,self.troot,'directions')
    numberOfAngularSector = property(get_numberOfAngularSector, set_numberOfAngularSector)
    def get_numberOfLayers(self): return self._numberOfLayers
    def set_numberOfLayers(self, value):
        self._numberOfLayers = value
        update_node(self,self.troot,'directions')
    numberOfLayers = property(get_numberOfLayers, set_numberOfLayers)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ExpertModeZone', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ExpertModeZone')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ExpertModeZone')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ExpertModeZone', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ExpertModeZone'):
        if self.numberOfAngularSector is not None and 'numberOfAngularSector' not in already_processed:
            already_processed.add('numberOfAngularSector')
            outfile.write(' numberOfAngularSector="%s"' % self.gds_format_integer(self.numberOfAngularSector, input_name='numberOfAngularSector'))
        if self.numberOfLayers is not None and 'numberOfLayers' not in already_processed:
            already_processed.add('numberOfLayers')
            outfile.write(' numberOfLayers="%s"' % self.gds_format_integer(self.numberOfLayers, input_name='numberOfLayers'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ExpertModeZone', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_ExpertModeZone', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.numberOfAngularSector is not None:
            element.set('numberOfAngularSector', self.gds_format_integer(self.numberOfAngularSector))
        if self.numberOfLayers is not None:
            element.set('numberOfLayers', self.gds_format_integer(self.numberOfLayers))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ExpertModeZone'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numberOfAngularSector is not None and 'numberOfAngularSector' not in already_processed:
            already_processed.add('numberOfAngularSector')
            showIndent(outfile, level)
            outfile.write('numberOfAngularSector=%d,\n' % (self.numberOfAngularSector,))
        if self.numberOfLayers is not None and 'numberOfLayers' not in already_processed:
            already_processed.add('numberOfLayers')
            showIndent(outfile, level)
            outfile.write('numberOfLayers=%d,\n' % (self.numberOfLayers,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfAngularSector', node)
        if value is not None and 'numberOfAngularSector' not in already_processed:
            already_processed.add('numberOfAngularSector')
            try:
                self.numberOfAngularSector = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('numberOfLayers', node)
        if value is not None and 'numberOfLayers' not in already_processed:
            already_processed.add('numberOfLayers')
            try:
                self.numberOfLayers = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_ExpertModeZone


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <createParser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from directions import *\n\n')
        sys.stdout.write('import directions as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "createDartFile",
    "create_AddedDirections",
    "create_AzimuthalOffset",
    "create_DefineDeltaPhi",
    "create_DefineDeltaTheta",
    "create_DefineOmega",
    "create_Directions",
    "create_ExactDateHour",
    "create_ExpertModeZone",
    "create_HotSpotDownwardRegion",
    "create_HotSpotOversampledPlane",
    "create_HotSpotProperties",
    "create_HotSpotUpwardRegion",
    "create_LatLon",
    "create_OversampledPlane",
    "create_Penumbra",
    "create_Rectangle",
    "create_Region",
    "create_Square",
    "create_Sun",
    "create_SunIcoSphere",
    "create_SunSphere",
    "create_SunViewingAngles",
    "create_ZenithAzimuth",
    "create_thetaRange"
]
