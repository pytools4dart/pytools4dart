#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Jan  2 18:30:52 2019 by generateDS.py version 2.29.25.
# Python 2.7.15rc1 (default, Nov 12 2018, 14:31:15)  [GCC 7.3.0]
#
# Command line options:
#   ('-m', '')
#   ('-f', '')
#   ('--always-export-default', '')
#   ('--export', 'write literal etree')
#   ('-u', 'pytools4dart.core_ui.user_methods')
#   ('-p', 'create')
#   ('--post-attrib-setter', "update_node(self,self.troot,'atmosphere')")
#   ('--pre-ctor', "self.troot=get_gs_troot('atmosphere','{classname}')")
#   ('--post-ctor', "update_node(self,self.troot,'atmosphere')")
#   ('--imports', 'from pytools4dart.core_ui.utils import get_gs_troot, update_node')
#   ('-o', 'pytools4dart/core_ui/atmosphere.py')
#
# Command line arguments:
#   pytools4dart/xsdschemas/atmosphere.xsd
#
# Command line:
#   /home/boissieu/git/pytools4dartMTD/venv/bin/generateDS.py -m -f --always-export-default --export="write literal etree" -u "pytools4dart.core_ui.user_methods" -p "create" --post-attrib-setter="update_node(self,self.troot,'atmosphere')" --pre-ctor="self.troot=get_gs_troot('atmosphere','{classname}')" --post-ctor="update_node(self,self.troot,'atmosphere')" --imports="from pytools4dart.core_ui.utils import get_gs_troot, update_node" -o "pytools4dart/core_ui/atmosphere.py" pytools4dart/xsdschemas/atmosphere.xsd
#
# Current working directory (os.getcwd()):
#   pytools4dartMTD
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_
from pytools4dart.core_ui.utils import get_gs_troot, update_node


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#

def checkclass(value, cl):
    if isinstance(value, list):
        for v in value:
            if not isinstance(v, cl):
                raise ValueError("invalid class")
    else:
        if not isinstance(value, cl):
            raise ValueError("invalid class")

def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class createDartFile(GeneratedsSuper):
    """Version of the plots.xml file. Depends of the version on DART
    itself. Version of the plots.xml file. Depends of the version on
    DART itself."""
    member_data_items_ = [
        MemberSpec_('version', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('build_', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('Atmosphere', '_Atmosphere', 0, 0, {u'maxOccurs': u'1', u'type': u'_Atmosphere', u'name': u'Atmosphere', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, version='5.7.4', build_='0', Atmosphere=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','DartFile')
        self.attrib = ['version', 'build_']
        self.children = ['Atmosphere']
        self.parent = None
        self._version = _cast(None, version)
        self._build_ = _cast(None, build_)
        self._Atmosphere = Atmosphere
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, createDartFile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if createDartFile.subclass:
            return createDartFile.subclass(*args_, **kwargs_)
        else:
            return createDartFile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Atmosphere(self): return self._Atmosphere
    def set_Atmosphere(self, value):
        if value is not None:
            checkclass(value, create_Atmosphere)
            value.parent = self
        self._Atmosphere = value
    Atmosphere = property(get_Atmosphere, set_Atmosphere)
    def get_version(self): return self._version
    def set_version(self, value):
        self._version = value
        update_node(self,self.troot,'atmosphere')
    version = property(get_version, set_version)
    def get_build(self): return self._build_
    def set_build(self, value):
        self._build_ = value
        update_node(self,self.troot,'atmosphere')
    build_ = property(get_build, set_build)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Atmosphere is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='DartFile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DartFile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DartFile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='DartFile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DartFile'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
        if self.build_ is not None and 'build_' not in already_processed:
            already_processed.add('build_')
            outfile.write(' build=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.build_), input_name='build')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='DartFile', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Atmosphere is not None:
            self.Atmosphere.export(outfile, level, namespaceprefix_, name_='Atmosphere', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='DartFile', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.version is not None:
            element.set('version', self.gds_format_string(self.version))
        if self.build_ is not None:
            element.set('build', self.gds_format_string(self.build_))
        if self.Atmosphere is not None:
            Atmosphere_ = self.Atmosphere
            Atmosphere_.to_etree(element, name_='Atmosphere', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='DartFile'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.build_ is not None and 'build_' not in already_processed:
            already_processed.add('build_')
            showIndent(outfile, level)
            outfile.write('build_="%s",\n' % (self.build_,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Atmosphere is not None:
            showIndent(outfile, level)
            outfile.write('Atmosphere=model_._Atmosphere(\n')
            self.Atmosphere.exportLiteral(outfile, level, name_='Atmosphere')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('build', node)
        if value is not None and 'build' not in already_processed:
            already_processed.add('build')
            self.build_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Atmosphere':
            obj_ = create_Atmosphere.factory()
            obj_.build(child_)
            self.set_Atmosphere(obj_)
            obj_.original_tagname_ = 'Atmosphere'
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class createDartFile


class create_Atmosphere(GeneratedsSuper):
    """Atmosphere Atmosphere Radiative transfer is simulated within the air
    of the lower atmosphere (i.e., the earth landscape is within the
    lower atmosphere) Radiative transfer is simulated within the air
    of the lower atmosphere (i.e., the earth landscape is within the
    lower atmosphere)"""
    member_data_items_ = [
        MemberSpec_('isRadiativeTransfertInBottomAtmosphereDefined', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('Aerosol', '_Aerosol', 0, 0, {u'maxOccurs': u'1', u'type': u'_Aerosol', u'name': u'Aerosol', u'minOccurs': u'1'}, None),
        MemberSpec_('IsAtmosphere', '_IsAtmosphere', 0, 0, {u'maxOccurs': u'1', u'type': u'_IsAtmosphere', u'name': u'IsAtmosphere', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, isRadiativeTransfertInBottomAtmosphereDefined=0, Aerosol=None, IsAtmosphere=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_Atmosphere')
        self.attrib = ['isRadiativeTransfertInBottomAtmosphereDefined']
        self.children = ['Aerosol', 'IsAtmosphere']
        self.parent = None
        self._isRadiativeTransfertInBottomAtmosphereDefined = _cast(int, isRadiativeTransfertInBottomAtmosphereDefined)
        self._Aerosol = Aerosol
        self._IsAtmosphere = IsAtmosphere
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Atmosphere)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Atmosphere.subclass:
            return create_Atmosphere.subclass(*args_, **kwargs_)
        else:
            return create_Atmosphere(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Aerosol(self): return self._Aerosol
    def set_Aerosol(self, value):
        if value is not None:
            checkclass(value, create_Aerosol)
            value.parent = self
        self._Aerosol = value
    Aerosol = property(get_Aerosol, set_Aerosol)
    def get_IsAtmosphere(self): return self._IsAtmosphere
    def set_IsAtmosphere(self, value):
        if value is not None:
            checkclass(value, create_IsAtmosphere)
            value.parent = self
        self._IsAtmosphere = value
    IsAtmosphere = property(get_IsAtmosphere, set_IsAtmosphere)
    def get_isRadiativeTransfertInBottomAtmosphereDefined(self): return self._isRadiativeTransfertInBottomAtmosphereDefined
    def set_isRadiativeTransfertInBottomAtmosphereDefined(self, value):
        self._isRadiativeTransfertInBottomAtmosphereDefined = value
        update_node(self,self.troot,'atmosphere')
    isRadiativeTransfertInBottomAtmosphereDefined = property(get_isRadiativeTransfertInBottomAtmosphereDefined, set_isRadiativeTransfertInBottomAtmosphereDefined)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Aerosol is not None or
            self.IsAtmosphere is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Atmosphere', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Atmosphere')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Atmosphere')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Atmosphere', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Atmosphere'):
        if self.isRadiativeTransfertInBottomAtmosphereDefined is not None and 'isRadiativeTransfertInBottomAtmosphereDefined' not in already_processed:
            already_processed.add('isRadiativeTransfertInBottomAtmosphereDefined')
            outfile.write(' isRadiativeTransfertInBottomAtmosphereDefined="%s"' % self.gds_format_integer(self.isRadiativeTransfertInBottomAtmosphereDefined, input_name='isRadiativeTransfertInBottomAtmosphereDefined'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Atmosphere', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Aerosol is not None:
            self.Aerosol.export(outfile, level, namespaceprefix_, name_='Aerosol', pretty_print=pretty_print)
        if self.IsAtmosphere is not None:
            self.IsAtmosphere.export(outfile, level, namespaceprefix_, name_='IsAtmosphere', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Atmosphere', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.isRadiativeTransfertInBottomAtmosphereDefined is not None:
            element.set('isRadiativeTransfertInBottomAtmosphereDefined', self.gds_format_integer(self.isRadiativeTransfertInBottomAtmosphereDefined))
        if self.Aerosol is not None:
            Aerosol_ = self.Aerosol
            Aerosol_.to_etree(element, name_='Aerosol', mapping_=mapping_)
        if self.IsAtmosphere is not None:
            IsAtmosphere_ = self.IsAtmosphere
            IsAtmosphere_.to_etree(element, name_='IsAtmosphere', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Atmosphere'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isRadiativeTransfertInBottomAtmosphereDefined is not None and 'isRadiativeTransfertInBottomAtmosphereDefined' not in already_processed:
            already_processed.add('isRadiativeTransfertInBottomAtmosphereDefined')
            showIndent(outfile, level)
            outfile.write('isRadiativeTransfertInBottomAtmosphereDefined=%d,\n' % (self.isRadiativeTransfertInBottomAtmosphereDefined,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Aerosol is not None:
            showIndent(outfile, level)
            outfile.write('Aerosol=model_._Aerosol(\n')
            self.Aerosol.exportLiteral(outfile, level, name_='Aerosol')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IsAtmosphere is not None:
            showIndent(outfile, level)
            outfile.write('IsAtmosphere=model_._IsAtmosphere(\n')
            self.IsAtmosphere.exportLiteral(outfile, level, name_='IsAtmosphere')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isRadiativeTransfertInBottomAtmosphereDefined', node)
        if value is not None and 'isRadiativeTransfertInBottomAtmosphereDefined' not in already_processed:
            already_processed.add('isRadiativeTransfertInBottomAtmosphereDefined')
            try:
                self.isRadiativeTransfertInBottomAtmosphereDefined = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Aerosol':
            obj_ = create_Aerosol.factory()
            obj_.build(child_)
            self.set_Aerosol(obj_)
            obj_.original_tagname_ = 'Aerosol'
        elif nodeName_ == 'IsAtmosphere':
            obj_ = create_IsAtmosphere.factory()
            obj_.build(child_)
            self.set_IsAtmosphere(obj_)
            obj_.original_tagname_ = 'IsAtmosphere'
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_Atmosphere


class create_Aerosol(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('AerosolProperties', '_AerosolProperties', 1, 0, {u'maxOccurs': u'unbounded', u'type': u'_AerosolProperties', u'name': u'AerosolProperties', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, AerosolProperties=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_Aerosol')
        self.attrib = ['']
        self.children = ['AerosolProperties']
        self.parent = None
        if AerosolProperties is None:
            self._AerosolProperties = []
        else:
            self._AerosolProperties = AerosolProperties
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Aerosol)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Aerosol.subclass:
            return create_Aerosol.subclass(*args_, **kwargs_)
        else:
            return create_Aerosol(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AerosolProperties(self): return self._AerosolProperties
    def set_AerosolProperties(self, value):
        if value is not None:
            checkclass(value, create_AerosolProperties)
            for v in value:
                v.parent = self
        self._AerosolProperties = value
    def add_AerosolProperties(self, value):
        value.parent = self
        self._AerosolProperties.append(value)
    def insert_AerosolProperties_at(self, index, value):
        value.parent = self
        self.AerosolProperties.insert(index, value)
    def replace_AerosolProperties_at(self, index, value):
        value.parent = self
        self.AerosolProperties[index] = value
    AerosolProperties = property(get_AerosolProperties, set_AerosolProperties)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.AerosolProperties
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Aerosol', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Aerosol')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Aerosol')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Aerosol', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Aerosol'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Aerosol', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AerosolProperties_ in self.AerosolProperties:
            AerosolProperties_.export(outfile, level, namespaceprefix_, name_='AerosolProperties', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Aerosol', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for AerosolProperties_ in self.AerosolProperties:
            AerosolProperties_.to_etree(element, name_='AerosolProperties', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Aerosol'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('AerosolProperties=[\n')
        level += 1
        for AerosolProperties_ in self.AerosolProperties:
            showIndent(outfile, level)
            outfile.write('model_._AerosolProperties(\n')
            AerosolProperties_.exportLiteral(outfile, level, name_='_AerosolProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.AerosolProperties = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AerosolProperties':
            obj_ = create_AerosolProperties.factory()
            obj_.build(child_)
            self.add_AerosolProperties(obj_)
            obj_.original_tagname_ = 'AerosolProperties'
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_Aerosol


class create_AerosolProperties(GeneratedsSuper):
    """Aerosol model Aerosol model Aerosol cumulative model Aerosol
    cumulative model Henyey Greenstein parameters model Henyey
    Greenstein parameters model Reflectance database Reflectance
    database Aerosol optical depth of the database will be
    multiplied by these factor at every wavelength Aerosol optical
    depth of the database will be multiplied by these factor at
    every wavelength"""
    member_data_items_ = [
        MemberSpec_('aerosolsModelName', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('aerosolCumulativeModelName', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('hgParametersModelName', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('databaseName', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('aerosolOptDepthFactor', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, aerosolsModelName='USSTD76_RURALV23', aerosolCumulativeModelName='RURALV23', hgParametersModelName='RURALV23', databaseName='dart_atmosphere.db', aerosolOptDepthFactor=1):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_AerosolProperties')
        self.attrib = ['aerosolsModelName', 'aerosolCumulativeModelName', 'hgParametersModelName', 'databaseName', 'aerosolOptDepthFactor']
        self.children = []
        self.parent = None
        self._aerosolsModelName = _cast(None, aerosolsModelName)
        self._aerosolCumulativeModelName = _cast(None, aerosolCumulativeModelName)
        self._hgParametersModelName = _cast(None, hgParametersModelName)
        self._databaseName = _cast(None, databaseName)
        self._aerosolOptDepthFactor = _cast(float, aerosolOptDepthFactor)
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_AerosolProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_AerosolProperties.subclass:
            return create_AerosolProperties.subclass(*args_, **kwargs_)
        else:
            return create_AerosolProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_aerosolsModelName(self): return self._aerosolsModelName
    def set_aerosolsModelName(self, value):
        self._aerosolsModelName = value
        update_node(self,self.troot,'atmosphere')
    aerosolsModelName = property(get_aerosolsModelName, set_aerosolsModelName)
    def get_aerosolCumulativeModelName(self): return self._aerosolCumulativeModelName
    def set_aerosolCumulativeModelName(self, value):
        self._aerosolCumulativeModelName = value
        update_node(self,self.troot,'atmosphere')
    aerosolCumulativeModelName = property(get_aerosolCumulativeModelName, set_aerosolCumulativeModelName)
    def get_hgParametersModelName(self): return self._hgParametersModelName
    def set_hgParametersModelName(self, value):
        self._hgParametersModelName = value
        update_node(self,self.troot,'atmosphere')
    hgParametersModelName = property(get_hgParametersModelName, set_hgParametersModelName)
    def get_databaseName(self): return self._databaseName
    def set_databaseName(self, value):
        self._databaseName = value
        update_node(self,self.troot,'atmosphere')
    databaseName = property(get_databaseName, set_databaseName)
    def get_aerosolOptDepthFactor(self): return self._aerosolOptDepthFactor
    def set_aerosolOptDepthFactor(self, value):
        self._aerosolOptDepthFactor = value
        update_node(self,self.troot,'atmosphere')
    aerosolOptDepthFactor = property(get_aerosolOptDepthFactor, set_aerosolOptDepthFactor)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_AerosolProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_AerosolProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_AerosolProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_AerosolProperties', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_AerosolProperties'):
        if self.aerosolsModelName is not None and 'aerosolsModelName' not in already_processed:
            already_processed.add('aerosolsModelName')
            outfile.write(' aerosolsModelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aerosolsModelName), input_name='aerosolsModelName')), ))
        if self.aerosolCumulativeModelName is not None and 'aerosolCumulativeModelName' not in already_processed:
            already_processed.add('aerosolCumulativeModelName')
            outfile.write(' aerosolCumulativeModelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aerosolCumulativeModelName), input_name='aerosolCumulativeModelName')), ))
        if self.hgParametersModelName is not None and 'hgParametersModelName' not in already_processed:
            already_processed.add('hgParametersModelName')
            outfile.write(' hgParametersModelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.hgParametersModelName), input_name='hgParametersModelName')), ))
        if self.databaseName is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            outfile.write(' databaseName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.databaseName), input_name='databaseName')), ))
        if self.aerosolOptDepthFactor is not None and 'aerosolOptDepthFactor' not in already_processed:
            already_processed.add('aerosolOptDepthFactor')
            outfile.write(' aerosolOptDepthFactor="%s"' % self.gds_format_double(self.aerosolOptDepthFactor, input_name='aerosolOptDepthFactor'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_AerosolProperties', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_AerosolProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.aerosolsModelName is not None:
            element.set('aerosolsModelName', self.gds_format_string(self.aerosolsModelName))
        if self.aerosolCumulativeModelName is not None:
            element.set('aerosolCumulativeModelName', self.gds_format_string(self.aerosolCumulativeModelName))
        if self.hgParametersModelName is not None:
            element.set('hgParametersModelName', self.gds_format_string(self.hgParametersModelName))
        if self.databaseName is not None:
            element.set('databaseName', self.gds_format_string(self.databaseName))
        if self.aerosolOptDepthFactor is not None:
            element.set('aerosolOptDepthFactor', self.gds_format_double(self.aerosolOptDepthFactor))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_AerosolProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.aerosolsModelName is not None and 'aerosolsModelName' not in already_processed:
            already_processed.add('aerosolsModelName')
            showIndent(outfile, level)
            outfile.write('aerosolsModelName="%s",\n' % (self.aerosolsModelName,))
        if self.aerosolCumulativeModelName is not None and 'aerosolCumulativeModelName' not in already_processed:
            already_processed.add('aerosolCumulativeModelName')
            showIndent(outfile, level)
            outfile.write('aerosolCumulativeModelName="%s",\n' % (self.aerosolCumulativeModelName,))
        if self.hgParametersModelName is not None and 'hgParametersModelName' not in already_processed:
            already_processed.add('hgParametersModelName')
            showIndent(outfile, level)
            outfile.write('hgParametersModelName="%s",\n' % (self.hgParametersModelName,))
        if self.databaseName is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            showIndent(outfile, level)
            outfile.write('databaseName="%s",\n' % (self.databaseName,))
        if self.aerosolOptDepthFactor is not None and 'aerosolOptDepthFactor' not in already_processed:
            already_processed.add('aerosolOptDepthFactor')
            showIndent(outfile, level)
            outfile.write('aerosolOptDepthFactor=%e,\n' % (self.aerosolOptDepthFactor,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aerosolsModelName', node)
        if value is not None and 'aerosolsModelName' not in already_processed:
            already_processed.add('aerosolsModelName')
            self.aerosolsModelName = value
        value = find_attr_value_('aerosolCumulativeModelName', node)
        if value is not None and 'aerosolCumulativeModelName' not in already_processed:
            already_processed.add('aerosolCumulativeModelName')
            self.aerosolCumulativeModelName = value
        value = find_attr_value_('hgParametersModelName', node)
        if value is not None and 'hgParametersModelName' not in already_processed:
            already_processed.add('hgParametersModelName')
            self.hgParametersModelName = value
        value = find_attr_value_('databaseName', node)
        if value is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            self.databaseName = value
        value = find_attr_value_('aerosolOptDepthFactor', node)
        if value is not None and 'aerosolOptDepthFactor' not in already_processed:
            already_processed.add('aerosolOptDepthFactor')
            try:
                self.aerosolOptDepthFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (aerosolOptDepthFactor): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_AerosolProperties


class create_IsAtmosphere(GeneratedsSuper):
    """IsAtmosphere IsAtmosphere Choice of an atmosphere spectral database
    or user defined mono-spectral parameters for the atmosphere
    Choice of an atmosphere spectral database or user defined mono-
    spectral parameters for the atmosphere"""
    member_data_items_ = [
        MemberSpec_('typeOfAtmosphere', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('isRadiativeTransfertInBottomAtmosphere', '_isRadiativeTransfertInBottomAtmosphere', 0, 0, {u'maxOccurs': u'1', u'type': u'_isRadiativeTransfertInBottomAtmosphere', u'name': u'isRadiativeTransfertInBottomAtmosphere', u'minOccurs': u'1'}, None),
        MemberSpec_('AtmosphericOpticalProperty', '_AtmosphericOpticalProperty', 0, 0, {u'maxOccurs': u'1', u'type': u'_AtmosphericOpticalProperty', u'name': u'AtmosphericOpticalProperty', u'minOccurs': u'1'}, None),
        MemberSpec_('TemperatureFile', '_TemperatureFile', 0, 0, {u'maxOccurs': u'1', u'type': u'_TemperatureFile', u'name': u'TemperatureFile', u'minOccurs': u'1'}, None),
        MemberSpec_('AtmosphericOpticalPropertyModel', '_AtmosphericOpticalPropertyModel', 0, 0, {u'maxOccurs': u'1', u'type': u'_AtmosphericOpticalPropertyModel', u'name': u'AtmosphericOpticalPropertyModel', u'minOccurs': u'1'}, None),
        MemberSpec_('AtmosphereIterations', '_AtmosphereIterations', 0, 0, {u'maxOccurs': u'1', u'type': u'_AtmosphereIterations', u'name': u'AtmosphereIterations', u'minOccurs': u'1'}, None),
        MemberSpec_('AtmosphereGeometry', '_AtmosphereGeometry', 0, 0, {u'maxOccurs': u'1', u'type': u'_AtmosphereGeometry', u'name': u'AtmosphereGeometry', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, typeOfAtmosphere=1, isRadiativeTransfertInBottomAtmosphere=None, AtmosphericOpticalProperty=None, TemperatureFile=None, AtmosphericOpticalPropertyModel=None, AtmosphereIterations=None, AtmosphereGeometry=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_IsAtmosphere')
        self.attrib = ['typeOfAtmosphere']
        self.children = ['isRadiativeTransfertInBottomAtmosphere', 'AtmosphericOpticalProperty', 'TemperatureFile', 'AtmosphericOpticalPropertyModel', 'AtmosphereIterations', 'AtmosphereGeometry']
        self.parent = None
        self._typeOfAtmosphere = _cast(int, typeOfAtmosphere)
        self._isRadiativeTransfertInBottomAtmosphere = isRadiativeTransfertInBottomAtmosphere
        self._AtmosphericOpticalProperty = AtmosphericOpticalProperty
        self._TemperatureFile = TemperatureFile
        self._AtmosphericOpticalPropertyModel = AtmosphericOpticalPropertyModel
        self._AtmosphereIterations = AtmosphereIterations
        self._AtmosphereGeometry = AtmosphereGeometry
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_IsAtmosphere)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_IsAtmosphere.subclass:
            return create_IsAtmosphere.subclass(*args_, **kwargs_)
        else:
            return create_IsAtmosphere(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isRadiativeTransfertInBottomAtmosphere(self): return self._isRadiativeTransfertInBottomAtmosphere
    def set_isRadiativeTransfertInBottomAtmosphere(self, value):
        if value is not None:
            checkclass(value, create_isRadiativeTransfertInBottomAtmosphere)
            value.parent = self
        self._isRadiativeTransfertInBottomAtmosphere = value
    isRadiativeTransfertInBottomAtmosphere = property(get_isRadiativeTransfertInBottomAtmosphere, set_isRadiativeTransfertInBottomAtmosphere)
    def get_AtmosphericOpticalProperty(self): return self._AtmosphericOpticalProperty
    def set_AtmosphericOpticalProperty(self, value):
        if value is not None:
            checkclass(value, create_AtmosphericOpticalProperty)
            value.parent = self
        self._AtmosphericOpticalProperty = value
    AtmosphericOpticalProperty = property(get_AtmosphericOpticalProperty, set_AtmosphericOpticalProperty)
    def get_TemperatureFile(self): return self._TemperatureFile
    def set_TemperatureFile(self, value):
        if value is not None:
            checkclass(value, create_TemperatureFile)
            value.parent = self
        self._TemperatureFile = value
    TemperatureFile = property(get_TemperatureFile, set_TemperatureFile)
    def get_AtmosphericOpticalPropertyModel(self): return self._AtmosphericOpticalPropertyModel
    def set_AtmosphericOpticalPropertyModel(self, value):
        if value is not None:
            checkclass(value, create_AtmosphericOpticalPropertyModel)
            value.parent = self
        self._AtmosphericOpticalPropertyModel = value
    AtmosphericOpticalPropertyModel = property(get_AtmosphericOpticalPropertyModel, set_AtmosphericOpticalPropertyModel)
    def get_AtmosphereIterations(self): return self._AtmosphereIterations
    def set_AtmosphereIterations(self, value):
        if value is not None:
            checkclass(value, create_AtmosphereIterations)
            value.parent = self
        self._AtmosphereIterations = value
    AtmosphereIterations = property(get_AtmosphereIterations, set_AtmosphereIterations)
    def get_AtmosphereGeometry(self): return self._AtmosphereGeometry
    def set_AtmosphereGeometry(self, value):
        if value is not None:
            checkclass(value, create_AtmosphereGeometry)
            value.parent = self
        self._AtmosphereGeometry = value
    AtmosphereGeometry = property(get_AtmosphereGeometry, set_AtmosphereGeometry)
    def get_typeOfAtmosphere(self): return self._typeOfAtmosphere
    def set_typeOfAtmosphere(self, value):
        self._typeOfAtmosphere = value
        update_node(self,self.troot,'atmosphere')
    typeOfAtmosphere = property(get_typeOfAtmosphere, set_typeOfAtmosphere)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.isRadiativeTransfertInBottomAtmosphere is not None or
            self.AtmosphericOpticalProperty is not None or
            self.TemperatureFile is not None or
            self.AtmosphericOpticalPropertyModel is not None or
            self.AtmosphereIterations is not None or
            self.AtmosphereGeometry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_IsAtmosphere', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_IsAtmosphere')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_IsAtmosphere')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_IsAtmosphere', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_IsAtmosphere'):
        if self.typeOfAtmosphere is not None and 'typeOfAtmosphere' not in already_processed:
            already_processed.add('typeOfAtmosphere')
            outfile.write(' typeOfAtmosphere="%s"' % self.gds_format_integer(self.typeOfAtmosphere, input_name='typeOfAtmosphere'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_IsAtmosphere', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isRadiativeTransfertInBottomAtmosphere is not None:
            self.isRadiativeTransfertInBottomAtmosphere.export(outfile, level, namespaceprefix_, name_='isRadiativeTransfertInBottomAtmosphere', pretty_print=pretty_print)
        if self.AtmosphericOpticalProperty is not None:
            self.AtmosphericOpticalProperty.export(outfile, level, namespaceprefix_, name_='AtmosphericOpticalProperty', pretty_print=pretty_print)
        if self.TemperatureFile is not None:
            self.TemperatureFile.export(outfile, level, namespaceprefix_, name_='TemperatureFile', pretty_print=pretty_print)
        if self.AtmosphericOpticalPropertyModel is not None:
            self.AtmosphericOpticalPropertyModel.export(outfile, level, namespaceprefix_, name_='AtmosphericOpticalPropertyModel', pretty_print=pretty_print)
        if self.AtmosphereIterations is not None:
            self.AtmosphereIterations.export(outfile, level, namespaceprefix_, name_='AtmosphereIterations', pretty_print=pretty_print)
        if self.AtmosphereGeometry is not None:
            self.AtmosphereGeometry.export(outfile, level, namespaceprefix_, name_='AtmosphereGeometry', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_IsAtmosphere', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.typeOfAtmosphere is not None:
            element.set('typeOfAtmosphere', self.gds_format_integer(self.typeOfAtmosphere))
        if self.isRadiativeTransfertInBottomAtmosphere is not None:
            isRadiativeTransfertInBottomAtmosphere_ = self.isRadiativeTransfertInBottomAtmosphere
            isRadiativeTransfertInBottomAtmosphere_.to_etree(element, name_='isRadiativeTransfertInBottomAtmosphere', mapping_=mapping_)
        if self.AtmosphericOpticalProperty is not None:
            AtmosphericOpticalProperty_ = self.AtmosphericOpticalProperty
            AtmosphericOpticalProperty_.to_etree(element, name_='AtmosphericOpticalProperty', mapping_=mapping_)
        if self.TemperatureFile is not None:
            TemperatureFile_ = self.TemperatureFile
            TemperatureFile_.to_etree(element, name_='TemperatureFile', mapping_=mapping_)
        if self.AtmosphericOpticalPropertyModel is not None:
            AtmosphericOpticalPropertyModel_ = self.AtmosphericOpticalPropertyModel
            AtmosphericOpticalPropertyModel_.to_etree(element, name_='AtmosphericOpticalPropertyModel', mapping_=mapping_)
        if self.AtmosphereIterations is not None:
            AtmosphereIterations_ = self.AtmosphereIterations
            AtmosphereIterations_.to_etree(element, name_='AtmosphereIterations', mapping_=mapping_)
        if self.AtmosphereGeometry is not None:
            AtmosphereGeometry_ = self.AtmosphereGeometry
            AtmosphereGeometry_.to_etree(element, name_='AtmosphereGeometry', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_IsAtmosphere'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.typeOfAtmosphere is not None and 'typeOfAtmosphere' not in already_processed:
            already_processed.add('typeOfAtmosphere')
            showIndent(outfile, level)
            outfile.write('typeOfAtmosphere=%d,\n' % (self.typeOfAtmosphere,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.isRadiativeTransfertInBottomAtmosphere is not None:
            showIndent(outfile, level)
            outfile.write('isRadiativeTransfertInBottomAtmosphere=model_._isRadiativeTransfertInBottomAtmosphere(\n')
            self.isRadiativeTransfertInBottomAtmosphere.exportLiteral(outfile, level, name_='isRadiativeTransfertInBottomAtmosphere')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AtmosphericOpticalProperty is not None:
            showIndent(outfile, level)
            outfile.write('AtmosphericOpticalProperty=model_._AtmosphericOpticalProperty(\n')
            self.AtmosphericOpticalProperty.exportLiteral(outfile, level, name_='AtmosphericOpticalProperty')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TemperatureFile is not None:
            showIndent(outfile, level)
            outfile.write('TemperatureFile=model_._TemperatureFile(\n')
            self.TemperatureFile.exportLiteral(outfile, level, name_='TemperatureFile')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AtmosphericOpticalPropertyModel is not None:
            showIndent(outfile, level)
            outfile.write('AtmosphericOpticalPropertyModel=model_._AtmosphericOpticalPropertyModel(\n')
            self.AtmosphericOpticalPropertyModel.exportLiteral(outfile, level, name_='AtmosphericOpticalPropertyModel')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AtmosphereIterations is not None:
            showIndent(outfile, level)
            outfile.write('AtmosphereIterations=model_._AtmosphereIterations(\n')
            self.AtmosphereIterations.exportLiteral(outfile, level, name_='AtmosphereIterations')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AtmosphereGeometry is not None:
            showIndent(outfile, level)
            outfile.write('AtmosphereGeometry=model_._AtmosphereGeometry(\n')
            self.AtmosphereGeometry.exportLiteral(outfile, level, name_='AtmosphereGeometry')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('typeOfAtmosphere', node)
        if value is not None and 'typeOfAtmosphere' not in already_processed:
            already_processed.add('typeOfAtmosphere')
            try:
                self.typeOfAtmosphere = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'isRadiativeTransfertInBottomAtmosphere':
            obj_ = create_isRadiativeTransfertInBottomAtmosphere.factory()
            obj_.build(child_)
            self.set_isRadiativeTransfertInBottomAtmosphere(obj_)
            obj_.original_tagname_ = 'isRadiativeTransfertInBottomAtmosphere'
        elif nodeName_ == 'AtmosphericOpticalProperty':
            obj_ = create_AtmosphericOpticalProperty.factory()
            obj_.build(child_)
            self.set_AtmosphericOpticalProperty(obj_)
            obj_.original_tagname_ = 'AtmosphericOpticalProperty'
        elif nodeName_ == 'TemperatureFile':
            obj_ = create_TemperatureFile.factory()
            obj_.build(child_)
            self.set_TemperatureFile(obj_)
            obj_.original_tagname_ = 'TemperatureFile'
        elif nodeName_ == 'AtmosphericOpticalPropertyModel':
            obj_ = create_AtmosphericOpticalPropertyModel.factory()
            obj_.build(child_)
            self.set_AtmosphericOpticalPropertyModel(obj_)
            obj_.original_tagname_ = 'AtmosphericOpticalPropertyModel'
        elif nodeName_ == 'AtmosphereIterations':
            obj_ = create_AtmosphereIterations.factory()
            obj_.build(child_)
            self.set_AtmosphereIterations(obj_)
            obj_.original_tagname_ = 'AtmosphereIterations'
        elif nodeName_ == 'AtmosphereGeometry':
            obj_ = create_AtmosphereGeometry.factory()
            obj_.build(child_)
            self.set_AtmosphereGeometry(obj_)
            obj_.original_tagname_ = 'AtmosphereGeometry'
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_IsAtmosphere


class create_isRadiativeTransfertInBottomAtmosphere(GeneratedsSuper):
    """isRadiativeTransfertInBottomAtmosphere
    isRadiativeTransfertInBottomAtmosphere Output file name
    input/extrapolateAtmTemperatureVertical1D.txt Output file name
    input/extrapolateAtmTemperatureVertical1D.txt Altitude of the
    atmosphere up to which will be included in the BA level.
    Altitude of the atmosphere up to which will be included in the
    BA level."""
    member_data_items_ = [
        MemberSpec_('writeTemperatureFile', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('BA_altitude', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, writeTemperatureFile=0, BA_altitude=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_isRadiativeTransfertInBottomAtmosphere')
        self.attrib = ['writeTemperatureFile', 'BA_altitude']
        self.children = []
        self.parent = None
        self._writeTemperatureFile = _cast(int, writeTemperatureFile)
        self._BA_altitude = _cast(float, BA_altitude)
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_isRadiativeTransfertInBottomAtmosphere)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_isRadiativeTransfertInBottomAtmosphere.subclass:
            return create_isRadiativeTransfertInBottomAtmosphere.subclass(*args_, **kwargs_)
        else:
            return create_isRadiativeTransfertInBottomAtmosphere(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_writeTemperatureFile(self): return self._writeTemperatureFile
    def set_writeTemperatureFile(self, value):
        self._writeTemperatureFile = value
        update_node(self,self.troot,'atmosphere')
    writeTemperatureFile = property(get_writeTemperatureFile, set_writeTemperatureFile)
    def get_BA_altitude(self): return self._BA_altitude
    def set_BA_altitude(self, value):
        self._BA_altitude = value
        update_node(self,self.troot,'atmosphere')
    BA_altitude = property(get_BA_altitude, set_BA_altitude)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_isRadiativeTransfertInBottomAtmosphere', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_isRadiativeTransfertInBottomAtmosphere')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_isRadiativeTransfertInBottomAtmosphere')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_isRadiativeTransfertInBottomAtmosphere', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_isRadiativeTransfertInBottomAtmosphere'):
        if self.writeTemperatureFile is not None and 'writeTemperatureFile' not in already_processed:
            already_processed.add('writeTemperatureFile')
            outfile.write(' writeTemperatureFile="%s"' % self.gds_format_integer(self.writeTemperatureFile, input_name='writeTemperatureFile'))
        if self.BA_altitude is not None and 'BA_altitude' not in already_processed:
            already_processed.add('BA_altitude')
            outfile.write(' BA_altitude="%s"' % self.gds_format_double(self.BA_altitude, input_name='BA_altitude'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_isRadiativeTransfertInBottomAtmosphere', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_isRadiativeTransfertInBottomAtmosphere', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.writeTemperatureFile is not None:
            element.set('writeTemperatureFile', self.gds_format_integer(self.writeTemperatureFile))
        if self.BA_altitude is not None:
            element.set('BA_altitude', self.gds_format_double(self.BA_altitude))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_isRadiativeTransfertInBottomAtmosphere'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.writeTemperatureFile is not None and 'writeTemperatureFile' not in already_processed:
            already_processed.add('writeTemperatureFile')
            showIndent(outfile, level)
            outfile.write('writeTemperatureFile=%d,\n' % (self.writeTemperatureFile,))
        if self.BA_altitude is not None and 'BA_altitude' not in already_processed:
            already_processed.add('BA_altitude')
            showIndent(outfile, level)
            outfile.write('BA_altitude=%e,\n' % (self.BA_altitude,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('writeTemperatureFile', node)
        if value is not None and 'writeTemperatureFile' not in already_processed:
            already_processed.add('writeTemperatureFile')
            try:
                self.writeTemperatureFile = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('BA_altitude', node)
        if value is not None and 'BA_altitude' not in already_processed:
            already_processed.add('BA_altitude')
            try:
                self.BA_altitude = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (BA_altitude): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_isRadiativeTransfertInBottomAtmosphere


class create_AtmosphericOpticalProperty(GeneratedsSuper):
    """It corresponds to aerosol scattering and absorbing processes It
    corresponds to aerosol scattering and absorbing processes g2 g2
    g1 g1 Aerosol density is proportional to exp[-z/Ha] at altitude
    z Aerosol density is proportional to exp[-z/Ha] at altitude z
    Mid point correction for first order scattering Mid point
    correction for first order scattering Gas density is
    proportional to exp[-z/Hg] at altitude z Gas density is
    proportional to exp[-z/Hg] at altitude z Plane parallel /
    spherical atmosphere Plane parallel / spherical atmosphere
    Optical depth associated to gas scattering only, without
    absorption Optical depth associated to gas scattering only,
    without absorption Multiplicative factor of the Henyey
    Greenstein phase function Multiplicative factor of the Henyey
    Greenstein phase function Single scattering albedo. \n1 if no
    absorption by aerosols.\n0 if no scattering by aerosols Single
    scattering albedo. \n1 if no absorption by aerosols.\n0 if no
    scattering by aerosols Transmittance ([0 1]) of an atmosphere
    made of 100% absorbing gas only Transmittance ([0 1]) of an
    atmosphere made of 100% absorbing gas only"""
    member_data_items_ = [
        MemberSpec_('aerosolOpticalDepth', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('g2', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('g1', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('aerosolScaleFactor', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('pointMilieu', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('gasScaleFactor', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('courbureTerre', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('gasOpticalDepth', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('a_HG', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('aerosolAlbedo', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('transmittanceOfGases', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, aerosolOpticalDepth=0.202, g2=0.4, g1=0.790, aerosolScaleFactor=1000, pointMilieu=1, gasScaleFactor=8400, courbureTerre=1, gasOpticalDepth=0.049, a_HG=0.95, aerosolAlbedo=0.947, transmittanceOfGases=0.750):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_AtmosphericOpticalProperty')
        self.attrib = ['aerosolOpticalDepth', 'g2', 'g1', 'aerosolScaleFactor', 'pointMilieu', 'gasScaleFactor', 'courbureTerre', 'gasOpticalDepth', 'a_HG', 'aerosolAlbedo', 'transmittanceOfGases']
        self.children = []
        self.parent = None
        self._aerosolOpticalDepth = _cast(float, aerosolOpticalDepth)
        self._g2 = _cast(float, g2)
        self._g1 = _cast(float, g1)
        self._aerosolScaleFactor = _cast(float, aerosolScaleFactor)
        self._pointMilieu = _cast(int, pointMilieu)
        self._gasScaleFactor = _cast(float, gasScaleFactor)
        self._courbureTerre = _cast(int, courbureTerre)
        self._gasOpticalDepth = _cast(float, gasOpticalDepth)
        self._a_HG = _cast(float, a_HG)
        self._aerosolAlbedo = _cast(float, aerosolAlbedo)
        self._transmittanceOfGases = _cast(float, transmittanceOfGases)
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_AtmosphericOpticalProperty)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_AtmosphericOpticalProperty.subclass:
            return create_AtmosphericOpticalProperty.subclass(*args_, **kwargs_)
        else:
            return create_AtmosphericOpticalProperty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_aerosolOpticalDepth(self): return self._aerosolOpticalDepth
    def set_aerosolOpticalDepth(self, value):
        self._aerosolOpticalDepth = value
        update_node(self,self.troot,'atmosphere')
    aerosolOpticalDepth = property(get_aerosolOpticalDepth, set_aerosolOpticalDepth)
    def get_g2(self): return self._g2
    def set_g2(self, value):
        self._g2 = value
        update_node(self,self.troot,'atmosphere')
    g2 = property(get_g2, set_g2)
    def get_g1(self): return self._g1
    def set_g1(self, value):
        self._g1 = value
        update_node(self,self.troot,'atmosphere')
    g1 = property(get_g1, set_g1)
    def get_aerosolScaleFactor(self): return self._aerosolScaleFactor
    def set_aerosolScaleFactor(self, value):
        self._aerosolScaleFactor = value
        update_node(self,self.troot,'atmosphere')
    aerosolScaleFactor = property(get_aerosolScaleFactor, set_aerosolScaleFactor)
    def get_pointMilieu(self): return self._pointMilieu
    def set_pointMilieu(self, value):
        self._pointMilieu = value
        update_node(self,self.troot,'atmosphere')
    pointMilieu = property(get_pointMilieu, set_pointMilieu)
    def get_gasScaleFactor(self): return self._gasScaleFactor
    def set_gasScaleFactor(self, value):
        self._gasScaleFactor = value
        update_node(self,self.troot,'atmosphere')
    gasScaleFactor = property(get_gasScaleFactor, set_gasScaleFactor)
    def get_courbureTerre(self): return self._courbureTerre
    def set_courbureTerre(self, value):
        self._courbureTerre = value
        update_node(self,self.troot,'atmosphere')
    courbureTerre = property(get_courbureTerre, set_courbureTerre)
    def get_gasOpticalDepth(self): return self._gasOpticalDepth
    def set_gasOpticalDepth(self, value):
        self._gasOpticalDepth = value
        update_node(self,self.troot,'atmosphere')
    gasOpticalDepth = property(get_gasOpticalDepth, set_gasOpticalDepth)
    def get_a_HG(self): return self._a_HG
    def set_a_HG(self, value):
        self._a_HG = value
        update_node(self,self.troot,'atmosphere')
    a_HG = property(get_a_HG, set_a_HG)
    def get_aerosolAlbedo(self): return self._aerosolAlbedo
    def set_aerosolAlbedo(self, value):
        self._aerosolAlbedo = value
        update_node(self,self.troot,'atmosphere')
    aerosolAlbedo = property(get_aerosolAlbedo, set_aerosolAlbedo)
    def get_transmittanceOfGases(self): return self._transmittanceOfGases
    def set_transmittanceOfGases(self, value):
        self._transmittanceOfGases = value
        update_node(self,self.troot,'atmosphere')
    transmittanceOfGases = property(get_transmittanceOfGases, set_transmittanceOfGases)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_AtmosphericOpticalProperty', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_AtmosphericOpticalProperty')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_AtmosphericOpticalProperty')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_AtmosphericOpticalProperty', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_AtmosphericOpticalProperty'):
        if self.aerosolOpticalDepth is not None and 'aerosolOpticalDepth' not in already_processed:
            already_processed.add('aerosolOpticalDepth')
            outfile.write(' aerosolOpticalDepth="%s"' % self.gds_format_double(self.aerosolOpticalDepth, input_name='aerosolOpticalDepth'))
        if self.g2 is not None and 'g2' not in already_processed:
            already_processed.add('g2')
            outfile.write(' g2="%s"' % self.gds_format_double(self.g2, input_name='g2'))
        if self.g1 is not None and 'g1' not in already_processed:
            already_processed.add('g1')
            outfile.write(' g1="%s"' % self.gds_format_double(self.g1, input_name='g1'))
        if self.aerosolScaleFactor is not None and 'aerosolScaleFactor' not in already_processed:
            already_processed.add('aerosolScaleFactor')
            outfile.write(' aerosolScaleFactor="%s"' % self.gds_format_double(self.aerosolScaleFactor, input_name='aerosolScaleFactor'))
        if self.pointMilieu is not None and 'pointMilieu' not in already_processed:
            already_processed.add('pointMilieu')
            outfile.write(' pointMilieu="%s"' % self.gds_format_integer(self.pointMilieu, input_name='pointMilieu'))
        if self.gasScaleFactor is not None and 'gasScaleFactor' not in already_processed:
            already_processed.add('gasScaleFactor')
            outfile.write(' gasScaleFactor="%s"' % self.gds_format_double(self.gasScaleFactor, input_name='gasScaleFactor'))
        if self.courbureTerre is not None and 'courbureTerre' not in already_processed:
            already_processed.add('courbureTerre')
            outfile.write(' courbureTerre="%s"' % self.gds_format_integer(self.courbureTerre, input_name='courbureTerre'))
        if self.gasOpticalDepth is not None and 'gasOpticalDepth' not in already_processed:
            already_processed.add('gasOpticalDepth')
            outfile.write(' gasOpticalDepth="%s"' % self.gds_format_double(self.gasOpticalDepth, input_name='gasOpticalDepth'))
        if self.a_HG is not None and 'a_HG' not in already_processed:
            already_processed.add('a_HG')
            outfile.write(' a_HG="%s"' % self.gds_format_double(self.a_HG, input_name='a_HG'))
        if self.aerosolAlbedo is not None and 'aerosolAlbedo' not in already_processed:
            already_processed.add('aerosolAlbedo')
            outfile.write(' aerosolAlbedo="%s"' % self.gds_format_double(self.aerosolAlbedo, input_name='aerosolAlbedo'))
        if self.transmittanceOfGases is not None and 'transmittanceOfGases' not in already_processed:
            already_processed.add('transmittanceOfGases')
            outfile.write(' transmittanceOfGases="%s"' % self.gds_format_double(self.transmittanceOfGases, input_name='transmittanceOfGases'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_AtmosphericOpticalProperty', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_AtmosphericOpticalProperty', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.aerosolOpticalDepth is not None:
            element.set('aerosolOpticalDepth', self.gds_format_double(self.aerosolOpticalDepth))
        if self.g2 is not None:
            element.set('g2', self.gds_format_double(self.g2))
        if self.g1 is not None:
            element.set('g1', self.gds_format_double(self.g1))
        if self.aerosolScaleFactor is not None:
            element.set('aerosolScaleFactor', self.gds_format_double(self.aerosolScaleFactor))
        if self.pointMilieu is not None:
            element.set('pointMilieu', self.gds_format_integer(self.pointMilieu))
        if self.gasScaleFactor is not None:
            element.set('gasScaleFactor', self.gds_format_double(self.gasScaleFactor))
        if self.courbureTerre is not None:
            element.set('courbureTerre', self.gds_format_integer(self.courbureTerre))
        if self.gasOpticalDepth is not None:
            element.set('gasOpticalDepth', self.gds_format_double(self.gasOpticalDepth))
        if self.a_HG is not None:
            element.set('a_HG', self.gds_format_double(self.a_HG))
        if self.aerosolAlbedo is not None:
            element.set('aerosolAlbedo', self.gds_format_double(self.aerosolAlbedo))
        if self.transmittanceOfGases is not None:
            element.set('transmittanceOfGases', self.gds_format_double(self.transmittanceOfGases))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_AtmosphericOpticalProperty'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.aerosolOpticalDepth is not None and 'aerosolOpticalDepth' not in already_processed:
            already_processed.add('aerosolOpticalDepth')
            showIndent(outfile, level)
            outfile.write('aerosolOpticalDepth=%e,\n' % (self.aerosolOpticalDepth,))
        if self.g2 is not None and 'g2' not in already_processed:
            already_processed.add('g2')
            showIndent(outfile, level)
            outfile.write('g2=%e,\n' % (self.g2,))
        if self.g1 is not None and 'g1' not in already_processed:
            already_processed.add('g1')
            showIndent(outfile, level)
            outfile.write('g1=%e,\n' % (self.g1,))
        if self.aerosolScaleFactor is not None and 'aerosolScaleFactor' not in already_processed:
            already_processed.add('aerosolScaleFactor')
            showIndent(outfile, level)
            outfile.write('aerosolScaleFactor=%e,\n' % (self.aerosolScaleFactor,))
        if self.pointMilieu is not None and 'pointMilieu' not in already_processed:
            already_processed.add('pointMilieu')
            showIndent(outfile, level)
            outfile.write('pointMilieu=%d,\n' % (self.pointMilieu,))
        if self.gasScaleFactor is not None and 'gasScaleFactor' not in already_processed:
            already_processed.add('gasScaleFactor')
            showIndent(outfile, level)
            outfile.write('gasScaleFactor=%e,\n' % (self.gasScaleFactor,))
        if self.courbureTerre is not None and 'courbureTerre' not in already_processed:
            already_processed.add('courbureTerre')
            showIndent(outfile, level)
            outfile.write('courbureTerre=%d,\n' % (self.courbureTerre,))
        if self.gasOpticalDepth is not None and 'gasOpticalDepth' not in already_processed:
            already_processed.add('gasOpticalDepth')
            showIndent(outfile, level)
            outfile.write('gasOpticalDepth=%e,\n' % (self.gasOpticalDepth,))
        if self.a_HG is not None and 'a_HG' not in already_processed:
            already_processed.add('a_HG')
            showIndent(outfile, level)
            outfile.write('a_HG=%e,\n' % (self.a_HG,))
        if self.aerosolAlbedo is not None and 'aerosolAlbedo' not in already_processed:
            already_processed.add('aerosolAlbedo')
            showIndent(outfile, level)
            outfile.write('aerosolAlbedo=%e,\n' % (self.aerosolAlbedo,))
        if self.transmittanceOfGases is not None and 'transmittanceOfGases' not in already_processed:
            already_processed.add('transmittanceOfGases')
            showIndent(outfile, level)
            outfile.write('transmittanceOfGases=%e,\n' % (self.transmittanceOfGases,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aerosolOpticalDepth', node)
        if value is not None and 'aerosolOpticalDepth' not in already_processed:
            already_processed.add('aerosolOpticalDepth')
            try:
                self.aerosolOpticalDepth = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (aerosolOpticalDepth): %s' % exp)
        value = find_attr_value_('g2', node)
        if value is not None and 'g2' not in already_processed:
            already_processed.add('g2')
            try:
                self.g2 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (g2): %s' % exp)
        value = find_attr_value_('g1', node)
        if value is not None and 'g1' not in already_processed:
            already_processed.add('g1')
            try:
                self.g1 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (g1): %s' % exp)
        value = find_attr_value_('aerosolScaleFactor', node)
        if value is not None and 'aerosolScaleFactor' not in already_processed:
            already_processed.add('aerosolScaleFactor')
            try:
                self.aerosolScaleFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (aerosolScaleFactor): %s' % exp)
        value = find_attr_value_('pointMilieu', node)
        if value is not None and 'pointMilieu' not in already_processed:
            already_processed.add('pointMilieu')
            try:
                self.pointMilieu = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('gasScaleFactor', node)
        if value is not None and 'gasScaleFactor' not in already_processed:
            already_processed.add('gasScaleFactor')
            try:
                self.gasScaleFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (gasScaleFactor): %s' % exp)
        value = find_attr_value_('courbureTerre', node)
        if value is not None and 'courbureTerre' not in already_processed:
            already_processed.add('courbureTerre')
            try:
                self.courbureTerre = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('gasOpticalDepth', node)
        if value is not None and 'gasOpticalDepth' not in already_processed:
            already_processed.add('gasOpticalDepth')
            try:
                self.gasOpticalDepth = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (gasOpticalDepth): %s' % exp)
        value = find_attr_value_('a_HG', node)
        if value is not None and 'a_HG' not in already_processed:
            already_processed.add('a_HG')
            try:
                self.a_HG = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (a_HG): %s' % exp)
        value = find_attr_value_('aerosolAlbedo', node)
        if value is not None and 'aerosolAlbedo' not in already_processed:
            already_processed.add('aerosolAlbedo')
            try:
                self.aerosolAlbedo = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (aerosolAlbedo): %s' % exp)
        value = find_attr_value_('transmittanceOfGases', node)
        if value is not None and 'transmittanceOfGases' not in already_processed:
            already_processed.add('transmittanceOfGases')
            try:
                self.transmittanceOfGases = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (transmittanceOfGases): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_AtmosphericOpticalProperty


class create_TemperatureFile(GeneratedsSuper):
    """File containing temperature vertical profile; example : \n *number
    of layers* 2 \n0 300\n80 220\n File necessary only in mode T or
    T+R File containing temperature vertical profile; example : \n
    *number of layers* 2 \n0 300\n80 220\n File necessary only in
    mode T or T+R"""
    member_data_items_ = [
        MemberSpec_('atmosphereTemperatureFileName', 'xsd:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, atmosphereTemperatureFileName='atmosphereTemperature.txt'):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_TemperatureFile')
        self.attrib = ['atmosphereTemperatureFileName']
        self.children = []
        self.parent = None
        self._atmosphereTemperatureFileName = _cast(None, atmosphereTemperatureFileName)
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_TemperatureFile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_TemperatureFile.subclass:
            return create_TemperatureFile.subclass(*args_, **kwargs_)
        else:
            return create_TemperatureFile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_atmosphereTemperatureFileName(self): return self._atmosphereTemperatureFileName
    def set_atmosphereTemperatureFileName(self, value):
        self._atmosphereTemperatureFileName = value
        update_node(self,self.troot,'atmosphere')
    atmosphereTemperatureFileName = property(get_atmosphereTemperatureFileName, set_atmosphereTemperatureFileName)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_TemperatureFile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_TemperatureFile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_TemperatureFile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_TemperatureFile', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_TemperatureFile'):
        if self.atmosphereTemperatureFileName is not None and 'atmosphereTemperatureFileName' not in already_processed:
            already_processed.add('atmosphereTemperatureFileName')
            outfile.write(' atmosphereTemperatureFileName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.atmosphereTemperatureFileName), input_name='atmosphereTemperatureFileName')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_TemperatureFile', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_TemperatureFile', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.atmosphereTemperatureFileName is not None:
            element.set('atmosphereTemperatureFileName', self.gds_format_string(self.atmosphereTemperatureFileName))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_TemperatureFile'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.atmosphereTemperatureFileName is not None and 'atmosphereTemperatureFileName' not in already_processed:
            already_processed.add('atmosphereTemperatureFileName')
            showIndent(outfile, level)
            outfile.write('atmosphereTemperatureFileName="%s",\n' % (self.atmosphereTemperatureFileName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('atmosphereTemperatureFileName', node)
        if value is not None and 'atmosphereTemperatureFileName' not in already_processed:
            already_processed.add('atmosphereTemperatureFileName')
            self.atmosphereTemperatureFileName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_TemperatureFile


class create_AtmosphericOpticalPropertyModel(GeneratedsSuper):
    """Atmospheric model Atmospheric model Define water vapour amount
    Define water vapour amount Atmospheric database name Atmospheric
    database name Band model correction Band model correction Gas
    temperature model Gas temperature model Redefine temperature
    profile up to 10km Redefine temperature profile up to 10km Gas
    model Gas model Same model for gas parameters Same model for gas
    parameters Gas cumulative model Gas cumulative model Gas --
    Ignore gas for atmosphere extrapolation Gas -- Ignore gas for
    atmosphere extrapolation CO2 mixing rate CO2 mixing rate
    Manually define the amount of other gases Manually define the
    amount of other gases"""
    member_data_items_ = [
        MemberSpec_('precipitableWaterAmountCkeckbox', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('databaseName', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('correctionBandModel', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('temperatureModelName', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('redefTemperature', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('gasModelName', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('gasGroup', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('gasCumulativeModelName', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('ignoreGasForExtrapolation', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('co2MixRate', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('scaleOtherGases', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('ignoredGas', '_ignoredGas', 0, 0, {u'maxOccurs': u'1', u'type': u'_ignoredGas', u'name': u'ignoredGas', u'minOccurs': u'1'}, None),
        MemberSpec_('OtherGasesScale', '_OtherGasesScale', 0, 0, {u'maxOccurs': u'1', u'type': u'_OtherGasesScale', u'name': u'OtherGasesScale', u'minOccurs': u'1'}, None),
        MemberSpec_('WaterAmount', '_WaterAmount', 0, 0, {u'maxOccurs': u'1', u'type': u'_WaterAmount', u'name': u'WaterAmount', u'minOccurs': u'1'}, None),
        MemberSpec_('tempParameters', '_tempParameters', 0, 0, {u'maxOccurs': u'1', u'type': u'_tempParameters', u'name': u'tempParameters', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, precipitableWaterAmountCkeckbox=0, databaseName='dart_atmosphere.db', correctionBandModel=1, temperatureModelName='USSTD76', redefTemperature=0, gasModelName='USSTD76', gasGroup=1, gasCumulativeModelName='USSTD76', ignoreGasForExtrapolation=0, co2MixRate=365.0, scaleOtherGases=0, ignoredGas=None, OtherGasesScale=None, WaterAmount=None, tempParameters=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_AtmosphericOpticalPropertyModel')
        self.attrib = ['precipitableWaterAmountCkeckbox', 'databaseName', 'correctionBandModel', 'temperatureModelName', 'redefTemperature', 'gasModelName', 'gasGroup', 'gasCumulativeModelName', 'ignoreGasForExtrapolation', 'co2MixRate', 'scaleOtherGases']
        self.children = ['ignoredGas', 'OtherGasesScale', 'WaterAmount', 'tempParameters']
        self.parent = None
        self._precipitableWaterAmountCkeckbox = _cast(int, precipitableWaterAmountCkeckbox)
        self._databaseName = _cast(None, databaseName)
        self._correctionBandModel = _cast(int, correctionBandModel)
        self._temperatureModelName = _cast(None, temperatureModelName)
        self._redefTemperature = _cast(int, redefTemperature)
        self._gasModelName = _cast(None, gasModelName)
        self._gasGroup = _cast(int, gasGroup)
        self._gasCumulativeModelName = _cast(None, gasCumulativeModelName)
        self._ignoreGasForExtrapolation = _cast(int, ignoreGasForExtrapolation)
        self._co2MixRate = _cast(float, co2MixRate)
        self._scaleOtherGases = _cast(int, scaleOtherGases)
        self._ignoredGas = ignoredGas
        self._OtherGasesScale = OtherGasesScale
        self._WaterAmount = WaterAmount
        self._tempParameters = tempParameters
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_AtmosphericOpticalPropertyModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_AtmosphericOpticalPropertyModel.subclass:
            return create_AtmosphericOpticalPropertyModel.subclass(*args_, **kwargs_)
        else:
            return create_AtmosphericOpticalPropertyModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ignoredGas(self): return self._ignoredGas
    def set_ignoredGas(self, value):
        if value is not None:
            checkclass(value, create_ignoredGas)
            value.parent = self
        self._ignoredGas = value
    ignoredGas = property(get_ignoredGas, set_ignoredGas)
    def get_OtherGasesScale(self): return self._OtherGasesScale
    def set_OtherGasesScale(self, value):
        if value is not None:
            checkclass(value, create_OtherGasesScale)
            value.parent = self
        self._OtherGasesScale = value
    OtherGasesScale = property(get_OtherGasesScale, set_OtherGasesScale)
    def get_WaterAmount(self): return self._WaterAmount
    def set_WaterAmount(self, value):
        if value is not None:
            checkclass(value, create_WaterAmount)
            value.parent = self
        self._WaterAmount = value
    WaterAmount = property(get_WaterAmount, set_WaterAmount)
    def get_tempParameters(self): return self._tempParameters
    def set_tempParameters(self, value):
        if value is not None:
            checkclass(value, create_tempParameters)
            value.parent = self
        self._tempParameters = value
    tempParameters = property(get_tempParameters, set_tempParameters)
    def get_precipitableWaterAmountCkeckbox(self): return self._precipitableWaterAmountCkeckbox
    def set_precipitableWaterAmountCkeckbox(self, value):
        self._precipitableWaterAmountCkeckbox = value
        update_node(self,self.troot,'atmosphere')
    precipitableWaterAmountCkeckbox = property(get_precipitableWaterAmountCkeckbox, set_precipitableWaterAmountCkeckbox)
    def get_databaseName(self): return self._databaseName
    def set_databaseName(self, value):
        self._databaseName = value
        update_node(self,self.troot,'atmosphere')
    databaseName = property(get_databaseName, set_databaseName)
    def get_correctionBandModel(self): return self._correctionBandModel
    def set_correctionBandModel(self, value):
        self._correctionBandModel = value
        update_node(self,self.troot,'atmosphere')
    correctionBandModel = property(get_correctionBandModel, set_correctionBandModel)
    def get_temperatureModelName(self): return self._temperatureModelName
    def set_temperatureModelName(self, value):
        self._temperatureModelName = value
        update_node(self,self.troot,'atmosphere')
    temperatureModelName = property(get_temperatureModelName, set_temperatureModelName)
    def get_redefTemperature(self): return self._redefTemperature
    def set_redefTemperature(self, value):
        self._redefTemperature = value
        update_node(self,self.troot,'atmosphere')
    redefTemperature = property(get_redefTemperature, set_redefTemperature)
    def get_gasModelName(self): return self._gasModelName
    def set_gasModelName(self, value):
        self._gasModelName = value
        update_node(self,self.troot,'atmosphere')
    gasModelName = property(get_gasModelName, set_gasModelName)
    def get_gasGroup(self): return self._gasGroup
    def set_gasGroup(self, value):
        self._gasGroup = value
        update_node(self,self.troot,'atmosphere')
    gasGroup = property(get_gasGroup, set_gasGroup)
    def get_gasCumulativeModelName(self): return self._gasCumulativeModelName
    def set_gasCumulativeModelName(self, value):
        self._gasCumulativeModelName = value
        update_node(self,self.troot,'atmosphere')
    gasCumulativeModelName = property(get_gasCumulativeModelName, set_gasCumulativeModelName)
    def get_ignoreGasForExtrapolation(self): return self._ignoreGasForExtrapolation
    def set_ignoreGasForExtrapolation(self, value):
        self._ignoreGasForExtrapolation = value
        update_node(self,self.troot,'atmosphere')
    ignoreGasForExtrapolation = property(get_ignoreGasForExtrapolation, set_ignoreGasForExtrapolation)
    def get_co2MixRate(self): return self._co2MixRate
    def set_co2MixRate(self, value):
        self._co2MixRate = value
        update_node(self,self.troot,'atmosphere')
    co2MixRate = property(get_co2MixRate, set_co2MixRate)
    def get_scaleOtherGases(self): return self._scaleOtherGases
    def set_scaleOtherGases(self, value):
        self._scaleOtherGases = value
        update_node(self,self.troot,'atmosphere')
    scaleOtherGases = property(get_scaleOtherGases, set_scaleOtherGases)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.ignoredGas is not None or
            self.OtherGasesScale is not None or
            self.WaterAmount is not None or
            self.tempParameters is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_AtmosphericOpticalPropertyModel', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_AtmosphericOpticalPropertyModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_AtmosphericOpticalPropertyModel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_AtmosphericOpticalPropertyModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_AtmosphericOpticalPropertyModel'):
        if self.precipitableWaterAmountCkeckbox is not None and 'precipitableWaterAmountCkeckbox' not in already_processed:
            already_processed.add('precipitableWaterAmountCkeckbox')
            outfile.write(' precipitableWaterAmountCkeckbox="%s"' % self.gds_format_integer(self.precipitableWaterAmountCkeckbox, input_name='precipitableWaterAmountCkeckbox'))
        if self.databaseName is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            outfile.write(' databaseName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.databaseName), input_name='databaseName')), ))
        if self.correctionBandModel is not None and 'correctionBandModel' not in already_processed:
            already_processed.add('correctionBandModel')
            outfile.write(' correctionBandModel="%s"' % self.gds_format_integer(self.correctionBandModel, input_name='correctionBandModel'))
        if self.temperatureModelName is not None and 'temperatureModelName' not in already_processed:
            already_processed.add('temperatureModelName')
            outfile.write(' temperatureModelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.temperatureModelName), input_name='temperatureModelName')), ))
        if self.redefTemperature is not None and 'redefTemperature' not in already_processed:
            already_processed.add('redefTemperature')
            outfile.write(' redefTemperature="%s"' % self.gds_format_integer(self.redefTemperature, input_name='redefTemperature'))
        if self.gasModelName is not None and 'gasModelName' not in already_processed:
            already_processed.add('gasModelName')
            outfile.write(' gasModelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.gasModelName), input_name='gasModelName')), ))
        if self.gasGroup is not None and 'gasGroup' not in already_processed:
            already_processed.add('gasGroup')
            outfile.write(' gasGroup="%s"' % self.gds_format_integer(self.gasGroup, input_name='gasGroup'))
        if self.gasCumulativeModelName is not None and 'gasCumulativeModelName' not in already_processed:
            already_processed.add('gasCumulativeModelName')
            outfile.write(' gasCumulativeModelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.gasCumulativeModelName), input_name='gasCumulativeModelName')), ))
        if self.ignoreGasForExtrapolation is not None and 'ignoreGasForExtrapolation' not in already_processed:
            already_processed.add('ignoreGasForExtrapolation')
            outfile.write(' ignoreGasForExtrapolation="%s"' % self.gds_format_integer(self.ignoreGasForExtrapolation, input_name='ignoreGasForExtrapolation'))
        if self.co2MixRate is not None and 'co2MixRate' not in already_processed:
            already_processed.add('co2MixRate')
            outfile.write(' co2MixRate="%s"' % self.gds_format_double(self.co2MixRate, input_name='co2MixRate'))
        if self.scaleOtherGases is not None and 'scaleOtherGases' not in already_processed:
            already_processed.add('scaleOtherGases')
            outfile.write(' scaleOtherGases="%s"' % self.gds_format_integer(self.scaleOtherGases, input_name='scaleOtherGases'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_AtmosphericOpticalPropertyModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ignoredGas is not None:
            self.ignoredGas.export(outfile, level, namespaceprefix_, name_='ignoredGas', pretty_print=pretty_print)
        if self.OtherGasesScale is not None:
            self.OtherGasesScale.export(outfile, level, namespaceprefix_, name_='OtherGasesScale', pretty_print=pretty_print)
        if self.WaterAmount is not None:
            self.WaterAmount.export(outfile, level, namespaceprefix_, name_='WaterAmount', pretty_print=pretty_print)
        if self.tempParameters is not None:
            self.tempParameters.export(outfile, level, namespaceprefix_, name_='tempParameters', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_AtmosphericOpticalPropertyModel', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.precipitableWaterAmountCkeckbox is not None:
            element.set('precipitableWaterAmountCkeckbox', self.gds_format_integer(self.precipitableWaterAmountCkeckbox))
        if self.databaseName is not None:
            element.set('databaseName', self.gds_format_string(self.databaseName))
        if self.correctionBandModel is not None:
            element.set('correctionBandModel', self.gds_format_integer(self.correctionBandModel))
        if self.temperatureModelName is not None:
            element.set('temperatureModelName', self.gds_format_string(self.temperatureModelName))
        if self.redefTemperature is not None:
            element.set('redefTemperature', self.gds_format_integer(self.redefTemperature))
        if self.gasModelName is not None:
            element.set('gasModelName', self.gds_format_string(self.gasModelName))
        if self.gasGroup is not None:
            element.set('gasGroup', self.gds_format_integer(self.gasGroup))
        if self.gasCumulativeModelName is not None:
            element.set('gasCumulativeModelName', self.gds_format_string(self.gasCumulativeModelName))
        if self.ignoreGasForExtrapolation is not None:
            element.set('ignoreGasForExtrapolation', self.gds_format_integer(self.ignoreGasForExtrapolation))
        if self.co2MixRate is not None:
            element.set('co2MixRate', self.gds_format_double(self.co2MixRate))
        if self.scaleOtherGases is not None:
            element.set('scaleOtherGases', self.gds_format_integer(self.scaleOtherGases))
        if self.ignoredGas is not None:
            ignoredGas_ = self.ignoredGas
            ignoredGas_.to_etree(element, name_='ignoredGas', mapping_=mapping_)
        if self.OtherGasesScale is not None:
            OtherGasesScale_ = self.OtherGasesScale
            OtherGasesScale_.to_etree(element, name_='OtherGasesScale', mapping_=mapping_)
        if self.WaterAmount is not None:
            WaterAmount_ = self.WaterAmount
            WaterAmount_.to_etree(element, name_='WaterAmount', mapping_=mapping_)
        if self.tempParameters is not None:
            tempParameters_ = self.tempParameters
            tempParameters_.to_etree(element, name_='tempParameters', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_AtmosphericOpticalPropertyModel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.precipitableWaterAmountCkeckbox is not None and 'precipitableWaterAmountCkeckbox' not in already_processed:
            already_processed.add('precipitableWaterAmountCkeckbox')
            showIndent(outfile, level)
            outfile.write('precipitableWaterAmountCkeckbox=%d,\n' % (self.precipitableWaterAmountCkeckbox,))
        if self.databaseName is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            showIndent(outfile, level)
            outfile.write('databaseName="%s",\n' % (self.databaseName,))
        if self.correctionBandModel is not None and 'correctionBandModel' not in already_processed:
            already_processed.add('correctionBandModel')
            showIndent(outfile, level)
            outfile.write('correctionBandModel=%d,\n' % (self.correctionBandModel,))
        if self.temperatureModelName is not None and 'temperatureModelName' not in already_processed:
            already_processed.add('temperatureModelName')
            showIndent(outfile, level)
            outfile.write('temperatureModelName="%s",\n' % (self.temperatureModelName,))
        if self.redefTemperature is not None and 'redefTemperature' not in already_processed:
            already_processed.add('redefTemperature')
            showIndent(outfile, level)
            outfile.write('redefTemperature=%d,\n' % (self.redefTemperature,))
        if self.gasModelName is not None and 'gasModelName' not in already_processed:
            already_processed.add('gasModelName')
            showIndent(outfile, level)
            outfile.write('gasModelName="%s",\n' % (self.gasModelName,))
        if self.gasGroup is not None and 'gasGroup' not in already_processed:
            already_processed.add('gasGroup')
            showIndent(outfile, level)
            outfile.write('gasGroup=%d,\n' % (self.gasGroup,))
        if self.gasCumulativeModelName is not None and 'gasCumulativeModelName' not in already_processed:
            already_processed.add('gasCumulativeModelName')
            showIndent(outfile, level)
            outfile.write('gasCumulativeModelName="%s",\n' % (self.gasCumulativeModelName,))
        if self.ignoreGasForExtrapolation is not None and 'ignoreGasForExtrapolation' not in already_processed:
            already_processed.add('ignoreGasForExtrapolation')
            showIndent(outfile, level)
            outfile.write('ignoreGasForExtrapolation=%d,\n' % (self.ignoreGasForExtrapolation,))
        if self.co2MixRate is not None and 'co2MixRate' not in already_processed:
            already_processed.add('co2MixRate')
            showIndent(outfile, level)
            outfile.write('co2MixRate=%e,\n' % (self.co2MixRate,))
        if self.scaleOtherGases is not None and 'scaleOtherGases' not in already_processed:
            already_processed.add('scaleOtherGases')
            showIndent(outfile, level)
            outfile.write('scaleOtherGases=%d,\n' % (self.scaleOtherGases,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ignoredGas is not None:
            showIndent(outfile, level)
            outfile.write('ignoredGas=model_._ignoredGas(\n')
            self.ignoredGas.exportLiteral(outfile, level, name_='ignoredGas')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OtherGasesScale is not None:
            showIndent(outfile, level)
            outfile.write('OtherGasesScale=model_._OtherGasesScale(\n')
            self.OtherGasesScale.exportLiteral(outfile, level, name_='OtherGasesScale')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.WaterAmount is not None:
            showIndent(outfile, level)
            outfile.write('WaterAmount=model_._WaterAmount(\n')
            self.WaterAmount.exportLiteral(outfile, level, name_='WaterAmount')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.tempParameters is not None:
            showIndent(outfile, level)
            outfile.write('tempParameters=model_._tempParameters(\n')
            self.tempParameters.exportLiteral(outfile, level, name_='tempParameters')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('precipitableWaterAmountCkeckbox', node)
        if value is not None and 'precipitableWaterAmountCkeckbox' not in already_processed:
            already_processed.add('precipitableWaterAmountCkeckbox')
            try:
                self.precipitableWaterAmountCkeckbox = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('databaseName', node)
        if value is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            self.databaseName = value
        value = find_attr_value_('correctionBandModel', node)
        if value is not None and 'correctionBandModel' not in already_processed:
            already_processed.add('correctionBandModel')
            try:
                self.correctionBandModel = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('temperatureModelName', node)
        if value is not None and 'temperatureModelName' not in already_processed:
            already_processed.add('temperatureModelName')
            self.temperatureModelName = value
        value = find_attr_value_('redefTemperature', node)
        if value is not None and 'redefTemperature' not in already_processed:
            already_processed.add('redefTemperature')
            try:
                self.redefTemperature = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('gasModelName', node)
        if value is not None and 'gasModelName' not in already_processed:
            already_processed.add('gasModelName')
            self.gasModelName = value
        value = find_attr_value_('gasGroup', node)
        if value is not None and 'gasGroup' not in already_processed:
            already_processed.add('gasGroup')
            try:
                self.gasGroup = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('gasCumulativeModelName', node)
        if value is not None and 'gasCumulativeModelName' not in already_processed:
            already_processed.add('gasCumulativeModelName')
            self.gasCumulativeModelName = value
        value = find_attr_value_('ignoreGasForExtrapolation', node)
        if value is not None and 'ignoreGasForExtrapolation' not in already_processed:
            already_processed.add('ignoreGasForExtrapolation')
            try:
                self.ignoreGasForExtrapolation = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('co2MixRate', node)
        if value is not None and 'co2MixRate' not in already_processed:
            already_processed.add('co2MixRate')
            try:
                self.co2MixRate = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (co2MixRate): %s' % exp)
        value = find_attr_value_('scaleOtherGases', node)
        if value is not None and 'scaleOtherGases' not in already_processed:
            already_processed.add('scaleOtherGases')
            try:
                self.scaleOtherGases = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ignoredGas':
            obj_ = create_ignoredGas.factory()
            obj_.build(child_)
            self.set_ignoredGas(obj_)
            obj_.original_tagname_ = 'ignoredGas'
        elif nodeName_ == 'OtherGasesScale':
            obj_ = create_OtherGasesScale.factory()
            obj_.build(child_)
            self.set_OtherGasesScale(obj_)
            obj_.original_tagname_ = 'OtherGasesScale'
        elif nodeName_ == 'WaterAmount':
            obj_ = create_WaterAmount.factory()
            obj_.build(child_)
            self.set_WaterAmount(obj_)
            obj_.original_tagname_ = 'WaterAmount'
        elif nodeName_ == 'tempParameters':
            obj_ = create_tempParameters.factory()
            obj_.build(child_)
            self.set_tempParameters(obj_)
            obj_.original_tagname_ = 'tempParameters'
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_AtmosphericOpticalPropertyModel


class create_ignoredGas(GeneratedsSuper):
    """Ignored gas Ignored gas CO2 CO2 CO CO NO NO HNO3 HNO3 H2O H2O SO2
    SO2 CH4 CH4 NH3 NH3 N2O N2O N2 N2 O3 O3 O2 O2 NO2 NO2"""
    member_data_items_ = [
        MemberSpec_('CO2', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('CO', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('NO', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('HNO3', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('H2O', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('SO2', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('CH4', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('NH3', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('N2O', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('N2', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('O3', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('O2', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('NO2', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('fillH2O', '_fillH2O', 0, 0, {u'maxOccurs': u'1', u'type': u'_fillH2O', u'name': u'fillH2O', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, CO2=0, CO=0, NO=0, HNO3=0, H2O=0, SO2=0, CH4=0, NH3=0, N2O=0, N2=0, O3=0, O2=0, NO2=0, fillH2O=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_ignoredGas')
        self.attrib = ['CO2', 'CO', 'NO', 'HNO3', 'H2O', 'SO2', 'CH4', 'NH3', 'N2O', 'N2', 'O3', 'O2', 'NO2']
        self.children = ['fillH2O']
        self.parent = None
        self._CO2 = _cast(int, CO2)
        self._CO = _cast(int, CO)
        self._NO = _cast(int, NO)
        self._HNO3 = _cast(int, HNO3)
        self._H2O = _cast(int, H2O)
        self._SO2 = _cast(int, SO2)
        self._CH4 = _cast(int, CH4)
        self._NH3 = _cast(int, NH3)
        self._N2O = _cast(int, N2O)
        self._N2 = _cast(int, N2)
        self._O3 = _cast(int, O3)
        self._O2 = _cast(int, O2)
        self._NO2 = _cast(int, NO2)
        self._fillH2O = fillH2O
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ignoredGas)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ignoredGas.subclass:
            return create_ignoredGas.subclass(*args_, **kwargs_)
        else:
            return create_ignoredGas(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fillH2O(self): return self._fillH2O
    def set_fillH2O(self, value):
        if value is not None:
            checkclass(value, create_fillH2O)
            value.parent = self
        self._fillH2O = value
    fillH2O = property(get_fillH2O, set_fillH2O)
    def get_CO2(self): return self._CO2
    def set_CO2(self, value):
        self._CO2 = value
        update_node(self,self.troot,'atmosphere')
    CO2 = property(get_CO2, set_CO2)
    def get_CO(self): return self._CO
    def set_CO(self, value):
        self._CO = value
        update_node(self,self.troot,'atmosphere')
    CO = property(get_CO, set_CO)
    def get_NO(self): return self._NO
    def set_NO(self, value):
        self._NO = value
        update_node(self,self.troot,'atmosphere')
    NO = property(get_NO, set_NO)
    def get_HNO3(self): return self._HNO3
    def set_HNO3(self, value):
        self._HNO3 = value
        update_node(self,self.troot,'atmosphere')
    HNO3 = property(get_HNO3, set_HNO3)
    def get_H2O(self): return self._H2O
    def set_H2O(self, value):
        self._H2O = value
        update_node(self,self.troot,'atmosphere')
    H2O = property(get_H2O, set_H2O)
    def get_SO2(self): return self._SO2
    def set_SO2(self, value):
        self._SO2 = value
        update_node(self,self.troot,'atmosphere')
    SO2 = property(get_SO2, set_SO2)
    def get_CH4(self): return self._CH4
    def set_CH4(self, value):
        self._CH4 = value
        update_node(self,self.troot,'atmosphere')
    CH4 = property(get_CH4, set_CH4)
    def get_NH3(self): return self._NH3
    def set_NH3(self, value):
        self._NH3 = value
        update_node(self,self.troot,'atmosphere')
    NH3 = property(get_NH3, set_NH3)
    def get_N2O(self): return self._N2O
    def set_N2O(self, value):
        self._N2O = value
        update_node(self,self.troot,'atmosphere')
    N2O = property(get_N2O, set_N2O)
    def get_N2(self): return self._N2
    def set_N2(self, value):
        self._N2 = value
        update_node(self,self.troot,'atmosphere')
    N2 = property(get_N2, set_N2)
    def get_O3(self): return self._O3
    def set_O3(self, value):
        self._O3 = value
        update_node(self,self.troot,'atmosphere')
    O3 = property(get_O3, set_O3)
    def get_O2(self): return self._O2
    def set_O2(self, value):
        self._O2 = value
        update_node(self,self.troot,'atmosphere')
    O2 = property(get_O2, set_O2)
    def get_NO2(self): return self._NO2
    def set_NO2(self, value):
        self._NO2 = value
        update_node(self,self.troot,'atmosphere')
    NO2 = property(get_NO2, set_NO2)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.fillH2O is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ignoredGas', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ignoredGas')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ignoredGas')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ignoredGas', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ignoredGas'):
        if self.CO2 is not None and 'CO2' not in already_processed:
            already_processed.add('CO2')
            outfile.write(' CO2="%s"' % self.gds_format_integer(self.CO2, input_name='CO2'))
        if self.CO is not None and 'CO' not in already_processed:
            already_processed.add('CO')
            outfile.write(' CO="%s"' % self.gds_format_integer(self.CO, input_name='CO'))
        if self.NO is not None and 'NO' not in already_processed:
            already_processed.add('NO')
            outfile.write(' NO="%s"' % self.gds_format_integer(self.NO, input_name='NO'))
        if self.HNO3 is not None and 'HNO3' not in already_processed:
            already_processed.add('HNO3')
            outfile.write(' HNO3="%s"' % self.gds_format_integer(self.HNO3, input_name='HNO3'))
        if self.H2O is not None and 'H2O' not in already_processed:
            already_processed.add('H2O')
            outfile.write(' H2O="%s"' % self.gds_format_integer(self.H2O, input_name='H2O'))
        if self.SO2 is not None and 'SO2' not in already_processed:
            already_processed.add('SO2')
            outfile.write(' SO2="%s"' % self.gds_format_integer(self.SO2, input_name='SO2'))
        if self.CH4 is not None and 'CH4' not in already_processed:
            already_processed.add('CH4')
            outfile.write(' CH4="%s"' % self.gds_format_integer(self.CH4, input_name='CH4'))
        if self.NH3 is not None and 'NH3' not in already_processed:
            already_processed.add('NH3')
            outfile.write(' NH3="%s"' % self.gds_format_integer(self.NH3, input_name='NH3'))
        if self.N2O is not None and 'N2O' not in already_processed:
            already_processed.add('N2O')
            outfile.write(' N2O="%s"' % self.gds_format_integer(self.N2O, input_name='N2O'))
        if self.N2 is not None and 'N2' not in already_processed:
            already_processed.add('N2')
            outfile.write(' N2="%s"' % self.gds_format_integer(self.N2, input_name='N2'))
        if self.O3 is not None and 'O3' not in already_processed:
            already_processed.add('O3')
            outfile.write(' O3="%s"' % self.gds_format_integer(self.O3, input_name='O3'))
        if self.O2 is not None and 'O2' not in already_processed:
            already_processed.add('O2')
            outfile.write(' O2="%s"' % self.gds_format_integer(self.O2, input_name='O2'))
        if self.NO2 is not None and 'NO2' not in already_processed:
            already_processed.add('NO2')
            outfile.write(' NO2="%s"' % self.gds_format_integer(self.NO2, input_name='NO2'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ignoredGas', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fillH2O is not None:
            self.fillH2O.export(outfile, level, namespaceprefix_, name_='fillH2O', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_ignoredGas', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.CO2 is not None:
            element.set('CO2', self.gds_format_integer(self.CO2))
        if self.CO is not None:
            element.set('CO', self.gds_format_integer(self.CO))
        if self.NO is not None:
            element.set('NO', self.gds_format_integer(self.NO))
        if self.HNO3 is not None:
            element.set('HNO3', self.gds_format_integer(self.HNO3))
        if self.H2O is not None:
            element.set('H2O', self.gds_format_integer(self.H2O))
        if self.SO2 is not None:
            element.set('SO2', self.gds_format_integer(self.SO2))
        if self.CH4 is not None:
            element.set('CH4', self.gds_format_integer(self.CH4))
        if self.NH3 is not None:
            element.set('NH3', self.gds_format_integer(self.NH3))
        if self.N2O is not None:
            element.set('N2O', self.gds_format_integer(self.N2O))
        if self.N2 is not None:
            element.set('N2', self.gds_format_integer(self.N2))
        if self.O3 is not None:
            element.set('O3', self.gds_format_integer(self.O3))
        if self.O2 is not None:
            element.set('O2', self.gds_format_integer(self.O2))
        if self.NO2 is not None:
            element.set('NO2', self.gds_format_integer(self.NO2))
        if self.fillH2O is not None:
            fillH2O_ = self.fillH2O
            fillH2O_.to_etree(element, name_='fillH2O', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ignoredGas'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.CO2 is not None and 'CO2' not in already_processed:
            already_processed.add('CO2')
            showIndent(outfile, level)
            outfile.write('CO2=%d,\n' % (self.CO2,))
        if self.CO is not None and 'CO' not in already_processed:
            already_processed.add('CO')
            showIndent(outfile, level)
            outfile.write('CO=%d,\n' % (self.CO,))
        if self.NO is not None and 'NO' not in already_processed:
            already_processed.add('NO')
            showIndent(outfile, level)
            outfile.write('NO=%d,\n' % (self.NO,))
        if self.HNO3 is not None and 'HNO3' not in already_processed:
            already_processed.add('HNO3')
            showIndent(outfile, level)
            outfile.write('HNO3=%d,\n' % (self.HNO3,))
        if self.H2O is not None and 'H2O' not in already_processed:
            already_processed.add('H2O')
            showIndent(outfile, level)
            outfile.write('H2O=%d,\n' % (self.H2O,))
        if self.SO2 is not None and 'SO2' not in already_processed:
            already_processed.add('SO2')
            showIndent(outfile, level)
            outfile.write('SO2=%d,\n' % (self.SO2,))
        if self.CH4 is not None and 'CH4' not in already_processed:
            already_processed.add('CH4')
            showIndent(outfile, level)
            outfile.write('CH4=%d,\n' % (self.CH4,))
        if self.NH3 is not None and 'NH3' not in already_processed:
            already_processed.add('NH3')
            showIndent(outfile, level)
            outfile.write('NH3=%d,\n' % (self.NH3,))
        if self.N2O is not None and 'N2O' not in already_processed:
            already_processed.add('N2O')
            showIndent(outfile, level)
            outfile.write('N2O=%d,\n' % (self.N2O,))
        if self.N2 is not None and 'N2' not in already_processed:
            already_processed.add('N2')
            showIndent(outfile, level)
            outfile.write('N2=%d,\n' % (self.N2,))
        if self.O3 is not None and 'O3' not in already_processed:
            already_processed.add('O3')
            showIndent(outfile, level)
            outfile.write('O3=%d,\n' % (self.O3,))
        if self.O2 is not None and 'O2' not in already_processed:
            already_processed.add('O2')
            showIndent(outfile, level)
            outfile.write('O2=%d,\n' % (self.O2,))
        if self.NO2 is not None and 'NO2' not in already_processed:
            already_processed.add('NO2')
            showIndent(outfile, level)
            outfile.write('NO2=%d,\n' % (self.NO2,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.fillH2O is not None:
            showIndent(outfile, level)
            outfile.write('fillH2O=model_._fillH2O(\n')
            self.fillH2O.exportLiteral(outfile, level, name_='fillH2O')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('CO2', node)
        if value is not None and 'CO2' not in already_processed:
            already_processed.add('CO2')
            try:
                self.CO2 = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('CO', node)
        if value is not None and 'CO' not in already_processed:
            already_processed.add('CO')
            try:
                self.CO = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('NO', node)
        if value is not None and 'NO' not in already_processed:
            already_processed.add('NO')
            try:
                self.NO = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('HNO3', node)
        if value is not None and 'HNO3' not in already_processed:
            already_processed.add('HNO3')
            try:
                self.HNO3 = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('H2O', node)
        if value is not None and 'H2O' not in already_processed:
            already_processed.add('H2O')
            try:
                self.H2O = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('SO2', node)
        if value is not None and 'SO2' not in already_processed:
            already_processed.add('SO2')
            try:
                self.SO2 = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('CH4', node)
        if value is not None and 'CH4' not in already_processed:
            already_processed.add('CH4')
            try:
                self.CH4 = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('NH3', node)
        if value is not None and 'NH3' not in already_processed:
            already_processed.add('NH3')
            try:
                self.NH3 = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('N2O', node)
        if value is not None and 'N2O' not in already_processed:
            already_processed.add('N2O')
            try:
                self.N2O = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('N2', node)
        if value is not None and 'N2' not in already_processed:
            already_processed.add('N2')
            try:
                self.N2 = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('O3', node)
        if value is not None and 'O3' not in already_processed:
            already_processed.add('O3')
            try:
                self.O3 = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('O2', node)
        if value is not None and 'O2' not in already_processed:
            already_processed.add('O2')
            try:
                self.O2 = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('NO2', node)
        if value is not None and 'NO2' not in already_processed:
            already_processed.add('NO2')
            try:
                self.NO2 = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fillH2O':
            obj_ = create_fillH2O.factory()
            obj_.build(child_)
            self.set_fillH2O(obj_)
            obj_.original_tagname_ = 'fillH2O'
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_ignoredGas


class create_fillH2O(GeneratedsSuper):
    """Fill in defined water vapor profile Fill in defined water vapor
    profile Define water vapor parameters at a point Define water
    vapor parameters at a point"""
    member_data_items_ = [
        MemberSpec_('ifFillH2O', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('h2oDef', '_h2oDef', 0, 0, {u'maxOccurs': u'1', u'type': u'_h2oDef', u'name': u'h2oDef', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ifFillH2O=0, h2oDef=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_fillH2O')
        self.attrib = ['ifFillH2O']
        self.children = ['h2oDef']
        self.parent = None
        self._ifFillH2O = _cast(int, ifFillH2O)
        self._h2oDef = h2oDef
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_fillH2O)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_fillH2O.subclass:
            return create_fillH2O.subclass(*args_, **kwargs_)
        else:
            return create_fillH2O(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_h2oDef(self): return self._h2oDef
    def set_h2oDef(self, value):
        if value is not None:
            checkclass(value, create_h2oDef)
            value.parent = self
        self._h2oDef = value
    h2oDef = property(get_h2oDef, set_h2oDef)
    def get_ifFillH2O(self): return self._ifFillH2O
    def set_ifFillH2O(self, value):
        self._ifFillH2O = value
        update_node(self,self.troot,'atmosphere')
    ifFillH2O = property(get_ifFillH2O, set_ifFillH2O)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.h2oDef is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_fillH2O', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_fillH2O')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_fillH2O')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_fillH2O', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_fillH2O'):
        if self.ifFillH2O is not None and 'ifFillH2O' not in already_processed:
            already_processed.add('ifFillH2O')
            outfile.write(' ifFillH2O="%s"' % self.gds_format_integer(self.ifFillH2O, input_name='ifFillH2O'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_fillH2O', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.h2oDef is not None:
            self.h2oDef.export(outfile, level, namespaceprefix_, name_='h2oDef', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_fillH2O', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ifFillH2O is not None:
            element.set('ifFillH2O', self.gds_format_integer(self.ifFillH2O))
        if self.h2oDef is not None:
            h2oDef_ = self.h2oDef
            h2oDef_.to_etree(element, name_='h2oDef', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_fillH2O'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ifFillH2O is not None and 'ifFillH2O' not in already_processed:
            already_processed.add('ifFillH2O')
            showIndent(outfile, level)
            outfile.write('ifFillH2O=%d,\n' % (self.ifFillH2O,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.h2oDef is not None:
            showIndent(outfile, level)
            outfile.write('h2oDef=model_._h2oDef(\n')
            self.h2oDef.exportLiteral(outfile, level, name_='h2oDef')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ifFillH2O', node)
        if value is not None and 'ifFillH2O' not in already_processed:
            already_processed.add('ifFillH2O')
            try:
                self.ifFillH2O = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'h2oDef':
            obj_ = create_h2oDef.factory()
            obj_.build(child_)
            self.set_h2oDef(obj_)
            obj_.original_tagname_ = 'h2oDef'
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_fillH2O


class create_h2oDef(GeneratedsSuper):
    """Parameters Parameters Pressure Pressure Altitude Altitude Relative
    humidity Relative humidity Distance to calculate reference
    cross-section Distance to calculate reference cross-section
    Temperature Temperature"""
    member_data_items_ = [
        MemberSpec_('pressure', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('altitude', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('rh', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('dist', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('temp', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, pressure=1013, altitude=0, rh=40, dist=160, temp=273.15):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_h2oDef')
        self.attrib = ['pressure', 'altitude', 'rh', 'dist', 'temp']
        self.children = []
        self.parent = None
        self._pressure = _cast(float, pressure)
        self._altitude = _cast(float, altitude)
        self._rh = _cast(float, rh)
        self._dist = _cast(float, dist)
        self._temp = _cast(float, temp)
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_h2oDef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_h2oDef.subclass:
            return create_h2oDef.subclass(*args_, **kwargs_)
        else:
            return create_h2oDef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pressure(self): return self._pressure
    def set_pressure(self, value):
        self._pressure = value
        update_node(self,self.troot,'atmosphere')
    pressure = property(get_pressure, set_pressure)
    def get_altitude(self): return self._altitude
    def set_altitude(self, value):
        self._altitude = value
        update_node(self,self.troot,'atmosphere')
    altitude = property(get_altitude, set_altitude)
    def get_rh(self): return self._rh
    def set_rh(self, value):
        self._rh = value
        update_node(self,self.troot,'atmosphere')
    rh = property(get_rh, set_rh)
    def get_dist(self): return self._dist
    def set_dist(self, value):
        self._dist = value
        update_node(self,self.troot,'atmosphere')
    dist = property(get_dist, set_dist)
    def get_temp(self): return self._temp
    def set_temp(self, value):
        self._temp = value
        update_node(self,self.troot,'atmosphere')
    temp = property(get_temp, set_temp)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_h2oDef', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_h2oDef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_h2oDef')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_h2oDef', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_h2oDef'):
        if self.pressure is not None and 'pressure' not in already_processed:
            already_processed.add('pressure')
            outfile.write(' pressure="%s"' % self.gds_format_double(self.pressure, input_name='pressure'))
        if self.altitude is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            outfile.write(' altitude="%s"' % self.gds_format_double(self.altitude, input_name='altitude'))
        if self.rh is not None and 'rh' not in already_processed:
            already_processed.add('rh')
            outfile.write(' rh="%s"' % self.gds_format_double(self.rh, input_name='rh'))
        if self.dist is not None and 'dist' not in already_processed:
            already_processed.add('dist')
            outfile.write(' dist="%s"' % self.gds_format_double(self.dist, input_name='dist'))
        if self.temp is not None and 'temp' not in already_processed:
            already_processed.add('temp')
            outfile.write(' temp="%s"' % self.gds_format_double(self.temp, input_name='temp'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_h2oDef', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_h2oDef', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.pressure is not None:
            element.set('pressure', self.gds_format_double(self.pressure))
        if self.altitude is not None:
            element.set('altitude', self.gds_format_double(self.altitude))
        if self.rh is not None:
            element.set('rh', self.gds_format_double(self.rh))
        if self.dist is not None:
            element.set('dist', self.gds_format_double(self.dist))
        if self.temp is not None:
            element.set('temp', self.gds_format_double(self.temp))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_h2oDef'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.pressure is not None and 'pressure' not in already_processed:
            already_processed.add('pressure')
            showIndent(outfile, level)
            outfile.write('pressure=%e,\n' % (self.pressure,))
        if self.altitude is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            showIndent(outfile, level)
            outfile.write('altitude=%e,\n' % (self.altitude,))
        if self.rh is not None and 'rh' not in already_processed:
            already_processed.add('rh')
            showIndent(outfile, level)
            outfile.write('rh=%e,\n' % (self.rh,))
        if self.dist is not None and 'dist' not in already_processed:
            already_processed.add('dist')
            showIndent(outfile, level)
            outfile.write('dist=%e,\n' % (self.dist,))
        if self.temp is not None and 'temp' not in already_processed:
            already_processed.add('temp')
            showIndent(outfile, level)
            outfile.write('temp=%e,\n' % (self.temp,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pressure', node)
        if value is not None and 'pressure' not in already_processed:
            already_processed.add('pressure')
            try:
                self.pressure = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (pressure): %s' % exp)
        value = find_attr_value_('altitude', node)
        if value is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            try:
                self.altitude = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (altitude): %s' % exp)
        value = find_attr_value_('rh', node)
        if value is not None and 'rh' not in already_processed:
            already_processed.add('rh')
            try:
                self.rh = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (rh): %s' % exp)
        value = find_attr_value_('dist', node)
        if value is not None and 'dist' not in already_processed:
            already_processed.add('dist')
            try:
                self.dist = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (dist): %s' % exp)
        value = find_attr_value_('temp', node)
        if value is not None and 'temp' not in already_processed:
            already_processed.add('temp')
            try:
                self.temp = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (temp): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_h2oDef


class create_OtherGasesScale(GeneratedsSuper):
    """Multiplicative factors for other gases' amounts Multiplicative
    factors for other gases' amounts N2 N2 CH4 CH4 CO CO NO NO N2O
    N2O O3 O3 SO2 SO2 Scattering Gases Scattering Gases HNO3 HNO3
    NO2 NO2 Others Others NH3 NH3 O2 O2"""
    member_data_items_ = [
        MemberSpec_('n2MulFactor', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('ch4MulFactor', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('coMulFactor', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('noMulFactor', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('n2oMulFactor', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('o3MulFactor', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('so2MulFactor', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('scatMulFactor', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('hno3MulFactor', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('no2MulFactor', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('othersMulFactor', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('nh3MulFactor', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('o2MulFactor', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, n2MulFactor=1, ch4MulFactor=1, coMulFactor=1, noMulFactor=1, n2oMulFactor=1, o3MulFactor=1, so2MulFactor=1, scatMulFactor=1, hno3MulFactor=1, no2MulFactor=1, othersMulFactor=1, nh3MulFactor=1, o2MulFactor=1):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_OtherGasesScale')
        self.attrib = ['n2MulFactor', 'ch4MulFactor', 'coMulFactor', 'noMulFactor', 'n2oMulFactor', 'o3MulFactor', 'so2MulFactor', 'scatMulFactor', 'hno3MulFactor', 'no2MulFactor', 'othersMulFactor', 'nh3MulFactor', 'o2MulFactor']
        self.children = []
        self.parent = None
        self._n2MulFactor = _cast(float, n2MulFactor)
        self._ch4MulFactor = _cast(float, ch4MulFactor)
        self._coMulFactor = _cast(float, coMulFactor)
        self._noMulFactor = _cast(float, noMulFactor)
        self._n2oMulFactor = _cast(float, n2oMulFactor)
        self._o3MulFactor = _cast(float, o3MulFactor)
        self._so2MulFactor = _cast(float, so2MulFactor)
        self._scatMulFactor = _cast(float, scatMulFactor)
        self._hno3MulFactor = _cast(float, hno3MulFactor)
        self._no2MulFactor = _cast(float, no2MulFactor)
        self._othersMulFactor = _cast(float, othersMulFactor)
        self._nh3MulFactor = _cast(float, nh3MulFactor)
        self._o2MulFactor = _cast(float, o2MulFactor)
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_OtherGasesScale)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_OtherGasesScale.subclass:
            return create_OtherGasesScale.subclass(*args_, **kwargs_)
        else:
            return create_OtherGasesScale(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_n2MulFactor(self): return self._n2MulFactor
    def set_n2MulFactor(self, value):
        self._n2MulFactor = value
        update_node(self,self.troot,'atmosphere')
    n2MulFactor = property(get_n2MulFactor, set_n2MulFactor)
    def get_ch4MulFactor(self): return self._ch4MulFactor
    def set_ch4MulFactor(self, value):
        self._ch4MulFactor = value
        update_node(self,self.troot,'atmosphere')
    ch4MulFactor = property(get_ch4MulFactor, set_ch4MulFactor)
    def get_coMulFactor(self): return self._coMulFactor
    def set_coMulFactor(self, value):
        self._coMulFactor = value
        update_node(self,self.troot,'atmosphere')
    coMulFactor = property(get_coMulFactor, set_coMulFactor)
    def get_noMulFactor(self): return self._noMulFactor
    def set_noMulFactor(self, value):
        self._noMulFactor = value
        update_node(self,self.troot,'atmosphere')
    noMulFactor = property(get_noMulFactor, set_noMulFactor)
    def get_n2oMulFactor(self): return self._n2oMulFactor
    def set_n2oMulFactor(self, value):
        self._n2oMulFactor = value
        update_node(self,self.troot,'atmosphere')
    n2oMulFactor = property(get_n2oMulFactor, set_n2oMulFactor)
    def get_o3MulFactor(self): return self._o3MulFactor
    def set_o3MulFactor(self, value):
        self._o3MulFactor = value
        update_node(self,self.troot,'atmosphere')
    o3MulFactor = property(get_o3MulFactor, set_o3MulFactor)
    def get_so2MulFactor(self): return self._so2MulFactor
    def set_so2MulFactor(self, value):
        self._so2MulFactor = value
        update_node(self,self.troot,'atmosphere')
    so2MulFactor = property(get_so2MulFactor, set_so2MulFactor)
    def get_scatMulFactor(self): return self._scatMulFactor
    def set_scatMulFactor(self, value):
        self._scatMulFactor = value
        update_node(self,self.troot,'atmosphere')
    scatMulFactor = property(get_scatMulFactor, set_scatMulFactor)
    def get_hno3MulFactor(self): return self._hno3MulFactor
    def set_hno3MulFactor(self, value):
        self._hno3MulFactor = value
        update_node(self,self.troot,'atmosphere')
    hno3MulFactor = property(get_hno3MulFactor, set_hno3MulFactor)
    def get_no2MulFactor(self): return self._no2MulFactor
    def set_no2MulFactor(self, value):
        self._no2MulFactor = value
        update_node(self,self.troot,'atmosphere')
    no2MulFactor = property(get_no2MulFactor, set_no2MulFactor)
    def get_othersMulFactor(self): return self._othersMulFactor
    def set_othersMulFactor(self, value):
        self._othersMulFactor = value
        update_node(self,self.troot,'atmosphere')
    othersMulFactor = property(get_othersMulFactor, set_othersMulFactor)
    def get_nh3MulFactor(self): return self._nh3MulFactor
    def set_nh3MulFactor(self, value):
        self._nh3MulFactor = value
        update_node(self,self.troot,'atmosphere')
    nh3MulFactor = property(get_nh3MulFactor, set_nh3MulFactor)
    def get_o2MulFactor(self): return self._o2MulFactor
    def set_o2MulFactor(self, value):
        self._o2MulFactor = value
        update_node(self,self.troot,'atmosphere')
    o2MulFactor = property(get_o2MulFactor, set_o2MulFactor)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_OtherGasesScale', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_OtherGasesScale')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_OtherGasesScale')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_OtherGasesScale', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_OtherGasesScale'):
        if self.n2MulFactor is not None and 'n2MulFactor' not in already_processed:
            already_processed.add('n2MulFactor')
            outfile.write(' n2MulFactor="%s"' % self.gds_format_double(self.n2MulFactor, input_name='n2MulFactor'))
        if self.ch4MulFactor is not None and 'ch4MulFactor' not in already_processed:
            already_processed.add('ch4MulFactor')
            outfile.write(' ch4MulFactor="%s"' % self.gds_format_double(self.ch4MulFactor, input_name='ch4MulFactor'))
        if self.coMulFactor is not None and 'coMulFactor' not in already_processed:
            already_processed.add('coMulFactor')
            outfile.write(' coMulFactor="%s"' % self.gds_format_double(self.coMulFactor, input_name='coMulFactor'))
        if self.noMulFactor is not None and 'noMulFactor' not in already_processed:
            already_processed.add('noMulFactor')
            outfile.write(' noMulFactor="%s"' % self.gds_format_double(self.noMulFactor, input_name='noMulFactor'))
        if self.n2oMulFactor is not None and 'n2oMulFactor' not in already_processed:
            already_processed.add('n2oMulFactor')
            outfile.write(' n2oMulFactor="%s"' % self.gds_format_double(self.n2oMulFactor, input_name='n2oMulFactor'))
        if self.o3MulFactor is not None and 'o3MulFactor' not in already_processed:
            already_processed.add('o3MulFactor')
            outfile.write(' o3MulFactor="%s"' % self.gds_format_double(self.o3MulFactor, input_name='o3MulFactor'))
        if self.so2MulFactor is not None and 'so2MulFactor' not in already_processed:
            already_processed.add('so2MulFactor')
            outfile.write(' so2MulFactor="%s"' % self.gds_format_double(self.so2MulFactor, input_name='so2MulFactor'))
        if self.scatMulFactor is not None and 'scatMulFactor' not in already_processed:
            already_processed.add('scatMulFactor')
            outfile.write(' scatMulFactor="%s"' % self.gds_format_double(self.scatMulFactor, input_name='scatMulFactor'))
        if self.hno3MulFactor is not None and 'hno3MulFactor' not in already_processed:
            already_processed.add('hno3MulFactor')
            outfile.write(' hno3MulFactor="%s"' % self.gds_format_double(self.hno3MulFactor, input_name='hno3MulFactor'))
        if self.no2MulFactor is not None and 'no2MulFactor' not in already_processed:
            already_processed.add('no2MulFactor')
            outfile.write(' no2MulFactor="%s"' % self.gds_format_double(self.no2MulFactor, input_name='no2MulFactor'))
        if self.othersMulFactor is not None and 'othersMulFactor' not in already_processed:
            already_processed.add('othersMulFactor')
            outfile.write(' othersMulFactor="%s"' % self.gds_format_double(self.othersMulFactor, input_name='othersMulFactor'))
        if self.nh3MulFactor is not None and 'nh3MulFactor' not in already_processed:
            already_processed.add('nh3MulFactor')
            outfile.write(' nh3MulFactor="%s"' % self.gds_format_double(self.nh3MulFactor, input_name='nh3MulFactor'))
        if self.o2MulFactor is not None and 'o2MulFactor' not in already_processed:
            already_processed.add('o2MulFactor')
            outfile.write(' o2MulFactor="%s"' % self.gds_format_double(self.o2MulFactor, input_name='o2MulFactor'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_OtherGasesScale', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_OtherGasesScale', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.n2MulFactor is not None:
            element.set('n2MulFactor', self.gds_format_double(self.n2MulFactor))
        if self.ch4MulFactor is not None:
            element.set('ch4MulFactor', self.gds_format_double(self.ch4MulFactor))
        if self.coMulFactor is not None:
            element.set('coMulFactor', self.gds_format_double(self.coMulFactor))
        if self.noMulFactor is not None:
            element.set('noMulFactor', self.gds_format_double(self.noMulFactor))
        if self.n2oMulFactor is not None:
            element.set('n2oMulFactor', self.gds_format_double(self.n2oMulFactor))
        if self.o3MulFactor is not None:
            element.set('o3MulFactor', self.gds_format_double(self.o3MulFactor))
        if self.so2MulFactor is not None:
            element.set('so2MulFactor', self.gds_format_double(self.so2MulFactor))
        if self.scatMulFactor is not None:
            element.set('scatMulFactor', self.gds_format_double(self.scatMulFactor))
        if self.hno3MulFactor is not None:
            element.set('hno3MulFactor', self.gds_format_double(self.hno3MulFactor))
        if self.no2MulFactor is not None:
            element.set('no2MulFactor', self.gds_format_double(self.no2MulFactor))
        if self.othersMulFactor is not None:
            element.set('othersMulFactor', self.gds_format_double(self.othersMulFactor))
        if self.nh3MulFactor is not None:
            element.set('nh3MulFactor', self.gds_format_double(self.nh3MulFactor))
        if self.o2MulFactor is not None:
            element.set('o2MulFactor', self.gds_format_double(self.o2MulFactor))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_OtherGasesScale'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.n2MulFactor is not None and 'n2MulFactor' not in already_processed:
            already_processed.add('n2MulFactor')
            showIndent(outfile, level)
            outfile.write('n2MulFactor=%e,\n' % (self.n2MulFactor,))
        if self.ch4MulFactor is not None and 'ch4MulFactor' not in already_processed:
            already_processed.add('ch4MulFactor')
            showIndent(outfile, level)
            outfile.write('ch4MulFactor=%e,\n' % (self.ch4MulFactor,))
        if self.coMulFactor is not None and 'coMulFactor' not in already_processed:
            already_processed.add('coMulFactor')
            showIndent(outfile, level)
            outfile.write('coMulFactor=%e,\n' % (self.coMulFactor,))
        if self.noMulFactor is not None and 'noMulFactor' not in already_processed:
            already_processed.add('noMulFactor')
            showIndent(outfile, level)
            outfile.write('noMulFactor=%e,\n' % (self.noMulFactor,))
        if self.n2oMulFactor is not None and 'n2oMulFactor' not in already_processed:
            already_processed.add('n2oMulFactor')
            showIndent(outfile, level)
            outfile.write('n2oMulFactor=%e,\n' % (self.n2oMulFactor,))
        if self.o3MulFactor is not None and 'o3MulFactor' not in already_processed:
            already_processed.add('o3MulFactor')
            showIndent(outfile, level)
            outfile.write('o3MulFactor=%e,\n' % (self.o3MulFactor,))
        if self.so2MulFactor is not None and 'so2MulFactor' not in already_processed:
            already_processed.add('so2MulFactor')
            showIndent(outfile, level)
            outfile.write('so2MulFactor=%e,\n' % (self.so2MulFactor,))
        if self.scatMulFactor is not None and 'scatMulFactor' not in already_processed:
            already_processed.add('scatMulFactor')
            showIndent(outfile, level)
            outfile.write('scatMulFactor=%e,\n' % (self.scatMulFactor,))
        if self.hno3MulFactor is not None and 'hno3MulFactor' not in already_processed:
            already_processed.add('hno3MulFactor')
            showIndent(outfile, level)
            outfile.write('hno3MulFactor=%e,\n' % (self.hno3MulFactor,))
        if self.no2MulFactor is not None and 'no2MulFactor' not in already_processed:
            already_processed.add('no2MulFactor')
            showIndent(outfile, level)
            outfile.write('no2MulFactor=%e,\n' % (self.no2MulFactor,))
        if self.othersMulFactor is not None and 'othersMulFactor' not in already_processed:
            already_processed.add('othersMulFactor')
            showIndent(outfile, level)
            outfile.write('othersMulFactor=%e,\n' % (self.othersMulFactor,))
        if self.nh3MulFactor is not None and 'nh3MulFactor' not in already_processed:
            already_processed.add('nh3MulFactor')
            showIndent(outfile, level)
            outfile.write('nh3MulFactor=%e,\n' % (self.nh3MulFactor,))
        if self.o2MulFactor is not None and 'o2MulFactor' not in already_processed:
            already_processed.add('o2MulFactor')
            showIndent(outfile, level)
            outfile.write('o2MulFactor=%e,\n' % (self.o2MulFactor,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('n2MulFactor', node)
        if value is not None and 'n2MulFactor' not in already_processed:
            already_processed.add('n2MulFactor')
            try:
                self.n2MulFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (n2MulFactor): %s' % exp)
        value = find_attr_value_('ch4MulFactor', node)
        if value is not None and 'ch4MulFactor' not in already_processed:
            already_processed.add('ch4MulFactor')
            try:
                self.ch4MulFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (ch4MulFactor): %s' % exp)
        value = find_attr_value_('coMulFactor', node)
        if value is not None and 'coMulFactor' not in already_processed:
            already_processed.add('coMulFactor')
            try:
                self.coMulFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (coMulFactor): %s' % exp)
        value = find_attr_value_('noMulFactor', node)
        if value is not None and 'noMulFactor' not in already_processed:
            already_processed.add('noMulFactor')
            try:
                self.noMulFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (noMulFactor): %s' % exp)
        value = find_attr_value_('n2oMulFactor', node)
        if value is not None and 'n2oMulFactor' not in already_processed:
            already_processed.add('n2oMulFactor')
            try:
                self.n2oMulFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (n2oMulFactor): %s' % exp)
        value = find_attr_value_('o3MulFactor', node)
        if value is not None and 'o3MulFactor' not in already_processed:
            already_processed.add('o3MulFactor')
            try:
                self.o3MulFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (o3MulFactor): %s' % exp)
        value = find_attr_value_('so2MulFactor', node)
        if value is not None and 'so2MulFactor' not in already_processed:
            already_processed.add('so2MulFactor')
            try:
                self.so2MulFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (so2MulFactor): %s' % exp)
        value = find_attr_value_('scatMulFactor', node)
        if value is not None and 'scatMulFactor' not in already_processed:
            already_processed.add('scatMulFactor')
            try:
                self.scatMulFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (scatMulFactor): %s' % exp)
        value = find_attr_value_('hno3MulFactor', node)
        if value is not None and 'hno3MulFactor' not in already_processed:
            already_processed.add('hno3MulFactor')
            try:
                self.hno3MulFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (hno3MulFactor): %s' % exp)
        value = find_attr_value_('no2MulFactor', node)
        if value is not None and 'no2MulFactor' not in already_processed:
            already_processed.add('no2MulFactor')
            try:
                self.no2MulFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (no2MulFactor): %s' % exp)
        value = find_attr_value_('othersMulFactor', node)
        if value is not None and 'othersMulFactor' not in already_processed:
            already_processed.add('othersMulFactor')
            try:
                self.othersMulFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (othersMulFactor): %s' % exp)
        value = find_attr_value_('nh3MulFactor', node)
        if value is not None and 'nh3MulFactor' not in already_processed:
            already_processed.add('nh3MulFactor')
            try:
                self.nh3MulFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (nh3MulFactor): %s' % exp)
        value = find_attr_value_('o2MulFactor', node)
        if value is not None and 'o2MulFactor' not in already_processed:
            already_processed.add('o2MulFactor')
            try:
                self.o2MulFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (o2MulFactor): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_OtherGasesScale


class create_WaterAmount(GeneratedsSuper):
    """Definition Definition"""
    member_data_items_ = [
        MemberSpec_('defWaterAmount', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('M_factor', '_M_factor', 0, 0, {u'maxOccurs': u'1', u'type': u'_M_factor', u'name': u'M_factor', u'minOccurs': u'1'}, None),
        MemberSpec_('Amount_g_per_cm2', '_Amount_g_per_cm2', 0, 0, {u'maxOccurs': u'1', u'type': u'_Amount_g_per_cm2', u'name': u'Amount_g_per_cm2', u'minOccurs': u'1'}, None),
        MemberSpec_('Amount_atm_cm', '_Amount_atm_cm', 0, 0, {u'maxOccurs': u'1', u'type': u'_Amount_atm_cm', u'name': u'Amount_atm_cm', u'minOccurs': u'1'}, None),
        MemberSpec_('Density_atm_cm_per_km_altitude', '_Density_atm_cm_per_km_altitude', 0, 0, {u'maxOccurs': u'1', u'type': u'_Density_atm_cm_per_km_altitude', u'name': u'Density_atm_cm_per_km_altitude', u'minOccurs': u'1'}, None),
        MemberSpec_('Density_RH_temp_altitude', '_Density_RH_temp_altitude', 0, 0, {u'maxOccurs': u'1', u'type': u'_Density_RH_temp_altitude', u'name': u'Density_RH_temp_altitude', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, defWaterAmount=0, M_factor=None, Amount_g_per_cm2=None, Amount_atm_cm=None, Density_atm_cm_per_km_altitude=None, Density_RH_temp_altitude=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_WaterAmount')
        self.attrib = ['defWaterAmount']
        self.children = ['M_factor', 'Amount_g_per_cm2', 'Amount_atm_cm', 'Density_atm_cm_per_km_altitude', 'Density_RH_temp_altitude']
        self.parent = None
        self._defWaterAmount = _cast(int, defWaterAmount)
        self._M_factor = M_factor
        self._Amount_g_per_cm2 = Amount_g_per_cm2
        self._Amount_atm_cm = Amount_atm_cm
        self._Density_atm_cm_per_km_altitude = Density_atm_cm_per_km_altitude
        self._Density_RH_temp_altitude = Density_RH_temp_altitude
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_WaterAmount)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_WaterAmount.subclass:
            return create_WaterAmount.subclass(*args_, **kwargs_)
        else:
            return create_WaterAmount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_M_factor(self): return self._M_factor
    def set_M_factor(self, value):
        if value is not None:
            checkclass(value, create_M_factor)
            value.parent = self
        self._M_factor = value
    M_factor = property(get_M_factor, set_M_factor)
    def get_Amount_g_per_cm2(self): return self._Amount_g_per_cm2
    def set_Amount_g_per_cm2(self, value):
        if value is not None:
            checkclass(value, create_Amount_g_per_cm2)
            value.parent = self
        self._Amount_g_per_cm2 = value
    Amount_g_per_cm2 = property(get_Amount_g_per_cm2, set_Amount_g_per_cm2)
    def get_Amount_atm_cm(self): return self._Amount_atm_cm
    def set_Amount_atm_cm(self, value):
        if value is not None:
            checkclass(value, create_Amount_atm_cm)
            value.parent = self
        self._Amount_atm_cm = value
    Amount_atm_cm = property(get_Amount_atm_cm, set_Amount_atm_cm)
    def get_Density_atm_cm_per_km_altitude(self): return self._Density_atm_cm_per_km_altitude
    def set_Density_atm_cm_per_km_altitude(self, value):
        if value is not None:
            checkclass(value, create_Density_atm_cm_per_km_altitude)
            value.parent = self
        self._Density_atm_cm_per_km_altitude = value
    Density_atm_cm_per_km_altitude = property(get_Density_atm_cm_per_km_altitude, set_Density_atm_cm_per_km_altitude)
    def get_Density_RH_temp_altitude(self): return self._Density_RH_temp_altitude
    def set_Density_RH_temp_altitude(self, value):
        if value is not None:
            checkclass(value, create_Density_RH_temp_altitude)
            value.parent = self
        self._Density_RH_temp_altitude = value
    Density_RH_temp_altitude = property(get_Density_RH_temp_altitude, set_Density_RH_temp_altitude)
    def get_defWaterAmount(self): return self._defWaterAmount
    def set_defWaterAmount(self, value):
        self._defWaterAmount = value
        update_node(self,self.troot,'atmosphere')
    defWaterAmount = property(get_defWaterAmount, set_defWaterAmount)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.M_factor is not None or
            self.Amount_g_per_cm2 is not None or
            self.Amount_atm_cm is not None or
            self.Density_atm_cm_per_km_altitude is not None or
            self.Density_RH_temp_altitude is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_WaterAmount', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_WaterAmount')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_WaterAmount')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_WaterAmount', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_WaterAmount'):
        if self.defWaterAmount is not None and 'defWaterAmount' not in already_processed:
            already_processed.add('defWaterAmount')
            outfile.write(' defWaterAmount="%s"' % self.gds_format_integer(self.defWaterAmount, input_name='defWaterAmount'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_WaterAmount', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.M_factor is not None:
            self.M_factor.export(outfile, level, namespaceprefix_, name_='M_factor', pretty_print=pretty_print)
        if self.Amount_g_per_cm2 is not None:
            self.Amount_g_per_cm2.export(outfile, level, namespaceprefix_, name_='Amount_g_per_cm2', pretty_print=pretty_print)
        if self.Amount_atm_cm is not None:
            self.Amount_atm_cm.export(outfile, level, namespaceprefix_, name_='Amount_atm_cm', pretty_print=pretty_print)
        if self.Density_atm_cm_per_km_altitude is not None:
            self.Density_atm_cm_per_km_altitude.export(outfile, level, namespaceprefix_, name_='Density_atm_cm_per_km_altitude', pretty_print=pretty_print)
        if self.Density_RH_temp_altitude is not None:
            self.Density_RH_temp_altitude.export(outfile, level, namespaceprefix_, name_='Density_RH_temp_altitude', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_WaterAmount', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.defWaterAmount is not None:
            element.set('defWaterAmount', self.gds_format_integer(self.defWaterAmount))
        if self.M_factor is not None:
            M_factor_ = self.M_factor
            M_factor_.to_etree(element, name_='M_factor', mapping_=mapping_)
        if self.Amount_g_per_cm2 is not None:
            Amount_g_per_cm2_ = self.Amount_g_per_cm2
            Amount_g_per_cm2_.to_etree(element, name_='Amount_g_per_cm2', mapping_=mapping_)
        if self.Amount_atm_cm is not None:
            Amount_atm_cm_ = self.Amount_atm_cm
            Amount_atm_cm_.to_etree(element, name_='Amount_atm_cm', mapping_=mapping_)
        if self.Density_atm_cm_per_km_altitude is not None:
            Density_atm_cm_per_km_altitude_ = self.Density_atm_cm_per_km_altitude
            Density_atm_cm_per_km_altitude_.to_etree(element, name_='Density_atm_cm_per_km_altitude', mapping_=mapping_)
        if self.Density_RH_temp_altitude is not None:
            Density_RH_temp_altitude_ = self.Density_RH_temp_altitude
            Density_RH_temp_altitude_.to_etree(element, name_='Density_RH_temp_altitude', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_WaterAmount'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.defWaterAmount is not None and 'defWaterAmount' not in already_processed:
            already_processed.add('defWaterAmount')
            showIndent(outfile, level)
            outfile.write('defWaterAmount=%d,\n' % (self.defWaterAmount,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.M_factor is not None:
            showIndent(outfile, level)
            outfile.write('M_factor=model_._M_factor(\n')
            self.M_factor.exportLiteral(outfile, level, name_='M_factor')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Amount_g_per_cm2 is not None:
            showIndent(outfile, level)
            outfile.write('Amount_g_per_cm2=model_._Amount_g_per_cm2(\n')
            self.Amount_g_per_cm2.exportLiteral(outfile, level, name_='Amount_g_per_cm2')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Amount_atm_cm is not None:
            showIndent(outfile, level)
            outfile.write('Amount_atm_cm=model_._Amount_atm_cm(\n')
            self.Amount_atm_cm.exportLiteral(outfile, level, name_='Amount_atm_cm')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Density_atm_cm_per_km_altitude is not None:
            showIndent(outfile, level)
            outfile.write('Density_atm_cm_per_km_altitude=model_._Density_atm_cm_per_km_altitude(\n')
            self.Density_atm_cm_per_km_altitude.exportLiteral(outfile, level, name_='Density_atm_cm_per_km_altitude')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Density_RH_temp_altitude is not None:
            showIndent(outfile, level)
            outfile.write('Density_RH_temp_altitude=model_._Density_RH_temp_altitude(\n')
            self.Density_RH_temp_altitude.exportLiteral(outfile, level, name_='Density_RH_temp_altitude')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('defWaterAmount', node)
        if value is not None and 'defWaterAmount' not in already_processed:
            already_processed.add('defWaterAmount')
            try:
                self.defWaterAmount = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'M_factor':
            obj_ = create_M_factor.factory()
            obj_.build(child_)
            self.set_M_factor(obj_)
            obj_.original_tagname_ = 'M_factor'
        elif nodeName_ == 'Amount_g_per_cm2':
            obj_ = create_Amount_g_per_cm2.factory()
            obj_.build(child_)
            self.set_Amount_g_per_cm2(obj_)
            obj_.original_tagname_ = 'Amount_g_per_cm2'
        elif nodeName_ == 'Amount_atm_cm':
            obj_ = create_Amount_atm_cm.factory()
            obj_.build(child_)
            self.set_Amount_atm_cm(obj_)
            obj_.original_tagname_ = 'Amount_atm_cm'
        elif nodeName_ == 'Density_atm_cm_per_km_altitude':
            obj_ = create_Density_atm_cm_per_km_altitude.factory()
            obj_.build(child_)
            self.set_Density_atm_cm_per_km_altitude(obj_)
            obj_.original_tagname_ = 'Density_atm_cm_per_km_altitude'
        elif nodeName_ == 'Density_RH_temp_altitude':
            obj_ = create_Density_RH_temp_altitude.factory()
            obj_.build(child_)
            self.set_Density_RH_temp_altitude(obj_)
            obj_.original_tagname_ = 'Density_RH_temp_altitude'
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_WaterAmount


class create_M_factor(GeneratedsSuper):
    """Multiplicative factor Multiplicative factor Multiplicative factor
    Multiplicative factor"""
    member_data_items_ = [
        MemberSpec_('mulFactorH2O', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, mulFactorH2O=1.0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_M_factor')
        self.attrib = ['mulFactorH2O']
        self.children = []
        self.parent = None
        self._mulFactorH2O = _cast(float, mulFactorH2O)
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_M_factor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_M_factor.subclass:
            return create_M_factor.subclass(*args_, **kwargs_)
        else:
            return create_M_factor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mulFactorH2O(self): return self._mulFactorH2O
    def set_mulFactorH2O(self, value):
        self._mulFactorH2O = value
        update_node(self,self.troot,'atmosphere')
    mulFactorH2O = property(get_mulFactorH2O, set_mulFactorH2O)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_M_factor', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_M_factor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_M_factor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_M_factor', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_M_factor'):
        if self.mulFactorH2O is not None and 'mulFactorH2O' not in already_processed:
            already_processed.add('mulFactorH2O')
            outfile.write(' mulFactorH2O="%s"' % self.gds_format_double(self.mulFactorH2O, input_name='mulFactorH2O'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_M_factor', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_M_factor', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.mulFactorH2O is not None:
            element.set('mulFactorH2O', self.gds_format_double(self.mulFactorH2O))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_M_factor'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.mulFactorH2O is not None and 'mulFactorH2O' not in already_processed:
            already_processed.add('mulFactorH2O')
            showIndent(outfile, level)
            outfile.write('mulFactorH2O=%e,\n' % (self.mulFactorH2O,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mulFactorH2O', node)
        if value is not None and 'mulFactorH2O' not in already_processed:
            already_processed.add('mulFactorH2O')
            try:
                self.mulFactorH2O = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (mulFactorH2O): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_M_factor


class create_Amount_g_per_cm2(GeneratedsSuper):
    """Total amount in g/cm2 Total amount in g/cm2 Amount Amount"""
    member_data_items_ = [
        MemberSpec_('g_per_cm2', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, g_per_cm2=1.41):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_Amount_g_per_cm2')
        self.attrib = ['g_per_cm2']
        self.children = []
        self.parent = None
        self._g_per_cm2 = _cast(float, g_per_cm2)
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Amount_g_per_cm2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Amount_g_per_cm2.subclass:
            return create_Amount_g_per_cm2.subclass(*args_, **kwargs_)
        else:
            return create_Amount_g_per_cm2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_g_per_cm2(self): return self._g_per_cm2
    def set_g_per_cm2(self, value):
        self._g_per_cm2 = value
        update_node(self,self.troot,'atmosphere')
    g_per_cm2 = property(get_g_per_cm2, set_g_per_cm2)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Amount_g_per_cm2', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Amount_g_per_cm2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Amount_g_per_cm2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Amount_g_per_cm2', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Amount_g_per_cm2'):
        if self.g_per_cm2 is not None and 'g_per_cm2' not in already_processed:
            already_processed.add('g_per_cm2')
            outfile.write(' g_per_cm2="%s"' % self.gds_format_double(self.g_per_cm2, input_name='g_per_cm2'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Amount_g_per_cm2', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_Amount_g_per_cm2', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.g_per_cm2 is not None:
            element.set('g_per_cm2', self.gds_format_double(self.g_per_cm2))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Amount_g_per_cm2'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.g_per_cm2 is not None and 'g_per_cm2' not in already_processed:
            already_processed.add('g_per_cm2')
            showIndent(outfile, level)
            outfile.write('g_per_cm2=%e,\n' % (self.g_per_cm2,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('g_per_cm2', node)
        if value is not None and 'g_per_cm2' not in already_processed:
            already_processed.add('g_per_cm2')
            try:
                self.g_per_cm2 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (g_per_cm2): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_Amount_g_per_cm2


class create_Amount_atm_cm(GeneratedsSuper):
    """Total amount in atm-cm Total amount in atm-cm Amount Amount"""
    member_data_items_ = [
        MemberSpec_('atm_cm', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, atm_cm=1762.3):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_Amount_atm_cm')
        self.attrib = ['atm_cm']
        self.children = []
        self.parent = None
        self._atm_cm = _cast(float, atm_cm)
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Amount_atm_cm)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Amount_atm_cm.subclass:
            return create_Amount_atm_cm.subclass(*args_, **kwargs_)
        else:
            return create_Amount_atm_cm(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_atm_cm(self): return self._atm_cm
    def set_atm_cm(self, value):
        self._atm_cm = value
        update_node(self,self.troot,'atmosphere')
    atm_cm = property(get_atm_cm, set_atm_cm)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Amount_atm_cm', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Amount_atm_cm')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Amount_atm_cm')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Amount_atm_cm', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Amount_atm_cm'):
        if self.atm_cm is not None and 'atm_cm' not in already_processed:
            already_processed.add('atm_cm')
            outfile.write(' atm_cm="%s"' % self.gds_format_double(self.atm_cm, input_name='atm_cm'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Amount_atm_cm', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_Amount_atm_cm', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.atm_cm is not None:
            element.set('atm_cm', self.gds_format_double(self.atm_cm))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Amount_atm_cm'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.atm_cm is not None and 'atm_cm' not in already_processed:
            already_processed.add('atm_cm')
            showIndent(outfile, level)
            outfile.write('atm_cm=%e,\n' % (self.atm_cm,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('atm_cm', node)
        if value is not None and 'atm_cm' not in already_processed:
            already_processed.add('atm_cm')
            try:
                self.atm_cm = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (atm_cm): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_Amount_atm_cm


class create_Density_atm_cm_per_km_altitude(GeneratedsSuper):
    """Density in atm-cm/km Density in atm-cm/km Altitude Altitude Density
    Density"""
    member_data_items_ = [
        MemberSpec_('altitude', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('atm_cm_per_km', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, altitude=0, atm_cm_per_km=734.0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_Density_atm_cm_per_km_altitude')
        self.attrib = ['altitude', 'atm_cm_per_km']
        self.children = []
        self.parent = None
        self._altitude = _cast(float, altitude)
        self._atm_cm_per_km = _cast(float, atm_cm_per_km)
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Density_atm_cm_per_km_altitude)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Density_atm_cm_per_km_altitude.subclass:
            return create_Density_atm_cm_per_km_altitude.subclass(*args_, **kwargs_)
        else:
            return create_Density_atm_cm_per_km_altitude(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_altitude(self): return self._altitude
    def set_altitude(self, value):
        self._altitude = value
        update_node(self,self.troot,'atmosphere')
    altitude = property(get_altitude, set_altitude)
    def get_atm_cm_per_km(self): return self._atm_cm_per_km
    def set_atm_cm_per_km(self, value):
        self._atm_cm_per_km = value
        update_node(self,self.troot,'atmosphere')
    atm_cm_per_km = property(get_atm_cm_per_km, set_atm_cm_per_km)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Density_atm_cm_per_km_altitude', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Density_atm_cm_per_km_altitude')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Density_atm_cm_per_km_altitude')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Density_atm_cm_per_km_altitude', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Density_atm_cm_per_km_altitude'):
        if self.altitude is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            outfile.write(' altitude="%s"' % self.gds_format_double(self.altitude, input_name='altitude'))
        if self.atm_cm_per_km is not None and 'atm_cm_per_km' not in already_processed:
            already_processed.add('atm_cm_per_km')
            outfile.write(' atm_cm_per_km="%s"' % self.gds_format_double(self.atm_cm_per_km, input_name='atm_cm_per_km'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Density_atm_cm_per_km_altitude', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_Density_atm_cm_per_km_altitude', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.altitude is not None:
            element.set('altitude', self.gds_format_double(self.altitude))
        if self.atm_cm_per_km is not None:
            element.set('atm_cm_per_km', self.gds_format_double(self.atm_cm_per_km))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Density_atm_cm_per_km_altitude'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.altitude is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            showIndent(outfile, level)
            outfile.write('altitude=%e,\n' % (self.altitude,))
        if self.atm_cm_per_km is not None and 'atm_cm_per_km' not in already_processed:
            already_processed.add('atm_cm_per_km')
            showIndent(outfile, level)
            outfile.write('atm_cm_per_km=%e,\n' % (self.atm_cm_per_km,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('altitude', node)
        if value is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            try:
                self.altitude = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (altitude): %s' % exp)
        value = find_attr_value_('atm_cm_per_km', node)
        if value is not None and 'atm_cm_per_km' not in already_processed:
            already_processed.add('atm_cm_per_km')
            try:
                self.atm_cm_per_km = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (atm_cm_per_km): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_Density_atm_cm_per_km_altitude


class create_Density_RH_temp_altitude(GeneratedsSuper):
    """Density in realtive humidity Density in realtive humidity Altitude
    Altitude Relative humidity Relative humidity Temperature
    Temperature"""
    member_data_items_ = [
        MemberSpec_('altitude', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('rh', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('temp', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, altitude=0, rh=50.0, temp=288.15):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_Density_RH_temp_altitude')
        self.attrib = ['altitude', 'rh', 'temp']
        self.children = []
        self.parent = None
        self._altitude = _cast(float, altitude)
        self._rh = _cast(float, rh)
        self._temp = _cast(float, temp)
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Density_RH_temp_altitude)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Density_RH_temp_altitude.subclass:
            return create_Density_RH_temp_altitude.subclass(*args_, **kwargs_)
        else:
            return create_Density_RH_temp_altitude(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_altitude(self): return self._altitude
    def set_altitude(self, value):
        self._altitude = value
        update_node(self,self.troot,'atmosphere')
    altitude = property(get_altitude, set_altitude)
    def get_rh(self): return self._rh
    def set_rh(self, value):
        self._rh = value
        update_node(self,self.troot,'atmosphere')
    rh = property(get_rh, set_rh)
    def get_temp(self): return self._temp
    def set_temp(self, value):
        self._temp = value
        update_node(self,self.troot,'atmosphere')
    temp = property(get_temp, set_temp)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Density_RH_temp_altitude', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Density_RH_temp_altitude')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Density_RH_temp_altitude')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Density_RH_temp_altitude', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Density_RH_temp_altitude'):
        if self.altitude is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            outfile.write(' altitude="%s"' % self.gds_format_double(self.altitude, input_name='altitude'))
        if self.rh is not None and 'rh' not in already_processed:
            already_processed.add('rh')
            outfile.write(' rh="%s"' % self.gds_format_double(self.rh, input_name='rh'))
        if self.temp is not None and 'temp' not in already_processed:
            already_processed.add('temp')
            outfile.write(' temp="%s"' % self.gds_format_double(self.temp, input_name='temp'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Density_RH_temp_altitude', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_Density_RH_temp_altitude', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.altitude is not None:
            element.set('altitude', self.gds_format_double(self.altitude))
        if self.rh is not None:
            element.set('rh', self.gds_format_double(self.rh))
        if self.temp is not None:
            element.set('temp', self.gds_format_double(self.temp))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Density_RH_temp_altitude'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.altitude is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            showIndent(outfile, level)
            outfile.write('altitude=%e,\n' % (self.altitude,))
        if self.rh is not None and 'rh' not in already_processed:
            already_processed.add('rh')
            showIndent(outfile, level)
            outfile.write('rh=%e,\n' % (self.rh,))
        if self.temp is not None and 'temp' not in already_processed:
            already_processed.add('temp')
            showIndent(outfile, level)
            outfile.write('temp=%e,\n' % (self.temp,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('altitude', node)
        if value is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            try:
                self.altitude = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (altitude): %s' % exp)
        value = find_attr_value_('rh', node)
        if value is not None and 'rh' not in already_processed:
            already_processed.add('rh')
            try:
                self.rh = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (rh): %s' % exp)
        value = find_attr_value_('temp', node)
        if value is not None and 'temp' not in already_processed:
            already_processed.add('temp')
            try:
                self.temp = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (temp): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_Density_RH_temp_altitude


class create_tempParameters(GeneratedsSuper):
    """Temperature at the defined altitude Temperature at the defined
    altitude Altitude Altitude Temperature Temperature"""
    member_data_items_ = [
        MemberSpec_('altitude', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('temp', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, altitude=0, temp=288.15):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_tempParameters')
        self.attrib = ['altitude', 'temp']
        self.children = []
        self.parent = None
        self._altitude = _cast(float, altitude)
        self._temp = _cast(float, temp)
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_tempParameters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_tempParameters.subclass:
            return create_tempParameters.subclass(*args_, **kwargs_)
        else:
            return create_tempParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_altitude(self): return self._altitude
    def set_altitude(self, value):
        self._altitude = value
        update_node(self,self.troot,'atmosphere')
    altitude = property(get_altitude, set_altitude)
    def get_temp(self): return self._temp
    def set_temp(self, value):
        self._temp = value
        update_node(self,self.troot,'atmosphere')
    temp = property(get_temp, set_temp)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_tempParameters', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_tempParameters')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_tempParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_tempParameters', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_tempParameters'):
        if self.altitude is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            outfile.write(' altitude="%s"' % self.gds_format_double(self.altitude, input_name='altitude'))
        if self.temp is not None and 'temp' not in already_processed:
            already_processed.add('temp')
            outfile.write(' temp="%s"' % self.gds_format_double(self.temp, input_name='temp'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_tempParameters', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_tempParameters', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.altitude is not None:
            element.set('altitude', self.gds_format_double(self.altitude))
        if self.temp is not None:
            element.set('temp', self.gds_format_double(self.temp))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_tempParameters'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.altitude is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            showIndent(outfile, level)
            outfile.write('altitude=%e,\n' % (self.altitude,))
        if self.temp is not None and 'temp' not in already_processed:
            already_processed.add('temp')
            showIndent(outfile, level)
            outfile.write('temp=%e,\n' % (self.temp,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('altitude', node)
        if value is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            try:
                self.altitude = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (altitude): %s' % exp)
        value = find_attr_value_('temp', node)
        if value is not None and 'temp' not in already_processed:
            already_processed.add('temp')
            try:
                self.temp = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (temp): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_tempParameters


class create_AtmosphereIterations(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('AtmosphereTransfertFunctions', '_AtmosphereTransfertFunctions', 0, 0, {u'maxOccurs': u'1', u'type': u'_AtmosphereTransfertFunctions', u'name': u'AtmosphereTransfertFunctions', u'minOccurs': u'1'}, None),
        MemberSpec_('AtmosphereProducts', '_AtmosphereProducts', 0, 0, {u'maxOccurs': u'1', u'type': u'_AtmosphereProducts', u'name': u'AtmosphereProducts', u'minOccurs': u'1'}, None),
        MemberSpec_('AtmosphereComponents', '_AtmosphereComponents', 0, 0, {u'maxOccurs': u'1', u'type': u'_AtmosphereComponents', u'name': u'AtmosphereComponents', u'minOccurs': u'1'}, None),
        MemberSpec_('AtmosphereExpertModeZone', '_AtmosphereExpertModeZone', 0, 0, {u'maxOccurs': u'1', u'type': u'_AtmosphereExpertModeZone', u'name': u'AtmosphereExpertModeZone', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, AtmosphereTransfertFunctions=None, AtmosphereProducts=None, AtmosphereComponents=None, AtmosphereExpertModeZone=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_AtmosphereIterations')
        self.attrib = ['']
        self.children = ['AtmosphereTransfertFunctions', 'AtmosphereProducts', 'AtmosphereComponents', 'AtmosphereExpertModeZone']
        self.parent = None
        self._AtmosphereTransfertFunctions = AtmosphereTransfertFunctions
        self._AtmosphereProducts = AtmosphereProducts
        self._AtmosphereComponents = AtmosphereComponents
        self._AtmosphereExpertModeZone = AtmosphereExpertModeZone
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_AtmosphereIterations)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_AtmosphereIterations.subclass:
            return create_AtmosphereIterations.subclass(*args_, **kwargs_)
        else:
            return create_AtmosphereIterations(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AtmosphereTransfertFunctions(self): return self._AtmosphereTransfertFunctions
    def set_AtmosphereTransfertFunctions(self, value):
        if value is not None:
            checkclass(value, create_AtmosphereTransfertFunctions)
            value.parent = self
        self._AtmosphereTransfertFunctions = value
    AtmosphereTransfertFunctions = property(get_AtmosphereTransfertFunctions, set_AtmosphereTransfertFunctions)
    def get_AtmosphereProducts(self): return self._AtmosphereProducts
    def set_AtmosphereProducts(self, value):
        if value is not None:
            checkclass(value, create_AtmosphereProducts)
            value.parent = self
        self._AtmosphereProducts = value
    AtmosphereProducts = property(get_AtmosphereProducts, set_AtmosphereProducts)
    def get_AtmosphereComponents(self): return self._AtmosphereComponents
    def set_AtmosphereComponents(self, value):
        if value is not None:
            checkclass(value, create_AtmosphereComponents)
            value.parent = self
        self._AtmosphereComponents = value
    AtmosphereComponents = property(get_AtmosphereComponents, set_AtmosphereComponents)
    def get_AtmosphereExpertModeZone(self): return self._AtmosphereExpertModeZone
    def set_AtmosphereExpertModeZone(self, value):
        if value is not None:
            checkclass(value, create_AtmosphereExpertModeZone)
            value.parent = self
        self._AtmosphereExpertModeZone = value
    AtmosphereExpertModeZone = property(get_AtmosphereExpertModeZone, set_AtmosphereExpertModeZone)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.AtmosphereTransfertFunctions is not None or
            self.AtmosphereProducts is not None or
            self.AtmosphereComponents is not None or
            self.AtmosphereExpertModeZone is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_AtmosphereIterations', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_AtmosphereIterations')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_AtmosphereIterations')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_AtmosphereIterations', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_AtmosphereIterations'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_AtmosphereIterations', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AtmosphereTransfertFunctions is not None:
            self.AtmosphereTransfertFunctions.export(outfile, level, namespaceprefix_, name_='AtmosphereTransfertFunctions', pretty_print=pretty_print)
        if self.AtmosphereProducts is not None:
            self.AtmosphereProducts.export(outfile, level, namespaceprefix_, name_='AtmosphereProducts', pretty_print=pretty_print)
        if self.AtmosphereComponents is not None:
            self.AtmosphereComponents.export(outfile, level, namespaceprefix_, name_='AtmosphereComponents', pretty_print=pretty_print)
        if self.AtmosphereExpertModeZone is not None:
            self.AtmosphereExpertModeZone.export(outfile, level, namespaceprefix_, name_='AtmosphereExpertModeZone', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_AtmosphereIterations', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.AtmosphereTransfertFunctions is not None:
            AtmosphereTransfertFunctions_ = self.AtmosphereTransfertFunctions
            AtmosphereTransfertFunctions_.to_etree(element, name_='AtmosphereTransfertFunctions', mapping_=mapping_)
        if self.AtmosphereProducts is not None:
            AtmosphereProducts_ = self.AtmosphereProducts
            AtmosphereProducts_.to_etree(element, name_='AtmosphereProducts', mapping_=mapping_)
        if self.AtmosphereComponents is not None:
            AtmosphereComponents_ = self.AtmosphereComponents
            AtmosphereComponents_.to_etree(element, name_='AtmosphereComponents', mapping_=mapping_)
        if self.AtmosphereExpertModeZone is not None:
            AtmosphereExpertModeZone_ = self.AtmosphereExpertModeZone
            AtmosphereExpertModeZone_.to_etree(element, name_='AtmosphereExpertModeZone', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_AtmosphereIterations'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AtmosphereTransfertFunctions is not None:
            showIndent(outfile, level)
            outfile.write('AtmosphereTransfertFunctions=model_._AtmosphereTransfertFunctions(\n')
            self.AtmosphereTransfertFunctions.exportLiteral(outfile, level, name_='AtmosphereTransfertFunctions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AtmosphereProducts is not None:
            showIndent(outfile, level)
            outfile.write('AtmosphereProducts=model_._AtmosphereProducts(\n')
            self.AtmosphereProducts.exportLiteral(outfile, level, name_='AtmosphereProducts')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AtmosphereComponents is not None:
            showIndent(outfile, level)
            outfile.write('AtmosphereComponents=model_._AtmosphereComponents(\n')
            self.AtmosphereComponents.exportLiteral(outfile, level, name_='AtmosphereComponents')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AtmosphereExpertModeZone is not None:
            showIndent(outfile, level)
            outfile.write('AtmosphereExpertModeZone=model_._AtmosphereExpertModeZone(\n')
            self.AtmosphereExpertModeZone.exportLiteral(outfile, level, name_='AtmosphereExpertModeZone')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AtmosphereTransfertFunctions':
            obj_ = create_AtmosphereTransfertFunctions.factory()
            obj_.build(child_)
            self.set_AtmosphereTransfertFunctions(obj_)
            obj_.original_tagname_ = 'AtmosphereTransfertFunctions'
        elif nodeName_ == 'AtmosphereProducts':
            obj_ = create_AtmosphereProducts.factory()
            obj_.build(child_)
            self.set_AtmosphereProducts(obj_)
            obj_.original_tagname_ = 'AtmosphereProducts'
        elif nodeName_ == 'AtmosphereComponents':
            obj_ = create_AtmosphereComponents.factory()
            obj_.build(child_)
            self.set_AtmosphereComponents(obj_)
            obj_.original_tagname_ = 'AtmosphereComponents'
        elif nodeName_ == 'AtmosphereExpertModeZone':
            obj_ = create_AtmosphereExpertModeZone.factory()
            obj_.build(child_)
            self.set_AtmosphereExpertModeZone(obj_)
            obj_.original_tagname_ = 'AtmosphereExpertModeZone'
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_AtmosphereIterations


class create_AtmosphereTransfertFunctions(GeneratedsSuper):
    """Transfer functions file as input (no recomputation)/output Transfer
    functions file as input (no recomputation)/output"""
    member_data_items_ = [
        MemberSpec_('inputOutputTransfertFunctions', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('ComputedTransferFunctions', '_ComputedTransferFunctions', 0, 0, {u'maxOccurs': u'1', u'type': u'_ComputedTransferFunctions', u'name': u'ComputedTransferFunctions', u'minOccurs': u'1'}, None),
        MemberSpec_('ImportedTransferFunctions', '_ImportedTransferFunctions', 0, 0, {u'maxOccurs': u'1', u'type': u'_ImportedTransferFunctions', u'name': u'ImportedTransferFunctions', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, inputOutputTransfertFunctions=0, ComputedTransferFunctions=None, ImportedTransferFunctions=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_AtmosphereTransfertFunctions')
        self.attrib = ['inputOutputTransfertFunctions']
        self.children = ['ComputedTransferFunctions', 'ImportedTransferFunctions']
        self.parent = None
        self._inputOutputTransfertFunctions = _cast(int, inputOutputTransfertFunctions)
        self._ComputedTransferFunctions = ComputedTransferFunctions
        self._ImportedTransferFunctions = ImportedTransferFunctions
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_AtmosphereTransfertFunctions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_AtmosphereTransfertFunctions.subclass:
            return create_AtmosphereTransfertFunctions.subclass(*args_, **kwargs_)
        else:
            return create_AtmosphereTransfertFunctions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ComputedTransferFunctions(self): return self._ComputedTransferFunctions
    def set_ComputedTransferFunctions(self, value):
        if value is not None:
            checkclass(value, create_ComputedTransferFunctions)
            value.parent = self
        self._ComputedTransferFunctions = value
    ComputedTransferFunctions = property(get_ComputedTransferFunctions, set_ComputedTransferFunctions)
    def get_ImportedTransferFunctions(self): return self._ImportedTransferFunctions
    def set_ImportedTransferFunctions(self, value):
        if value is not None:
            checkclass(value, create_ImportedTransferFunctions)
            value.parent = self
        self._ImportedTransferFunctions = value
    ImportedTransferFunctions = property(get_ImportedTransferFunctions, set_ImportedTransferFunctions)
    def get_inputOutputTransfertFunctions(self): return self._inputOutputTransfertFunctions
    def set_inputOutputTransfertFunctions(self, value):
        self._inputOutputTransfertFunctions = value
        update_node(self,self.troot,'atmosphere')
    inputOutputTransfertFunctions = property(get_inputOutputTransfertFunctions, set_inputOutputTransfertFunctions)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.ComputedTransferFunctions is not None or
            self.ImportedTransferFunctions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_AtmosphereTransfertFunctions', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_AtmosphereTransfertFunctions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_AtmosphereTransfertFunctions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_AtmosphereTransfertFunctions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_AtmosphereTransfertFunctions'):
        if self.inputOutputTransfertFunctions is not None and 'inputOutputTransfertFunctions' not in already_processed:
            already_processed.add('inputOutputTransfertFunctions')
            outfile.write(' inputOutputTransfertFunctions="%s"' % self.gds_format_integer(self.inputOutputTransfertFunctions, input_name='inputOutputTransfertFunctions'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_AtmosphereTransfertFunctions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ComputedTransferFunctions is not None:
            self.ComputedTransferFunctions.export(outfile, level, namespaceprefix_, name_='ComputedTransferFunctions', pretty_print=pretty_print)
        if self.ImportedTransferFunctions is not None:
            self.ImportedTransferFunctions.export(outfile, level, namespaceprefix_, name_='ImportedTransferFunctions', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_AtmosphereTransfertFunctions', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.inputOutputTransfertFunctions is not None:
            element.set('inputOutputTransfertFunctions', self.gds_format_integer(self.inputOutputTransfertFunctions))
        if self.ComputedTransferFunctions is not None:
            ComputedTransferFunctions_ = self.ComputedTransferFunctions
            ComputedTransferFunctions_.to_etree(element, name_='ComputedTransferFunctions', mapping_=mapping_)
        if self.ImportedTransferFunctions is not None:
            ImportedTransferFunctions_ = self.ImportedTransferFunctions
            ImportedTransferFunctions_.to_etree(element, name_='ImportedTransferFunctions', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_AtmosphereTransfertFunctions'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.inputOutputTransfertFunctions is not None and 'inputOutputTransfertFunctions' not in already_processed:
            already_processed.add('inputOutputTransfertFunctions')
            showIndent(outfile, level)
            outfile.write('inputOutputTransfertFunctions=%d,\n' % (self.inputOutputTransfertFunctions,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ComputedTransferFunctions is not None:
            showIndent(outfile, level)
            outfile.write('ComputedTransferFunctions=model_._ComputedTransferFunctions(\n')
            self.ComputedTransferFunctions.exportLiteral(outfile, level, name_='ComputedTransferFunctions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ImportedTransferFunctions is not None:
            showIndent(outfile, level)
            outfile.write('ImportedTransferFunctions=model_._ImportedTransferFunctions(\n')
            self.ImportedTransferFunctions.exportLiteral(outfile, level, name_='ImportedTransferFunctions')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inputOutputTransfertFunctions', node)
        if value is not None and 'inputOutputTransfertFunctions' not in already_processed:
            already_processed.add('inputOutputTransfertFunctions')
            try:
                self.inputOutputTransfertFunctions = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ComputedTransferFunctions':
            obj_ = create_ComputedTransferFunctions.factory()
            obj_.build(child_)
            self.set_ComputedTransferFunctions(obj_)
            obj_.original_tagname_ = 'ComputedTransferFunctions'
        elif nodeName_ == 'ImportedTransferFunctions':
            obj_ = create_ImportedTransferFunctions.factory()
            obj_.build(child_)
            self.set_ImportedTransferFunctions(obj_)
            obj_.original_tagname_ = 'ImportedTransferFunctions'
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_AtmosphereTransfertFunctions


class create_ComputedTransferFunctions(GeneratedsSuper):
    """Write the computed transfer functions in a file that can be later
    reused by DART. See option just above. Write the computed
    transfer functions in a file that can be later reused by DART.
    See option just above."""
    member_data_items_ = [
        MemberSpec_('writeTransferFunctions', 'xsd:int', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, writeTransferFunctions=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_ComputedTransferFunctions')
        self.attrib = ['writeTransferFunctions']
        self.children = []
        self.parent = None
        self._writeTransferFunctions = _cast(int, writeTransferFunctions)
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ComputedTransferFunctions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ComputedTransferFunctions.subclass:
            return create_ComputedTransferFunctions.subclass(*args_, **kwargs_)
        else:
            return create_ComputedTransferFunctions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_writeTransferFunctions(self): return self._writeTransferFunctions
    def set_writeTransferFunctions(self, value):
        self._writeTransferFunctions = value
        update_node(self,self.troot,'atmosphere')
    writeTransferFunctions = property(get_writeTransferFunctions, set_writeTransferFunctions)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ComputedTransferFunctions', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ComputedTransferFunctions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ComputedTransferFunctions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ComputedTransferFunctions', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ComputedTransferFunctions'):
        if self.writeTransferFunctions is not None and 'writeTransferFunctions' not in already_processed:
            already_processed.add('writeTransferFunctions')
            outfile.write(' writeTransferFunctions="%s"' % self.gds_format_integer(self.writeTransferFunctions, input_name='writeTransferFunctions'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ComputedTransferFunctions', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_ComputedTransferFunctions', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.writeTransferFunctions is not None:
            element.set('writeTransferFunctions', self.gds_format_integer(self.writeTransferFunctions))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ComputedTransferFunctions'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.writeTransferFunctions is not None and 'writeTransferFunctions' not in already_processed:
            already_processed.add('writeTransferFunctions')
            showIndent(outfile, level)
            outfile.write('writeTransferFunctions=%d,\n' % (self.writeTransferFunctions,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('writeTransferFunctions', node)
        if value is not None and 'writeTransferFunctions' not in already_processed:
            already_processed.add('writeTransferFunctions')
            try:
                self.writeTransferFunctions = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_ComputedTransferFunctions


class create_ImportedTransferFunctions(GeneratedsSuper):
    """(Relative) file path to the precomputed transfer functions. This
    file can be generated by DART in "on the fly" mode. (Relative)
    file path to the precomputed transfer functions. This file can
    be generated by DART in "on the fly" mode."""
    member_data_items_ = [
        MemberSpec_('transferFunctionsFile', 'xsd:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, transferFunctionsFile='atmosphereTransferFunctions.binary'):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_ImportedTransferFunctions')
        self.attrib = ['transferFunctionsFile']
        self.children = []
        self.parent = None
        self._transferFunctionsFile = _cast(None, transferFunctionsFile)
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ImportedTransferFunctions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ImportedTransferFunctions.subclass:
            return create_ImportedTransferFunctions.subclass(*args_, **kwargs_)
        else:
            return create_ImportedTransferFunctions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_transferFunctionsFile(self): return self._transferFunctionsFile
    def set_transferFunctionsFile(self, value):
        self._transferFunctionsFile = value
        update_node(self,self.troot,'atmosphere')
    transferFunctionsFile = property(get_transferFunctionsFile, set_transferFunctionsFile)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ImportedTransferFunctions', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ImportedTransferFunctions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ImportedTransferFunctions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ImportedTransferFunctions', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ImportedTransferFunctions'):
        if self.transferFunctionsFile is not None and 'transferFunctionsFile' not in already_processed:
            already_processed.add('transferFunctionsFile')
            outfile.write(' transferFunctionsFile=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transferFunctionsFile), input_name='transferFunctionsFile')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ImportedTransferFunctions', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_ImportedTransferFunctions', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.transferFunctionsFile is not None:
            element.set('transferFunctionsFile', self.gds_format_string(self.transferFunctionsFile))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ImportedTransferFunctions'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.transferFunctionsFile is not None and 'transferFunctionsFile' not in already_processed:
            already_processed.add('transferFunctionsFile')
            showIndent(outfile, level)
            outfile.write('transferFunctionsFile="%s",\n' % (self.transferFunctionsFile,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('transferFunctionsFile', node)
        if value is not None and 'transferFunctionsFile' not in already_processed:
            already_processed.add('transferFunctionsFile')
            self.transferFunctionsFile = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_ImportedTransferFunctions


class create_AtmosphereProducts(GeneratedsSuper):
    """Atmosphere products Atmosphere products atmosphere radiance BOA
    before coupling atmosphere radiance BOA before coupling
    atmosphere radiance BOA after coupling atmosphere radiance BOA
    after coupling Order 1 for atmosphere Order 1 for atmosphere
    atmosphere BRF TOA atmosphere BRF TOA"""
    member_data_items_ = [
        MemberSpec_('atmosphereRadiance_BOA_avantCouplage', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('atmosphereRadiance_BOA_apresCouplage', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('ordreUnAtmos', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('atmosphereBRF_TOA', 'xsd:int', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, atmosphereRadiance_BOA_avantCouplage=0, atmosphereRadiance_BOA_apresCouplage=0, ordreUnAtmos=0, atmosphereBRF_TOA=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_AtmosphereProducts')
        self.attrib = ['atmosphereRadiance_BOA_avantCouplage', 'atmosphereRadiance_BOA_apresCouplage', 'ordreUnAtmos', 'atmosphereBRF_TOA']
        self.children = []
        self.parent = None
        self._atmosphereRadiance_BOA_avantCouplage = _cast(int, atmosphereRadiance_BOA_avantCouplage)
        self._atmosphereRadiance_BOA_apresCouplage = _cast(int, atmosphereRadiance_BOA_apresCouplage)
        self._ordreUnAtmos = _cast(int, ordreUnAtmos)
        self._atmosphereBRF_TOA = _cast(int, atmosphereBRF_TOA)
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_AtmosphereProducts)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_AtmosphereProducts.subclass:
            return create_AtmosphereProducts.subclass(*args_, **kwargs_)
        else:
            return create_AtmosphereProducts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_atmosphereRadiance_BOA_avantCouplage(self): return self._atmosphereRadiance_BOA_avantCouplage
    def set_atmosphereRadiance_BOA_avantCouplage(self, value):
        self._atmosphereRadiance_BOA_avantCouplage = value
        update_node(self,self.troot,'atmosphere')
    atmosphereRadiance_BOA_avantCouplage = property(get_atmosphereRadiance_BOA_avantCouplage, set_atmosphereRadiance_BOA_avantCouplage)
    def get_atmosphereRadiance_BOA_apresCouplage(self): return self._atmosphereRadiance_BOA_apresCouplage
    def set_atmosphereRadiance_BOA_apresCouplage(self, value):
        self._atmosphereRadiance_BOA_apresCouplage = value
        update_node(self,self.troot,'atmosphere')
    atmosphereRadiance_BOA_apresCouplage = property(get_atmosphereRadiance_BOA_apresCouplage, set_atmosphereRadiance_BOA_apresCouplage)
    def get_ordreUnAtmos(self): return self._ordreUnAtmos
    def set_ordreUnAtmos(self, value):
        self._ordreUnAtmos = value
        update_node(self,self.troot,'atmosphere')
    ordreUnAtmos = property(get_ordreUnAtmos, set_ordreUnAtmos)
    def get_atmosphereBRF_TOA(self): return self._atmosphereBRF_TOA
    def set_atmosphereBRF_TOA(self, value):
        self._atmosphereBRF_TOA = value
        update_node(self,self.troot,'atmosphere')
    atmosphereBRF_TOA = property(get_atmosphereBRF_TOA, set_atmosphereBRF_TOA)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_AtmosphereProducts', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_AtmosphereProducts')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_AtmosphereProducts')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_AtmosphereProducts', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_AtmosphereProducts'):
        if self.atmosphereRadiance_BOA_avantCouplage is not None and 'atmosphereRadiance_BOA_avantCouplage' not in already_processed:
            already_processed.add('atmosphereRadiance_BOA_avantCouplage')
            outfile.write(' atmosphereRadiance_BOA_avantCouplage="%s"' % self.gds_format_integer(self.atmosphereRadiance_BOA_avantCouplage, input_name='atmosphereRadiance_BOA_avantCouplage'))
        if self.atmosphereRadiance_BOA_apresCouplage is not None and 'atmosphereRadiance_BOA_apresCouplage' not in already_processed:
            already_processed.add('atmosphereRadiance_BOA_apresCouplage')
            outfile.write(' atmosphereRadiance_BOA_apresCouplage="%s"' % self.gds_format_integer(self.atmosphereRadiance_BOA_apresCouplage, input_name='atmosphereRadiance_BOA_apresCouplage'))
        if self.ordreUnAtmos is not None and 'ordreUnAtmos' not in already_processed:
            already_processed.add('ordreUnAtmos')
            outfile.write(' ordreUnAtmos="%s"' % self.gds_format_integer(self.ordreUnAtmos, input_name='ordreUnAtmos'))
        if self.atmosphereBRF_TOA is not None and 'atmosphereBRF_TOA' not in already_processed:
            already_processed.add('atmosphereBRF_TOA')
            outfile.write(' atmosphereBRF_TOA="%s"' % self.gds_format_integer(self.atmosphereBRF_TOA, input_name='atmosphereBRF_TOA'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_AtmosphereProducts', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_AtmosphereProducts', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.atmosphereRadiance_BOA_avantCouplage is not None:
            element.set('atmosphereRadiance_BOA_avantCouplage', self.gds_format_integer(self.atmosphereRadiance_BOA_avantCouplage))
        if self.atmosphereRadiance_BOA_apresCouplage is not None:
            element.set('atmosphereRadiance_BOA_apresCouplage', self.gds_format_integer(self.atmosphereRadiance_BOA_apresCouplage))
        if self.ordreUnAtmos is not None:
            element.set('ordreUnAtmos', self.gds_format_integer(self.ordreUnAtmos))
        if self.atmosphereBRF_TOA is not None:
            element.set('atmosphereBRF_TOA', self.gds_format_integer(self.atmosphereBRF_TOA))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_AtmosphereProducts'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.atmosphereRadiance_BOA_avantCouplage is not None and 'atmosphereRadiance_BOA_avantCouplage' not in already_processed:
            already_processed.add('atmosphereRadiance_BOA_avantCouplage')
            showIndent(outfile, level)
            outfile.write('atmosphereRadiance_BOA_avantCouplage=%d,\n' % (self.atmosphereRadiance_BOA_avantCouplage,))
        if self.atmosphereRadiance_BOA_apresCouplage is not None and 'atmosphereRadiance_BOA_apresCouplage' not in already_processed:
            already_processed.add('atmosphereRadiance_BOA_apresCouplage')
            showIndent(outfile, level)
            outfile.write('atmosphereRadiance_BOA_apresCouplage=%d,\n' % (self.atmosphereRadiance_BOA_apresCouplage,))
        if self.ordreUnAtmos is not None and 'ordreUnAtmos' not in already_processed:
            already_processed.add('ordreUnAtmos')
            showIndent(outfile, level)
            outfile.write('ordreUnAtmos=%d,\n' % (self.ordreUnAtmos,))
        if self.atmosphereBRF_TOA is not None and 'atmosphereBRF_TOA' not in already_processed:
            already_processed.add('atmosphereBRF_TOA')
            showIndent(outfile, level)
            outfile.write('atmosphereBRF_TOA=%d,\n' % (self.atmosphereBRF_TOA,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('atmosphereRadiance_BOA_avantCouplage', node)
        if value is not None and 'atmosphereRadiance_BOA_avantCouplage' not in already_processed:
            already_processed.add('atmosphereRadiance_BOA_avantCouplage')
            try:
                self.atmosphereRadiance_BOA_avantCouplage = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('atmosphereRadiance_BOA_apresCouplage', node)
        if value is not None and 'atmosphereRadiance_BOA_apresCouplage' not in already_processed:
            already_processed.add('atmosphereRadiance_BOA_apresCouplage')
            try:
                self.atmosphereRadiance_BOA_apresCouplage = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ordreUnAtmos', node)
        if value is not None and 'ordreUnAtmos' not in already_processed:
            already_processed.add('ordreUnAtmos')
            try:
                self.ordreUnAtmos = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('atmosphereBRF_TOA', node)
        if value is not None and 'atmosphereBRF_TOA' not in already_processed:
            already_processed.add('atmosphereBRF_TOA')
            try:
                self.atmosphereBRF_TOA = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_AtmosphereProducts


class create_AtmosphereComponents(GeneratedsSuper):
    """Atmosphere fluxes used to irradiate BOA scene and compute BOA
    products are defined here Atmosphere fluxes used to irradiate
    BOA scene and compute BOA products are defined here 1) None:
    TOA, Sensor and BOA irradiance irradiance has no component from
    Earth surface. \n2) Diffuse: TOA, Sensor and BOA irradiance has
    1 component due to the Earth surface: \n -Earth scene
    reflected/emitted radiation that is scattered by the atmosphere.
    \n3) Direct: TOA, Sensor and BOA irradiance has 1 component due
    to the Earth surface: \n -Earth scene reflected/emitted
    radiation that is directly transmitted by the atmosphere,
    without absorption and scattering. \n4) Total: TOA, Sensor and
    BOA irradiance has 2 component due to the Earth surface: \n
    -Earth scene reflected/emitted radiation that is scattered by
    the atmosphere. \n -Earth scene reflected/emitted radiation that
    is directly transmitted by the atmosphere, without absorption
    and scattering. 1) None: TOA, Sensor and BOA irradiance
    irradiance has no component from Earth surface. \n2) Diffuse:
    TOA, Sensor and BOA irradiance has 1 component due to the Earth
    surface: \n -Earth scene reflected/emitted radiation that is
    scattered by the atmosphere. \n3) Direct: TOA, Sensor and BOA
    irradiance has 1 component due to the Earth surface: \n -Earth
    scene reflected/emitted radiation that is directly transmitted
    by the atmosphere, without absorption and scattering. \n4)
    Total: TOA, Sensor and BOA irradiance has 2 component due to the
    Earth surface: \n -Earth scene reflected/emitted radiation that
    is scattered by the atmosphere. \n -Earth scene
    reflected/emitted radiation that is directly transmitted by the
    atmosphere, without absorption and scattering. 1) Total: TOA,
    Sensor and BOA irradiance has 2 components due to downward sun
    radiation: \n -Sun radiation that is directly transmitted by the
    atmosphere , without absorption and scattering. \n - Direct sun
    radiation that is scattered by the atmosphere. \n There can be
    also atmosphere thermal emission and Earth scene
    reflected/emitted radiation that is possibly scattered and/or
    directly transmitted by the atmosphere. \n2) Diffuse: TOA,
    Sensor and BOA irradiance has 1 components due to downward sun
    radiation: \n - Direct sun radiation that is scattered by the
    atmosphere. \n There can be also atmosphere thermal emission and
    Earth scene reflected/emitted radiation that is possibly
    scattered and/or directly transmitted by the atmosphere. \n3)
    Direct:TOA, Sensor and BOA irradiance has 1 components due to
    downward sun radiation: \n -Sun radiation that is directly
    transmitted by the atmosphere , without absorption and
    scattering. \n There can be also Earth scene reflected/emitted
    radiation that is possibly scattered and/or directly transmitted
    by the atmosphere. 1) Total: TOA, Sensor and BOA irradiance has
    2 components due to downward sun radiation: \n -Sun radiation
    that is directly transmitted by the atmosphere , without
    absorption and scattering. \n - Direct sun radiation that is
    scattered by the atmosphere. \n There can be also atmosphere
    thermal emission and Earth scene reflected/emitted radiation
    that is possibly scattered and/or directly transmitted by the
    atmosphere. \n2) Diffuse: TOA, Sensor and BOA irradiance has 1
    components due to downward sun radiation: \n - Direct sun
    radiation that is scattered by the atmosphere. \n There can be
    also atmosphere thermal emission and Earth scene
    reflected/emitted radiation that is possibly scattered and/or
    directly transmitted by the atmosphere. \n3) Direct:TOA, Sensor
    and BOA irradiance has 1 components due to downward sun
    radiation: \n -Sun radiation that is directly transmitted by the
    atmosphere , without absorption and scattering. \n There can be
    also Earth scene reflected/emitted radiation that is possibly
    scattered and/or directly transmitted by the atmosphere."""
    member_data_items_ = [
        MemberSpec_('upwardingFluxes', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('downwardingFluxes', 'xsd:int', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, upwardingFluxes=0, downwardingFluxes=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_AtmosphereComponents')
        self.attrib = ['upwardingFluxes', 'downwardingFluxes']
        self.children = []
        self.parent = None
        self._upwardingFluxes = _cast(int, upwardingFluxes)
        self._downwardingFluxes = _cast(int, downwardingFluxes)
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_AtmosphereComponents)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_AtmosphereComponents.subclass:
            return create_AtmosphereComponents.subclass(*args_, **kwargs_)
        else:
            return create_AtmosphereComponents(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_upwardingFluxes(self): return self._upwardingFluxes
    def set_upwardingFluxes(self, value):
        self._upwardingFluxes = value
        update_node(self,self.troot,'atmosphere')
    upwardingFluxes = property(get_upwardingFluxes, set_upwardingFluxes)
    def get_downwardingFluxes(self): return self._downwardingFluxes
    def set_downwardingFluxes(self, value):
        self._downwardingFluxes = value
        update_node(self,self.troot,'atmosphere')
    downwardingFluxes = property(get_downwardingFluxes, set_downwardingFluxes)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_AtmosphereComponents', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_AtmosphereComponents')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_AtmosphereComponents')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_AtmosphereComponents', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_AtmosphereComponents'):
        if self.upwardingFluxes is not None and 'upwardingFluxes' not in already_processed:
            already_processed.add('upwardingFluxes')
            outfile.write(' upwardingFluxes="%s"' % self.gds_format_integer(self.upwardingFluxes, input_name='upwardingFluxes'))
        if self.downwardingFluxes is not None and 'downwardingFluxes' not in already_processed:
            already_processed.add('downwardingFluxes')
            outfile.write(' downwardingFluxes="%s"' % self.gds_format_integer(self.downwardingFluxes, input_name='downwardingFluxes'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_AtmosphereComponents', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_AtmosphereComponents', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.upwardingFluxes is not None:
            element.set('upwardingFluxes', self.gds_format_integer(self.upwardingFluxes))
        if self.downwardingFluxes is not None:
            element.set('downwardingFluxes', self.gds_format_integer(self.downwardingFluxes))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_AtmosphereComponents'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.upwardingFluxes is not None and 'upwardingFluxes' not in already_processed:
            already_processed.add('upwardingFluxes')
            showIndent(outfile, level)
            outfile.write('upwardingFluxes=%d,\n' % (self.upwardingFluxes,))
        if self.downwardingFluxes is not None and 'downwardingFluxes' not in already_processed:
            already_processed.add('downwardingFluxes')
            showIndent(outfile, level)
            outfile.write('downwardingFluxes=%d,\n' % (self.downwardingFluxes,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('upwardingFluxes', node)
        if value is not None and 'upwardingFluxes' not in already_processed:
            already_processed.add('upwardingFluxes')
            try:
                self.upwardingFluxes = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('downwardingFluxes', node)
        if value is not None and 'downwardingFluxes' not in already_processed:
            already_processed.add('downwardingFluxes')
            try:
                self.downwardingFluxes = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_AtmosphereComponents


class create_AtmosphereExpertModeZone(GeneratedsSuper):
    """Scattering threshold for irradiation and for transfer function
    Scattering threshold for irradiation and for transfer function
    Maximum scattering iteration number Maximum scattering iteration
    number Extrapolation over the 3 last iterations at BOA, TOA and
    Sensor level for illumination computation Extrapolation over the
    3 last iterations at BOA, TOA and Sensor level for illumination
    computation"""
    member_data_items_ = [
        MemberSpec_('threshold_Atmos_scattering', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('number_iterationMax', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('extrapol_atmos', 'xsd:int', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, threshold_Atmos_scattering=0.0001, number_iterationMax=100, extrapol_atmos=1):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_AtmosphereExpertModeZone')
        self.attrib = ['threshold_Atmos_scattering', 'number_iterationMax', 'extrapol_atmos']
        self.children = []
        self.parent = None
        self._threshold_Atmos_scattering = _cast(float, threshold_Atmos_scattering)
        self._number_iterationMax = _cast(int, number_iterationMax)
        self._extrapol_atmos = _cast(int, extrapol_atmos)
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_AtmosphereExpertModeZone)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_AtmosphereExpertModeZone.subclass:
            return create_AtmosphereExpertModeZone.subclass(*args_, **kwargs_)
        else:
            return create_AtmosphereExpertModeZone(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_threshold_Atmos_scattering(self): return self._threshold_Atmos_scattering
    def set_threshold_Atmos_scattering(self, value):
        self._threshold_Atmos_scattering = value
        update_node(self,self.troot,'atmosphere')
    threshold_Atmos_scattering = property(get_threshold_Atmos_scattering, set_threshold_Atmos_scattering)
    def get_number_iterationMax(self): return self._number_iterationMax
    def set_number_iterationMax(self, value):
        self._number_iterationMax = value
        update_node(self,self.troot,'atmosphere')
    number_iterationMax = property(get_number_iterationMax, set_number_iterationMax)
    def get_extrapol_atmos(self): return self._extrapol_atmos
    def set_extrapol_atmos(self, value):
        self._extrapol_atmos = value
        update_node(self,self.troot,'atmosphere')
    extrapol_atmos = property(get_extrapol_atmos, set_extrapol_atmos)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_AtmosphereExpertModeZone', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_AtmosphereExpertModeZone')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_AtmosphereExpertModeZone')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_AtmosphereExpertModeZone', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_AtmosphereExpertModeZone'):
        if self.threshold_Atmos_scattering is not None and 'threshold_Atmos_scattering' not in already_processed:
            already_processed.add('threshold_Atmos_scattering')
            outfile.write(' threshold_Atmos_scattering="%s"' % self.gds_format_double(self.threshold_Atmos_scattering, input_name='threshold_Atmos_scattering'))
        if self.number_iterationMax is not None and 'number_iterationMax' not in already_processed:
            already_processed.add('number_iterationMax')
            outfile.write(' number_iterationMax="%s"' % self.gds_format_integer(self.number_iterationMax, input_name='number_iterationMax'))
        if self.extrapol_atmos is not None and 'extrapol_atmos' not in already_processed:
            already_processed.add('extrapol_atmos')
            outfile.write(' extrapol_atmos="%s"' % self.gds_format_integer(self.extrapol_atmos, input_name='extrapol_atmos'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_AtmosphereExpertModeZone', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_AtmosphereExpertModeZone', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.threshold_Atmos_scattering is not None:
            element.set('threshold_Atmos_scattering', self.gds_format_double(self.threshold_Atmos_scattering))
        if self.number_iterationMax is not None:
            element.set('number_iterationMax', self.gds_format_integer(self.number_iterationMax))
        if self.extrapol_atmos is not None:
            element.set('extrapol_atmos', self.gds_format_integer(self.extrapol_atmos))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_AtmosphereExpertModeZone'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.threshold_Atmos_scattering is not None and 'threshold_Atmos_scattering' not in already_processed:
            already_processed.add('threshold_Atmos_scattering')
            showIndent(outfile, level)
            outfile.write('threshold_Atmos_scattering=%e,\n' % (self.threshold_Atmos_scattering,))
        if self.number_iterationMax is not None and 'number_iterationMax' not in already_processed:
            already_processed.add('number_iterationMax')
            showIndent(outfile, level)
            outfile.write('number_iterationMax=%d,\n' % (self.number_iterationMax,))
        if self.extrapol_atmos is not None and 'extrapol_atmos' not in already_processed:
            already_processed.add('extrapol_atmos')
            showIndent(outfile, level)
            outfile.write('extrapol_atmos=%d,\n' % (self.extrapol_atmos,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('threshold_Atmos_scattering', node)
        if value is not None and 'threshold_Atmos_scattering' not in already_processed:
            already_processed.add('threshold_Atmos_scattering')
            try:
                self.threshold_Atmos_scattering = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (threshold_Atmos_scattering): %s' % exp)
        value = find_attr_value_('number_iterationMax', node)
        if value is not None and 'number_iterationMax' not in already_processed:
            already_processed.add('number_iterationMax')
            try:
                self.number_iterationMax = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('extrapol_atmos', node)
        if value is not None and 'extrapol_atmos' not in already_processed:
            already_processed.add('extrapol_atmos')
            try:
                self.extrapol_atmos = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_AtmosphereExpertModeZone


class create_AtmosphereGeometry(GeneratedsSuper):
    """AtmosphereGeometry AtmosphereGeometry Number of integration division
    for aerosol phase function Number of integration division for
    aerosol phase function If "Automatic", the layers number depends
    on total optical depth of the first spectral band If
    "Automatic", the layers number depends on total optical depth of
    the first spectral band With the -atmosphere RT + sensor-
    options, the Sensor layer altitude is used to compute atmosphere
    upward transmittance and path radiance from the Earth scene to
    the sensor. With the -atmosphere RT + sensor- options, the
    Sensor layer altitude is used to compute atmosphere upward
    transmittance and path radiance from the Earth scene to the
    sensor."""
    member_data_items_ = [
        MemberSpec_('minimumNumberOfDivisions', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('discretisationAtmos', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('heightOfSensor', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('discretisationAtmosAuto', '_discretisationAtmosAuto', 0, 0, {u'maxOccurs': u'1', u'type': u'_discretisationAtmosAuto', u'name': u'discretisationAtmosAuto', u'minOccurs': u'1'}, None),
        MemberSpec_('MidAtmosphere', '_MidAtmosphere', 0, 0, {u'maxOccurs': u'1', u'type': u'_MidAtmosphere', u'name': u'MidAtmosphere', u'minOccurs': u'1'}, None),
        MemberSpec_('UpperAtmosphere', '_UpperAtmosphere', 0, 0, {u'maxOccurs': u'1', u'type': u'_UpperAtmosphere', u'name': u'UpperAtmosphere', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, minimumNumberOfDivisions=4, discretisationAtmos=1, heightOfSensor=3000, discretisationAtmosAuto=None, MidAtmosphere=None, UpperAtmosphere=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_AtmosphereGeometry')
        self.attrib = ['minimumNumberOfDivisions', 'discretisationAtmos', 'heightOfSensor']
        self.children = ['discretisationAtmosAuto', 'MidAtmosphere', 'UpperAtmosphere']
        self.parent = None
        self._minimumNumberOfDivisions = _cast(int, minimumNumberOfDivisions)
        self._discretisationAtmos = _cast(int, discretisationAtmos)
        self._heightOfSensor = _cast(float, heightOfSensor)
        self._discretisationAtmosAuto = discretisationAtmosAuto
        self._MidAtmosphere = MidAtmosphere
        self._UpperAtmosphere = UpperAtmosphere
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_AtmosphereGeometry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_AtmosphereGeometry.subclass:
            return create_AtmosphereGeometry.subclass(*args_, **kwargs_)
        else:
            return create_AtmosphereGeometry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_discretisationAtmosAuto(self): return self._discretisationAtmosAuto
    def set_discretisationAtmosAuto(self, value):
        if value is not None:
            checkclass(value, create_discretisationAtmosAuto)
            value.parent = self
        self._discretisationAtmosAuto = value
    discretisationAtmosAuto = property(get_discretisationAtmosAuto, set_discretisationAtmosAuto)
    def get_MidAtmosphere(self): return self._MidAtmosphere
    def set_MidAtmosphere(self, value):
        if value is not None:
            checkclass(value, create_MidAtmosphere)
            value.parent = self
        self._MidAtmosphere = value
    MidAtmosphere = property(get_MidAtmosphere, set_MidAtmosphere)
    def get_UpperAtmosphere(self): return self._UpperAtmosphere
    def set_UpperAtmosphere(self, value):
        if value is not None:
            checkclass(value, create_UpperAtmosphere)
            value.parent = self
        self._UpperAtmosphere = value
    UpperAtmosphere = property(get_UpperAtmosphere, set_UpperAtmosphere)
    def get_minimumNumberOfDivisions(self): return self._minimumNumberOfDivisions
    def set_minimumNumberOfDivisions(self, value):
        self._minimumNumberOfDivisions = value
        update_node(self,self.troot,'atmosphere')
    minimumNumberOfDivisions = property(get_minimumNumberOfDivisions, set_minimumNumberOfDivisions)
    def get_discretisationAtmos(self): return self._discretisationAtmos
    def set_discretisationAtmos(self, value):
        self._discretisationAtmos = value
        update_node(self,self.troot,'atmosphere')
    discretisationAtmos = property(get_discretisationAtmos, set_discretisationAtmos)
    def get_heightOfSensor(self): return self._heightOfSensor
    def set_heightOfSensor(self, value):
        self._heightOfSensor = value
        update_node(self,self.troot,'atmosphere')
    heightOfSensor = property(get_heightOfSensor, set_heightOfSensor)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.discretisationAtmosAuto is not None or
            self.MidAtmosphere is not None or
            self.UpperAtmosphere is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_AtmosphereGeometry', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_AtmosphereGeometry')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_AtmosphereGeometry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_AtmosphereGeometry', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_AtmosphereGeometry'):
        if self.minimumNumberOfDivisions is not None and 'minimumNumberOfDivisions' not in already_processed:
            already_processed.add('minimumNumberOfDivisions')
            outfile.write(' minimumNumberOfDivisions="%s"' % self.gds_format_integer(self.minimumNumberOfDivisions, input_name='minimumNumberOfDivisions'))
        if self.discretisationAtmos is not None and 'discretisationAtmos' not in already_processed:
            already_processed.add('discretisationAtmos')
            outfile.write(' discretisationAtmos="%s"' % self.gds_format_integer(self.discretisationAtmos, input_name='discretisationAtmos'))
        if self.heightOfSensor is not None and 'heightOfSensor' not in already_processed:
            already_processed.add('heightOfSensor')
            outfile.write(' heightOfSensor="%s"' % self.gds_format_double(self.heightOfSensor, input_name='heightOfSensor'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_AtmosphereGeometry', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.discretisationAtmosAuto is not None:
            self.discretisationAtmosAuto.export(outfile, level, namespaceprefix_, name_='discretisationAtmosAuto', pretty_print=pretty_print)
        if self.MidAtmosphere is not None:
            self.MidAtmosphere.export(outfile, level, namespaceprefix_, name_='MidAtmosphere', pretty_print=pretty_print)
        if self.UpperAtmosphere is not None:
            self.UpperAtmosphere.export(outfile, level, namespaceprefix_, name_='UpperAtmosphere', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_AtmosphereGeometry', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.minimumNumberOfDivisions is not None:
            element.set('minimumNumberOfDivisions', self.gds_format_integer(self.minimumNumberOfDivisions))
        if self.discretisationAtmos is not None:
            element.set('discretisationAtmos', self.gds_format_integer(self.discretisationAtmos))
        if self.heightOfSensor is not None:
            element.set('heightOfSensor', self.gds_format_double(self.heightOfSensor))
        if self.discretisationAtmosAuto is not None:
            discretisationAtmosAuto_ = self.discretisationAtmosAuto
            discretisationAtmosAuto_.to_etree(element, name_='discretisationAtmosAuto', mapping_=mapping_)
        if self.MidAtmosphere is not None:
            MidAtmosphere_ = self.MidAtmosphere
            MidAtmosphere_.to_etree(element, name_='MidAtmosphere', mapping_=mapping_)
        if self.UpperAtmosphere is not None:
            UpperAtmosphere_ = self.UpperAtmosphere
            UpperAtmosphere_.to_etree(element, name_='UpperAtmosphere', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_AtmosphereGeometry'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.minimumNumberOfDivisions is not None and 'minimumNumberOfDivisions' not in already_processed:
            already_processed.add('minimumNumberOfDivisions')
            showIndent(outfile, level)
            outfile.write('minimumNumberOfDivisions=%d,\n' % (self.minimumNumberOfDivisions,))
        if self.discretisationAtmos is not None and 'discretisationAtmos' not in already_processed:
            already_processed.add('discretisationAtmos')
            showIndent(outfile, level)
            outfile.write('discretisationAtmos=%d,\n' % (self.discretisationAtmos,))
        if self.heightOfSensor is not None and 'heightOfSensor' not in already_processed:
            already_processed.add('heightOfSensor')
            showIndent(outfile, level)
            outfile.write('heightOfSensor=%e,\n' % (self.heightOfSensor,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.discretisationAtmosAuto is not None:
            showIndent(outfile, level)
            outfile.write('discretisationAtmosAuto=model_._discretisationAtmosAuto(\n')
            self.discretisationAtmosAuto.exportLiteral(outfile, level, name_='discretisationAtmosAuto')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MidAtmosphere is not None:
            showIndent(outfile, level)
            outfile.write('MidAtmosphere=model_._MidAtmosphere(\n')
            self.MidAtmosphere.exportLiteral(outfile, level, name_='MidAtmosphere')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.UpperAtmosphere is not None:
            showIndent(outfile, level)
            outfile.write('UpperAtmosphere=model_._UpperAtmosphere(\n')
            self.UpperAtmosphere.exportLiteral(outfile, level, name_='UpperAtmosphere')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minimumNumberOfDivisions', node)
        if value is not None and 'minimumNumberOfDivisions' not in already_processed:
            already_processed.add('minimumNumberOfDivisions')
            try:
                self.minimumNumberOfDivisions = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('discretisationAtmos', node)
        if value is not None and 'discretisationAtmos' not in already_processed:
            already_processed.add('discretisationAtmos')
            try:
                self.discretisationAtmos = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('heightOfSensor', node)
        if value is not None and 'heightOfSensor' not in already_processed:
            already_processed.add('heightOfSensor')
            try:
                self.heightOfSensor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (heightOfSensor): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'discretisationAtmosAuto':
            obj_ = create_discretisationAtmosAuto.factory()
            obj_.build(child_)
            self.set_discretisationAtmosAuto(obj_)
            obj_.original_tagname_ = 'discretisationAtmosAuto'
        elif nodeName_ == 'MidAtmosphere':
            obj_ = create_MidAtmosphere.factory()
            obj_.build(child_)
            self.set_MidAtmosphere(obj_)
            obj_.original_tagname_ = 'MidAtmosphere'
        elif nodeName_ == 'UpperAtmosphere':
            obj_ = create_UpperAtmosphere.factory()
            obj_.build(child_)
            self.set_UpperAtmosphere(obj_)
            obj_.original_tagname_ = 'UpperAtmosphere'
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_AtmosphereGeometry


class create_discretisationAtmosAuto(GeneratedsSuper):
    """Theoretical relative error on TOA reflectance to be found, resulting
    of atmosphere discretisation Theoretical relative error on TOA
    reflectance to be found, resulting of atmosphere discretisation
    Dimension in x of the MA cells\nAdvice: Smaller cell dimensions
    and layer depth increase accuracy and computation time\n Better
    and faster results if the number of BA cells is a multiple of
    the number of MA cells (on x and y) Dimension in x of the MA
    cells\nAdvice: Smaller cell dimensions and layer depth increase
    accuracy and computation time\n Better and faster results if the
    number of BA cells is a multiple of the number of MA cells (on x
    and y) percentage of MA contribution on BOA reflectance (for
    backscattering) percentage of MA contribution on BOA reflectance
    (for backscattering) Dimension in y of the MA cells\nAdvice:
    Smaller cell dimensions and layer depth increase accuracy and
    computation time\n Better and faster results if the number of BA
    cells is a multiple of the number of MA cells (on x and y)
    Dimension in y of the MA cells\nAdvice: Smaller cell dimensions
    and layer depth increase accuracy and computation time\n Better
    and faster results if the number of BA cells is a multiple of
    the number of MA cells (on x and y)"""
    member_data_items_ = [
        MemberSpec_('epsilon_atmos', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('xAI', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('gamma_atmos', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('yAI', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, epsilon_atmos=0.003, xAI=400.0, gamma_atmos=0.95, yAI=400.0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_discretisationAtmosAuto')
        self.attrib = ['epsilon_atmos', 'xAI', 'gamma_atmos', 'yAI']
        self.children = []
        self.parent = None
        self._epsilon_atmos = _cast(float, epsilon_atmos)
        self._xAI = _cast(float, xAI)
        self._gamma_atmos = _cast(float, gamma_atmos)
        self._yAI = _cast(float, yAI)
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_discretisationAtmosAuto)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_discretisationAtmosAuto.subclass:
            return create_discretisationAtmosAuto.subclass(*args_, **kwargs_)
        else:
            return create_discretisationAtmosAuto(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_epsilon_atmos(self): return self._epsilon_atmos
    def set_epsilon_atmos(self, value):
        self._epsilon_atmos = value
        update_node(self,self.troot,'atmosphere')
    epsilon_atmos = property(get_epsilon_atmos, set_epsilon_atmos)
    def get_xAI(self): return self._xAI
    def set_xAI(self, value):
        self._xAI = value
        update_node(self,self.troot,'atmosphere')
    xAI = property(get_xAI, set_xAI)
    def get_gamma_atmos(self): return self._gamma_atmos
    def set_gamma_atmos(self, value):
        self._gamma_atmos = value
        update_node(self,self.troot,'atmosphere')
    gamma_atmos = property(get_gamma_atmos, set_gamma_atmos)
    def get_yAI(self): return self._yAI
    def set_yAI(self, value):
        self._yAI = value
        update_node(self,self.troot,'atmosphere')
    yAI = property(get_yAI, set_yAI)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_discretisationAtmosAuto', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_discretisationAtmosAuto')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_discretisationAtmosAuto')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_discretisationAtmosAuto', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_discretisationAtmosAuto'):
        if self.epsilon_atmos is not None and 'epsilon_atmos' not in already_processed:
            already_processed.add('epsilon_atmos')
            outfile.write(' epsilon_atmos="%s"' % self.gds_format_double(self.epsilon_atmos, input_name='epsilon_atmos'))
        if self.xAI is not None and 'xAI' not in already_processed:
            already_processed.add('xAI')
            outfile.write(' xAI="%s"' % self.gds_format_double(self.xAI, input_name='xAI'))
        if self.gamma_atmos is not None and 'gamma_atmos' not in already_processed:
            already_processed.add('gamma_atmos')
            outfile.write(' gamma_atmos="%s"' % self.gds_format_double(self.gamma_atmos, input_name='gamma_atmos'))
        if self.yAI is not None and 'yAI' not in already_processed:
            already_processed.add('yAI')
            outfile.write(' yAI="%s"' % self.gds_format_double(self.yAI, input_name='yAI'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_discretisationAtmosAuto', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_discretisationAtmosAuto', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.epsilon_atmos is not None:
            element.set('epsilon_atmos', self.gds_format_double(self.epsilon_atmos))
        if self.xAI is not None:
            element.set('xAI', self.gds_format_double(self.xAI))
        if self.gamma_atmos is not None:
            element.set('gamma_atmos', self.gds_format_double(self.gamma_atmos))
        if self.yAI is not None:
            element.set('yAI', self.gds_format_double(self.yAI))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_discretisationAtmosAuto'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.epsilon_atmos is not None and 'epsilon_atmos' not in already_processed:
            already_processed.add('epsilon_atmos')
            showIndent(outfile, level)
            outfile.write('epsilon_atmos=%e,\n' % (self.epsilon_atmos,))
        if self.xAI is not None and 'xAI' not in already_processed:
            already_processed.add('xAI')
            showIndent(outfile, level)
            outfile.write('xAI=%e,\n' % (self.xAI,))
        if self.gamma_atmos is not None and 'gamma_atmos' not in already_processed:
            already_processed.add('gamma_atmos')
            showIndent(outfile, level)
            outfile.write('gamma_atmos=%e,\n' % (self.gamma_atmos,))
        if self.yAI is not None and 'yAI' not in already_processed:
            already_processed.add('yAI')
            showIndent(outfile, level)
            outfile.write('yAI=%e,\n' % (self.yAI,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('epsilon_atmos', node)
        if value is not None and 'epsilon_atmos' not in already_processed:
            already_processed.add('epsilon_atmos')
            try:
                self.epsilon_atmos = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (epsilon_atmos): %s' % exp)
        value = find_attr_value_('xAI', node)
        if value is not None and 'xAI' not in already_processed:
            already_processed.add('xAI')
            try:
                self.xAI = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (xAI): %s' % exp)
        value = find_attr_value_('gamma_atmos', node)
        if value is not None and 'gamma_atmos' not in already_processed:
            already_processed.add('gamma_atmos')
            try:
                self.gamma_atmos = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (gamma_atmos): %s' % exp)
        value = find_attr_value_('yAI', node)
        if value is not None and 'yAI' not in already_processed:
            already_processed.add('yAI')
            try:
                self.yAI = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (yAI): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_discretisationAtmosAuto


class create_MidAtmosphere(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('CellDimensions', '_CellDimensions', 0, 0, {u'maxOccurs': u'1', u'type': u'_CellDimensions', u'name': u'CellDimensions', u'minOccurs': u'1'}, None),
        MemberSpec_('Height', '_Height', 0, 0, {u'maxOccurs': u'1', u'type': u'_Height', u'name': u'Height', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, CellDimensions=None, Height=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_MidAtmosphere')
        self.attrib = ['']
        self.children = ['CellDimensions', 'Height']
        self.parent = None
        self._CellDimensions = CellDimensions
        self._Height = Height
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_MidAtmosphere)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_MidAtmosphere.subclass:
            return create_MidAtmosphere.subclass(*args_, **kwargs_)
        else:
            return create_MidAtmosphere(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CellDimensions(self): return self._CellDimensions
    def set_CellDimensions(self, value):
        if value is not None:
            checkclass(value, create_CellDimensions)
            value.parent = self
        self._CellDimensions = value
    CellDimensions = property(get_CellDimensions, set_CellDimensions)
    def get_Height(self): return self._Height
    def set_Height(self, value):
        if value is not None:
            checkclass(value, create_Height)
            value.parent = self
        self._Height = value
    Height = property(get_Height, set_Height)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.CellDimensions is not None or
            self.Height is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_MidAtmosphere', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_MidAtmosphere')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_MidAtmosphere')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_MidAtmosphere', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_MidAtmosphere'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_MidAtmosphere', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CellDimensions is not None:
            self.CellDimensions.export(outfile, level, namespaceprefix_, name_='CellDimensions', pretty_print=pretty_print)
        if self.Height is not None:
            self.Height.export(outfile, level, namespaceprefix_, name_='Height', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_MidAtmosphere', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.CellDimensions is not None:
            CellDimensions_ = self.CellDimensions
            CellDimensions_.to_etree(element, name_='CellDimensions', mapping_=mapping_)
        if self.Height is not None:
            Height_ = self.Height
            Height_.to_etree(element, name_='Height', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_MidAtmosphere'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CellDimensions is not None:
            showIndent(outfile, level)
            outfile.write('CellDimensions=model_._CellDimensions(\n')
            self.CellDimensions.exportLiteral(outfile, level, name_='CellDimensions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Height is not None:
            showIndent(outfile, level)
            outfile.write('Height=model_._Height(\n')
            self.Height.exportLiteral(outfile, level, name_='Height')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CellDimensions':
            obj_ = create_CellDimensions.factory()
            obj_.build(child_)
            self.set_CellDimensions(obj_)
            obj_.original_tagname_ = 'CellDimensions'
        elif nodeName_ == 'Height':
            obj_ = create_Height.factory()
            obj_.build(child_)
            self.set_Height(obj_)
            obj_.original_tagname_ = 'Height'
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_MidAtmosphere


class create_CellDimensions(GeneratedsSuper):
    """Dimension in x of the MA cells\nAdvice: Smaller cell dimensions and
    layer depth increase accuracy and computation time\n Better and
    faster results if the number of BA cells is a multiple of the
    number of MA cells (on x and y) Dimension in x of the MA
    cells\nAdvice: Smaller cell dimensions and layer depth increase
    accuracy and computation time\n Better and faster results if the
    number of BA cells is a multiple of the number of MA cells (on x
    and y) Dimension in y of the MA cells\nAdvice: Smaller cell
    dimensions and layer depth increase accuracy and computation
    time\n Better and faster results if the number of BA cells is a
    multiple of the number of MA cells (on x and y) Dimension in y
    of the MA cells\nAdvice: Smaller cell dimensions and layer depth
    increase accuracy and computation time\n Better and faster
    results if the number of BA cells is a multiple of the number of
    MA cells (on x and y) Dimension in z of the MA cells\nAdvice:
    Smaller cell dimensions and layer depth increase accuracy and
    computation time Dimension in z of the MA cells\nAdvice: Smaller
    cell dimensions and layer depth increase accuracy and
    computation time"""
    member_data_items_ = [
        MemberSpec_('xAI', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('yAI', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('zAI', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, xAI=100.0, yAI=100.0, zAI=500.0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_CellDimensions')
        self.attrib = ['xAI', 'yAI', 'zAI']
        self.children = []
        self.parent = None
        self._xAI = _cast(float, xAI)
        self._yAI = _cast(float, yAI)
        self._zAI = _cast(float, zAI)
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_CellDimensions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_CellDimensions.subclass:
            return create_CellDimensions.subclass(*args_, **kwargs_)
        else:
            return create_CellDimensions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xAI(self): return self._xAI
    def set_xAI(self, value):
        self._xAI = value
        update_node(self,self.troot,'atmosphere')
    xAI = property(get_xAI, set_xAI)
    def get_yAI(self): return self._yAI
    def set_yAI(self, value):
        self._yAI = value
        update_node(self,self.troot,'atmosphere')
    yAI = property(get_yAI, set_yAI)
    def get_zAI(self): return self._zAI
    def set_zAI(self, value):
        self._zAI = value
        update_node(self,self.troot,'atmosphere')
    zAI = property(get_zAI, set_zAI)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_CellDimensions', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_CellDimensions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_CellDimensions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_CellDimensions', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_CellDimensions'):
        if self.xAI is not None and 'xAI' not in already_processed:
            already_processed.add('xAI')
            outfile.write(' xAI="%s"' % self.gds_format_double(self.xAI, input_name='xAI'))
        if self.yAI is not None and 'yAI' not in already_processed:
            already_processed.add('yAI')
            outfile.write(' yAI="%s"' % self.gds_format_double(self.yAI, input_name='yAI'))
        if self.zAI is not None and 'zAI' not in already_processed:
            already_processed.add('zAI')
            outfile.write(' zAI="%s"' % self.gds_format_double(self.zAI, input_name='zAI'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_CellDimensions', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_CellDimensions', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.xAI is not None:
            element.set('xAI', self.gds_format_double(self.xAI))
        if self.yAI is not None:
            element.set('yAI', self.gds_format_double(self.yAI))
        if self.zAI is not None:
            element.set('zAI', self.gds_format_double(self.zAI))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_CellDimensions'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.xAI is not None and 'xAI' not in already_processed:
            already_processed.add('xAI')
            showIndent(outfile, level)
            outfile.write('xAI=%e,\n' % (self.xAI,))
        if self.yAI is not None and 'yAI' not in already_processed:
            already_processed.add('yAI')
            showIndent(outfile, level)
            outfile.write('yAI=%e,\n' % (self.yAI,))
        if self.zAI is not None and 'zAI' not in already_processed:
            already_processed.add('zAI')
            showIndent(outfile, level)
            outfile.write('zAI=%e,\n' % (self.zAI,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xAI', node)
        if value is not None and 'xAI' not in already_processed:
            already_processed.add('xAI')
            try:
                self.xAI = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (xAI): %s' % exp)
        value = find_attr_value_('yAI', node)
        if value is not None and 'yAI' not in already_processed:
            already_processed.add('yAI')
            try:
                self.yAI = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (yAI): %s' % exp)
        value = find_attr_value_('zAI', node)
        if value is not None and 'zAI' not in already_processed:
            already_processed.add('zAI')
            try:
                self.zAI = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (zAI): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_CellDimensions


class create_Height(GeneratedsSuper):
    """Number of MA layers Number of MA layers"""
    member_data_items_ = [
        MemberSpec_('hCFAI', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, hCFAI=4000.0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_Height')
        self.attrib = ['hCFAI']
        self.children = []
        self.parent = None
        self._hCFAI = _cast(float, hCFAI)
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Height)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Height.subclass:
            return create_Height.subclass(*args_, **kwargs_)
        else:
            return create_Height(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hCFAI(self): return self._hCFAI
    def set_hCFAI(self, value):
        self._hCFAI = value
        update_node(self,self.troot,'atmosphere')
    hCFAI = property(get_hCFAI, set_hCFAI)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Height', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Height')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Height')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Height', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Height'):
        if self.hCFAI is not None and 'hCFAI' not in already_processed:
            already_processed.add('hCFAI')
            outfile.write(' hCFAI="%s"' % self.gds_format_double(self.hCFAI, input_name='hCFAI'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Height', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_Height', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.hCFAI is not None:
            element.set('hCFAI', self.gds_format_double(self.hCFAI))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Height'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.hCFAI is not None and 'hCFAI' not in already_processed:
            already_processed.add('hCFAI')
            showIndent(outfile, level)
            outfile.write('hCFAI=%e,\n' % (self.hCFAI,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hCFAI', node)
        if value is not None and 'hCFAI' not in already_processed:
            already_processed.add('hCFAI')
            try:
                self.hCFAI = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (hCFAI): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_Height


class create_UpperAtmosphere(GeneratedsSuper):
    """smaller computer times. smaller computer times."""
    member_data_items_ = [
        MemberSpec_('hCFHA', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('Layer', '_Layer', 0, 0, {u'maxOccurs': u'1', u'type': u'_Layer', u'name': u'Layer', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, hCFHA=80000.0, Layer=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_UpperAtmosphere')
        self.attrib = ['hCFHA']
        self.children = ['Layer']
        self.parent = None
        self._hCFHA = _cast(float, hCFHA)
        self._Layer = Layer
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_UpperAtmosphere)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_UpperAtmosphere.subclass:
            return create_UpperAtmosphere.subclass(*args_, **kwargs_)
        else:
            return create_UpperAtmosphere(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Layer(self): return self._Layer
    def set_Layer(self, value):
        if value is not None:
            checkclass(value, create_Layer)
            value.parent = self
        self._Layer = value
    Layer = property(get_Layer, set_Layer)
    def get_hCFHA(self): return self._hCFHA
    def set_hCFHA(self, value):
        self._hCFHA = value
        update_node(self,self.troot,'atmosphere')
    hCFHA = property(get_hCFHA, set_hCFHA)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Layer is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_UpperAtmosphere', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_UpperAtmosphere')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_UpperAtmosphere')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_UpperAtmosphere', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_UpperAtmosphere'):
        if self.hCFHA is not None and 'hCFHA' not in already_processed:
            already_processed.add('hCFHA')
            outfile.write(' hCFHA="%s"' % self.gds_format_double(self.hCFHA, input_name='hCFHA'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_UpperAtmosphere', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Layer is not None:
            self.Layer.export(outfile, level, namespaceprefix_, name_='Layer', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_UpperAtmosphere', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.hCFHA is not None:
            element.set('hCFHA', self.gds_format_double(self.hCFHA))
        if self.Layer is not None:
            Layer_ = self.Layer
            Layer_.to_etree(element, name_='Layer', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_UpperAtmosphere'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.hCFHA is not None and 'hCFHA' not in already_processed:
            already_processed.add('hCFHA')
            showIndent(outfile, level)
            outfile.write('hCFHA=%e,\n' % (self.hCFHA,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Layer is not None:
            showIndent(outfile, level)
            outfile.write('Layer=model_._Layer(\n')
            self.Layer.exportLiteral(outfile, level, name_='Layer')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hCFHA', node)
        if value is not None and 'hCFHA' not in already_processed:
            already_processed.add('hCFHA')
            try:
                self.hCFHA = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (hCFHA): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Layer':
            obj_ = create_Layer.factory()
            obj_.build(child_)
            self.set_Layer(obj_)
            obj_.original_tagname_ = 'Layer'
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_UpperAtmosphere


class create_Layer(GeneratedsSuper):
    """smaller computer times. smaller computer times."""
    member_data_items_ = [
        MemberSpec_('zHA', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, zHA=2000.0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('atmosphere','_Layer')
        self.attrib = ['zHA']
        self.children = []
        self.parent = None
        self._zHA = _cast(float, zHA)
        update_node(self,self.troot,'atmosphere')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Layer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Layer.subclass:
            return create_Layer.subclass(*args_, **kwargs_)
        else:
            return create_Layer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_zHA(self): return self._zHA
    def set_zHA(self, value):
        self._zHA = value
        update_node(self,self.troot,'atmosphere')
    zHA = property(get_zHA, set_zHA)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Layer', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Layer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Layer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Layer', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Layer'):
        if self.zHA is not None and 'zHA' not in already_processed:
            already_processed.add('zHA')
            outfile.write(' zHA="%s"' % self.gds_format_double(self.zHA, input_name='zHA'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Layer', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_Layer', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.zHA is not None:
            element.set('zHA', self.gds_format_double(self.zHA))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Layer'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.zHA is not None and 'zHA' not in already_processed:
            already_processed.add('zHA')
            showIndent(outfile, level)
            outfile.write('zHA=%e,\n' % (self.zHA,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('zHA', node)
        if value is not None and 'zHA' not in already_processed:
            already_processed.add('zHA')
            try:
                self.zHA = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (zHA): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
    # end class create_Layer


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <createParser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from atmosphere import *\n\n')
        sys.stdout.write('import atmosphere as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "createDartFile",
    "create_Aerosol",
    "create_AerosolProperties",
    "create_Amount_atm_cm",
    "create_Amount_g_per_cm2",
    "create_Atmosphere",
    "create_AtmosphereComponents",
    "create_AtmosphereExpertModeZone",
    "create_AtmosphereGeometry",
    "create_AtmosphereIterations",
    "create_AtmosphereProducts",
    "create_AtmosphereTransfertFunctions",
    "create_AtmosphericOpticalProperty",
    "create_AtmosphericOpticalPropertyModel",
    "create_CellDimensions",
    "create_ComputedTransferFunctions",
    "create_Density_RH_temp_altitude",
    "create_Density_atm_cm_per_km_altitude",
    "create_Height",
    "create_ImportedTransferFunctions",
    "create_IsAtmosphere",
    "create_Layer",
    "create_M_factor",
    "create_MidAtmosphere",
    "create_OtherGasesScale",
    "create_TemperatureFile",
    "create_UpperAtmosphere",
    "create_WaterAmount",
    "create_discretisationAtmosAuto",
    "create_fillH2O",
    "create_h2oDef",
    "create_ignoredGas",
    "create_isRadiativeTransfertInBottomAtmosphere",
    "create_tempParameters"
]
