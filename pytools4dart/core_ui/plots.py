#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Jan 30 01:18:11 2019 by generateDS.py version 2.29.25.
# Python 2.7.3 (default, Oct 26 2016, 21:01:49)  [GCC 4.6.3]
#
# Command line options:
#   ('-m', '')
#   ('-f', '')
#   ('--always-export-default', '')
#   ('--export', 'write literal etree')
#   ('-u', 'core_ui.user_methods')
#   ('-p', 'create')
#   ('--post-attrib-setter', "update_node(self,self.troot,'plots')")
#   ('--pre-ctor', "self.troot=get_gs_troot('plots','{classname}')")
#   ('--post-ctor', "update_node(self,self.troot,'plots')")
#   ('--imports', 'from pytools4dart.core_ui.utils import get_gs_troot, update_node, get_path')
#   ('-o', '/media/DATA/Florian/IRSTEA/Scripts/pytools4dartMTD/pytools4dart/core_ui/plots.py')
#
# Command line arguments:
#   /media/DATA/Florian/IRSTEA/Scripts/pytools4dartMTD/pytools4dart/xsdschemas/plots.xsd
#
# Command line:
#   /media/DATA/Florian/IRSTEA/Scripts/pytools4dartMTD/venv/bin/generateDS.py -m -f --always-export-default --export="write literal etree" -u "core_ui.user_methods" -p "create" --post-attrib-setter="update_node(self,self.troot,'plots')" --pre-ctor="self.troot=get_gs_troot('plots','{classname}')" --post-ctor="update_node(self,self.troot,'plots')" --imports="from pytools4dart.core_ui.utils import get_gs_troot, update_node, get_path" -o "/media/DATA/Florian/IRSTEA/Scripts/pytools4dartMTD/pytools4dart/core_ui/plots.py" /media/DATA/Florian/IRSTEA/Scripts/pytools4dartMTD/pytools4dart/xsdschemas/plots.xsd
#
# Current working directory (os.getcwd()):
#   pytools4dart
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_
from pytools4dart.core_ui.utils import get_gs_troot, update_node, get_path


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#

def checkclass(value, cl):
    if isinstance(value, list):
        for v in value:
            if not isinstance(v, cl):
                raise ValueError("invalid class")
    else:
        if not isinstance(value, cl):
            raise ValueError("invalid class")

def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class createDartFile(GeneratedsSuper):
    """Version of the plots.xml file. Depends of the version on DART
    itself. Version of the plots.xml file. Depends of the version on
    DART itself."""
    member_data_items_ = [
        MemberSpec_('version', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('build_', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('Plots', '_Plots', 0, 0, {u'maxOccurs': u'1', u'type': u'_Plots', u'name': u'Plots', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, version='5.7.4', build_='0', Plots=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('plots','DartFile')
        self.attrib = ['version', 'build_']
        self.children = ['Plots']
        self.parent = None
        self._version = _cast(None, version)
        self._build_ = _cast(None, build_)
        self._Plots = Plots
        update_node(self,self.troot,'plots')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, createDartFile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if createDartFile.subclass:
            return createDartFile.subclass(*args_, **kwargs_)
        else:
            return createDartFile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Plots(self): return self._Plots
    def set_Plots(self, value):
        if value is not None:
            checkclass(value, create_Plots)
            value.parent = self
        self._Plots = value
    Plots = property(get_Plots, set_Plots)
    def get_version(self): return self._version
    def set_version(self, value):
        self._version = value
        update_node(self,self.troot,'plots')
    version = property(get_version, set_version)
    def get_build(self): return self._build_
    def set_build(self, value):
        self._build_ = value
        update_node(self,self.troot,'plots')
    build_ = property(get_build, set_build)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Plots is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='DartFile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DartFile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DartFile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='DartFile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DartFile'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
        if self.build_ is not None and 'build_' not in already_processed:
            already_processed.add('build_')
            outfile.write(' build=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.build_), input_name='build')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='DartFile', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Plots is not None:
            self.Plots.export(outfile, level, namespaceprefix_, name_='Plots', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='DartFile', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.version is not None:
            element.set('version', self.gds_format_string(self.version))
        if self.build_ is not None:
            element.set('build', self.gds_format_string(self.build_))
        if self.Plots is not None:
            Plots_ = self.Plots
            Plots_.to_etree(element, name_='Plots', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='DartFile'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.build_ is not None and 'build_' not in already_processed:
            already_processed.add('build_')
            showIndent(outfile, level)
            outfile.write('build_="%s",\n' % (self.build_,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Plots is not None:
            showIndent(outfile, level)
            outfile.write('Plots=model_._Plots(\n')
            self.Plots.exportLiteral(outfile, level, name_='Plots')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('build', node)
        if value is not None and 'build' not in already_processed:
            already_processed.add('build')
            self.build_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Plots':
            obj_ = create_Plots.factory()
            obj_.build(child_)
            self.set_Plots(obj_)
            obj_.original_tagname_ = 'Plots'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class createDartFile


class create_Plots(GeneratedsSuper):
    """Contains the description of the working environment for the
    Vegetation module. Contains also the list of the plots for the
    simulation and their optical(s) property(ies). Contains the
    description of the working environment for the Vegetation
    module. Contains also the list of the plots for the simulation
    and their optical(s) property(ies). Indicate if there is
    information for the module Vegetation. 1 if the user wants to
    use the Vegetation module, 0 otherwise. Indicate if there is
    information for the module Vegetation. 1 if the user wants to
    use the Vegetation module, 0 otherwise. Choose if you want to
    add an extra plot file Choose if you want to add an extra plot
    file"""
    member_data_items_ = [
        MemberSpec_('isVegetation', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('addExtraPlotsTextFile', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('ExtraPlotsTextFileDefinition', '_ExtraPlotsTextFileDefinition', 0, 0, {u'maxOccurs': u'1', u'type': u'_ExtraPlotsTextFileDefinition', u'name': u'ExtraPlotsTextFileDefinition', u'minOccurs': u'1'}, None),
        MemberSpec_('ImportationFichierRaster', '_ImportationFichierRaster', 0, 0, {u'maxOccurs': u'1', u'type': u'_ImportationFichierRaster', u'name': u'ImportationFichierRaster', u'minOccurs': u'1'}, None),
        MemberSpec_('Plot', '_Plot', 1, 1, {u'maxOccurs': u'unbounded', u'type': u'_Plot', u'name': u'Plot', u'minOccurs': u'0'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, isVegetation=0, addExtraPlotsTextFile=0, ExtraPlotsTextFileDefinition=None, ImportationFichierRaster=None, Plot=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('plots','_Plots')
        self.attrib = ['isVegetation', 'addExtraPlotsTextFile']
        self.children = ['ExtraPlotsTextFileDefinition', 'ImportationFichierRaster', 'Plot']
        self.parent = None
        self._isVegetation = _cast(int, isVegetation)
        self._addExtraPlotsTextFile = _cast(int, addExtraPlotsTextFile)
        self._ExtraPlotsTextFileDefinition = ExtraPlotsTextFileDefinition
        self._ImportationFichierRaster = ImportationFichierRaster
        if Plot is None:
            self._Plot = []
        else:
            self._Plot = Plot
        update_node(self,self.troot,'plots')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Plots)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Plots.subclass:
            return create_Plots.subclass(*args_, **kwargs_)
        else:
            return create_Plots(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ExtraPlotsTextFileDefinition(self): return self._ExtraPlotsTextFileDefinition
    def set_ExtraPlotsTextFileDefinition(self, value):
        if value is not None:
            checkclass(value, create_ExtraPlotsTextFileDefinition)
            value.parent = self
        self._ExtraPlotsTextFileDefinition = value
    ExtraPlotsTextFileDefinition = property(get_ExtraPlotsTextFileDefinition, set_ExtraPlotsTextFileDefinition)
    def get_ImportationFichierRaster(self): return self._ImportationFichierRaster
    def set_ImportationFichierRaster(self, value):
        if value is not None:
            checkclass(value, create_ImportationFichierRaster)
            value.parent = self
        self._ImportationFichierRaster = value
    ImportationFichierRaster = property(get_ImportationFichierRaster, set_ImportationFichierRaster)
    def get_Plot(self): return self._Plot
    def set_Plot(self, value):
        if value is not None:
            checkclass(value, create_Plot)
            for v in value:
                v.parent = self
        self._Plot = value
    def add_Plot(self, value):
        value.parent = self
        self._Plot.append(value)
    def insert_Plot_at(self, index, value):
        value.parent = self
        self.Plot.insert(index, value)
    def replace_Plot_at(self, index, value):
        value.parent = self
        self.Plot[index] = value
    Plot = property(get_Plot, set_Plot)
    def get_isVegetation(self): return self._isVegetation
    def set_isVegetation(self, value):
        self._isVegetation = value
        update_node(self,self.troot,'plots')
    isVegetation = property(get_isVegetation, set_isVegetation)
    def get_addExtraPlotsTextFile(self): return self._addExtraPlotsTextFile
    def set_addExtraPlotsTextFile(self, value):
        self._addExtraPlotsTextFile = value
        update_node(self,self.troot,'plots')
    addExtraPlotsTextFile = property(get_addExtraPlotsTextFile, set_addExtraPlotsTextFile)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.ExtraPlotsTextFileDefinition is not None or
            self.ImportationFichierRaster is not None or
            self.Plot
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Plots', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Plots')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Plots')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Plots', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Plots'):
        if self.isVegetation is not None and 'isVegetation' not in already_processed:
            already_processed.add('isVegetation')
            outfile.write(' isVegetation="%s"' % self.gds_format_integer(self.isVegetation, input_name='isVegetation'))
        if self.addExtraPlotsTextFile is not None and 'addExtraPlotsTextFile' not in already_processed:
            already_processed.add('addExtraPlotsTextFile')
            outfile.write(' addExtraPlotsTextFile="%s"' % self.gds_format_integer(self.addExtraPlotsTextFile, input_name='addExtraPlotsTextFile'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Plots', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ExtraPlotsTextFileDefinition is not None:
            self.ExtraPlotsTextFileDefinition.export(outfile, level, namespaceprefix_, name_='ExtraPlotsTextFileDefinition', pretty_print=pretty_print)
        if self.ImportationFichierRaster is not None:
            self.ImportationFichierRaster.export(outfile, level, namespaceprefix_, name_='ImportationFichierRaster', pretty_print=pretty_print)
        for Plot_ in self.Plot:
            Plot_.export(outfile, level, namespaceprefix_, name_='Plot', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Plots', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.isVegetation is not None:
            element.set('isVegetation', self.gds_format_integer(self.isVegetation))
        if self.addExtraPlotsTextFile is not None:
            element.set('addExtraPlotsTextFile', self.gds_format_integer(self.addExtraPlotsTextFile))
        if self.ExtraPlotsTextFileDefinition is not None:
            ExtraPlotsTextFileDefinition_ = self.ExtraPlotsTextFileDefinition
            ExtraPlotsTextFileDefinition_.to_etree(element, name_='ExtraPlotsTextFileDefinition', mapping_=mapping_)
        if self.ImportationFichierRaster is not None:
            ImportationFichierRaster_ = self.ImportationFichierRaster
            ImportationFichierRaster_.to_etree(element, name_='ImportationFichierRaster', mapping_=mapping_)
        for Plot_ in self.Plot:
            Plot_.to_etree(element, name_='Plot', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Plots'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isVegetation is not None and 'isVegetation' not in already_processed:
            already_processed.add('isVegetation')
            showIndent(outfile, level)
            outfile.write('isVegetation=%d,\n' % (self.isVegetation,))
        if self.addExtraPlotsTextFile is not None and 'addExtraPlotsTextFile' not in already_processed:
            already_processed.add('addExtraPlotsTextFile')
            showIndent(outfile, level)
            outfile.write('addExtraPlotsTextFile=%d,\n' % (self.addExtraPlotsTextFile,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ExtraPlotsTextFileDefinition is not None:
            showIndent(outfile, level)
            outfile.write('ExtraPlotsTextFileDefinition=model_._ExtraPlotsTextFileDefinition(\n')
            self.ExtraPlotsTextFileDefinition.exportLiteral(outfile, level, name_='ExtraPlotsTextFileDefinition')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ImportationFichierRaster is not None:
            showIndent(outfile, level)
            outfile.write('ImportationFichierRaster=model_._ImportationFichierRaster(\n')
            self.ImportationFichierRaster.exportLiteral(outfile, level, name_='ImportationFichierRaster')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Plot=[\n')
        level += 1
        for Plot_ in self.Plot:
            showIndent(outfile, level)
            outfile.write('model_._Plot(\n')
            Plot_.exportLiteral(outfile, level, name_='_Plot')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.Plot = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isVegetation', node)
        if value is not None and 'isVegetation' not in already_processed:
            already_processed.add('isVegetation')
            try:
                self.isVegetation = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('addExtraPlotsTextFile', node)
        if value is not None and 'addExtraPlotsTextFile' not in already_processed:
            already_processed.add('addExtraPlotsTextFile')
            try:
                self.addExtraPlotsTextFile = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExtraPlotsTextFileDefinition':
            obj_ = create_ExtraPlotsTextFileDefinition.factory()
            obj_.build(child_)
            self.set_ExtraPlotsTextFileDefinition(obj_)
            obj_.original_tagname_ = 'ExtraPlotsTextFileDefinition'
        elif nodeName_ == 'ImportationFichierRaster':
            obj_ = create_ImportationFichierRaster.factory()
            obj_.build(child_)
            self.set_ImportationFichierRaster(obj_)
            obj_.original_tagname_ = 'ImportationFichierRaster'
        elif nodeName_ == 'Plot':
            obj_ = create_Plot.factory()
            obj_.build(child_)
            self.add_Plot(obj_)
            obj_.original_tagname_ = 'Plot'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_Plots


class create_ExtraPlotsTextFileDefinition(GeneratedsSuper):
    """Extra plot file definition Extra plot file definition Path to extra
    plot file Path to extra plot file"""
    member_data_items_ = [
        MemberSpec_('extraPlotsFileName', 'xsd:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, extraPlotsFileName='plots.txt'):
        self.original_tagname_ = None
        self.troot=get_gs_troot('plots','_ExtraPlotsTextFileDefinition')
        self.attrib = ['extraPlotsFileName']
        self.children = []
        self.parent = None
        self._extraPlotsFileName = _cast(None, extraPlotsFileName)
        update_node(self,self.troot,'plots')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ExtraPlotsTextFileDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ExtraPlotsTextFileDefinition.subclass:
            return create_ExtraPlotsTextFileDefinition.subclass(*args_, **kwargs_)
        else:
            return create_ExtraPlotsTextFileDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extraPlotsFileName(self): return self._extraPlotsFileName
    def set_extraPlotsFileName(self, value):
        self._extraPlotsFileName = value
        update_node(self,self.troot,'plots')
    extraPlotsFileName = property(get_extraPlotsFileName, set_extraPlotsFileName)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ExtraPlotsTextFileDefinition', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ExtraPlotsTextFileDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ExtraPlotsTextFileDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ExtraPlotsTextFileDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ExtraPlotsTextFileDefinition'):
        if self.extraPlotsFileName is not None and 'extraPlotsFileName' not in already_processed:
            already_processed.add('extraPlotsFileName')
            outfile.write(' extraPlotsFileName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.extraPlotsFileName), input_name='extraPlotsFileName')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ExtraPlotsTextFileDefinition', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_ExtraPlotsTextFileDefinition', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.extraPlotsFileName is not None:
            element.set('extraPlotsFileName', self.gds_format_string(self.extraPlotsFileName))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ExtraPlotsTextFileDefinition'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.extraPlotsFileName is not None and 'extraPlotsFileName' not in already_processed:
            already_processed.add('extraPlotsFileName')
            showIndent(outfile, level)
            outfile.write('extraPlotsFileName="%s",\n' % (self.extraPlotsFileName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('extraPlotsFileName', node)
        if value is not None and 'extraPlotsFileName' not in already_processed:
            already_processed.add('extraPlotsFileName')
            self.extraPlotsFileName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_ExtraPlotsTextFileDefinition


class create_ImportationFichierRaster(GeneratedsSuper):
    """Contains the information of the input files for the Vegetation
    module. Contains the information of the input files for the
    Vegetation module."""
    member_data_items_ = [
        MemberSpec_('VegetationProperties', '_VegetationProperties', 0, 0, {u'maxOccurs': u'1', u'type': u'_VegetationProperties', u'name': u'VegetationProperties', u'minOccurs': u'1'}, None),
        MemberSpec_('RasterCOSInformation', '_RasterCOSInformation', 0, 0, {u'maxOccurs': u'1', u'type': u'_RasterCOSInformation', u'name': u'RasterCOSInformation', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, VegetationProperties=None, RasterCOSInformation=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('plots','_ImportationFichierRaster')
        self.attrib = ['']
        self.children = ['VegetationProperties', 'RasterCOSInformation']
        self.parent = None
        self._VegetationProperties = VegetationProperties
        self._RasterCOSInformation = RasterCOSInformation
        update_node(self,self.troot,'plots')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ImportationFichierRaster)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ImportationFichierRaster.subclass:
            return create_ImportationFichierRaster.subclass(*args_, **kwargs_)
        else:
            return create_ImportationFichierRaster(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VegetationProperties(self): return self._VegetationProperties
    def set_VegetationProperties(self, value):
        if value is not None:
            checkclass(value, create_VegetationProperties)
            value.parent = self
        self._VegetationProperties = value
    VegetationProperties = property(get_VegetationProperties, set_VegetationProperties)
    def get_RasterCOSInformation(self): return self._RasterCOSInformation
    def set_RasterCOSInformation(self, value):
        if value is not None:
            checkclass(value, create_RasterCOSInformation)
            value.parent = self
        self._RasterCOSInformation = value
    RasterCOSInformation = property(get_RasterCOSInformation, set_RasterCOSInformation)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.VegetationProperties is not None or
            self.RasterCOSInformation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ImportationFichierRaster', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ImportationFichierRaster')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ImportationFichierRaster')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ImportationFichierRaster', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ImportationFichierRaster'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ImportationFichierRaster', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VegetationProperties is not None:
            self.VegetationProperties.export(outfile, level, namespaceprefix_, name_='VegetationProperties', pretty_print=pretty_print)
        if self.RasterCOSInformation is not None:
            self.RasterCOSInformation.export(outfile, level, namespaceprefix_, name_='RasterCOSInformation', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_ImportationFichierRaster', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.VegetationProperties is not None:
            VegetationProperties_ = self.VegetationProperties
            VegetationProperties_.to_etree(element, name_='VegetationProperties', mapping_=mapping_)
        if self.RasterCOSInformation is not None:
            RasterCOSInformation_ = self.RasterCOSInformation
            RasterCOSInformation_.to_etree(element, name_='RasterCOSInformation', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ImportationFichierRaster'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.VegetationProperties is not None:
            showIndent(outfile, level)
            outfile.write('VegetationProperties=model_._VegetationProperties(\n')
            self.VegetationProperties.exportLiteral(outfile, level, name_='VegetationProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RasterCOSInformation is not None:
            showIndent(outfile, level)
            outfile.write('RasterCOSInformation=model_._RasterCOSInformation(\n')
            self.RasterCOSInformation.exportLiteral(outfile, level, name_='RasterCOSInformation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VegetationProperties':
            obj_ = create_VegetationProperties.factory()
            obj_.build(child_)
            self.set_VegetationProperties(obj_)
            obj_.original_tagname_ = 'VegetationProperties'
        elif nodeName_ == 'RasterCOSInformation':
            obj_ = create_RasterCOSInformation.factory()
            obj_.build(child_)
            self.set_RasterCOSInformation(obj_)
            obj_.original_tagname_ = 'RasterCOSInformation'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_ImportationFichierRaster


class create_VegetationProperties(GeneratedsSuper):
    """Properties of the raster image of the Vegetation module (name,
    number of lines/colunms, type of the pixel ...). Properties of
    the raster image of the Vegetation module (name, number of
    lines/colunms, type of the pixel ...). Allows the user to work
    on a subzone of the raster image. 1 for extracting a sub-zone of
    the COS, 0 otherwise. Allows the user to work on a subzone of
    the raster image. 1 for extracting a sub-zone of the COS, 0
    otherwise. Raster file name. It must be in the simulation
    "input" directory of the simulation. Raster file name. It must
    be in the simulation "input" directory of the simulation. Allows
    Vegetation module to keep or crush the current plots. 1, the
    plots are crushed. 0, the plots are kept. Allows Vegetation
    module to keep or crush the current plots. 1, the plots are
    crushed. 0, the plots are kept."""
    member_data_items_ = [
        MemberSpec_('selectSubZone', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('coverLandMapFileName', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('coverLandMapDescFileName', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('OverwritePlots', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('SelectSubZoneProperties', '_SelectSubZoneProperties', 0, 0, {u'maxOccurs': u'1', u'type': u'_SelectSubZoneProperties', u'name': u'SelectSubZoneProperties', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, selectSubZone=0, coverLandMapFileName='land_cover.mp#', coverLandMapDescFileName='Desc_CoverLandMap.txt', OverwritePlots=1, SelectSubZoneProperties=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('plots','_VegetationProperties')
        self.attrib = ['selectSubZone', 'coverLandMapFileName', 'coverLandMapDescFileName', 'OverwritePlots']
        self.children = ['SelectSubZoneProperties']
        self.parent = None
        self._selectSubZone = _cast(int, selectSubZone)
        self._coverLandMapFileName = _cast(None, coverLandMapFileName)
        self._coverLandMapDescFileName = _cast(None, coverLandMapDescFileName)
        self._OverwritePlots = _cast(int, OverwritePlots)
        self._SelectSubZoneProperties = SelectSubZoneProperties
        update_node(self,self.troot,'plots')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_VegetationProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_VegetationProperties.subclass:
            return create_VegetationProperties.subclass(*args_, **kwargs_)
        else:
            return create_VegetationProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SelectSubZoneProperties(self): return self._SelectSubZoneProperties
    def set_SelectSubZoneProperties(self, value):
        if value is not None:
            checkclass(value, create_SelectSubZoneProperties)
            value.parent = self
        self._SelectSubZoneProperties = value
    SelectSubZoneProperties = property(get_SelectSubZoneProperties, set_SelectSubZoneProperties)
    def get_selectSubZone(self): return self._selectSubZone
    def set_selectSubZone(self, value):
        self._selectSubZone = value
        update_node(self,self.troot,'plots')
    selectSubZone = property(get_selectSubZone, set_selectSubZone)
    def get_coverLandMapFileName(self): return self._coverLandMapFileName
    def set_coverLandMapFileName(self, value):
        self._coverLandMapFileName = value
        update_node(self,self.troot,'plots')
    coverLandMapFileName = property(get_coverLandMapFileName, set_coverLandMapFileName)
    def get_coverLandMapDescFileName(self): return self._coverLandMapDescFileName
    def set_coverLandMapDescFileName(self, value):
        self._coverLandMapDescFileName = value
        update_node(self,self.troot,'plots')
    coverLandMapDescFileName = property(get_coverLandMapDescFileName, set_coverLandMapDescFileName)
    def get_OverwritePlots(self): return self._OverwritePlots
    def set_OverwritePlots(self, value):
        self._OverwritePlots = value
        update_node(self,self.troot,'plots')
    OverwritePlots = property(get_OverwritePlots, set_OverwritePlots)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.SelectSubZoneProperties is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_VegetationProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_VegetationProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_VegetationProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_VegetationProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_VegetationProperties'):
        if self.selectSubZone is not None and 'selectSubZone' not in already_processed:
            already_processed.add('selectSubZone')
            outfile.write(' selectSubZone="%s"' % self.gds_format_integer(self.selectSubZone, input_name='selectSubZone'))
        if self.coverLandMapFileName is not None and 'coverLandMapFileName' not in already_processed:
            already_processed.add('coverLandMapFileName')
            outfile.write(' coverLandMapFileName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.coverLandMapFileName), input_name='coverLandMapFileName')), ))
        if self.coverLandMapDescFileName is not None and 'coverLandMapDescFileName' not in already_processed:
            already_processed.add('coverLandMapDescFileName')
            outfile.write(' coverLandMapDescFileName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.coverLandMapDescFileName), input_name='coverLandMapDescFileName')), ))
        if self.OverwritePlots is not None and 'OverwritePlots' not in already_processed:
            already_processed.add('OverwritePlots')
            outfile.write(' OverwritePlots="%s"' % self.gds_format_integer(self.OverwritePlots, input_name='OverwritePlots'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_VegetationProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SelectSubZoneProperties is not None:
            self.SelectSubZoneProperties.export(outfile, level, namespaceprefix_, name_='SelectSubZoneProperties', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_VegetationProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.selectSubZone is not None:
            element.set('selectSubZone', self.gds_format_integer(self.selectSubZone))
        if self.coverLandMapFileName is not None:
            element.set('coverLandMapFileName', self.gds_format_string(self.coverLandMapFileName))
        if self.coverLandMapDescFileName is not None:
            element.set('coverLandMapDescFileName', self.gds_format_string(self.coverLandMapDescFileName))
        if self.OverwritePlots is not None:
            element.set('OverwritePlots', self.gds_format_integer(self.OverwritePlots))
        if self.SelectSubZoneProperties is not None:
            SelectSubZoneProperties_ = self.SelectSubZoneProperties
            SelectSubZoneProperties_.to_etree(element, name_='SelectSubZoneProperties', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_VegetationProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.selectSubZone is not None and 'selectSubZone' not in already_processed:
            already_processed.add('selectSubZone')
            showIndent(outfile, level)
            outfile.write('selectSubZone=%d,\n' % (self.selectSubZone,))
        if self.coverLandMapFileName is not None and 'coverLandMapFileName' not in already_processed:
            already_processed.add('coverLandMapFileName')
            showIndent(outfile, level)
            outfile.write('coverLandMapFileName="%s",\n' % (self.coverLandMapFileName,))
        if self.coverLandMapDescFileName is not None and 'coverLandMapDescFileName' not in already_processed:
            already_processed.add('coverLandMapDescFileName')
            showIndent(outfile, level)
            outfile.write('coverLandMapDescFileName="%s",\n' % (self.coverLandMapDescFileName,))
        if self.OverwritePlots is not None and 'OverwritePlots' not in already_processed:
            already_processed.add('OverwritePlots')
            showIndent(outfile, level)
            outfile.write('OverwritePlots=%d,\n' % (self.OverwritePlots,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SelectSubZoneProperties is not None:
            showIndent(outfile, level)
            outfile.write('SelectSubZoneProperties=model_._SelectSubZoneProperties(\n')
            self.SelectSubZoneProperties.exportLiteral(outfile, level, name_='SelectSubZoneProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('selectSubZone', node)
        if value is not None and 'selectSubZone' not in already_processed:
            already_processed.add('selectSubZone')
            try:
                self.selectSubZone = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('coverLandMapFileName', node)
        if value is not None and 'coverLandMapFileName' not in already_processed:
            already_processed.add('coverLandMapFileName')
            self.coverLandMapFileName = value
        value = find_attr_value_('coverLandMapDescFileName', node)
        if value is not None and 'coverLandMapDescFileName' not in already_processed:
            already_processed.add('coverLandMapDescFileName')
            self.coverLandMapDescFileName = value
        value = find_attr_value_('OverwritePlots', node)
        if value is not None and 'OverwritePlots' not in already_processed:
            already_processed.add('OverwritePlots')
            try:
                self.OverwritePlots = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SelectSubZoneProperties':
            obj_ = create_SelectSubZoneProperties.factory()
            obj_.build(child_)
            self.set_SelectSubZoneProperties(obj_)
            obj_.original_tagname_ = 'SelectSubZoneProperties'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_VegetationProperties


class create_SelectSubZoneProperties(GeneratedsSuper):
    """Properties of the sub zone. It's defined by a starting point and a
    number of lines/colunms. Properties of the sub zone. It's
    defined by a starting point and a number of lines/colunms.
    Number of lines of the subzone. Number of lines of the subzone.
    First column of the sub-zone. First column of the sub-zone.
    Number of columns of the sub-zone. Number of columns of the sub-
    zone. First line of the sub-zone. First line of the sub-zone."""
    member_data_items_ = [
        MemberSpec_('lineNbSubZone', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('columnOfTopLeftPixel', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('columnNbSubZone', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('lineOfTopLeftPixel', 'xsd:int', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, lineNbSubZone=5, columnOfTopLeftPixel=0, columnNbSubZone=5, lineOfTopLeftPixel=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('plots','_SelectSubZoneProperties')
        self.attrib = ['lineNbSubZone', 'columnOfTopLeftPixel', 'columnNbSubZone', 'lineOfTopLeftPixel']
        self.children = []
        self.parent = None
        self._lineNbSubZone = _cast(int, lineNbSubZone)
        self._columnOfTopLeftPixel = _cast(int, columnOfTopLeftPixel)
        self._columnNbSubZone = _cast(int, columnNbSubZone)
        self._lineOfTopLeftPixel = _cast(int, lineOfTopLeftPixel)
        update_node(self,self.troot,'plots')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_SelectSubZoneProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_SelectSubZoneProperties.subclass:
            return create_SelectSubZoneProperties.subclass(*args_, **kwargs_)
        else:
            return create_SelectSubZoneProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lineNbSubZone(self): return self._lineNbSubZone
    def set_lineNbSubZone(self, value):
        self._lineNbSubZone = value
        update_node(self,self.troot,'plots')
    lineNbSubZone = property(get_lineNbSubZone, set_lineNbSubZone)
    def get_columnOfTopLeftPixel(self): return self._columnOfTopLeftPixel
    def set_columnOfTopLeftPixel(self, value):
        self._columnOfTopLeftPixel = value
        update_node(self,self.troot,'plots')
    columnOfTopLeftPixel = property(get_columnOfTopLeftPixel, set_columnOfTopLeftPixel)
    def get_columnNbSubZone(self): return self._columnNbSubZone
    def set_columnNbSubZone(self, value):
        self._columnNbSubZone = value
        update_node(self,self.troot,'plots')
    columnNbSubZone = property(get_columnNbSubZone, set_columnNbSubZone)
    def get_lineOfTopLeftPixel(self): return self._lineOfTopLeftPixel
    def set_lineOfTopLeftPixel(self, value):
        self._lineOfTopLeftPixel = value
        update_node(self,self.troot,'plots')
    lineOfTopLeftPixel = property(get_lineOfTopLeftPixel, set_lineOfTopLeftPixel)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_SelectSubZoneProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_SelectSubZoneProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_SelectSubZoneProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_SelectSubZoneProperties', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_SelectSubZoneProperties'):
        if self.lineNbSubZone is not None and 'lineNbSubZone' not in already_processed:
            already_processed.add('lineNbSubZone')
            outfile.write(' lineNbSubZone="%s"' % self.gds_format_integer(self.lineNbSubZone, input_name='lineNbSubZone'))
        if self.columnOfTopLeftPixel is not None and 'columnOfTopLeftPixel' not in already_processed:
            already_processed.add('columnOfTopLeftPixel')
            outfile.write(' columnOfTopLeftPixel="%s"' % self.gds_format_integer(self.columnOfTopLeftPixel, input_name='columnOfTopLeftPixel'))
        if self.columnNbSubZone is not None and 'columnNbSubZone' not in already_processed:
            already_processed.add('columnNbSubZone')
            outfile.write(' columnNbSubZone="%s"' % self.gds_format_integer(self.columnNbSubZone, input_name='columnNbSubZone'))
        if self.lineOfTopLeftPixel is not None and 'lineOfTopLeftPixel' not in already_processed:
            already_processed.add('lineOfTopLeftPixel')
            outfile.write(' lineOfTopLeftPixel="%s"' % self.gds_format_integer(self.lineOfTopLeftPixel, input_name='lineOfTopLeftPixel'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_SelectSubZoneProperties', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_SelectSubZoneProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.lineNbSubZone is not None:
            element.set('lineNbSubZone', self.gds_format_integer(self.lineNbSubZone))
        if self.columnOfTopLeftPixel is not None:
            element.set('columnOfTopLeftPixel', self.gds_format_integer(self.columnOfTopLeftPixel))
        if self.columnNbSubZone is not None:
            element.set('columnNbSubZone', self.gds_format_integer(self.columnNbSubZone))
        if self.lineOfTopLeftPixel is not None:
            element.set('lineOfTopLeftPixel', self.gds_format_integer(self.lineOfTopLeftPixel))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_SelectSubZoneProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lineNbSubZone is not None and 'lineNbSubZone' not in already_processed:
            already_processed.add('lineNbSubZone')
            showIndent(outfile, level)
            outfile.write('lineNbSubZone=%d,\n' % (self.lineNbSubZone,))
        if self.columnOfTopLeftPixel is not None and 'columnOfTopLeftPixel' not in already_processed:
            already_processed.add('columnOfTopLeftPixel')
            showIndent(outfile, level)
            outfile.write('columnOfTopLeftPixel=%d,\n' % (self.columnOfTopLeftPixel,))
        if self.columnNbSubZone is not None and 'columnNbSubZone' not in already_processed:
            already_processed.add('columnNbSubZone')
            showIndent(outfile, level)
            outfile.write('columnNbSubZone=%d,\n' % (self.columnNbSubZone,))
        if self.lineOfTopLeftPixel is not None and 'lineOfTopLeftPixel' not in already_processed:
            already_processed.add('lineOfTopLeftPixel')
            showIndent(outfile, level)
            outfile.write('lineOfTopLeftPixel=%d,\n' % (self.lineOfTopLeftPixel,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lineNbSubZone', node)
        if value is not None and 'lineNbSubZone' not in already_processed:
            already_processed.add('lineNbSubZone')
            try:
                self.lineNbSubZone = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('columnOfTopLeftPixel', node)
        if value is not None and 'columnOfTopLeftPixel' not in already_processed:
            already_processed.add('columnOfTopLeftPixel')
            try:
                self.columnOfTopLeftPixel = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('columnNbSubZone', node)
        if value is not None and 'columnNbSubZone' not in already_processed:
            already_processed.add('columnNbSubZone')
            try:
                self.columnNbSubZone = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('lineOfTopLeftPixel', node)
        if value is not None and 'lineOfTopLeftPixel' not in already_processed:
            already_processed.add('lineOfTopLeftPixel')
            try:
                self.lineOfTopLeftPixel = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_SelectSubZoneProperties


class create_RasterCOSInformation(GeneratedsSuper):
    """Properties of the raster image of the Vegetation module (name,
    number of lines/colunms, type of the pixel ...). Properties of
    the raster image of the Vegetation module (name, number of
    lines/colunms, type of the pixel ...). Dimension in meters of a
    pixel of the raster image, along a column. Dimension in meters
    of a pixel of the raster image, along a column. Number of
    columns of the raster image. Number of columns of the raster
    image. Dimension in meters of a pixel of the raster image, along
    a line. Dimension in meters of a pixel of the raster image,
    along a line. double. double. Number of lines of the raster
    image. Number of lines of the raster image."""
    member_data_items_ = [
        MemberSpec_('pixelSizeCol', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('nbColCOS', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('pixelSizeLi', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('pixelByteSizeCOS', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('nbLiCOS', 'xsd:int', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, pixelSizeCol=1, nbColCOS=20, pixelSizeLi=1, pixelByteSizeCOS=1, nbLiCOS=20):
        self.original_tagname_ = None
        self.troot=get_gs_troot('plots','_RasterCOSInformation')
        self.attrib = ['pixelSizeCol', 'nbColCOS', 'pixelSizeLi', 'pixelByteSizeCOS', 'nbLiCOS']
        self.children = []
        self.parent = None
        self._pixelSizeCol = _cast(float, pixelSizeCol)
        self._nbColCOS = _cast(int, nbColCOS)
        self._pixelSizeLi = _cast(float, pixelSizeLi)
        self._pixelByteSizeCOS = _cast(int, pixelByteSizeCOS)
        self._nbLiCOS = _cast(int, nbLiCOS)
        update_node(self,self.troot,'plots')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_RasterCOSInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_RasterCOSInformation.subclass:
            return create_RasterCOSInformation.subclass(*args_, **kwargs_)
        else:
            return create_RasterCOSInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pixelSizeCol(self): return self._pixelSizeCol
    def set_pixelSizeCol(self, value):
        self._pixelSizeCol = value
        update_node(self,self.troot,'plots')
    pixelSizeCol = property(get_pixelSizeCol, set_pixelSizeCol)
    def get_nbColCOS(self): return self._nbColCOS
    def set_nbColCOS(self, value):
        self._nbColCOS = value
        update_node(self,self.troot,'plots')
    nbColCOS = property(get_nbColCOS, set_nbColCOS)
    def get_pixelSizeLi(self): return self._pixelSizeLi
    def set_pixelSizeLi(self, value):
        self._pixelSizeLi = value
        update_node(self,self.troot,'plots')
    pixelSizeLi = property(get_pixelSizeLi, set_pixelSizeLi)
    def get_pixelByteSizeCOS(self): return self._pixelByteSizeCOS
    def set_pixelByteSizeCOS(self, value):
        self._pixelByteSizeCOS = value
        update_node(self,self.troot,'plots')
    pixelByteSizeCOS = property(get_pixelByteSizeCOS, set_pixelByteSizeCOS)
    def get_nbLiCOS(self): return self._nbLiCOS
    def set_nbLiCOS(self, value):
        self._nbLiCOS = value
        update_node(self,self.troot,'plots')
    nbLiCOS = property(get_nbLiCOS, set_nbLiCOS)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_RasterCOSInformation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_RasterCOSInformation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_RasterCOSInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_RasterCOSInformation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_RasterCOSInformation'):
        if self.pixelSizeCol is not None and 'pixelSizeCol' not in already_processed:
            already_processed.add('pixelSizeCol')
            outfile.write(' pixelSizeCol="%s"' % self.gds_format_double(self.pixelSizeCol, input_name='pixelSizeCol'))
        if self.nbColCOS is not None and 'nbColCOS' not in already_processed:
            already_processed.add('nbColCOS')
            outfile.write(' nbColCOS="%s"' % self.gds_format_integer(self.nbColCOS, input_name='nbColCOS'))
        if self.pixelSizeLi is not None and 'pixelSizeLi' not in already_processed:
            already_processed.add('pixelSizeLi')
            outfile.write(' pixelSizeLi="%s"' % self.gds_format_double(self.pixelSizeLi, input_name='pixelSizeLi'))
        if self.pixelByteSizeCOS is not None and 'pixelByteSizeCOS' not in already_processed:
            already_processed.add('pixelByteSizeCOS')
            outfile.write(' pixelByteSizeCOS="%s"' % self.gds_format_integer(self.pixelByteSizeCOS, input_name='pixelByteSizeCOS'))
        if self.nbLiCOS is not None and 'nbLiCOS' not in already_processed:
            already_processed.add('nbLiCOS')
            outfile.write(' nbLiCOS="%s"' % self.gds_format_integer(self.nbLiCOS, input_name='nbLiCOS'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_RasterCOSInformation', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_RasterCOSInformation', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.pixelSizeCol is not None:
            element.set('pixelSizeCol', self.gds_format_double(self.pixelSizeCol))
        if self.nbColCOS is not None:
            element.set('nbColCOS', self.gds_format_integer(self.nbColCOS))
        if self.pixelSizeLi is not None:
            element.set('pixelSizeLi', self.gds_format_double(self.pixelSizeLi))
        if self.pixelByteSizeCOS is not None:
            element.set('pixelByteSizeCOS', self.gds_format_integer(self.pixelByteSizeCOS))
        if self.nbLiCOS is not None:
            element.set('nbLiCOS', self.gds_format_integer(self.nbLiCOS))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_RasterCOSInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.pixelSizeCol is not None and 'pixelSizeCol' not in already_processed:
            already_processed.add('pixelSizeCol')
            showIndent(outfile, level)
            outfile.write('pixelSizeCol=%e,\n' % (self.pixelSizeCol,))
        if self.nbColCOS is not None and 'nbColCOS' not in already_processed:
            already_processed.add('nbColCOS')
            showIndent(outfile, level)
            outfile.write('nbColCOS=%d,\n' % (self.nbColCOS,))
        if self.pixelSizeLi is not None and 'pixelSizeLi' not in already_processed:
            already_processed.add('pixelSizeLi')
            showIndent(outfile, level)
            outfile.write('pixelSizeLi=%e,\n' % (self.pixelSizeLi,))
        if self.pixelByteSizeCOS is not None and 'pixelByteSizeCOS' not in already_processed:
            already_processed.add('pixelByteSizeCOS')
            showIndent(outfile, level)
            outfile.write('pixelByteSizeCOS=%d,\n' % (self.pixelByteSizeCOS,))
        if self.nbLiCOS is not None and 'nbLiCOS' not in already_processed:
            already_processed.add('nbLiCOS')
            showIndent(outfile, level)
            outfile.write('nbLiCOS=%d,\n' % (self.nbLiCOS,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pixelSizeCol', node)
        if value is not None and 'pixelSizeCol' not in already_processed:
            already_processed.add('pixelSizeCol')
            try:
                self.pixelSizeCol = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (pixelSizeCol): %s' % exp)
        value = find_attr_value_('nbColCOS', node)
        if value is not None and 'nbColCOS' not in already_processed:
            already_processed.add('nbColCOS')
            try:
                self.nbColCOS = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('pixelSizeLi', node)
        if value is not None and 'pixelSizeLi' not in already_processed:
            already_processed.add('pixelSizeLi')
            try:
                self.pixelSizeLi = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (pixelSizeLi): %s' % exp)
        value = find_attr_value_('pixelByteSizeCOS', node)
        if value is not None and 'pixelByteSizeCOS' not in already_processed:
            already_processed.add('pixelByteSizeCOS')
            try:
                self.pixelByteSizeCOS = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('nbLiCOS', node)
        if value is not None and 'nbLiCOS' not in already_processed:
            already_processed.add('nbLiCOS')
            try:
                self.nbLiCOS = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_RasterCOSInformation


class create_Plot(GeneratedsSuper):
    """Representation of a DART plot. It's defined by its type, a geometric
    property and its optical(s) property(ies). The number of optical
    properties depends of the type of the plot. It can be formed of
    soil, vegetation or a combinaison of soil and vegetation.
    Representation of a DART plot. It's defined by its type, a
    geometric property and its optical(s) property(ies). The number
    of optical properties depends of the type of the plot. It can be
    formed of soil, vegetation or a combinaison of soil and
    vegetation. If you select this option, this plot are not use in
    all DART modules, \n it's useful if you want conserve plot
    properties backup without delete this for tests If you select
    this option, this plot are not use in all DART modules, \n it's
    useful if you want conserve plot properties backup without
    delete this for tests If part of the object goes beyond the
    border of the scene, this part is copied on the other side of
    the scene. If part of the object goes beyond the border of the
    scene, this part is copied on the other side of the scene. Plot:
    "vegetation layer + ground surface over the ground of the
    scene", "ground surface over the ground of the scene" or
    "vegetation layer over the ground of the scene" Plot:
    "vegetation layer + ground surface over the ground of the
    scene", "ground surface over the ground of the scene" or
    "vegetation layer over the ground of the scene" How the plot
    geometry will be defined. This can be done by giving the
    dimension and position of a rectangle, or by directly giving the
    coordinates of the four corners of the the delimiting
    quadrilater. How the plot geometry will be defined. This can be
    done by giving the dimension and position of a rectangle, or by
    directly giving the coordinates of the four corners of the the
    delimiting quadrilater. Objects's positions are taken from the
    position file.\nDesactivate this option if you experience some
    slowdown. Objects's positions are taken from the position
    file.\nDesactivate this option if you experience some slowdown."""
    member_data_items_ = [
        MemberSpec_('hidden', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('repeatedOnBorder', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('type_', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('form', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('isDisplayed', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('Polygon2D', '_Polygon2D', 0, 0, {u'maxOccurs': u'1', u'type': u'_Polygon2D', u'name': u'Polygon2D', u'minOccurs': u'1'}, None),
        MemberSpec_('Rectangle2D', '_Rectangle2D', 0, 0, {u'maxOccurs': u'1', u'type': u'_Rectangle2D', u'name': u'Rectangle2D', u'minOccurs': u'1'}, None),
        MemberSpec_('GroundOpticalPropertyLink', '_GroundOpticalPropertyLink', 0, 0, {u'maxOccurs': u'1', u'type': u'_GroundOpticalPropertyLink', u'name': u'GroundOpticalPropertyLink', u'minOccurs': u'1'}, None),
        MemberSpec_('GroundThermalPropertyLink', '_GroundThermalPropertyLink', 0, 0, {u'maxOccurs': u'1', u'type': u'_GroundThermalPropertyLink', u'name': u'GroundThermalPropertyLink', u'minOccurs': u'1'}, None),
        MemberSpec_('PlotVegetationProperties', '_PlotVegetationProperties', 0, 0, {u'maxOccurs': u'1', u'type': u'_PlotVegetationProperties', u'name': u'PlotVegetationProperties', u'minOccurs': u'1'}, None),
        MemberSpec_('PlotAirProperties', '_PlotAirProperties', 0, 0, {u'maxOccurs': u'1', u'type': u'_PlotAirProperties', u'name': u'PlotAirProperties', u'minOccurs': u'1'}, None),
        MemberSpec_('PlotWaterProperties', '_PlotWaterProperties', 0, 0, {u'maxOccurs': u'1', u'type': u'_PlotWaterProperties', u'name': u'PlotWaterProperties', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, hidden=0, repeatedOnBorder=1, type_=1, form=0, isDisplayed=1, Polygon2D=None, Rectangle2D=None, GroundOpticalPropertyLink=None, GroundThermalPropertyLink=None, PlotVegetationProperties=None, PlotAirProperties=None, PlotWaterProperties=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('plots','_Plot')
        self.attrib = ['hidden', 'repeatedOnBorder', 'type_', 'form', 'isDisplayed']
        self.children = ['Polygon2D', 'Rectangle2D', 'GroundOpticalPropertyLink', 'GroundThermalPropertyLink', 'PlotVegetationProperties', 'PlotAirProperties', 'PlotWaterProperties']
        self.parent = None
        self._hidden = _cast(int, hidden)
        self._repeatedOnBorder = _cast(int, repeatedOnBorder)
        self._type_ = _cast(int, type_)
        self._form = _cast(int, form)
        self._isDisplayed = _cast(int, isDisplayed)
        self._Polygon2D = Polygon2D
        self._Rectangle2D = Rectangle2D
        self._GroundOpticalPropertyLink = GroundOpticalPropertyLink
        self._GroundThermalPropertyLink = GroundThermalPropertyLink
        self._PlotVegetationProperties = PlotVegetationProperties
        self._PlotAirProperties = PlotAirProperties
        self._PlotWaterProperties = PlotWaterProperties
        update_node(self,self.troot,'plots')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Plot)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Plot.subclass:
            return create_Plot.subclass(*args_, **kwargs_)
        else:
            return create_Plot(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Polygon2D(self): return self._Polygon2D
    def set_Polygon2D(self, value):
        if value is not None:
            checkclass(value, create_Polygon2D)
            value.parent = self
        self._Polygon2D = value
    Polygon2D = property(get_Polygon2D, set_Polygon2D)
    def get_Rectangle2D(self): return self._Rectangle2D
    def set_Rectangle2D(self, value):
        if value is not None:
            checkclass(value, create_Rectangle2D)
            value.parent = self
        self._Rectangle2D = value
    Rectangle2D = property(get_Rectangle2D, set_Rectangle2D)
    def get_GroundOpticalPropertyLink(self): return self._GroundOpticalPropertyLink
    def set_GroundOpticalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_GroundOpticalPropertyLink)
            value.parent = self
        self._GroundOpticalPropertyLink = value
    GroundOpticalPropertyLink = property(get_GroundOpticalPropertyLink, set_GroundOpticalPropertyLink)
    def get_GroundThermalPropertyLink(self): return self._GroundThermalPropertyLink
    def set_GroundThermalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_GroundThermalPropertyLink)
            value.parent = self
        self._GroundThermalPropertyLink = value
    GroundThermalPropertyLink = property(get_GroundThermalPropertyLink, set_GroundThermalPropertyLink)
    def get_PlotVegetationProperties(self): return self._PlotVegetationProperties
    def set_PlotVegetationProperties(self, value):
        if value is not None:
            checkclass(value, create_PlotVegetationProperties)
            value.parent = self
        self._PlotVegetationProperties = value
    PlotVegetationProperties = property(get_PlotVegetationProperties, set_PlotVegetationProperties)
    def get_PlotAirProperties(self): return self._PlotAirProperties
    def set_PlotAirProperties(self, value):
        if value is not None:
            checkclass(value, create_PlotAirProperties)
            value.parent = self
        self._PlotAirProperties = value
    PlotAirProperties = property(get_PlotAirProperties, set_PlotAirProperties)
    def get_PlotWaterProperties(self): return self._PlotWaterProperties
    def set_PlotWaterProperties(self, value):
        if value is not None:
            checkclass(value, create_PlotWaterProperties)
            value.parent = self
        self._PlotWaterProperties = value
    PlotWaterProperties = property(get_PlotWaterProperties, set_PlotWaterProperties)
    def get_hidden(self): return self._hidden
    def set_hidden(self, value):
        self._hidden = value
        update_node(self,self.troot,'plots')
    hidden = property(get_hidden, set_hidden)
    def get_repeatedOnBorder(self): return self._repeatedOnBorder
    def set_repeatedOnBorder(self, value):
        self._repeatedOnBorder = value
        update_node(self,self.troot,'plots')
    repeatedOnBorder = property(get_repeatedOnBorder, set_repeatedOnBorder)
    def get_type(self): return self._type_
    def set_type(self, value):
        self._type_ = value
        update_node(self,self.troot,'plots')
    type_ = property(get_type, set_type)
    def get_form(self): return self._form
    def set_form(self, value):
        self._form = value
        update_node(self,self.troot,'plots')
    form = property(get_form, set_form)
    def get_isDisplayed(self): return self._isDisplayed
    def set_isDisplayed(self, value):
        self._isDisplayed = value
        update_node(self,self.troot,'plots')
    isDisplayed = property(get_isDisplayed, set_isDisplayed)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Polygon2D is not None or
            self.Rectangle2D is not None or
            self.GroundOpticalPropertyLink is not None or
            self.GroundThermalPropertyLink is not None or
            self.PlotVegetationProperties is not None or
            self.PlotAirProperties is not None or
            self.PlotWaterProperties is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Plot', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Plot')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Plot')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Plot', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Plot'):
        if self.hidden is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            outfile.write(' hidden="%s"' % self.gds_format_integer(self.hidden, input_name='hidden'))
        if self.repeatedOnBorder is not None and 'repeatedOnBorder' not in already_processed:
            already_processed.add('repeatedOnBorder')
            outfile.write(' repeatedOnBorder="%s"' % self.gds_format_integer(self.repeatedOnBorder, input_name='repeatedOnBorder'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type="%s"' % self.gds_format_integer(self.type_, input_name='type'))
        if self.form is not None and 'form' not in already_processed:
            already_processed.add('form')
            outfile.write(' form="%s"' % self.gds_format_integer(self.form, input_name='form'))
        if self.isDisplayed is not None and 'isDisplayed' not in already_processed:
            already_processed.add('isDisplayed')
            outfile.write(' isDisplayed="%s"' % self.gds_format_integer(self.isDisplayed, input_name='isDisplayed'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Plot', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Polygon2D is not None:
            self.Polygon2D.export(outfile, level, namespaceprefix_, name_='Polygon2D', pretty_print=pretty_print)
        if self.Rectangle2D is not None:
            self.Rectangle2D.export(outfile, level, namespaceprefix_, name_='Rectangle2D', pretty_print=pretty_print)
        if self.GroundOpticalPropertyLink is not None:
            self.GroundOpticalPropertyLink.export(outfile, level, namespaceprefix_, name_='GroundOpticalPropertyLink', pretty_print=pretty_print)
        if self.GroundThermalPropertyLink is not None:
            self.GroundThermalPropertyLink.export(outfile, level, namespaceprefix_, name_='GroundThermalPropertyLink', pretty_print=pretty_print)
        if self.PlotVegetationProperties is not None:
            self.PlotVegetationProperties.export(outfile, level, namespaceprefix_, name_='PlotVegetationProperties', pretty_print=pretty_print)
        if self.PlotAirProperties is not None:
            self.PlotAirProperties.export(outfile, level, namespaceprefix_, name_='PlotAirProperties', pretty_print=pretty_print)
        if self.PlotWaterProperties is not None:
            self.PlotWaterProperties.export(outfile, level, namespaceprefix_, name_='PlotWaterProperties', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Plot', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.hidden is not None:
            element.set('hidden', self.gds_format_integer(self.hidden))
        if self.repeatedOnBorder is not None:
            element.set('repeatedOnBorder', self.gds_format_integer(self.repeatedOnBorder))
        if self.type_ is not None:
            element.set('type', self.gds_format_integer(self.type_))
        if self.form is not None:
            element.set('form', self.gds_format_integer(self.form))
        if self.isDisplayed is not None:
            element.set('isDisplayed', self.gds_format_integer(self.isDisplayed))
        if self.Polygon2D is not None:
            Polygon2D_ = self.Polygon2D
            Polygon2D_.to_etree(element, name_='Polygon2D', mapping_=mapping_)
        if self.Rectangle2D is not None:
            Rectangle2D_ = self.Rectangle2D
            Rectangle2D_.to_etree(element, name_='Rectangle2D', mapping_=mapping_)
        if self.GroundOpticalPropertyLink is not None:
            GroundOpticalPropertyLink_ = self.GroundOpticalPropertyLink
            GroundOpticalPropertyLink_.to_etree(element, name_='GroundOpticalPropertyLink', mapping_=mapping_)
        if self.GroundThermalPropertyLink is not None:
            GroundThermalPropertyLink_ = self.GroundThermalPropertyLink
            GroundThermalPropertyLink_.to_etree(element, name_='GroundThermalPropertyLink', mapping_=mapping_)
        if self.PlotVegetationProperties is not None:
            PlotVegetationProperties_ = self.PlotVegetationProperties
            PlotVegetationProperties_.to_etree(element, name_='PlotVegetationProperties', mapping_=mapping_)
        if self.PlotAirProperties is not None:
            PlotAirProperties_ = self.PlotAirProperties
            PlotAirProperties_.to_etree(element, name_='PlotAirProperties', mapping_=mapping_)
        if self.PlotWaterProperties is not None:
            PlotWaterProperties_ = self.PlotWaterProperties
            PlotWaterProperties_.to_etree(element, name_='PlotWaterProperties', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Plot'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.hidden is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            showIndent(outfile, level)
            outfile.write('hidden=%d,\n' % (self.hidden,))
        if self.repeatedOnBorder is not None and 'repeatedOnBorder' not in already_processed:
            already_processed.add('repeatedOnBorder')
            showIndent(outfile, level)
            outfile.write('repeatedOnBorder=%d,\n' % (self.repeatedOnBorder,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_=%d,\n' % (self.type_,))
        if self.form is not None and 'form' not in already_processed:
            already_processed.add('form')
            showIndent(outfile, level)
            outfile.write('form=%d,\n' % (self.form,))
        if self.isDisplayed is not None and 'isDisplayed' not in already_processed:
            already_processed.add('isDisplayed')
            showIndent(outfile, level)
            outfile.write('isDisplayed=%d,\n' % (self.isDisplayed,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Polygon2D is not None:
            showIndent(outfile, level)
            outfile.write('Polygon2D=model_._Polygon2D(\n')
            self.Polygon2D.exportLiteral(outfile, level, name_='Polygon2D')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Rectangle2D is not None:
            showIndent(outfile, level)
            outfile.write('Rectangle2D=model_._Rectangle2D(\n')
            self.Rectangle2D.exportLiteral(outfile, level, name_='Rectangle2D')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GroundOpticalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('GroundOpticalPropertyLink=model_._GroundOpticalPropertyLink(\n')
            self.GroundOpticalPropertyLink.exportLiteral(outfile, level, name_='GroundOpticalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GroundThermalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('GroundThermalPropertyLink=model_._GroundThermalPropertyLink(\n')
            self.GroundThermalPropertyLink.exportLiteral(outfile, level, name_='GroundThermalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PlotVegetationProperties is not None:
            showIndent(outfile, level)
            outfile.write('PlotVegetationProperties=model_._PlotVegetationProperties(\n')
            self.PlotVegetationProperties.exportLiteral(outfile, level, name_='PlotVegetationProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PlotAirProperties is not None:
            showIndent(outfile, level)
            outfile.write('PlotAirProperties=model_._PlotAirProperties(\n')
            self.PlotAirProperties.exportLiteral(outfile, level, name_='PlotAirProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PlotWaterProperties is not None:
            showIndent(outfile, level)
            outfile.write('PlotWaterProperties=model_._PlotWaterProperties(\n')
            self.PlotWaterProperties.exportLiteral(outfile, level, name_='PlotWaterProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hidden', node)
        if value is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            try:
                self.hidden = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('repeatedOnBorder', node)
        if value is not None and 'repeatedOnBorder' not in already_processed:
            already_processed.add('repeatedOnBorder')
            try:
                self.repeatedOnBorder = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            try:
                self.type_ = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('form', node)
        if value is not None and 'form' not in already_processed:
            already_processed.add('form')
            try:
                self.form = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isDisplayed', node)
        if value is not None and 'isDisplayed' not in already_processed:
            already_processed.add('isDisplayed')
            try:
                self.isDisplayed = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Polygon2D':
            obj_ = create_Polygon2D.factory()
            obj_.build(child_)
            self.set_Polygon2D(obj_)
            obj_.original_tagname_ = 'Polygon2D'
        elif nodeName_ == 'Rectangle2D':
            obj_ = create_Rectangle2D.factory()
            obj_.build(child_)
            self.set_Rectangle2D(obj_)
            obj_.original_tagname_ = 'Rectangle2D'
        elif nodeName_ == 'GroundOpticalPropertyLink':
            obj_ = create_GroundOpticalPropertyLink.factory()
            obj_.build(child_)
            self.set_GroundOpticalPropertyLink(obj_)
            obj_.original_tagname_ = 'GroundOpticalPropertyLink'
        elif nodeName_ == 'GroundThermalPropertyLink':
            obj_ = create_GroundThermalPropertyLink.factory()
            obj_.build(child_)
            self.set_GroundThermalPropertyLink(obj_)
            obj_.original_tagname_ = 'GroundThermalPropertyLink'
        elif nodeName_ == 'PlotVegetationProperties':
            obj_ = create_PlotVegetationProperties.factory()
            obj_.build(child_)
            self.set_PlotVegetationProperties(obj_)
            obj_.original_tagname_ = 'PlotVegetationProperties'
        elif nodeName_ == 'PlotAirProperties':
            obj_ = create_PlotAirProperties.factory()
            obj_.build(child_)
            self.set_PlotAirProperties(obj_)
            obj_.original_tagname_ = 'PlotAirProperties'
        elif nodeName_ == 'PlotWaterProperties':
            obj_ = create_PlotWaterProperties.factory()
            obj_.build(child_)
            self.set_PlotWaterProperties(obj_)
            obj_.original_tagname_ = 'PlotWaterProperties'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_Plot


class create_Polygon2D(GeneratedsSuper):
    """Representation of a DART polygon. He's defined by his 4 corners,
    starting form the top left one, and turning anticlockwise.
    Representation of a DART polygon. He's defined by his 4 corners,
    starting form the top left one, and turning anticlockwise."""
    member_data_items_ = [
        MemberSpec_('Point2D', '_Point2D', 1, 0, {u'maxOccurs': u'4', u'type': u'_Point2D', u'name': u'Point2D', u'minOccurs': u'4'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Point2D=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('plots','_Polygon2D')
        self.attrib = ['']
        self.children = ['Point2D']
        self.parent = None
        if Point2D is None:
            self._Point2D = []
        else:
            self._Point2D = Point2D
        update_node(self,self.troot,'plots')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Polygon2D)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Polygon2D.subclass:
            return create_Polygon2D.subclass(*args_, **kwargs_)
        else:
            return create_Polygon2D(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Point2D(self): return self._Point2D
    def set_Point2D(self, value):
        if value is not None:
            checkclass(value, create_Point2D)
            for v in value:
                v.parent = self
        self._Point2D = value
    def add_Point2D(self, value):
        if (value is not None) and (len(self._Point2D) == 4):
            raise ValueError('Maximum length already reached.')
        value.parent = self
        self._Point2D.append(value)
    def insert_Point2D_at(self, index, value):
        if (value is not None) and (len(self._Point2D) == 4):
            raise ValueError('Maximum length already reached.')
        value.parent = self
        self.Point2D.insert(index, value)
    def replace_Point2D_at(self, index, value):
        value.parent = self
        self.Point2D[index] = value
    Point2D = property(get_Point2D, set_Point2D)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Point2D
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Polygon2D', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Polygon2D')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Polygon2D')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Polygon2D', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Polygon2D'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Polygon2D', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Point2D_ in self.Point2D:
            Point2D_.export(outfile, level, namespaceprefix_, name_='Point2D', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Polygon2D', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for Point2D_ in self.Point2D:
            Point2D_.to_etree(element, name_='Point2D', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Polygon2D'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Point2D=[\n')
        level += 1
        for Point2D_ in self.Point2D:
            showIndent(outfile, level)
            outfile.write('model_._Point2D(\n')
            Point2D_.exportLiteral(outfile, level, name_='_Point2D')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.Point2D = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Point2D':
            obj_ = create_Point2D.factory()
            obj_.build(child_)
            self.add_Point2D(obj_)
            obj_.original_tagname_ = 'Point2D'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_Polygon2D


class create_Point2D(GeneratedsSuper):
    """Optical properties for a DART soil phase function. Optical
    properties for a DART soil phase function. y coordinate of a
    corner of the quadrilateral that defines the plot. Points are
    defined anticlockwise y coordinate of a corner of the
    quadrilateral that defines the plot. Points are defined
    anticlockwise x coordinate of a corner of the quadrilateral that
    defines the plot. Points are defined anticlockwise x coordinate
    of a corner of the quadrilateral that defines the plot. Points
    are defined anticlockwise"""
    member_data_items_ = [
        MemberSpec_('y', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('x', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, y=0.00, x=0.00):
        self.original_tagname_ = None
        self.troot=get_gs_troot('plots','_Point2D')
        self.attrib = ['y', 'x']
        self.children = []
        self.parent = None
        self._y = _cast(float, y)
        self._x = _cast(float, x)
        update_node(self,self.troot,'plots')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Point2D)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Point2D.subclass:
            return create_Point2D.subclass(*args_, **kwargs_)
        else:
            return create_Point2D(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_y(self): return self._y
    def set_y(self, value):
        self._y = value
        update_node(self,self.troot,'plots')
    y = property(get_y, set_y)
    def get_x(self): return self._x
    def set_x(self, value):
        self._x = value
        update_node(self,self.troot,'plots')
    x = property(get_x, set_x)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Point2D', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Point2D')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Point2D')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Point2D', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Point2D'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y="%s"' % self.gds_format_double(self.y, input_name='y'))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name='x'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Point2D', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_Point2D', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.y is not None:
            element.set('y', self.gds_format_double(self.y))
        if self.x is not None:
            element.set('x', self.gds_format_double(self.x))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Point2D'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            showIndent(outfile, level)
            outfile.write('y=%e,\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            showIndent(outfile, level)
            outfile.write('x=%e,\n' % (self.x,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            try:
                self.y = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (y): %s' % exp)
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            try:
                self.x = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_Point2D


class create_Rectangle2D(GeneratedsSuper):
    """Rectangle2D Rectangle2D Length along X axis (in meters) Length along
    X axis (in meters) Length along Y axis (in meters) Length along
    Y axis (in meters) Rotation around the plot center (in degrees,
    in the range [-180, 180]) Rotation around the plot center (in
    degrees, in the range [-180, 180]) Center along X axis (in
    meters) Center along X axis (in meters) Center along Y axis (in
    meters) Center along Y axis (in meters)"""
    member_data_items_ = [
        MemberSpec_('coteX', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('coteY', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('intrinsicRotation', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('centreX', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('centreY', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, coteX=10, coteY=10, intrinsicRotation=0, centreX=5, centreY=5):
        self.original_tagname_ = None
        self.troot=get_gs_troot('plots','_Rectangle2D')
        self.attrib = ['coteX', 'coteY', 'intrinsicRotation', 'centreX', 'centreY']
        self.children = []
        self.parent = None
        self._coteX = _cast(float, coteX)
        self._coteY = _cast(float, coteY)
        self._intrinsicRotation = _cast(float, intrinsicRotation)
        self._centreX = _cast(float, centreX)
        self._centreY = _cast(float, centreY)
        update_node(self,self.troot,'plots')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Rectangle2D)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Rectangle2D.subclass:
            return create_Rectangle2D.subclass(*args_, **kwargs_)
        else:
            return create_Rectangle2D(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_coteX(self): return self._coteX
    def set_coteX(self, value):
        self._coteX = value
        update_node(self,self.troot,'plots')
    coteX = property(get_coteX, set_coteX)
    def get_coteY(self): return self._coteY
    def set_coteY(self, value):
        self._coteY = value
        update_node(self,self.troot,'plots')
    coteY = property(get_coteY, set_coteY)
    def get_intrinsicRotation(self): return self._intrinsicRotation
    def set_intrinsicRotation(self, value):
        self._intrinsicRotation = value
        update_node(self,self.troot,'plots')
    intrinsicRotation = property(get_intrinsicRotation, set_intrinsicRotation)
    def get_centreX(self): return self._centreX
    def set_centreX(self, value):
        self._centreX = value
        update_node(self,self.troot,'plots')
    centreX = property(get_centreX, set_centreX)
    def get_centreY(self): return self._centreY
    def set_centreY(self, value):
        self._centreY = value
        update_node(self,self.troot,'plots')
    centreY = property(get_centreY, set_centreY)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Rectangle2D', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Rectangle2D')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Rectangle2D')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Rectangle2D', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Rectangle2D'):
        if self.coteX is not None and 'coteX' not in already_processed:
            already_processed.add('coteX')
            outfile.write(' coteX="%s"' % self.gds_format_double(self.coteX, input_name='coteX'))
        if self.coteY is not None and 'coteY' not in already_processed:
            already_processed.add('coteY')
            outfile.write(' coteY="%s"' % self.gds_format_double(self.coteY, input_name='coteY'))
        if self.intrinsicRotation is not None and 'intrinsicRotation' not in already_processed:
            already_processed.add('intrinsicRotation')
            outfile.write(' intrinsicRotation="%s"' % self.gds_format_double(self.intrinsicRotation, input_name='intrinsicRotation'))
        if self.centreX is not None and 'centreX' not in already_processed:
            already_processed.add('centreX')
            outfile.write(' centreX="%s"' % self.gds_format_double(self.centreX, input_name='centreX'))
        if self.centreY is not None and 'centreY' not in already_processed:
            already_processed.add('centreY')
            outfile.write(' centreY="%s"' % self.gds_format_double(self.centreY, input_name='centreY'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Rectangle2D', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_Rectangle2D', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.coteX is not None:
            element.set('coteX', self.gds_format_double(self.coteX))
        if self.coteY is not None:
            element.set('coteY', self.gds_format_double(self.coteY))
        if self.intrinsicRotation is not None:
            element.set('intrinsicRotation', self.gds_format_double(self.intrinsicRotation))
        if self.centreX is not None:
            element.set('centreX', self.gds_format_double(self.centreX))
        if self.centreY is not None:
            element.set('centreY', self.gds_format_double(self.centreY))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Rectangle2D'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.coteX is not None and 'coteX' not in already_processed:
            already_processed.add('coteX')
            showIndent(outfile, level)
            outfile.write('coteX=%e,\n' % (self.coteX,))
        if self.coteY is not None and 'coteY' not in already_processed:
            already_processed.add('coteY')
            showIndent(outfile, level)
            outfile.write('coteY=%e,\n' % (self.coteY,))
        if self.intrinsicRotation is not None and 'intrinsicRotation' not in already_processed:
            already_processed.add('intrinsicRotation')
            showIndent(outfile, level)
            outfile.write('intrinsicRotation=%e,\n' % (self.intrinsicRotation,))
        if self.centreX is not None and 'centreX' not in already_processed:
            already_processed.add('centreX')
            showIndent(outfile, level)
            outfile.write('centreX=%e,\n' % (self.centreX,))
        if self.centreY is not None and 'centreY' not in already_processed:
            already_processed.add('centreY')
            showIndent(outfile, level)
            outfile.write('centreY=%e,\n' % (self.centreY,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('coteX', node)
        if value is not None and 'coteX' not in already_processed:
            already_processed.add('coteX')
            try:
                self.coteX = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (coteX): %s' % exp)
        value = find_attr_value_('coteY', node)
        if value is not None and 'coteY' not in already_processed:
            already_processed.add('coteY')
            try:
                self.coteY = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (coteY): %s' % exp)
        value = find_attr_value_('intrinsicRotation', node)
        if value is not None and 'intrinsicRotation' not in already_processed:
            already_processed.add('intrinsicRotation')
            try:
                self.intrinsicRotation = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (intrinsicRotation): %s' % exp)
        value = find_attr_value_('centreX', node)
        if value is not None and 'centreX' not in already_processed:
            already_processed.add('centreX')
            try:
                self.centreX = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (centreX): %s' % exp)
        value = find_attr_value_('centreY', node)
        if value is not None and 'centreY' not in already_processed:
            already_processed.add('centreY')
            try:
                self.centreY = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (centreY): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_Rectangle2D


class create_GroundOpticalPropertyLink(GeneratedsSuper):
    """Optical properties for a DART soil phase function (name, type and
    index). Optical properties for a DART soil phase function (name,
    type and index). Index of the DART phase function of the ground
    of the plot. Index of the DART phase function of the ground of
    the plot. proportion of photons intercepted along an incident
    direction that are scattered within a solid angle along a given
    direction proportion of photons intercepted along an incident
    direction that are scattered within a solid angle along a given
    direction Type of phase function (lambertian, etc.) Type of
    phase function (lambertian, etc.)"""
    member_data_items_ = [
        MemberSpec_('indexFctPhase', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('ident', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('type_', 'xsd:int', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, indexFctPhase=0, ident='Lambertian_Phase_Function_1', type_=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('plots','_GroundOpticalPropertyLink')
        self.attrib = ['indexFctPhase', 'ident', 'type_']
        self.children = []
        self.parent = None
        self._indexFctPhase = _cast(int, indexFctPhase)
        self._ident = _cast(None, ident)
        self._type_ = _cast(int, type_)
        update_node(self,self.troot,'plots')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_GroundOpticalPropertyLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_GroundOpticalPropertyLink.subclass:
            return create_GroundOpticalPropertyLink.subclass(*args_, **kwargs_)
        else:
            return create_GroundOpticalPropertyLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexFctPhase(self): return self._indexFctPhase
    def set_indexFctPhase(self, value):
        self._indexFctPhase = value
        update_node(self,self.troot,'plots')
    indexFctPhase = property(get_indexFctPhase, set_indexFctPhase)
    def get_ident(self): return self._ident
    def set_ident(self, value):
        self._ident = value
        update_node(self,self.troot,'plots')
    ident = property(get_ident, set_ident)
    def get_type(self): return self._type_
    def set_type(self, value):
        self._type_ = value
        update_node(self,self.troot,'plots')
    type_ = property(get_type, set_type)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_GroundOpticalPropertyLink', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_GroundOpticalPropertyLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_GroundOpticalPropertyLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_GroundOpticalPropertyLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_GroundOpticalPropertyLink'):
        if self.indexFctPhase is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            outfile.write(' indexFctPhase="%s"' % self.gds_format_integer(self.indexFctPhase, input_name='indexFctPhase'))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            outfile.write(' ident=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ident), input_name='ident')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type="%s"' % self.gds_format_integer(self.type_, input_name='type'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_GroundOpticalPropertyLink', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_GroundOpticalPropertyLink', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.indexFctPhase is not None:
            element.set('indexFctPhase', self.gds_format_integer(self.indexFctPhase))
        if self.ident is not None:
            element.set('ident', self.gds_format_string(self.ident))
        if self.type_ is not None:
            element.set('type', self.gds_format_integer(self.type_))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_GroundOpticalPropertyLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.indexFctPhase is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            showIndent(outfile, level)
            outfile.write('indexFctPhase=%d,\n' % (self.indexFctPhase,))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            showIndent(outfile, level)
            outfile.write('ident="%s",\n' % (self.ident,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_=%d,\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('indexFctPhase', node)
        if value is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            try:
                self.indexFctPhase = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ident', node)
        if value is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            self.ident = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            try:
                self.type_ = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_GroundOpticalPropertyLink


class create_GroundThermalPropertyLink(GeneratedsSuper):
    """GroundThermalPropertyLink GroundThermalPropertyLink indexTemperature
    indexTemperature Thermal Function ID Thermal Function ID"""
    member_data_items_ = [
        MemberSpec_('indexTemperature', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('idTemperature', 'xsd:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, indexTemperature=0, idTemperature='ThermalFunction290_310'):
        self.original_tagname_ = None
        self.troot=get_gs_troot('plots','_GroundThermalPropertyLink')
        self.attrib = ['indexTemperature', 'idTemperature']
        self.children = []
        self.parent = None
        self._indexTemperature = _cast(int, indexTemperature)
        self._idTemperature = _cast(None, idTemperature)
        update_node(self,self.troot,'plots')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_GroundThermalPropertyLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_GroundThermalPropertyLink.subclass:
            return create_GroundThermalPropertyLink.subclass(*args_, **kwargs_)
        else:
            return create_GroundThermalPropertyLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexTemperature(self): return self._indexTemperature
    def set_indexTemperature(self, value):
        self._indexTemperature = value
        update_node(self,self.troot,'plots')
    indexTemperature = property(get_indexTemperature, set_indexTemperature)
    def get_idTemperature(self): return self._idTemperature
    def set_idTemperature(self, value):
        self._idTemperature = value
        update_node(self,self.troot,'plots')
    idTemperature = property(get_idTemperature, set_idTemperature)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_GroundThermalPropertyLink', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_GroundThermalPropertyLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_GroundThermalPropertyLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_GroundThermalPropertyLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_GroundThermalPropertyLink'):
        if self.indexTemperature is not None and 'indexTemperature' not in already_processed:
            already_processed.add('indexTemperature')
            outfile.write(' indexTemperature="%s"' % self.gds_format_integer(self.indexTemperature, input_name='indexTemperature'))
        if self.idTemperature is not None and 'idTemperature' not in already_processed:
            already_processed.add('idTemperature')
            outfile.write(' idTemperature=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idTemperature), input_name='idTemperature')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_GroundThermalPropertyLink', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_GroundThermalPropertyLink', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.indexTemperature is not None:
            element.set('indexTemperature', self.gds_format_integer(self.indexTemperature))
        if self.idTemperature is not None:
            element.set('idTemperature', self.gds_format_string(self.idTemperature))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_GroundThermalPropertyLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.indexTemperature is not None and 'indexTemperature' not in already_processed:
            already_processed.add('indexTemperature')
            showIndent(outfile, level)
            outfile.write('indexTemperature=%d,\n' % (self.indexTemperature,))
        if self.idTemperature is not None and 'idTemperature' not in already_processed:
            already_processed.add('idTemperature')
            showIndent(outfile, level)
            outfile.write('idTemperature="%s",\n' % (self.idTemperature,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('indexTemperature', node)
        if value is not None and 'indexTemperature' not in already_processed:
            already_processed.add('indexTemperature')
            try:
                self.indexTemperature = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('idTemperature', node)
        if value is not None and 'idTemperature' not in already_processed:
            already_processed.add('idTemperature')
            self.idTemperature = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_GroundThermalPropertyLink


class create_PlotVegetationProperties(GeneratedsSuper):
    """Caracteristics of a plot (height of its vegetation, LAI ...).
    Caracteristics of a plot (height of its vegetation, LAI ...).
    Fill everything in the defined area below a given altitude. Fill
    everything in the defined area below a given altitude. If
    checked, the plot will be represented as a cloud of triangles.
    Otherwise, it will be represented as a juxtaposition of turbid
    cells. If checked, the plot will be represented as a cloud of
    triangles. Otherwise, it will be represented as a juxtaposition
    of turbid cells. Choose if you define vegetation by LAI (foliar
    m2 / m2 of the plot) or Ul (foliar m2 / m3 of the plot) Choose
    if you define vegetation by LAI (foliar m2 / m2 of the plot) or
    Ul (foliar m2 / m3 of the plot)"""
    member_data_items_ = [
        MemberSpec_('verticalFillMode', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('trianglePlotRepresentation', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('densityDefinition', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('MeshPlotRepresentation', '_MeshPlotRepresentation', 0, 0, {u'maxOccurs': u'1', u'type': u'_MeshPlotRepresentation', u'name': u'MeshPlotRepresentation', u'minOccurs': u'1'}, None),
        MemberSpec_('VegetationGeometry', '_VegetationGeometry', 0, 0, {u'maxOccurs': u'1', u'type': u'_VegetationGeometry', u'name': u'VegetationGeometry', u'minOccurs': u'1'}, None),
        MemberSpec_('VegetationFillGeometry', '_VegetationFillGeometry', 0, 0, {u'maxOccurs': u'1', u'type': u'_VegetationFillGeometry', u'name': u'VegetationFillGeometry', u'minOccurs': u'1'}, None),
        MemberSpec_('LAIVegetation', '_LAIVegetation', 0, 0, {u'maxOccurs': u'1', u'type': u'_LAIVegetation', u'name': u'LAIVegetation', u'minOccurs': u'1'}, None),
        MemberSpec_('UFVegetation', '_UFVegetation', 0, 0, {u'maxOccurs': u'1', u'type': u'_UFVegetation', u'name': u'UFVegetation', u'minOccurs': u'1'}, None),
        MemberSpec_('VegetationOpticalPropertyLink', '_VegetationOpticalPropertyLink', 0, 0, {u'maxOccurs': u'1', u'type': u'_VegetationOpticalPropertyLink', u'name': u'VegetationOpticalPropertyLink', u'minOccurs': u'1'}, None),
        MemberSpec_('GroundThermalPropertyLink', '_GroundThermalPropertyLink', 0, 0, {u'maxOccurs': u'1', u'type': u'_GroundThermalPropertyLink', u'name': u'GroundThermalPropertyLink', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, verticalFillMode=0, trianglePlotRepresentation=0, densityDefinition=0, MeshPlotRepresentation=None, VegetationGeometry=None, VegetationFillGeometry=None, LAIVegetation=None, UFVegetation=None, VegetationOpticalPropertyLink=None, GroundThermalPropertyLink=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('plots','_PlotVegetationProperties')
        self.attrib = ['verticalFillMode', 'trianglePlotRepresentation', 'densityDefinition']
        self.children = ['MeshPlotRepresentation', 'VegetationGeometry', 'VegetationFillGeometry', 'LAIVegetation', 'UFVegetation', 'VegetationOpticalPropertyLink', 'GroundThermalPropertyLink']
        self.parent = None
        self._verticalFillMode = _cast(int, verticalFillMode)
        self._trianglePlotRepresentation = _cast(int, trianglePlotRepresentation)
        self._densityDefinition = _cast(int, densityDefinition)
        self._MeshPlotRepresentation = MeshPlotRepresentation
        self._VegetationGeometry = VegetationGeometry
        self._VegetationFillGeometry = VegetationFillGeometry
        self._LAIVegetation = LAIVegetation
        self._UFVegetation = UFVegetation
        self._VegetationOpticalPropertyLink = VegetationOpticalPropertyLink
        self._GroundThermalPropertyLink = GroundThermalPropertyLink
        update_node(self,self.troot,'plots')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_PlotVegetationProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_PlotVegetationProperties.subclass:
            return create_PlotVegetationProperties.subclass(*args_, **kwargs_)
        else:
            return create_PlotVegetationProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MeshPlotRepresentation(self): return self._MeshPlotRepresentation
    def set_MeshPlotRepresentation(self, value):
        if value is not None:
            checkclass(value, create_MeshPlotRepresentation)
            value.parent = self
        self._MeshPlotRepresentation = value
    MeshPlotRepresentation = property(get_MeshPlotRepresentation, set_MeshPlotRepresentation)
    def get_VegetationGeometry(self): return self._VegetationGeometry
    def set_VegetationGeometry(self, value):
        if value is not None:
            checkclass(value, create_VegetationGeometry)
            value.parent = self
        self._VegetationGeometry = value
    VegetationGeometry = property(get_VegetationGeometry, set_VegetationGeometry)
    def get_VegetationFillGeometry(self): return self._VegetationFillGeometry
    def set_VegetationFillGeometry(self, value):
        if value is not None:
            checkclass(value, create_VegetationFillGeometry)
            value.parent = self
        self._VegetationFillGeometry = value
    VegetationFillGeometry = property(get_VegetationFillGeometry, set_VegetationFillGeometry)
    def get_LAIVegetation(self): return self._LAIVegetation
    def set_LAIVegetation(self, value):
        if value is not None:
            checkclass(value, create_LAIVegetation)
            value.parent = self
        self._LAIVegetation = value
    LAIVegetation = property(get_LAIVegetation, set_LAIVegetation)
    def get_UFVegetation(self): return self._UFVegetation
    def set_UFVegetation(self, value):
        if value is not None:
            checkclass(value, create_UFVegetation)
            value.parent = self
        self._UFVegetation = value
    UFVegetation = property(get_UFVegetation, set_UFVegetation)
    def get_VegetationOpticalPropertyLink(self): return self._VegetationOpticalPropertyLink
    def set_VegetationOpticalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_VegetationOpticalPropertyLink)
            value.parent = self
        self._VegetationOpticalPropertyLink = value
    VegetationOpticalPropertyLink = property(get_VegetationOpticalPropertyLink, set_VegetationOpticalPropertyLink)
    def get_GroundThermalPropertyLink(self): return self._GroundThermalPropertyLink
    def set_GroundThermalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_GroundThermalPropertyLink)
            value.parent = self
        self._GroundThermalPropertyLink = value
    GroundThermalPropertyLink = property(get_GroundThermalPropertyLink, set_GroundThermalPropertyLink)
    def get_verticalFillMode(self): return self._verticalFillMode
    def set_verticalFillMode(self, value):
        self._verticalFillMode = value
        update_node(self,self.troot,'plots')
    verticalFillMode = property(get_verticalFillMode, set_verticalFillMode)
    def get_trianglePlotRepresentation(self): return self._trianglePlotRepresentation
    def set_trianglePlotRepresentation(self, value):
        self._trianglePlotRepresentation = value
        update_node(self,self.troot,'plots')
    trianglePlotRepresentation = property(get_trianglePlotRepresentation, set_trianglePlotRepresentation)
    def get_densityDefinition(self): return self._densityDefinition
    def set_densityDefinition(self, value):
        self._densityDefinition = value
        update_node(self,self.troot,'plots')
    densityDefinition = property(get_densityDefinition, set_densityDefinition)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.MeshPlotRepresentation is not None or
            self.VegetationGeometry is not None or
            self.VegetationFillGeometry is not None or
            self.LAIVegetation is not None or
            self.UFVegetation is not None or
            self.VegetationOpticalPropertyLink is not None or
            self.GroundThermalPropertyLink is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_PlotVegetationProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_PlotVegetationProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_PlotVegetationProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_PlotVegetationProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_PlotVegetationProperties'):
        if self.verticalFillMode is not None and 'verticalFillMode' not in already_processed:
            already_processed.add('verticalFillMode')
            outfile.write(' verticalFillMode="%s"' % self.gds_format_integer(self.verticalFillMode, input_name='verticalFillMode'))
        if self.trianglePlotRepresentation is not None and 'trianglePlotRepresentation' not in already_processed:
            already_processed.add('trianglePlotRepresentation')
            outfile.write(' trianglePlotRepresentation="%s"' % self.gds_format_integer(self.trianglePlotRepresentation, input_name='trianglePlotRepresentation'))
        if self.densityDefinition is not None and 'densityDefinition' not in already_processed:
            already_processed.add('densityDefinition')
            outfile.write(' densityDefinition="%s"' % self.gds_format_integer(self.densityDefinition, input_name='densityDefinition'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_PlotVegetationProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MeshPlotRepresentation is not None:
            self.MeshPlotRepresentation.export(outfile, level, namespaceprefix_, name_='MeshPlotRepresentation', pretty_print=pretty_print)
        if self.VegetationGeometry is not None:
            self.VegetationGeometry.export(outfile, level, namespaceprefix_, name_='VegetationGeometry', pretty_print=pretty_print)
        if self.VegetationFillGeometry is not None:
            self.VegetationFillGeometry.export(outfile, level, namespaceprefix_, name_='VegetationFillGeometry', pretty_print=pretty_print)
        if self.LAIVegetation is not None:
            self.LAIVegetation.export(outfile, level, namespaceprefix_, name_='LAIVegetation', pretty_print=pretty_print)
        if self.UFVegetation is not None:
            self.UFVegetation.export(outfile, level, namespaceprefix_, name_='UFVegetation', pretty_print=pretty_print)
        if self.VegetationOpticalPropertyLink is not None:
            self.VegetationOpticalPropertyLink.export(outfile, level, namespaceprefix_, name_='VegetationOpticalPropertyLink', pretty_print=pretty_print)
        if self.GroundThermalPropertyLink is not None:
            self.GroundThermalPropertyLink.export(outfile, level, namespaceprefix_, name_='GroundThermalPropertyLink', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_PlotVegetationProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.verticalFillMode is not None:
            element.set('verticalFillMode', self.gds_format_integer(self.verticalFillMode))
        if self.trianglePlotRepresentation is not None:
            element.set('trianglePlotRepresentation', self.gds_format_integer(self.trianglePlotRepresentation))
        if self.densityDefinition is not None:
            element.set('densityDefinition', self.gds_format_integer(self.densityDefinition))
        if self.MeshPlotRepresentation is not None:
            MeshPlotRepresentation_ = self.MeshPlotRepresentation
            MeshPlotRepresentation_.to_etree(element, name_='MeshPlotRepresentation', mapping_=mapping_)
        if self.VegetationGeometry is not None:
            VegetationGeometry_ = self.VegetationGeometry
            VegetationGeometry_.to_etree(element, name_='VegetationGeometry', mapping_=mapping_)
        if self.VegetationFillGeometry is not None:
            VegetationFillGeometry_ = self.VegetationFillGeometry
            VegetationFillGeometry_.to_etree(element, name_='VegetationFillGeometry', mapping_=mapping_)
        if self.LAIVegetation is not None:
            LAIVegetation_ = self.LAIVegetation
            LAIVegetation_.to_etree(element, name_='LAIVegetation', mapping_=mapping_)
        if self.UFVegetation is not None:
            UFVegetation_ = self.UFVegetation
            UFVegetation_.to_etree(element, name_='UFVegetation', mapping_=mapping_)
        if self.VegetationOpticalPropertyLink is not None:
            VegetationOpticalPropertyLink_ = self.VegetationOpticalPropertyLink
            VegetationOpticalPropertyLink_.to_etree(element, name_='VegetationOpticalPropertyLink', mapping_=mapping_)
        if self.GroundThermalPropertyLink is not None:
            GroundThermalPropertyLink_ = self.GroundThermalPropertyLink
            GroundThermalPropertyLink_.to_etree(element, name_='GroundThermalPropertyLink', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_PlotVegetationProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.verticalFillMode is not None and 'verticalFillMode' not in already_processed:
            already_processed.add('verticalFillMode')
            showIndent(outfile, level)
            outfile.write('verticalFillMode=%d,\n' % (self.verticalFillMode,))
        if self.trianglePlotRepresentation is not None and 'trianglePlotRepresentation' not in already_processed:
            already_processed.add('trianglePlotRepresentation')
            showIndent(outfile, level)
            outfile.write('trianglePlotRepresentation=%d,\n' % (self.trianglePlotRepresentation,))
        if self.densityDefinition is not None and 'densityDefinition' not in already_processed:
            already_processed.add('densityDefinition')
            showIndent(outfile, level)
            outfile.write('densityDefinition=%d,\n' % (self.densityDefinition,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MeshPlotRepresentation is not None:
            showIndent(outfile, level)
            outfile.write('MeshPlotRepresentation=model_._MeshPlotRepresentation(\n')
            self.MeshPlotRepresentation.exportLiteral(outfile, level, name_='MeshPlotRepresentation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VegetationGeometry is not None:
            showIndent(outfile, level)
            outfile.write('VegetationGeometry=model_._VegetationGeometry(\n')
            self.VegetationGeometry.exportLiteral(outfile, level, name_='VegetationGeometry')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VegetationFillGeometry is not None:
            showIndent(outfile, level)
            outfile.write('VegetationFillGeometry=model_._VegetationFillGeometry(\n')
            self.VegetationFillGeometry.exportLiteral(outfile, level, name_='VegetationFillGeometry')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LAIVegetation is not None:
            showIndent(outfile, level)
            outfile.write('LAIVegetation=model_._LAIVegetation(\n')
            self.LAIVegetation.exportLiteral(outfile, level, name_='LAIVegetation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.UFVegetation is not None:
            showIndent(outfile, level)
            outfile.write('UFVegetation=model_._UFVegetation(\n')
            self.UFVegetation.exportLiteral(outfile, level, name_='UFVegetation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VegetationOpticalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('VegetationOpticalPropertyLink=model_._VegetationOpticalPropertyLink(\n')
            self.VegetationOpticalPropertyLink.exportLiteral(outfile, level, name_='VegetationOpticalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GroundThermalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('GroundThermalPropertyLink=model_._GroundThermalPropertyLink(\n')
            self.GroundThermalPropertyLink.exportLiteral(outfile, level, name_='GroundThermalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('verticalFillMode', node)
        if value is not None and 'verticalFillMode' not in already_processed:
            already_processed.add('verticalFillMode')
            try:
                self.verticalFillMode = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('trianglePlotRepresentation', node)
        if value is not None and 'trianglePlotRepresentation' not in already_processed:
            already_processed.add('trianglePlotRepresentation')
            try:
                self.trianglePlotRepresentation = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('densityDefinition', node)
        if value is not None and 'densityDefinition' not in already_processed:
            already_processed.add('densityDefinition')
            try:
                self.densityDefinition = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeshPlotRepresentation':
            obj_ = create_MeshPlotRepresentation.factory()
            obj_.build(child_)
            self.set_MeshPlotRepresentation(obj_)
            obj_.original_tagname_ = 'MeshPlotRepresentation'
        elif nodeName_ == 'VegetationGeometry':
            obj_ = create_VegetationGeometry.factory()
            obj_.build(child_)
            self.set_VegetationGeometry(obj_)
            obj_.original_tagname_ = 'VegetationGeometry'
        elif nodeName_ == 'VegetationFillGeometry':
            obj_ = create_VegetationFillGeometry.factory()
            obj_.build(child_)
            self.set_VegetationFillGeometry(obj_)
            obj_.original_tagname_ = 'VegetationFillGeometry'
        elif nodeName_ == 'LAIVegetation':
            obj_ = create_LAIVegetation.factory()
            obj_.build(child_)
            self.set_LAIVegetation(obj_)
            obj_.original_tagname_ = 'LAIVegetation'
        elif nodeName_ == 'UFVegetation':
            obj_ = create_UFVegetation.factory()
            obj_.build(child_)
            self.set_UFVegetation(obj_)
            obj_.original_tagname_ = 'UFVegetation'
        elif nodeName_ == 'VegetationOpticalPropertyLink':
            obj_ = create_VegetationOpticalPropertyLink.factory()
            obj_.build(child_)
            self.set_VegetationOpticalPropertyLink(obj_)
            obj_.original_tagname_ = 'VegetationOpticalPropertyLink'
        elif nodeName_ == 'GroundThermalPropertyLink':
            obj_ = create_GroundThermalPropertyLink.factory()
            obj_.build(child_)
            self.set_GroundThermalPropertyLink(obj_)
            obj_.original_tagname_ = 'GroundThermalPropertyLink'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_PlotVegetationProperties


class create_MeshPlotRepresentation(GeneratedsSuper):
    """Defines how the leaves are geometrically distributed in the crown.
    Defines how the leaves are geometrically distributed in the
    crown. Definition of the leaves geometry and numbers. Definition
    of the leaves geometry and numbers."""
    member_data_items_ = [
        MemberSpec_('distributionMode', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('leafDefinition', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('NumberOfTriangleParameters', '_NumberOfTriangleParameters', 0, 0, {u'maxOccurs': u'1', u'type': u'_NumberOfTriangleParameters', u'name': u'NumberOfTriangleParameters', u'minOccurs': u'1'}, None),
        MemberSpec_('MeshLeafDimensionParameters', '_MeshLeafDimensionParameters', 0, 0, {u'maxOccurs': u'1', u'type': u'_MeshLeafDimensionParameters', u'name': u'MeshLeafDimensionParameters', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, distributionMode=0, leafDefinition=1, NumberOfTriangleParameters=None, MeshLeafDimensionParameters=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('plots','_MeshPlotRepresentation')
        self.attrib = ['distributionMode', 'leafDefinition']
        self.children = ['NumberOfTriangleParameters', 'MeshLeafDimensionParameters']
        self.parent = None
        self._distributionMode = _cast(int, distributionMode)
        self._leafDefinition = _cast(int, leafDefinition)
        self._NumberOfTriangleParameters = NumberOfTriangleParameters
        self._MeshLeafDimensionParameters = MeshLeafDimensionParameters
        update_node(self,self.troot,'plots')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_MeshPlotRepresentation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_MeshPlotRepresentation.subclass:
            return create_MeshPlotRepresentation.subclass(*args_, **kwargs_)
        else:
            return create_MeshPlotRepresentation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NumberOfTriangleParameters(self): return self._NumberOfTriangleParameters
    def set_NumberOfTriangleParameters(self, value):
        if value is not None:
            checkclass(value, create_NumberOfTriangleParameters)
            value.parent = self
        self._NumberOfTriangleParameters = value
    NumberOfTriangleParameters = property(get_NumberOfTriangleParameters, set_NumberOfTriangleParameters)
    def get_MeshLeafDimensionParameters(self): return self._MeshLeafDimensionParameters
    def set_MeshLeafDimensionParameters(self, value):
        if value is not None:
            checkclass(value, create_MeshLeafDimensionParameters)
            value.parent = self
        self._MeshLeafDimensionParameters = value
    MeshLeafDimensionParameters = property(get_MeshLeafDimensionParameters, set_MeshLeafDimensionParameters)
    def get_distributionMode(self): return self._distributionMode
    def set_distributionMode(self, value):
        self._distributionMode = value
        update_node(self,self.troot,'plots')
    distributionMode = property(get_distributionMode, set_distributionMode)
    def get_leafDefinition(self): return self._leafDefinition
    def set_leafDefinition(self, value):
        self._leafDefinition = value
        update_node(self,self.troot,'plots')
    leafDefinition = property(get_leafDefinition, set_leafDefinition)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.NumberOfTriangleParameters is not None or
            self.MeshLeafDimensionParameters is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_MeshPlotRepresentation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_MeshPlotRepresentation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_MeshPlotRepresentation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_MeshPlotRepresentation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_MeshPlotRepresentation'):
        if self.distributionMode is not None and 'distributionMode' not in already_processed:
            already_processed.add('distributionMode')
            outfile.write(' distributionMode="%s"' % self.gds_format_integer(self.distributionMode, input_name='distributionMode'))
        if self.leafDefinition is not None and 'leafDefinition' not in already_processed:
            already_processed.add('leafDefinition')
            outfile.write(' leafDefinition="%s"' % self.gds_format_integer(self.leafDefinition, input_name='leafDefinition'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_MeshPlotRepresentation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NumberOfTriangleParameters is not None:
            self.NumberOfTriangleParameters.export(outfile, level, namespaceprefix_, name_='NumberOfTriangleParameters', pretty_print=pretty_print)
        if self.MeshLeafDimensionParameters is not None:
            self.MeshLeafDimensionParameters.export(outfile, level, namespaceprefix_, name_='MeshLeafDimensionParameters', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_MeshPlotRepresentation', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.distributionMode is not None:
            element.set('distributionMode', self.gds_format_integer(self.distributionMode))
        if self.leafDefinition is not None:
            element.set('leafDefinition', self.gds_format_integer(self.leafDefinition))
        if self.NumberOfTriangleParameters is not None:
            NumberOfTriangleParameters_ = self.NumberOfTriangleParameters
            NumberOfTriangleParameters_.to_etree(element, name_='NumberOfTriangleParameters', mapping_=mapping_)
        if self.MeshLeafDimensionParameters is not None:
            MeshLeafDimensionParameters_ = self.MeshLeafDimensionParameters
            MeshLeafDimensionParameters_.to_etree(element, name_='MeshLeafDimensionParameters', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_MeshPlotRepresentation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.distributionMode is not None and 'distributionMode' not in already_processed:
            already_processed.add('distributionMode')
            showIndent(outfile, level)
            outfile.write('distributionMode=%d,\n' % (self.distributionMode,))
        if self.leafDefinition is not None and 'leafDefinition' not in already_processed:
            already_processed.add('leafDefinition')
            showIndent(outfile, level)
            outfile.write('leafDefinition=%d,\n' % (self.leafDefinition,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.NumberOfTriangleParameters is not None:
            showIndent(outfile, level)
            outfile.write('NumberOfTriangleParameters=model_._NumberOfTriangleParameters(\n')
            self.NumberOfTriangleParameters.exportLiteral(outfile, level, name_='NumberOfTriangleParameters')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MeshLeafDimensionParameters is not None:
            showIndent(outfile, level)
            outfile.write('MeshLeafDimensionParameters=model_._MeshLeafDimensionParameters(\n')
            self.MeshLeafDimensionParameters.exportLiteral(outfile, level, name_='MeshLeafDimensionParameters')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('distributionMode', node)
        if value is not None and 'distributionMode' not in already_processed:
            already_processed.add('distributionMode')
            try:
                self.distributionMode = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('leafDefinition', node)
        if value is not None and 'leafDefinition' not in already_processed:
            already_processed.add('leafDefinition')
            try:
                self.leafDefinition = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NumberOfTriangleParameters':
            obj_ = create_NumberOfTriangleParameters.factory()
            obj_.build(child_)
            self.set_NumberOfTriangleParameters(obj_)
            obj_.original_tagname_ = 'NumberOfTriangleParameters'
        elif nodeName_ == 'MeshLeafDimensionParameters':
            obj_ = create_MeshLeafDimensionParameters.factory()
            obj_.build(child_)
            self.set_MeshLeafDimensionParameters(obj_)
            obj_.original_tagname_ = 'MeshLeafDimensionParameters'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_MeshPlotRepresentation


class create_NumberOfTriangleParameters(GeneratedsSuper):
    """Fix the number of leaves/triangles of the plot. The leaf area will
    then be the total area of leaves in the plot divided by this
    number. The real effective number generated may vary due to
    rounding and distribution errors. Fix the number of
    leaves/triangles of the plot. The leaf area will then be the
    total area of leaves in the plot divided by this number. The
    real effective number generated may vary due to rounding and
    distribution errors."""
    member_data_items_ = [
        MemberSpec_('nbTriangles', 'xsd:int', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, nbTriangles=10000):
        self.original_tagname_ = None
        self.troot=get_gs_troot('plots','_NumberOfTriangleParameters')
        self.attrib = ['nbTriangles']
        self.children = []
        self.parent = None
        self._nbTriangles = _cast(int, nbTriangles)
        update_node(self,self.troot,'plots')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_NumberOfTriangleParameters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_NumberOfTriangleParameters.subclass:
            return create_NumberOfTriangleParameters.subclass(*args_, **kwargs_)
        else:
            return create_NumberOfTriangleParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nbTriangles(self): return self._nbTriangles
    def set_nbTriangles(self, value):
        self._nbTriangles = value
        update_node(self,self.troot,'plots')
    nbTriangles = property(get_nbTriangles, set_nbTriangles)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_NumberOfTriangleParameters', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_NumberOfTriangleParameters')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_NumberOfTriangleParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_NumberOfTriangleParameters', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_NumberOfTriangleParameters'):
        if self.nbTriangles is not None and 'nbTriangles' not in already_processed:
            already_processed.add('nbTriangles')
            outfile.write(' nbTriangles="%s"' % self.gds_format_integer(self.nbTriangles, input_name='nbTriangles'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_NumberOfTriangleParameters', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_NumberOfTriangleParameters', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.nbTriangles is not None:
            element.set('nbTriangles', self.gds_format_integer(self.nbTriangles))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_NumberOfTriangleParameters'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nbTriangles is not None and 'nbTriangles' not in already_processed:
            already_processed.add('nbTriangles')
            showIndent(outfile, level)
            outfile.write('nbTriangles=%d,\n' % (self.nbTriangles,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nbTriangles', node)
        if value is not None and 'nbTriangles' not in already_processed:
            already_processed.add('nbTriangles')
            try:
                self.nbTriangles = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_NumberOfTriangleParameters


class create_MeshLeafDimensionParameters(GeneratedsSuper):
    """Area of each individual leaf/triangle. The number of
    leaves/triangles will then be the total area of leaves in the
    plot divided by this number. The real effective number generated
    may vary due to rounding and distribution errors. Area of each
    individual leaf/triangle. The number of leaves/triangles will
    then be the total area of leaves in the plot divided by this
    number. The real effective number generated may vary due to
    rounding and distribution errors."""
    member_data_items_ = [
        MemberSpec_('meshLeafDimension', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, meshLeafDimension=0.003):
        self.original_tagname_ = None
        self.troot=get_gs_troot('plots','_MeshLeafDimensionParameters')
        self.attrib = ['meshLeafDimension']
        self.children = []
        self.parent = None
        self._meshLeafDimension = _cast(float, meshLeafDimension)
        update_node(self,self.troot,'plots')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_MeshLeafDimensionParameters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_MeshLeafDimensionParameters.subclass:
            return create_MeshLeafDimensionParameters.subclass(*args_, **kwargs_)
        else:
            return create_MeshLeafDimensionParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meshLeafDimension(self): return self._meshLeafDimension
    def set_meshLeafDimension(self, value):
        self._meshLeafDimension = value
        update_node(self,self.troot,'plots')
    meshLeafDimension = property(get_meshLeafDimension, set_meshLeafDimension)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_MeshLeafDimensionParameters', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_MeshLeafDimensionParameters')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_MeshLeafDimensionParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_MeshLeafDimensionParameters', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_MeshLeafDimensionParameters'):
        if self.meshLeafDimension is not None and 'meshLeafDimension' not in already_processed:
            already_processed.add('meshLeafDimension')
            outfile.write(' meshLeafDimension="%s"' % self.gds_format_double(self.meshLeafDimension, input_name='meshLeafDimension'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_MeshLeafDimensionParameters', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_MeshLeafDimensionParameters', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.meshLeafDimension is not None:
            element.set('meshLeafDimension', self.gds_format_double(self.meshLeafDimension))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_MeshLeafDimensionParameters'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.meshLeafDimension is not None and 'meshLeafDimension' not in already_processed:
            already_processed.add('meshLeafDimension')
            showIndent(outfile, level)
            outfile.write('meshLeafDimension=%e,\n' % (self.meshLeafDimension,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('meshLeafDimension', node)
        if value is not None and 'meshLeafDimension' not in already_processed:
            already_processed.add('meshLeafDimension')
            try:
                self.meshLeafDimension = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (meshLeafDimension): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_MeshLeafDimensionParameters


class create_VegetationGeometry(GeneratedsSuper):
    """Thickness of the vegetation layer Thickness of the vegetation layer
    Altitude in meter of the base of the vegetation above the ground
    of the plot. Altitude in meter of the base of the vegetation
    above the ground of the plot. Standard deviation of the
    vegetation layer height Standard deviation of the vegetation
    layer height"""
    member_data_items_ = [
        MemberSpec_('height', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('baseheight', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('stDev', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, height=1.0, baseheight=0, stDev=0.0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('plots','_VegetationGeometry')
        self.attrib = ['height', 'baseheight', 'stDev']
        self.children = []
        self.parent = None
        self._height = _cast(float, height)
        self._baseheight = _cast(float, baseheight)
        self._stDev = _cast(float, stDev)
        update_node(self,self.troot,'plots')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_VegetationGeometry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_VegetationGeometry.subclass:
            return create_VegetationGeometry.subclass(*args_, **kwargs_)
        else:
            return create_VegetationGeometry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_height(self): return self._height
    def set_height(self, value):
        self._height = value
        update_node(self,self.troot,'plots')
    height = property(get_height, set_height)
    def get_baseheight(self): return self._baseheight
    def set_baseheight(self, value):
        self._baseheight = value
        update_node(self,self.troot,'plots')
    baseheight = property(get_baseheight, set_baseheight)
    def get_stDev(self): return self._stDev
    def set_stDev(self, value):
        self._stDev = value
        update_node(self,self.troot,'plots')
    stDev = property(get_stDev, set_stDev)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_VegetationGeometry', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_VegetationGeometry')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_VegetationGeometry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_VegetationGeometry', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_VegetationGeometry'):
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height="%s"' % self.gds_format_double(self.height, input_name='height'))
        if self.baseheight is not None and 'baseheight' not in already_processed:
            already_processed.add('baseheight')
            outfile.write(' baseheight="%s"' % self.gds_format_double(self.baseheight, input_name='baseheight'))
        if self.stDev is not None and 'stDev' not in already_processed:
            already_processed.add('stDev')
            outfile.write(' stDev="%s"' % self.gds_format_double(self.stDev, input_name='stDev'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_VegetationGeometry', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_VegetationGeometry', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.height is not None:
            element.set('height', self.gds_format_double(self.height))
        if self.baseheight is not None:
            element.set('baseheight', self.gds_format_double(self.baseheight))
        if self.stDev is not None:
            element.set('stDev', self.gds_format_double(self.stDev))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_VegetationGeometry'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            showIndent(outfile, level)
            outfile.write('height=%e,\n' % (self.height,))
        if self.baseheight is not None and 'baseheight' not in already_processed:
            already_processed.add('baseheight')
            showIndent(outfile, level)
            outfile.write('baseheight=%e,\n' % (self.baseheight,))
        if self.stDev is not None and 'stDev' not in already_processed:
            already_processed.add('stDev')
            showIndent(outfile, level)
            outfile.write('stDev=%e,\n' % (self.stDev,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            try:
                self.height = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (height): %s' % exp)
        value = find_attr_value_('baseheight', node)
        if value is not None and 'baseheight' not in already_processed:
            already_processed.add('baseheight')
            try:
                self.baseheight = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (baseheight): %s' % exp)
        value = find_attr_value_('stDev', node)
        if value is not None and 'stDev' not in already_processed:
            already_processed.add('stDev')
            try:
                self.stDev = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (stDev): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_VegetationGeometry


class create_VegetationFillGeometry(GeneratedsSuper):
    """Altitude up to which the plot fill the scene, stating from the
    bottom of the scene Altitude up to which the plot fill the
    scene, stating from the bottom of the scene"""
    member_data_items_ = [
        MemberSpec_('topHeight', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, topHeight=1.0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('plots','_VegetationFillGeometry')
        self.attrib = ['topHeight']
        self.children = []
        self.parent = None
        self._topHeight = _cast(float, topHeight)
        update_node(self,self.troot,'plots')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_VegetationFillGeometry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_VegetationFillGeometry.subclass:
            return create_VegetationFillGeometry.subclass(*args_, **kwargs_)
        else:
            return create_VegetationFillGeometry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_topHeight(self): return self._topHeight
    def set_topHeight(self, value):
        self._topHeight = value
        update_node(self,self.troot,'plots')
    topHeight = property(get_topHeight, set_topHeight)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_VegetationFillGeometry', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_VegetationFillGeometry')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_VegetationFillGeometry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_VegetationFillGeometry', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_VegetationFillGeometry'):
        if self.topHeight is not None and 'topHeight' not in already_processed:
            already_processed.add('topHeight')
            outfile.write(' topHeight="%s"' % self.gds_format_double(self.topHeight, input_name='topHeight'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_VegetationFillGeometry', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_VegetationFillGeometry', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.topHeight is not None:
            element.set('topHeight', self.gds_format_double(self.topHeight))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_VegetationFillGeometry'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.topHeight is not None and 'topHeight' not in already_processed:
            already_processed.add('topHeight')
            showIndent(outfile, level)
            outfile.write('topHeight=%e,\n' % (self.topHeight,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('topHeight', node)
        if value is not None and 'topHeight' not in already_processed:
            already_processed.add('topHeight')
            try:
                self.topHeight = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (topHeight): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_VegetationFillGeometry


class create_LAIVegetation(GeneratedsSuper):
    """Leaf Area Index: total leaf area in the plot divided by the scene
    area. Leaf Area Index: total leaf area in the plot divided by
    the scene area."""
    member_data_items_ = [
        MemberSpec_('LAI', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, LAI=1.0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('plots','_LAIVegetation')
        self.attrib = ['LAI']
        self.children = []
        self.parent = None
        self._LAI = _cast(float, LAI)
        update_node(self,self.troot,'plots')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_LAIVegetation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_LAIVegetation.subclass:
            return create_LAIVegetation.subclass(*args_, **kwargs_)
        else:
            return create_LAIVegetation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LAI(self): return self._LAI
    def set_LAI(self, value):
        self._LAI = value
        update_node(self,self.troot,'plots')
    LAI = property(get_LAI, set_LAI)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_LAIVegetation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_LAIVegetation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_LAIVegetation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_LAIVegetation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_LAIVegetation'):
        if self.LAI is not None and 'LAI' not in already_processed:
            already_processed.add('LAI')
            outfile.write(' LAI="%s"' % self.gds_format_double(self.LAI, input_name='LAI'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_LAIVegetation', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_LAIVegetation', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.LAI is not None:
            element.set('LAI', self.gds_format_double(self.LAI))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_LAIVegetation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.LAI is not None and 'LAI' not in already_processed:
            already_processed.add('LAI')
            showIndent(outfile, level)
            outfile.write('LAI=%e,\n' % (self.LAI,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('LAI', node)
        if value is not None and 'LAI' not in already_processed:
            already_processed.add('LAI')
            try:
                self.LAI = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (LAI): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_LAIVegetation


class create_UFVegetation(GeneratedsSuper):
    """Ul Ul"""
    member_data_items_ = [
        MemberSpec_('UF', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, UF=1.0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('plots','_UFVegetation')
        self.attrib = ['UF']
        self.children = []
        self.parent = None
        self._UF = _cast(float, UF)
        update_node(self,self.troot,'plots')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_UFVegetation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_UFVegetation.subclass:
            return create_UFVegetation.subclass(*args_, **kwargs_)
        else:
            return create_UFVegetation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UF(self): return self._UF
    def set_UF(self, value):
        self._UF = value
        update_node(self,self.troot,'plots')
    UF = property(get_UF, set_UF)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_UFVegetation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_UFVegetation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_UFVegetation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_UFVegetation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_UFVegetation'):
        if self.UF is not None and 'UF' not in already_processed:
            already_processed.add('UF')
            outfile.write(' UF="%s"' % self.gds_format_double(self.UF, input_name='UF'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_UFVegetation', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_UFVegetation', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.UF is not None:
            element.set('UF', self.gds_format_double(self.UF))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_UFVegetation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.UF is not None and 'UF' not in already_processed:
            already_processed.add('UF')
            showIndent(outfile, level)
            outfile.write('UF=%e,\n' % (self.UF,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('UF', node)
        if value is not None and 'UF' not in already_processed:
            already_processed.add('UF')
            try:
                self.UF = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (UF): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_UFVegetation


class create_VegetationOpticalPropertyLink(GeneratedsSuper):
    """Optical properties for a DART vegetation phase function (name, type
    and index). Optical properties for a DART vegetation phase
    function (name, type and index). Index of the DART phase
    function of the ground of the plot. Index of the DART phase
    function of the ground of the plot. proportion of photons
    intercepted along an incident direction that are scattered
    within a solid angle along a given direction proportion of
    photons intercepted along an incident direction that are
    scattered within a solid angle along a given direction"""
    member_data_items_ = [
        MemberSpec_('indexFctPhase', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('ident', 'xsd:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, indexFctPhase=0, ident='Turbid_Leaf_Deciduous_Phase_Function'):
        self.original_tagname_ = None
        self.troot=get_gs_troot('plots','_VegetationOpticalPropertyLink')
        self.attrib = ['indexFctPhase', 'ident']
        self.children = []
        self.parent = None
        self._indexFctPhase = _cast(int, indexFctPhase)
        self._ident = _cast(None, ident)
        update_node(self,self.troot,'plots')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_VegetationOpticalPropertyLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_VegetationOpticalPropertyLink.subclass:
            return create_VegetationOpticalPropertyLink.subclass(*args_, **kwargs_)
        else:
            return create_VegetationOpticalPropertyLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexFctPhase(self): return self._indexFctPhase
    def set_indexFctPhase(self, value):
        self._indexFctPhase = value
        update_node(self,self.troot,'plots')
    indexFctPhase = property(get_indexFctPhase, set_indexFctPhase)
    def get_ident(self): return self._ident
    def set_ident(self, value):
        self._ident = value
        update_node(self,self.troot,'plots')
    ident = property(get_ident, set_ident)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_VegetationOpticalPropertyLink', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_VegetationOpticalPropertyLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_VegetationOpticalPropertyLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_VegetationOpticalPropertyLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_VegetationOpticalPropertyLink'):
        if self.indexFctPhase is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            outfile.write(' indexFctPhase="%s"' % self.gds_format_integer(self.indexFctPhase, input_name='indexFctPhase'))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            outfile.write(' ident=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ident), input_name='ident')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_VegetationOpticalPropertyLink', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_VegetationOpticalPropertyLink', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.indexFctPhase is not None:
            element.set('indexFctPhase', self.gds_format_integer(self.indexFctPhase))
        if self.ident is not None:
            element.set('ident', self.gds_format_string(self.ident))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_VegetationOpticalPropertyLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.indexFctPhase is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            showIndent(outfile, level)
            outfile.write('indexFctPhase=%d,\n' % (self.indexFctPhase,))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            showIndent(outfile, level)
            outfile.write('ident="%s",\n' % (self.ident,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('indexFctPhase', node)
        if value is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            try:
                self.indexFctPhase = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ident', node)
        if value is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            self.ident = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_VegetationOpticalPropertyLink


class create_PlotAirProperties(GeneratedsSuper):
    """PlotAirProperties PlotAirProperties Fill everything in the defined
    area below a given altitude. Fill everything in the defined area
    below a given altitude. Number of gas/particles in the air plot.
    Number of gas/particles in the air plot."""
    member_data_items_ = [
        MemberSpec_('verticalFillMode', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('nbParticule', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('AirGeometry', '_AirGeometry', 0, 0, {u'maxOccurs': u'1', u'type': u'_AirGeometry', u'name': u'AirGeometry', u'minOccurs': u'1'}, None),
        MemberSpec_('AirFillGeometry', '_AirFillGeometry', 0, 0, {u'maxOccurs': u'1', u'type': u'_AirFillGeometry', u'name': u'AirFillGeometry', u'minOccurs': u'1'}, None),
        MemberSpec_('AirOpticalProperties', '_AirOpticalProperties', 1, 0, {u'maxOccurs': u'unbounded', u'type': u'_AirOpticalProperties', u'name': u'AirOpticalProperties', u'minOccurs': u'1'}, None),
        MemberSpec_('GroundThermalPropertyLink', '_GroundThermalPropertyLink', 0, 0, {u'maxOccurs': u'1', u'type': u'_GroundThermalPropertyLink', u'name': u'GroundThermalPropertyLink', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, verticalFillMode=0, nbParticule=1, AirGeometry=None, AirFillGeometry=None, AirOpticalProperties=None, GroundThermalPropertyLink=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('plots','_PlotAirProperties')
        self.attrib = ['verticalFillMode', 'nbParticule']
        self.children = ['AirGeometry', 'AirFillGeometry', 'AirOpticalProperties', 'GroundThermalPropertyLink']
        self.parent = None
        self._verticalFillMode = _cast(int, verticalFillMode)
        self._nbParticule = _cast(int, nbParticule)
        self._AirGeometry = AirGeometry
        self._AirFillGeometry = AirFillGeometry
        if AirOpticalProperties is None:
            self._AirOpticalProperties = []
        else:
            self._AirOpticalProperties = AirOpticalProperties
        self._GroundThermalPropertyLink = GroundThermalPropertyLink
        update_node(self,self.troot,'plots')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_PlotAirProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_PlotAirProperties.subclass:
            return create_PlotAirProperties.subclass(*args_, **kwargs_)
        else:
            return create_PlotAirProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AirGeometry(self): return self._AirGeometry
    def set_AirGeometry(self, value):
        if value is not None:
            checkclass(value, create_AirGeometry)
            value.parent = self
        self._AirGeometry = value
    AirGeometry = property(get_AirGeometry, set_AirGeometry)
    def get_AirFillGeometry(self): return self._AirFillGeometry
    def set_AirFillGeometry(self, value):
        if value is not None:
            checkclass(value, create_AirFillGeometry)
            value.parent = self
        self._AirFillGeometry = value
    AirFillGeometry = property(get_AirFillGeometry, set_AirFillGeometry)
    def get_AirOpticalProperties(self): return self._AirOpticalProperties
    def set_AirOpticalProperties(self, value):
        if value is not None:
            checkclass(value, create_AirOpticalProperties)
            for v in value:
                v.parent = self
        self._AirOpticalProperties = value
    def add_AirOpticalProperties(self, value):
        value.parent = self
        self._AirOpticalProperties.append(value)
    def insert_AirOpticalProperties_at(self, index, value):
        value.parent = self
        self.AirOpticalProperties.insert(index, value)
    def replace_AirOpticalProperties_at(self, index, value):
        value.parent = self
        self.AirOpticalProperties[index] = value
    AirOpticalProperties = property(get_AirOpticalProperties, set_AirOpticalProperties)
    def get_GroundThermalPropertyLink(self): return self._GroundThermalPropertyLink
    def set_GroundThermalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_GroundThermalPropertyLink)
            value.parent = self
        self._GroundThermalPropertyLink = value
    GroundThermalPropertyLink = property(get_GroundThermalPropertyLink, set_GroundThermalPropertyLink)
    def get_verticalFillMode(self): return self._verticalFillMode
    def set_verticalFillMode(self, value):
        self._verticalFillMode = value
        update_node(self,self.troot,'plots')
    verticalFillMode = property(get_verticalFillMode, set_verticalFillMode)
    def get_nbParticule(self): return self._nbParticule
    def set_nbParticule(self, value):
        self._nbParticule = value
        update_node(self,self.troot,'plots')
    nbParticule = property(get_nbParticule, set_nbParticule)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.AirGeometry is not None or
            self.AirFillGeometry is not None or
            self.AirOpticalProperties or
            self.GroundThermalPropertyLink is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_PlotAirProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_PlotAirProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_PlotAirProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_PlotAirProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_PlotAirProperties'):
        if self.verticalFillMode is not None and 'verticalFillMode' not in already_processed:
            already_processed.add('verticalFillMode')
            outfile.write(' verticalFillMode="%s"' % self.gds_format_integer(self.verticalFillMode, input_name='verticalFillMode'))
        if self.nbParticule is not None and 'nbParticule' not in already_processed:
            already_processed.add('nbParticule')
            outfile.write(' nbParticule="%s"' % self.gds_format_integer(self.nbParticule, input_name='nbParticule'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_PlotAirProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AirGeometry is not None:
            self.AirGeometry.export(outfile, level, namespaceprefix_, name_='AirGeometry', pretty_print=pretty_print)
        if self.AirFillGeometry is not None:
            self.AirFillGeometry.export(outfile, level, namespaceprefix_, name_='AirFillGeometry', pretty_print=pretty_print)
        for AirOpticalProperties_ in self.AirOpticalProperties:
            AirOpticalProperties_.export(outfile, level, namespaceprefix_, name_='AirOpticalProperties', pretty_print=pretty_print)
        if self.GroundThermalPropertyLink is not None:
            self.GroundThermalPropertyLink.export(outfile, level, namespaceprefix_, name_='GroundThermalPropertyLink', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_PlotAirProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.verticalFillMode is not None:
            element.set('verticalFillMode', self.gds_format_integer(self.verticalFillMode))
        if self.nbParticule is not None:
            element.set('nbParticule', self.gds_format_integer(self.nbParticule))
        if self.AirGeometry is not None:
            AirGeometry_ = self.AirGeometry
            AirGeometry_.to_etree(element, name_='AirGeometry', mapping_=mapping_)
        if self.AirFillGeometry is not None:
            AirFillGeometry_ = self.AirFillGeometry
            AirFillGeometry_.to_etree(element, name_='AirFillGeometry', mapping_=mapping_)
        for AirOpticalProperties_ in self.AirOpticalProperties:
            AirOpticalProperties_.to_etree(element, name_='AirOpticalProperties', mapping_=mapping_)
        if self.GroundThermalPropertyLink is not None:
            GroundThermalPropertyLink_ = self.GroundThermalPropertyLink
            GroundThermalPropertyLink_.to_etree(element, name_='GroundThermalPropertyLink', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_PlotAirProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.verticalFillMode is not None and 'verticalFillMode' not in already_processed:
            already_processed.add('verticalFillMode')
            showIndent(outfile, level)
            outfile.write('verticalFillMode=%d,\n' % (self.verticalFillMode,))
        if self.nbParticule is not None and 'nbParticule' not in already_processed:
            already_processed.add('nbParticule')
            showIndent(outfile, level)
            outfile.write('nbParticule=%d,\n' % (self.nbParticule,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AirGeometry is not None:
            showIndent(outfile, level)
            outfile.write('AirGeometry=model_._AirGeometry(\n')
            self.AirGeometry.exportLiteral(outfile, level, name_='AirGeometry')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AirFillGeometry is not None:
            showIndent(outfile, level)
            outfile.write('AirFillGeometry=model_._AirFillGeometry(\n')
            self.AirFillGeometry.exportLiteral(outfile, level, name_='AirFillGeometry')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('AirOpticalProperties=[\n')
        level += 1
        for AirOpticalProperties_ in self.AirOpticalProperties:
            showIndent(outfile, level)
            outfile.write('model_._AirOpticalProperties(\n')
            AirOpticalProperties_.exportLiteral(outfile, level, name_='_AirOpticalProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.GroundThermalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('GroundThermalPropertyLink=model_._GroundThermalPropertyLink(\n')
            self.GroundThermalPropertyLink.exportLiteral(outfile, level, name_='GroundThermalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.AirOpticalProperties = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('verticalFillMode', node)
        if value is not None and 'verticalFillMode' not in already_processed:
            already_processed.add('verticalFillMode')
            try:
                self.verticalFillMode = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('nbParticule', node)
        if value is not None and 'nbParticule' not in already_processed:
            already_processed.add('nbParticule')
            try:
                self.nbParticule = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AirGeometry':
            obj_ = create_AirGeometry.factory()
            obj_.build(child_)
            self.set_AirGeometry(obj_)
            obj_.original_tagname_ = 'AirGeometry'
        elif nodeName_ == 'AirFillGeometry':
            obj_ = create_AirFillGeometry.factory()
            obj_.build(child_)
            self.set_AirFillGeometry(obj_)
            obj_.original_tagname_ = 'AirFillGeometry'
        elif nodeName_ == 'AirOpticalProperties':
            obj_ = create_AirOpticalProperties.factory()
            obj_.build(child_)
            self.add_AirOpticalProperties(obj_)
            obj_.original_tagname_ = 'AirOpticalProperties'
        elif nodeName_ == 'GroundThermalPropertyLink':
            obj_ = create_GroundThermalPropertyLink.factory()
            obj_.build(child_)
            self.set_GroundThermalPropertyLink(obj_)
            obj_.original_tagname_ = 'GroundThermalPropertyLink'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_PlotAirProperties


class create_AirGeometry(GeneratedsSuper):
    """Thickness of the air layer Thickness of the air layer Altitude in
    meter of the base of the vegetation above the ground of the
    plot. Altitude in meter of the base of the vegetation above the
    ground of the plot. Standard deviation of the air layer height
    Standard deviation of the air layer height"""
    member_data_items_ = [
        MemberSpec_('height', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('baseheight', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('stDev', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, height=1.0, baseheight=0, stDev=0.0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('plots','_AirGeometry')
        self.attrib = ['height', 'baseheight', 'stDev']
        self.children = []
        self.parent = None
        self._height = _cast(float, height)
        self._baseheight = _cast(float, baseheight)
        self._stDev = _cast(float, stDev)
        update_node(self,self.troot,'plots')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_AirGeometry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_AirGeometry.subclass:
            return create_AirGeometry.subclass(*args_, **kwargs_)
        else:
            return create_AirGeometry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_height(self): return self._height
    def set_height(self, value):
        self._height = value
        update_node(self,self.troot,'plots')
    height = property(get_height, set_height)
    def get_baseheight(self): return self._baseheight
    def set_baseheight(self, value):
        self._baseheight = value
        update_node(self,self.troot,'plots')
    baseheight = property(get_baseheight, set_baseheight)
    def get_stDev(self): return self._stDev
    def set_stDev(self, value):
        self._stDev = value
        update_node(self,self.troot,'plots')
    stDev = property(get_stDev, set_stDev)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_AirGeometry', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_AirGeometry')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_AirGeometry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_AirGeometry', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_AirGeometry'):
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height="%s"' % self.gds_format_double(self.height, input_name='height'))
        if self.baseheight is not None and 'baseheight' not in already_processed:
            already_processed.add('baseheight')
            outfile.write(' baseheight="%s"' % self.gds_format_double(self.baseheight, input_name='baseheight'))
        if self.stDev is not None and 'stDev' not in already_processed:
            already_processed.add('stDev')
            outfile.write(' stDev="%s"' % self.gds_format_double(self.stDev, input_name='stDev'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_AirGeometry', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_AirGeometry', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.height is not None:
            element.set('height', self.gds_format_double(self.height))
        if self.baseheight is not None:
            element.set('baseheight', self.gds_format_double(self.baseheight))
        if self.stDev is not None:
            element.set('stDev', self.gds_format_double(self.stDev))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_AirGeometry'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            showIndent(outfile, level)
            outfile.write('height=%e,\n' % (self.height,))
        if self.baseheight is not None and 'baseheight' not in already_processed:
            already_processed.add('baseheight')
            showIndent(outfile, level)
            outfile.write('baseheight=%e,\n' % (self.baseheight,))
        if self.stDev is not None and 'stDev' not in already_processed:
            already_processed.add('stDev')
            showIndent(outfile, level)
            outfile.write('stDev=%e,\n' % (self.stDev,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            try:
                self.height = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (height): %s' % exp)
        value = find_attr_value_('baseheight', node)
        if value is not None and 'baseheight' not in already_processed:
            already_processed.add('baseheight')
            try:
                self.baseheight = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (baseheight): %s' % exp)
        value = find_attr_value_('stDev', node)
        if value is not None and 'stDev' not in already_processed:
            already_processed.add('stDev')
            try:
                self.stDev = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (stDev): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_AirGeometry


class create_AirFillGeometry(GeneratedsSuper):
    """Altitude up to which the plot fill the scene, stating from the
    bottom of the scene Altitude up to which the plot fill the
    scene, stating from the bottom of the scene"""
    member_data_items_ = [
        MemberSpec_('topHeight', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, topHeight=1.0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('plots','_AirFillGeometry')
        self.attrib = ['topHeight']
        self.children = []
        self.parent = None
        self._topHeight = _cast(float, topHeight)
        update_node(self,self.troot,'plots')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_AirFillGeometry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_AirFillGeometry.subclass:
            return create_AirFillGeometry.subclass(*args_, **kwargs_)
        else:
            return create_AirFillGeometry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_topHeight(self): return self._topHeight
    def set_topHeight(self, value):
        self._topHeight = value
        update_node(self,self.troot,'plots')
    topHeight = property(get_topHeight, set_topHeight)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_AirFillGeometry', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_AirFillGeometry')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_AirFillGeometry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_AirFillGeometry', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_AirFillGeometry'):
        if self.topHeight is not None and 'topHeight' not in already_processed:
            already_processed.add('topHeight')
            outfile.write(' topHeight="%s"' % self.gds_format_double(self.topHeight, input_name='topHeight'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_AirFillGeometry', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_AirFillGeometry', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.topHeight is not None:
            element.set('topHeight', self.gds_format_double(self.topHeight))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_AirFillGeometry'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.topHeight is not None and 'topHeight' not in already_processed:
            already_processed.add('topHeight')
            showIndent(outfile, level)
            outfile.write('topHeight=%e,\n' % (self.topHeight,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('topHeight', node)
        if value is not None and 'topHeight' not in already_processed:
            already_processed.add('topHeight')
            try:
                self.topHeight = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (topHeight): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_AirFillGeometry


class create_AirOpticalProperties(GeneratedsSuper):
    """AirOpticalProperties AirOpticalProperties Particle Density (Number
    of particle per meter-cube) Particle Density (Number of particle
    per meter-cube)"""
    member_data_items_ = [
        MemberSpec_('extinctionCoefficient', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('AirOpticalPropertyLink', '_AirOpticalPropertyLink', 0, 0, {u'maxOccurs': u'1', u'type': u'_AirOpticalPropertyLink', u'name': u'AirOpticalPropertyLink', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, extinctionCoefficient=5E-16, AirOpticalPropertyLink=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('plots','_AirOpticalProperties')
        self.attrib = ['extinctionCoefficient']
        self.children = ['AirOpticalPropertyLink']
        self.parent = None
        self._extinctionCoefficient = _cast(float, extinctionCoefficient)
        self._AirOpticalPropertyLink = AirOpticalPropertyLink
        update_node(self,self.troot,'plots')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_AirOpticalProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_AirOpticalProperties.subclass:
            return create_AirOpticalProperties.subclass(*args_, **kwargs_)
        else:
            return create_AirOpticalProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AirOpticalPropertyLink(self): return self._AirOpticalPropertyLink
    def set_AirOpticalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_AirOpticalPropertyLink)
            value.parent = self
        self._AirOpticalPropertyLink = value
    AirOpticalPropertyLink = property(get_AirOpticalPropertyLink, set_AirOpticalPropertyLink)
    def get_extinctionCoefficient(self): return self._extinctionCoefficient
    def set_extinctionCoefficient(self, value):
        self._extinctionCoefficient = value
        update_node(self,self.troot,'plots')
    extinctionCoefficient = property(get_extinctionCoefficient, set_extinctionCoefficient)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.AirOpticalPropertyLink is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_AirOpticalProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_AirOpticalProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_AirOpticalProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_AirOpticalProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_AirOpticalProperties'):
        if self.extinctionCoefficient is not None and 'extinctionCoefficient' not in already_processed:
            already_processed.add('extinctionCoefficient')
            outfile.write(' extinctionCoefficient="%s"' % self.gds_format_double(self.extinctionCoefficient, input_name='extinctionCoefficient'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_AirOpticalProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AirOpticalPropertyLink is not None:
            self.AirOpticalPropertyLink.export(outfile, level, namespaceprefix_, name_='AirOpticalPropertyLink', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_AirOpticalProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.extinctionCoefficient is not None:
            element.set('extinctionCoefficient', self.gds_format_double(self.extinctionCoefficient))
        if self.AirOpticalPropertyLink is not None:
            AirOpticalPropertyLink_ = self.AirOpticalPropertyLink
            AirOpticalPropertyLink_.to_etree(element, name_='AirOpticalPropertyLink', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_AirOpticalProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.extinctionCoefficient is not None and 'extinctionCoefficient' not in already_processed:
            already_processed.add('extinctionCoefficient')
            showIndent(outfile, level)
            outfile.write('extinctionCoefficient=%e,\n' % (self.extinctionCoefficient,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AirOpticalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('AirOpticalPropertyLink=model_._AirOpticalPropertyLink(\n')
            self.AirOpticalPropertyLink.exportLiteral(outfile, level, name_='AirOpticalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('extinctionCoefficient', node)
        if value is not None and 'extinctionCoefficient' not in already_processed:
            already_processed.add('extinctionCoefficient')
            try:
                self.extinctionCoefficient = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (extinctionCoefficient): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AirOpticalPropertyLink':
            obj_ = create_AirOpticalPropertyLink.factory()
            obj_.build(child_)
            self.set_AirOpticalPropertyLink(obj_)
            obj_.original_tagname_ = 'AirOpticalPropertyLink'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_AirOpticalProperties


class create_AirOpticalPropertyLink(GeneratedsSuper):
    """AirOpticalPropertyLink AirOpticalPropertyLink Index of the DART
    phase function of the ground of the plot. Index of the DART
    phase function of the ground of the plot. proportion of photons
    intercepted along an incident direction that are scattered
    within a solid angle along a given direction proportion of
    photons intercepted along an incident direction that are
    scattered within a solid angle along a given direction"""
    member_data_items_ = [
        MemberSpec_('indexFctPhase', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('ident', 'xsd:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, indexFctPhase=0, ident='Molecule'):
        self.original_tagname_ = None
        self.troot=get_gs_troot('plots','_AirOpticalPropertyLink')
        self.attrib = ['indexFctPhase', 'ident']
        self.children = []
        self.parent = None
        self._indexFctPhase = _cast(int, indexFctPhase)
        self._ident = _cast(None, ident)
        update_node(self,self.troot,'plots')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_AirOpticalPropertyLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_AirOpticalPropertyLink.subclass:
            return create_AirOpticalPropertyLink.subclass(*args_, **kwargs_)
        else:
            return create_AirOpticalPropertyLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexFctPhase(self): return self._indexFctPhase
    def set_indexFctPhase(self, value):
        self._indexFctPhase = value
        update_node(self,self.troot,'plots')
    indexFctPhase = property(get_indexFctPhase, set_indexFctPhase)
    def get_ident(self): return self._ident
    def set_ident(self, value):
        self._ident = value
        update_node(self,self.troot,'plots')
    ident = property(get_ident, set_ident)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_AirOpticalPropertyLink', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_AirOpticalPropertyLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_AirOpticalPropertyLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_AirOpticalPropertyLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_AirOpticalPropertyLink'):
        if self.indexFctPhase is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            outfile.write(' indexFctPhase="%s"' % self.gds_format_integer(self.indexFctPhase, input_name='indexFctPhase'))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            outfile.write(' ident=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ident), input_name='ident')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_AirOpticalPropertyLink', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_AirOpticalPropertyLink', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.indexFctPhase is not None:
            element.set('indexFctPhase', self.gds_format_integer(self.indexFctPhase))
        if self.ident is not None:
            element.set('ident', self.gds_format_string(self.ident))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_AirOpticalPropertyLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.indexFctPhase is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            showIndent(outfile, level)
            outfile.write('indexFctPhase=%d,\n' % (self.indexFctPhase,))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            showIndent(outfile, level)
            outfile.write('ident="%s",\n' % (self.ident,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('indexFctPhase', node)
        if value is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            try:
                self.indexFctPhase = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ident', node)
        if value is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            self.ident = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_AirOpticalPropertyLink


class create_PlotWaterProperties(GeneratedsSuper):
    """Water properties Water properties Number of components of the water
    volume Number of components of the water volume Water depth
    Water depth Water height level Water height level stDev stDev"""
    member_data_items_ = [
        MemberSpec_('nbComponents', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('waterDepth', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('waterHeight', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('stDev', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('WaterOpticalProperties', '_WaterOpticalProperties', 1, 0, {u'maxOccurs': u'unbounded', u'type': u'_WaterOpticalProperties', u'name': u'WaterOpticalProperties', u'minOccurs': u'1'}, None),
        MemberSpec_('GroundThermalPropertyLink', '_GroundThermalPropertyLink', 0, 0, {u'maxOccurs': u'1', u'type': u'_GroundThermalPropertyLink', u'name': u'GroundThermalPropertyLink', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, nbComponents=1, waterDepth=10.0, waterHeight=0.0, stDev=0.0, WaterOpticalProperties=None, GroundThermalPropertyLink=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('plots','_PlotWaterProperties')
        self.attrib = ['nbComponents', 'waterDepth', 'waterHeight', 'stDev']
        self.children = ['WaterOpticalProperties', 'GroundThermalPropertyLink']
        self.parent = None
        self._nbComponents = _cast(int, nbComponents)
        self._waterDepth = _cast(float, waterDepth)
        self._waterHeight = _cast(float, waterHeight)
        self._stDev = _cast(float, stDev)
        if WaterOpticalProperties is None:
            self._WaterOpticalProperties = []
        else:
            self._WaterOpticalProperties = WaterOpticalProperties
        self._GroundThermalPropertyLink = GroundThermalPropertyLink
        update_node(self,self.troot,'plots')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_PlotWaterProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_PlotWaterProperties.subclass:
            return create_PlotWaterProperties.subclass(*args_, **kwargs_)
        else:
            return create_PlotWaterProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WaterOpticalProperties(self): return self._WaterOpticalProperties
    def set_WaterOpticalProperties(self, value):
        if value is not None:
            checkclass(value, create_WaterOpticalProperties)
            for v in value:
                v.parent = self
        self._WaterOpticalProperties = value
    def add_WaterOpticalProperties(self, value):
        value.parent = self
        self._WaterOpticalProperties.append(value)
    def insert_WaterOpticalProperties_at(self, index, value):
        value.parent = self
        self.WaterOpticalProperties.insert(index, value)
    def replace_WaterOpticalProperties_at(self, index, value):
        value.parent = self
        self.WaterOpticalProperties[index] = value
    WaterOpticalProperties = property(get_WaterOpticalProperties, set_WaterOpticalProperties)
    def get_GroundThermalPropertyLink(self): return self._GroundThermalPropertyLink
    def set_GroundThermalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_GroundThermalPropertyLink)
            value.parent = self
        self._GroundThermalPropertyLink = value
    GroundThermalPropertyLink = property(get_GroundThermalPropertyLink, set_GroundThermalPropertyLink)
    def get_nbComponents(self): return self._nbComponents
    def set_nbComponents(self, value):
        self._nbComponents = value
        update_node(self,self.troot,'plots')
    nbComponents = property(get_nbComponents, set_nbComponents)
    def get_waterDepth(self): return self._waterDepth
    def set_waterDepth(self, value):
        self._waterDepth = value
        update_node(self,self.troot,'plots')
    waterDepth = property(get_waterDepth, set_waterDepth)
    def get_waterHeight(self): return self._waterHeight
    def set_waterHeight(self, value):
        self._waterHeight = value
        update_node(self,self.troot,'plots')
    waterHeight = property(get_waterHeight, set_waterHeight)
    def get_stDev(self): return self._stDev
    def set_stDev(self, value):
        self._stDev = value
        update_node(self,self.troot,'plots')
    stDev = property(get_stDev, set_stDev)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.WaterOpticalProperties or
            self.GroundThermalPropertyLink is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_PlotWaterProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_PlotWaterProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_PlotWaterProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_PlotWaterProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_PlotWaterProperties'):
        if self.nbComponents is not None and 'nbComponents' not in already_processed:
            already_processed.add('nbComponents')
            outfile.write(' nbComponents="%s"' % self.gds_format_integer(self.nbComponents, input_name='nbComponents'))
        if self.waterDepth is not None and 'waterDepth' not in already_processed:
            already_processed.add('waterDepth')
            outfile.write(' waterDepth="%s"' % self.gds_format_double(self.waterDepth, input_name='waterDepth'))
        if self.waterHeight is not None and 'waterHeight' not in already_processed:
            already_processed.add('waterHeight')
            outfile.write(' waterHeight="%s"' % self.gds_format_double(self.waterHeight, input_name='waterHeight'))
        if self.stDev is not None and 'stDev' not in already_processed:
            already_processed.add('stDev')
            outfile.write(' stDev="%s"' % self.gds_format_double(self.stDev, input_name='stDev'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_PlotWaterProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for WaterOpticalProperties_ in self.WaterOpticalProperties:
            WaterOpticalProperties_.export(outfile, level, namespaceprefix_, name_='WaterOpticalProperties', pretty_print=pretty_print)
        if self.GroundThermalPropertyLink is not None:
            self.GroundThermalPropertyLink.export(outfile, level, namespaceprefix_, name_='GroundThermalPropertyLink', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_PlotWaterProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.nbComponents is not None:
            element.set('nbComponents', self.gds_format_integer(self.nbComponents))
        if self.waterDepth is not None:
            element.set('waterDepth', self.gds_format_double(self.waterDepth))
        if self.waterHeight is not None:
            element.set('waterHeight', self.gds_format_double(self.waterHeight))
        if self.stDev is not None:
            element.set('stDev', self.gds_format_double(self.stDev))
        for WaterOpticalProperties_ in self.WaterOpticalProperties:
            WaterOpticalProperties_.to_etree(element, name_='WaterOpticalProperties', mapping_=mapping_)
        if self.GroundThermalPropertyLink is not None:
            GroundThermalPropertyLink_ = self.GroundThermalPropertyLink
            GroundThermalPropertyLink_.to_etree(element, name_='GroundThermalPropertyLink', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_PlotWaterProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nbComponents is not None and 'nbComponents' not in already_processed:
            already_processed.add('nbComponents')
            showIndent(outfile, level)
            outfile.write('nbComponents=%d,\n' % (self.nbComponents,))
        if self.waterDepth is not None and 'waterDepth' not in already_processed:
            already_processed.add('waterDepth')
            showIndent(outfile, level)
            outfile.write('waterDepth=%e,\n' % (self.waterDepth,))
        if self.waterHeight is not None and 'waterHeight' not in already_processed:
            already_processed.add('waterHeight')
            showIndent(outfile, level)
            outfile.write('waterHeight=%e,\n' % (self.waterHeight,))
        if self.stDev is not None and 'stDev' not in already_processed:
            already_processed.add('stDev')
            showIndent(outfile, level)
            outfile.write('stDev=%e,\n' % (self.stDev,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('WaterOpticalProperties=[\n')
        level += 1
        for WaterOpticalProperties_ in self.WaterOpticalProperties:
            showIndent(outfile, level)
            outfile.write('model_._WaterOpticalProperties(\n')
            WaterOpticalProperties_.exportLiteral(outfile, level, name_='_WaterOpticalProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.GroundThermalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('GroundThermalPropertyLink=model_._GroundThermalPropertyLink(\n')
            self.GroundThermalPropertyLink.exportLiteral(outfile, level, name_='GroundThermalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.WaterOpticalProperties = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nbComponents', node)
        if value is not None and 'nbComponents' not in already_processed:
            already_processed.add('nbComponents')
            try:
                self.nbComponents = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('waterDepth', node)
        if value is not None and 'waterDepth' not in already_processed:
            already_processed.add('waterDepth')
            try:
                self.waterDepth = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (waterDepth): %s' % exp)
        value = find_attr_value_('waterHeight', node)
        if value is not None and 'waterHeight' not in already_processed:
            already_processed.add('waterHeight')
            try:
                self.waterHeight = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (waterHeight): %s' % exp)
        value = find_attr_value_('stDev', node)
        if value is not None and 'stDev' not in already_processed:
            already_processed.add('stDev')
            try:
                self.stDev = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (stDev): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WaterOpticalProperties':
            obj_ = create_WaterOpticalProperties.factory()
            obj_.build(child_)
            self.add_WaterOpticalProperties(obj_)
            obj_.original_tagname_ = 'WaterOpticalProperties'
        elif nodeName_ == 'GroundThermalPropertyLink':
            obj_ = create_GroundThermalPropertyLink.factory()
            obj_.build(child_)
            self.set_GroundThermalPropertyLink(obj_)
            obj_.original_tagname_ = 'GroundThermalPropertyLink'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_PlotWaterProperties


class create_WaterOpticalProperties(GeneratedsSuper):
    """Component properties Component properties Extinction coefficient
    Extinction coefficient"""
    member_data_items_ = [
        MemberSpec_('extinctionCoefficient', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('AirOpticalPropertyLink', '_AirOpticalPropertyLink', 0, 0, {u'maxOccurs': u'1', u'type': u'_AirOpticalPropertyLink', u'name': u'AirOpticalPropertyLink', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, extinctionCoefficient=0.5, AirOpticalPropertyLink=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('plots','_WaterOpticalProperties')
        self.attrib = ['extinctionCoefficient']
        self.children = ['AirOpticalPropertyLink']
        self.parent = None
        self._extinctionCoefficient = _cast(float, extinctionCoefficient)
        self._AirOpticalPropertyLink = AirOpticalPropertyLink
        update_node(self,self.troot,'plots')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_WaterOpticalProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_WaterOpticalProperties.subclass:
            return create_WaterOpticalProperties.subclass(*args_, **kwargs_)
        else:
            return create_WaterOpticalProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AirOpticalPropertyLink(self): return self._AirOpticalPropertyLink
    def set_AirOpticalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_AirOpticalPropertyLink)
            value.parent = self
        self._AirOpticalPropertyLink = value
    AirOpticalPropertyLink = property(get_AirOpticalPropertyLink, set_AirOpticalPropertyLink)
    def get_extinctionCoefficient(self): return self._extinctionCoefficient
    def set_extinctionCoefficient(self, value):
        self._extinctionCoefficient = value
        update_node(self,self.troot,'plots')
    extinctionCoefficient = property(get_extinctionCoefficient, set_extinctionCoefficient)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.AirOpticalPropertyLink is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_WaterOpticalProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_WaterOpticalProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_WaterOpticalProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_WaterOpticalProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_WaterOpticalProperties'):
        if self.extinctionCoefficient is not None and 'extinctionCoefficient' not in already_processed:
            already_processed.add('extinctionCoefficient')
            outfile.write(' extinctionCoefficient="%s"' % self.gds_format_double(self.extinctionCoefficient, input_name='extinctionCoefficient'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_WaterOpticalProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AirOpticalPropertyLink is not None:
            self.AirOpticalPropertyLink.export(outfile, level, namespaceprefix_, name_='AirOpticalPropertyLink', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_WaterOpticalProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.extinctionCoefficient is not None:
            element.set('extinctionCoefficient', self.gds_format_double(self.extinctionCoefficient))
        if self.AirOpticalPropertyLink is not None:
            AirOpticalPropertyLink_ = self.AirOpticalPropertyLink
            AirOpticalPropertyLink_.to_etree(element, name_='AirOpticalPropertyLink', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_WaterOpticalProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.extinctionCoefficient is not None and 'extinctionCoefficient' not in already_processed:
            already_processed.add('extinctionCoefficient')
            showIndent(outfile, level)
            outfile.write('extinctionCoefficient=%e,\n' % (self.extinctionCoefficient,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AirOpticalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('AirOpticalPropertyLink=model_._AirOpticalPropertyLink(\n')
            self.AirOpticalPropertyLink.exportLiteral(outfile, level, name_='AirOpticalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('extinctionCoefficient', node)
        if value is not None and 'extinctionCoefficient' not in already_processed:
            already_processed.add('extinctionCoefficient')
            try:
                self.extinctionCoefficient = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (extinctionCoefficient): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AirOpticalPropertyLink':
            obj_ = create_AirOpticalPropertyLink.factory()
            obj_.build(child_)
            self.set_AirOpticalPropertyLink(obj_)
            obj_.original_tagname_ = 'AirOpticalPropertyLink'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_WaterOpticalProperties


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <createParser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from plots import *\n\n')
        sys.stdout.write('import plots as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "createDartFile",
    "create_AirFillGeometry",
    "create_AirGeometry",
    "create_AirOpticalProperties",
    "create_AirOpticalPropertyLink",
    "create_ExtraPlotsTextFileDefinition",
    "create_GroundOpticalPropertyLink",
    "create_GroundThermalPropertyLink",
    "create_ImportationFichierRaster",
    "create_LAIVegetation",
    "create_MeshLeafDimensionParameters",
    "create_MeshPlotRepresentation",
    "create_NumberOfTriangleParameters",
    "create_Plot",
    "create_PlotAirProperties",
    "create_PlotVegetationProperties",
    "create_PlotWaterProperties",
    "create_Plots",
    "create_Point2D",
    "create_Polygon2D",
    "create_RasterCOSInformation",
    "create_Rectangle2D",
    "create_SelectSubZoneProperties",
    "create_UFVegetation",
    "create_VegetationFillGeometry",
    "create_VegetationGeometry",
    "create_VegetationOpticalPropertyLink",
    "create_VegetationProperties",
    "create_WaterOpticalProperties"
]
