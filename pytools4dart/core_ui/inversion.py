#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Nov 19 15:08:18 2019 by generateDS.py version 2.29.25.
# Python 3.6.7 | packaged by conda-forge | (default, Nov  6 2019, 16:19:42)  [GCC 7.3.0]
#
# Command line options:
#   ('-m', '')
#   ('-f', '')
#   ('--always-export-default', '')
#   ('--export', 'write literal etree')
#   ('-u', 'core_ui.user_methods')
#   ('-p', 'create')
#   ('--post-attrib-setter', "update_node(self,self.troot,'inversion')")
#   ('--pre-ctor', "self.troot=get_gs_troot('inversion','{classname}')")
#   ('--post-ctor', "update_node(self,self.troot,'inversion')")
#   ('--imports', 'from pytools4dart.core_ui.utils import get_gs_troot, update_node, get_path, findpaths, subpaths, set_nodes')
#   ('-o', '/media/DATA/Florian/git/pytools4dart/pytools4dart/core_ui/inversion.py')
#
# Command line arguments:
#   /media/DATA/Florian/git/pytools4dart/pytools4dart/xsdschemas/inversion.xsd
#
# Command line:
#   /home/boissieu/anaconda3/envs/pytools4dart/bin/generateDS.py -m -f --always-export-default --export="write literal etree" -u "core_ui.user_methods" -p "create" --post-attrib-setter="update_node(self,self.troot,'inversion')" --pre-ctor="self.troot=get_gs_troot('inversion','{classname}')" --post-ctor="update_node(self,self.troot,'inversion')" --imports="from pytools4dart.core_ui.utils import get_gs_troot, update_node, get_path, findpaths, subpaths, set_nodes" -o "/media/DATA/Florian/git/pytools4dart/pytools4dart/core_ui/inversion.py" /media/DATA/Florian/git/pytools4dart/pytools4dart/xsdschemas/inversion.xsd
#
# Current working directory (os.getcwd()):
#   pytools4dart
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_
from pytools4dart.core_ui.utils import get_gs_troot, update_node, get_path, findpaths, subpaths, set_nodes


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#

def checkclass(value, cl):
    if isinstance(value, list):
        for v in value:
            if not isinstance(v, cl):
                raise ValueError("invalid class")
    else:
        if not isinstance(value, cl):
            raise ValueError("invalid class")

def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class createDartFile(GeneratedsSuper):
    """Version of the plots.xml file. Depends of the version on DART
    itself. Version of the plots.xml file. Depends of the version on
    DART itself."""
    member_data_items_ = [
        MemberSpec_('version', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('build_', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('DartInversion', '_DartInversion', 0, 0, {'name': 'DartInversion', 'type': '_DartInversion', 'minOccurs': '1', 'maxOccurs': '1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, version='5.7.5', build_='0', DartInversion=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('inversion','DartFile')
        self.attrib = ['version', 'build_']
        self.children = ['DartInversion']
        self.parent = None
        self._version = _cast(None, version)
        self._build_ = _cast(None, build_)
        self._DartInversion = DartInversion
        update_node(self,self.troot,'inversion')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, createDartFile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if createDartFile.subclass:
            return createDartFile.subclass(*args_, **kwargs_)
        else:
            return createDartFile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DartInversion(self): return self._DartInversion
    def set_DartInversion(self, value):
        if value is not None:
            checkclass(value, create_DartInversion)
            value.parent = self
        self._DartInversion = value
    DartInversion = property(get_DartInversion, set_DartInversion)
    def get_version(self): return self._version
    def set_version(self, value):
        self._version = value
        update_node(self,self.troot,'inversion')
    version = property(get_version, set_version)
    def get_build(self): return self._build_
    def set_build(self, value):
        self._build_ = value
        update_node(self,self.troot,'inversion')
    build_ = property(get_build, set_build)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.DartInversion is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='DartFile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DartFile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DartFile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='DartFile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DartFile'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
        if self.build_ is not None and 'build_' not in already_processed:
            already_processed.add('build_')
            outfile.write(' build=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.build_), input_name='build')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='DartFile', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DartInversion is not None:
            self.DartInversion.export(outfile, level, namespaceprefix_, name_='DartInversion', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='DartFile', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.version is not None:
            element.set('version', self.gds_format_string(self.version))
        if self.build_ is not None:
            element.set('build', self.gds_format_string(self.build_))
        if self.DartInversion is not None:
            DartInversion_ = self.DartInversion
            DartInversion_.to_etree(element, name_='DartInversion', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='DartFile'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.build_ is not None and 'build_' not in already_processed:
            already_processed.add('build_')
            showIndent(outfile, level)
            outfile.write('build_="%s",\n' % (self.build_,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DartInversion is not None:
            showIndent(outfile, level)
            outfile.write('DartInversion=model_._DartInversion(\n')
            self.DartInversion.exportLiteral(outfile, level, name_='DartInversion')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('build', node)
        if value is not None and 'build' not in already_processed:
            already_processed.add('build')
            self.build_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DartInversion':
            obj_ = create_DartInversion.factory()
            obj_.build(child_)
            self.set_DartInversion(obj_)
            obj_.original_tagname_ = 'DartInversion'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class createDartFile


class create_DartInversion(GeneratedsSuper):
    """Inversion : Input Parameters Inversion : Input Parameters Run
    Inversion Run Inversion"""
    member_data_items_ = [
        MemberSpec_('runInversion', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('InversionImages', '_InversionImages', 0, 0, {'name': 'InversionImages', 'type': '_InversionImages', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('Inversion', '_Inversion', 0, 0, {'name': 'Inversion', 'type': '_Inversion', 'minOccurs': '1', 'maxOccurs': '1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, runInversion=0, InversionImages=None, Inversion=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('inversion','_DartInversion')
        self.attrib = ['runInversion']
        self.children = ['InversionImages', 'Inversion']
        self.parent = None
        self._runInversion = _cast(int, runInversion)
        self._InversionImages = InversionImages
        self._Inversion = Inversion
        update_node(self,self.troot,'inversion')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_DartInversion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_DartInversion.subclass:
            return create_DartInversion.subclass(*args_, **kwargs_)
        else:
            return create_DartInversion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_InversionImages(self): return self._InversionImages
    def set_InversionImages(self, value):
        if value is not None:
            checkclass(value, create_InversionImages)
            value.parent = self
        self._InversionImages = value
    InversionImages = property(get_InversionImages, set_InversionImages)
    def get_Inversion(self): return self._Inversion
    def set_Inversion(self, value):
        if value is not None:
            checkclass(value, create_Inversion)
            value.parent = self
        self._Inversion = value
    Inversion = property(get_Inversion, set_Inversion)
    def get_runInversion(self): return self._runInversion
    def set_runInversion(self, value):
        self._runInversion = value
        update_node(self,self.troot,'inversion')
    runInversion = property(get_runInversion, set_runInversion)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.InversionImages is not None or
            self.Inversion is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_DartInversion', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_DartInversion')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_DartInversion')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_DartInversion', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_DartInversion'):
        if self.runInversion is not None and 'runInversion' not in already_processed:
            already_processed.add('runInversion')
            outfile.write(' runInversion="%s"' % self.gds_format_integer(self.runInversion, input_name='runInversion'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_DartInversion', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InversionImages is not None:
            self.InversionImages.export(outfile, level, namespaceprefix_, name_='InversionImages', pretty_print=pretty_print)
        if self.Inversion is not None:
            self.Inversion.export(outfile, level, namespaceprefix_, name_='Inversion', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_DartInversion', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.runInversion is not None:
            element.set('runInversion', self.gds_format_integer(self.runInversion))
        if self.InversionImages is not None:
            InversionImages_ = self.InversionImages
            InversionImages_.to_etree(element, name_='InversionImages', mapping_=mapping_)
        if self.Inversion is not None:
            Inversion_ = self.Inversion
            Inversion_.to_etree(element, name_='Inversion', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_DartInversion'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.runInversion is not None and 'runInversion' not in already_processed:
            already_processed.add('runInversion')
            showIndent(outfile, level)
            outfile.write('runInversion=%d,\n' % (self.runInversion,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.InversionImages is not None:
            showIndent(outfile, level)
            outfile.write('InversionImages=model_._InversionImages(\n')
            self.InversionImages.exportLiteral(outfile, level, name_='InversionImages')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Inversion is not None:
            showIndent(outfile, level)
            outfile.write('Inversion=model_._Inversion(\n')
            self.Inversion.exportLiteral(outfile, level, name_='Inversion')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('runInversion', node)
        if value is not None and 'runInversion' not in already_processed:
            already_processed.add('runInversion')
            try:
                self.runInversion = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InversionImages':
            obj_ = create_InversionImages.factory()
            obj_.build(child_)
            self.set_InversionImages(obj_)
            obj_.original_tagname_ = 'InversionImages'
        elif nodeName_ == 'Inversion':
            obj_ = create_Inversion.factory()
            obj_.build(child_)
            self.set_Inversion(obj_)
            obj_.original_tagname_ = 'Inversion'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_DartInversion


class create_InversionImages(GeneratedsSuper):
    """Is mask Is mask"""
    member_data_items_ = [
        MemberSpec_('isMask', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('MaskProperties', '_MaskProperties', 0, 0, {'name': 'MaskProperties', 'type': '_MaskProperties', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('ImageProperties', '_ImageProperties', 1, 0, {'name': 'ImageProperties', 'type': '_ImageProperties', 'minOccurs': '1', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, isMask=0, MaskProperties=None, ImageProperties=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('inversion','_InversionImages')
        self.attrib = ['isMask']
        self.children = ['MaskProperties', 'ImageProperties']
        self.parent = None
        self._isMask = _cast(int, isMask)
        self._MaskProperties = MaskProperties
        if ImageProperties is None:
            self._ImageProperties = []
        else:
            self._ImageProperties = ImageProperties
        update_node(self,self.troot,'inversion')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_InversionImages)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_InversionImages.subclass:
            return create_InversionImages.subclass(*args_, **kwargs_)
        else:
            return create_InversionImages(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MaskProperties(self): return self._MaskProperties
    def set_MaskProperties(self, value):
        if value is not None:
            checkclass(value, create_MaskProperties)
            value.parent = self
        self._MaskProperties = value
    MaskProperties = property(get_MaskProperties, set_MaskProperties)
    def get_ImageProperties(self): return self._ImageProperties
    def set_ImageProperties(self, value):
        if value is not None:
            checkclass(value, create_ImageProperties)
            for v in value:
                v.parent = self
        self._ImageProperties = value
    def add_ImageProperties(self, value):
        value.parent = self
        self._ImageProperties.append(value)
    def insert_ImageProperties_at(self, index, value):
        value.parent = self
        self.ImageProperties.insert(index, value)
    def replace_ImageProperties_at(self, index, value):
        value.parent = self
        self.ImageProperties[index] = value
    ImageProperties = property(get_ImageProperties, set_ImageProperties)
    def get_isMask(self): return self._isMask
    def set_isMask(self, value):
        self._isMask = value
        update_node(self,self.troot,'inversion')
    isMask = property(get_isMask, set_isMask)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.MaskProperties is not None or
            self.ImageProperties
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_InversionImages', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_InversionImages')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_InversionImages')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_InversionImages', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_InversionImages'):
        if self.isMask is not None and 'isMask' not in already_processed:
            already_processed.add('isMask')
            outfile.write(' isMask="%s"' % self.gds_format_integer(self.isMask, input_name='isMask'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_InversionImages', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MaskProperties is not None:
            self.MaskProperties.export(outfile, level, namespaceprefix_, name_='MaskProperties', pretty_print=pretty_print)
        for ImageProperties_ in self.ImageProperties:
            ImageProperties_.export(outfile, level, namespaceprefix_, name_='ImageProperties', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_InversionImages', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.isMask is not None:
            element.set('isMask', self.gds_format_integer(self.isMask))
        if self.MaskProperties is not None:
            MaskProperties_ = self.MaskProperties
            MaskProperties_.to_etree(element, name_='MaskProperties', mapping_=mapping_)
        for ImageProperties_ in self.ImageProperties:
            ImageProperties_.to_etree(element, name_='ImageProperties', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_InversionImages'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isMask is not None and 'isMask' not in already_processed:
            already_processed.add('isMask')
            showIndent(outfile, level)
            outfile.write('isMask=%d,\n' % (self.isMask,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MaskProperties is not None:
            showIndent(outfile, level)
            outfile.write('MaskProperties=model_._MaskProperties(\n')
            self.MaskProperties.exportLiteral(outfile, level, name_='MaskProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('ImageProperties=[\n')
        level += 1
        for ImageProperties_ in self.ImageProperties:
            showIndent(outfile, level)
            outfile.write('model_._ImageProperties(\n')
            ImageProperties_.exportLiteral(outfile, level, name_='_ImageProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.ImageProperties = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isMask', node)
        if value is not None and 'isMask' not in already_processed:
            already_processed.add('isMask')
            try:
                self.isMask = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MaskProperties':
            obj_ = create_MaskProperties.factory()
            obj_.build(child_)
            self.set_MaskProperties(obj_)
            obj_.original_tagname_ = 'MaskProperties'
        elif nodeName_ == 'ImageProperties':
            obj_ = create_ImageProperties.factory()
            obj_.build(child_)
            self.add_ImageProperties(obj_)
            obj_.original_tagname_ = 'ImageProperties'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_InversionImages


class create_MaskProperties(GeneratedsSuper):
    """Mask properties Mask properties Data mask file Data mask file"""
    member_data_items_ = [
        MemberSpec_('dataMaskFile', 'xsd:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, dataMaskFile='mask.mp#'):
        self.original_tagname_ = None
        self.troot=get_gs_troot('inversion','_MaskProperties')
        self.attrib = ['dataMaskFile']
        self.children = []
        self.parent = None
        self._dataMaskFile = _cast(None, dataMaskFile)
        update_node(self,self.troot,'inversion')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_MaskProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_MaskProperties.subclass:
            return create_MaskProperties.subclass(*args_, **kwargs_)
        else:
            return create_MaskProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dataMaskFile(self): return self._dataMaskFile
    def set_dataMaskFile(self, value):
        self._dataMaskFile = value
        update_node(self,self.troot,'inversion')
    dataMaskFile = property(get_dataMaskFile, set_dataMaskFile)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_MaskProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_MaskProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_MaskProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_MaskProperties', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_MaskProperties'):
        if self.dataMaskFile is not None and 'dataMaskFile' not in already_processed:
            already_processed.add('dataMaskFile')
            outfile.write(' dataMaskFile=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dataMaskFile), input_name='dataMaskFile')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_MaskProperties', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_MaskProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.dataMaskFile is not None:
            element.set('dataMaskFile', self.gds_format_string(self.dataMaskFile))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_MaskProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.dataMaskFile is not None and 'dataMaskFile' not in already_processed:
            already_processed.add('dataMaskFile')
            showIndent(outfile, level)
            outfile.write('dataMaskFile="%s",\n' % (self.dataMaskFile,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dataMaskFile', node)
        if value is not None and 'dataMaskFile' not in already_processed:
            already_processed.add('dataMaskFile')
            self.dataMaskFile = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_MaskProperties


class create_ImageProperties(GeneratedsSuper):
    """Image properties Image properties Image number Image number Data
    file name Data file name Multiplicative factor Multiplicative
    factor Spectral band number for this image Spectral band number
    for this image"""
    member_data_items_ = [
        MemberSpec_('ImageNumber', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('dataFileName', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('multiplicativeFactor', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('spectralBandKey', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('SunViewAngleProperties', '_SunViewAngleProperties', 0, 0, {'name': 'SunViewAngleProperties', 'type': '_SunViewAngleProperties', 'minOccurs': '1', 'maxOccurs': '1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ImageNumber=0, dataFileName='image.mp#', multiplicativeFactor=1, spectralBandKey='0', SunViewAngleProperties=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('inversion','_ImageProperties')
        self.attrib = ['ImageNumber', 'dataFileName', 'multiplicativeFactor', 'spectralBandKey']
        self.children = ['SunViewAngleProperties']
        self.parent = None
        self._ImageNumber = _cast(int, ImageNumber)
        self._dataFileName = _cast(None, dataFileName)
        self._multiplicativeFactor = _cast(float, multiplicativeFactor)
        self._spectralBandKey = _cast(None, spectralBandKey)
        self._SunViewAngleProperties = SunViewAngleProperties
        update_node(self,self.troot,'inversion')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ImageProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ImageProperties.subclass:
            return create_ImageProperties.subclass(*args_, **kwargs_)
        else:
            return create_ImageProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SunViewAngleProperties(self): return self._SunViewAngleProperties
    def set_SunViewAngleProperties(self, value):
        if value is not None:
            checkclass(value, create_SunViewAngleProperties)
            value.parent = self
        self._SunViewAngleProperties = value
    SunViewAngleProperties = property(get_SunViewAngleProperties, set_SunViewAngleProperties)
    def get_ImageNumber(self): return self._ImageNumber
    def set_ImageNumber(self, value):
        self._ImageNumber = value
        update_node(self,self.troot,'inversion')
    ImageNumber = property(get_ImageNumber, set_ImageNumber)
    def get_dataFileName(self): return self._dataFileName
    def set_dataFileName(self, value):
        self._dataFileName = value
        update_node(self,self.troot,'inversion')
    dataFileName = property(get_dataFileName, set_dataFileName)
    def get_multiplicativeFactor(self): return self._multiplicativeFactor
    def set_multiplicativeFactor(self, value):
        self._multiplicativeFactor = value
        update_node(self,self.troot,'inversion')
    multiplicativeFactor = property(get_multiplicativeFactor, set_multiplicativeFactor)
    def get_spectralBandKey(self): return self._spectralBandKey
    def set_spectralBandKey(self, value):
        self._spectralBandKey = value
        update_node(self,self.troot,'inversion')
    spectralBandKey = property(get_spectralBandKey, set_spectralBandKey)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.SunViewAngleProperties is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ImageProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ImageProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ImageProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ImageProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ImageProperties'):
        if self.ImageNumber is not None and 'ImageNumber' not in already_processed:
            already_processed.add('ImageNumber')
            outfile.write(' ImageNumber="%s"' % self.gds_format_integer(self.ImageNumber, input_name='ImageNumber'))
        if self.dataFileName is not None and 'dataFileName' not in already_processed:
            already_processed.add('dataFileName')
            outfile.write(' dataFileName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dataFileName), input_name='dataFileName')), ))
        if self.multiplicativeFactor is not None and 'multiplicativeFactor' not in already_processed:
            already_processed.add('multiplicativeFactor')
            outfile.write(' multiplicativeFactor="%s"' % self.gds_format_double(self.multiplicativeFactor, input_name='multiplicativeFactor'))
        if self.spectralBandKey is not None and 'spectralBandKey' not in already_processed:
            already_processed.add('spectralBandKey')
            outfile.write(' spectralBandKey=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.spectralBandKey), input_name='spectralBandKey')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ImageProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SunViewAngleProperties is not None:
            self.SunViewAngleProperties.export(outfile, level, namespaceprefix_, name_='SunViewAngleProperties', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_ImageProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ImageNumber is not None:
            element.set('ImageNumber', self.gds_format_integer(self.ImageNumber))
        if self.dataFileName is not None:
            element.set('dataFileName', self.gds_format_string(self.dataFileName))
        if self.multiplicativeFactor is not None:
            element.set('multiplicativeFactor', self.gds_format_double(self.multiplicativeFactor))
        if self.spectralBandKey is not None:
            element.set('spectralBandKey', self.gds_format_string(self.spectralBandKey))
        if self.SunViewAngleProperties is not None:
            SunViewAngleProperties_ = self.SunViewAngleProperties
            SunViewAngleProperties_.to_etree(element, name_='SunViewAngleProperties', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ImageProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ImageNumber is not None and 'ImageNumber' not in already_processed:
            already_processed.add('ImageNumber')
            showIndent(outfile, level)
            outfile.write('ImageNumber=%d,\n' % (self.ImageNumber,))
        if self.dataFileName is not None and 'dataFileName' not in already_processed:
            already_processed.add('dataFileName')
            showIndent(outfile, level)
            outfile.write('dataFileName="%s",\n' % (self.dataFileName,))
        if self.multiplicativeFactor is not None and 'multiplicativeFactor' not in already_processed:
            already_processed.add('multiplicativeFactor')
            showIndent(outfile, level)
            outfile.write('multiplicativeFactor=%e,\n' % (self.multiplicativeFactor,))
        if self.spectralBandKey is not None and 'spectralBandKey' not in already_processed:
            already_processed.add('spectralBandKey')
            showIndent(outfile, level)
            outfile.write('spectralBandKey="%s",\n' % (self.spectralBandKey,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SunViewAngleProperties is not None:
            showIndent(outfile, level)
            outfile.write('SunViewAngleProperties=model_._SunViewAngleProperties(\n')
            self.SunViewAngleProperties.exportLiteral(outfile, level, name_='SunViewAngleProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ImageNumber', node)
        if value is not None and 'ImageNumber' not in already_processed:
            already_processed.add('ImageNumber')
            try:
                self.ImageNumber = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('dataFileName', node)
        if value is not None and 'dataFileName' not in already_processed:
            already_processed.add('dataFileName')
            self.dataFileName = value
        value = find_attr_value_('multiplicativeFactor', node)
        if value is not None and 'multiplicativeFactor' not in already_processed:
            already_processed.add('multiplicativeFactor')
            try:
                self.multiplicativeFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (multiplicativeFactor): %s' % exp)
        value = find_attr_value_('spectralBandKey', node)
        if value is not None and 'spectralBandKey' not in already_processed:
            already_processed.add('spectralBandKey')
            self.spectralBandKey = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SunViewAngleProperties':
            obj_ = create_SunViewAngleProperties.factory()
            obj_.build(child_)
            self.set_SunViewAngleProperties(obj_)
            obj_.original_tagname_ = 'SunViewAngleProperties'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_ImageProperties


class create_SunViewAngleProperties(GeneratedsSuper):
    """Sun-View angle properties Sun-View angle properties View zenith
    angle View zenith angle View azimuth angle View azimuth angle
    Sun zenith angle Sun zenith angle Sun azimuth angle Sun azimuth
    angle"""
    member_data_items_ = [
        MemberSpec_('viewZenithalAngle', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('viewAzimuthalAngle', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('sunZenithalAngle', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('sunAzimuthalAngle', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, viewZenithalAngle=0, viewAzimuthalAngle=0, sunZenithalAngle=30, sunAzimuthalAngle=225):
        self.original_tagname_ = None
        self.troot=get_gs_troot('inversion','_SunViewAngleProperties')
        self.attrib = ['viewZenithalAngle', 'viewAzimuthalAngle', 'sunZenithalAngle', 'sunAzimuthalAngle']
        self.children = []
        self.parent = None
        self._viewZenithalAngle = _cast(float, viewZenithalAngle)
        self._viewAzimuthalAngle = _cast(float, viewAzimuthalAngle)
        self._sunZenithalAngle = _cast(float, sunZenithalAngle)
        self._sunAzimuthalAngle = _cast(float, sunAzimuthalAngle)
        update_node(self,self.troot,'inversion')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_SunViewAngleProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_SunViewAngleProperties.subclass:
            return create_SunViewAngleProperties.subclass(*args_, **kwargs_)
        else:
            return create_SunViewAngleProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_viewZenithalAngle(self): return self._viewZenithalAngle
    def set_viewZenithalAngle(self, value):
        self._viewZenithalAngle = value
        update_node(self,self.troot,'inversion')
    viewZenithalAngle = property(get_viewZenithalAngle, set_viewZenithalAngle)
    def get_viewAzimuthalAngle(self): return self._viewAzimuthalAngle
    def set_viewAzimuthalAngle(self, value):
        self._viewAzimuthalAngle = value
        update_node(self,self.troot,'inversion')
    viewAzimuthalAngle = property(get_viewAzimuthalAngle, set_viewAzimuthalAngle)
    def get_sunZenithalAngle(self): return self._sunZenithalAngle
    def set_sunZenithalAngle(self, value):
        self._sunZenithalAngle = value
        update_node(self,self.troot,'inversion')
    sunZenithalAngle = property(get_sunZenithalAngle, set_sunZenithalAngle)
    def get_sunAzimuthalAngle(self): return self._sunAzimuthalAngle
    def set_sunAzimuthalAngle(self, value):
        self._sunAzimuthalAngle = value
        update_node(self,self.troot,'inversion')
    sunAzimuthalAngle = property(get_sunAzimuthalAngle, set_sunAzimuthalAngle)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_SunViewAngleProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_SunViewAngleProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_SunViewAngleProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_SunViewAngleProperties', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_SunViewAngleProperties'):
        if self.viewZenithalAngle is not None and 'viewZenithalAngle' not in already_processed:
            already_processed.add('viewZenithalAngle')
            outfile.write(' viewZenithalAngle="%s"' % self.gds_format_double(self.viewZenithalAngle, input_name='viewZenithalAngle'))
        if self.viewAzimuthalAngle is not None and 'viewAzimuthalAngle' not in already_processed:
            already_processed.add('viewAzimuthalAngle')
            outfile.write(' viewAzimuthalAngle="%s"' % self.gds_format_double(self.viewAzimuthalAngle, input_name='viewAzimuthalAngle'))
        if self.sunZenithalAngle is not None and 'sunZenithalAngle' not in already_processed:
            already_processed.add('sunZenithalAngle')
            outfile.write(' sunZenithalAngle="%s"' % self.gds_format_double(self.sunZenithalAngle, input_name='sunZenithalAngle'))
        if self.sunAzimuthalAngle is not None and 'sunAzimuthalAngle' not in already_processed:
            already_processed.add('sunAzimuthalAngle')
            outfile.write(' sunAzimuthalAngle="%s"' % self.gds_format_double(self.sunAzimuthalAngle, input_name='sunAzimuthalAngle'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_SunViewAngleProperties', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_SunViewAngleProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.viewZenithalAngle is not None:
            element.set('viewZenithalAngle', self.gds_format_double(self.viewZenithalAngle))
        if self.viewAzimuthalAngle is not None:
            element.set('viewAzimuthalAngle', self.gds_format_double(self.viewAzimuthalAngle))
        if self.sunZenithalAngle is not None:
            element.set('sunZenithalAngle', self.gds_format_double(self.sunZenithalAngle))
        if self.sunAzimuthalAngle is not None:
            element.set('sunAzimuthalAngle', self.gds_format_double(self.sunAzimuthalAngle))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_SunViewAngleProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.viewZenithalAngle is not None and 'viewZenithalAngle' not in already_processed:
            already_processed.add('viewZenithalAngle')
            showIndent(outfile, level)
            outfile.write('viewZenithalAngle=%e,\n' % (self.viewZenithalAngle,))
        if self.viewAzimuthalAngle is not None and 'viewAzimuthalAngle' not in already_processed:
            already_processed.add('viewAzimuthalAngle')
            showIndent(outfile, level)
            outfile.write('viewAzimuthalAngle=%e,\n' % (self.viewAzimuthalAngle,))
        if self.sunZenithalAngle is not None and 'sunZenithalAngle' not in already_processed:
            already_processed.add('sunZenithalAngle')
            showIndent(outfile, level)
            outfile.write('sunZenithalAngle=%e,\n' % (self.sunZenithalAngle,))
        if self.sunAzimuthalAngle is not None and 'sunAzimuthalAngle' not in already_processed:
            already_processed.add('sunAzimuthalAngle')
            showIndent(outfile, level)
            outfile.write('sunAzimuthalAngle=%e,\n' % (self.sunAzimuthalAngle,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('viewZenithalAngle', node)
        if value is not None and 'viewZenithalAngle' not in already_processed:
            already_processed.add('viewZenithalAngle')
            try:
                self.viewZenithalAngle = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (viewZenithalAngle): %s' % exp)
        value = find_attr_value_('viewAzimuthalAngle', node)
        if value is not None and 'viewAzimuthalAngle' not in already_processed:
            already_processed.add('viewAzimuthalAngle')
            try:
                self.viewAzimuthalAngle = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (viewAzimuthalAngle): %s' % exp)
        value = find_attr_value_('sunZenithalAngle', node)
        if value is not None and 'sunZenithalAngle' not in already_processed:
            already_processed.add('sunZenithalAngle')
            try:
                self.sunZenithalAngle = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sunZenithalAngle): %s' % exp)
        value = find_attr_value_('sunAzimuthalAngle', node)
        if value is not None and 'sunAzimuthalAngle' not in already_processed:
            already_processed.add('sunAzimuthalAngle')
            try:
                self.sunAzimuthalAngle = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sunAzimuthalAngle): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_SunViewAngleProperties


class create_Inversion(GeneratedsSuper):
    """Inversion Inversion"""
    member_data_items_ = [
        MemberSpec_('InversionDatabase', '_InversionDatabase', 0, 0, {'name': 'InversionDatabase', 'type': '_InversionDatabase', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('InversionInterpolation', '_InversionInterpolation', 0, 0, {'name': 'InversionInterpolation', 'type': '_InversionInterpolation', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('InversionSimplexConvergence', '_InversionSimplexConvergence', 0, 0, {'name': 'InversionSimplexConvergence', 'type': '_InversionSimplexConvergence', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('InversionParameters', '_InversionParameters', 0, 0, {'name': 'InversionParameters', 'type': '_InversionParameters', 'minOccurs': '1', 'maxOccurs': '1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, InversionDatabase=None, InversionInterpolation=None, InversionSimplexConvergence=None, InversionParameters=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('inversion','_Inversion')
        self.attrib = ['']
        self.children = ['InversionDatabase', 'InversionInterpolation', 'InversionSimplexConvergence', 'InversionParameters']
        self.parent = None
        self._InversionDatabase = InversionDatabase
        self._InversionInterpolation = InversionInterpolation
        self._InversionSimplexConvergence = InversionSimplexConvergence
        self._InversionParameters = InversionParameters
        update_node(self,self.troot,'inversion')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Inversion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Inversion.subclass:
            return create_Inversion.subclass(*args_, **kwargs_)
        else:
            return create_Inversion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_InversionDatabase(self): return self._InversionDatabase
    def set_InversionDatabase(self, value):
        if value is not None:
            checkclass(value, create_InversionDatabase)
            value.parent = self
        self._InversionDatabase = value
    InversionDatabase = property(get_InversionDatabase, set_InversionDatabase)
    def get_InversionInterpolation(self): return self._InversionInterpolation
    def set_InversionInterpolation(self, value):
        if value is not None:
            checkclass(value, create_InversionInterpolation)
            value.parent = self
        self._InversionInterpolation = value
    InversionInterpolation = property(get_InversionInterpolation, set_InversionInterpolation)
    def get_InversionSimplexConvergence(self): return self._InversionSimplexConvergence
    def set_InversionSimplexConvergence(self, value):
        if value is not None:
            checkclass(value, create_InversionSimplexConvergence)
            value.parent = self
        self._InversionSimplexConvergence = value
    InversionSimplexConvergence = property(get_InversionSimplexConvergence, set_InversionSimplexConvergence)
    def get_InversionParameters(self): return self._InversionParameters
    def set_InversionParameters(self, value):
        if value is not None:
            checkclass(value, create_InversionParameters)
            value.parent = self
        self._InversionParameters = value
    InversionParameters = property(get_InversionParameters, set_InversionParameters)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.InversionDatabase is not None or
            self.InversionInterpolation is not None or
            self.InversionSimplexConvergence is not None or
            self.InversionParameters is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Inversion', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Inversion')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Inversion')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Inversion', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Inversion'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Inversion', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InversionDatabase is not None:
            self.InversionDatabase.export(outfile, level, namespaceprefix_, name_='InversionDatabase', pretty_print=pretty_print)
        if self.InversionInterpolation is not None:
            self.InversionInterpolation.export(outfile, level, namespaceprefix_, name_='InversionInterpolation', pretty_print=pretty_print)
        if self.InversionSimplexConvergence is not None:
            self.InversionSimplexConvergence.export(outfile, level, namespaceprefix_, name_='InversionSimplexConvergence', pretty_print=pretty_print)
        if self.InversionParameters is not None:
            self.InversionParameters.export(outfile, level, namespaceprefix_, name_='InversionParameters', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Inversion', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.InversionDatabase is not None:
            InversionDatabase_ = self.InversionDatabase
            InversionDatabase_.to_etree(element, name_='InversionDatabase', mapping_=mapping_)
        if self.InversionInterpolation is not None:
            InversionInterpolation_ = self.InversionInterpolation
            InversionInterpolation_.to_etree(element, name_='InversionInterpolation', mapping_=mapping_)
        if self.InversionSimplexConvergence is not None:
            InversionSimplexConvergence_ = self.InversionSimplexConvergence
            InversionSimplexConvergence_.to_etree(element, name_='InversionSimplexConvergence', mapping_=mapping_)
        if self.InversionParameters is not None:
            InversionParameters_ = self.InversionParameters
            InversionParameters_.to_etree(element, name_='InversionParameters', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Inversion'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.InversionDatabase is not None:
            showIndent(outfile, level)
            outfile.write('InversionDatabase=model_._InversionDatabase(\n')
            self.InversionDatabase.exportLiteral(outfile, level, name_='InversionDatabase')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InversionInterpolation is not None:
            showIndent(outfile, level)
            outfile.write('InversionInterpolation=model_._InversionInterpolation(\n')
            self.InversionInterpolation.exportLiteral(outfile, level, name_='InversionInterpolation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InversionSimplexConvergence is not None:
            showIndent(outfile, level)
            outfile.write('InversionSimplexConvergence=model_._InversionSimplexConvergence(\n')
            self.InversionSimplexConvergence.exportLiteral(outfile, level, name_='InversionSimplexConvergence')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InversionParameters is not None:
            showIndent(outfile, level)
            outfile.write('InversionParameters=model_._InversionParameters(\n')
            self.InversionParameters.exportLiteral(outfile, level, name_='InversionParameters')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InversionDatabase':
            obj_ = create_InversionDatabase.factory()
            obj_.build(child_)
            self.set_InversionDatabase(obj_)
            obj_.original_tagname_ = 'InversionDatabase'
        elif nodeName_ == 'InversionInterpolation':
            obj_ = create_InversionInterpolation.factory()
            obj_.build(child_)
            self.set_InversionInterpolation(obj_)
            obj_.original_tagname_ = 'InversionInterpolation'
        elif nodeName_ == 'InversionSimplexConvergence':
            obj_ = create_InversionSimplexConvergence.factory()
            obj_.build(child_)
            self.set_InversionSimplexConvergence(obj_)
            obj_.original_tagname_ = 'InversionSimplexConvergence'
        elif nodeName_ == 'InversionParameters':
            obj_ = create_InversionParameters.factory()
            obj_.build(child_)
            self.set_InversionParameters(obj_)
            obj_.original_tagname_ = 'InversionParameters'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_Inversion


class create_InversionDatabase(GeneratedsSuper):
    """Inversion database Inversion database Ground spectral model that was
    used for creating the database (LUT) Ground spectral model that
    was used for creating the database (LUT) Inversion database
    Inversion database Reflectance database Reflectance database
    Analytic reflectance model Analytic reflectance model"""
    member_data_items_ = [
        MemberSpec_('GroundSpectralModel', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('InversionDatabase', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('databaseName', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('InversionCoefficientModelName', 'xsd:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, GroundSpectralModel='', InversionDatabase='', databaseName='Lambertian.db', InversionCoefficientModelName='0'):
        self.original_tagname_ = None
        self.troot=get_gs_troot('inversion','_InversionDatabase')
        self.attrib = ['GroundSpectralModel', 'InversionDatabase', 'databaseName', 'InversionCoefficientModelName']
        self.children = []
        self.parent = None
        self._GroundSpectralModel = _cast(None, GroundSpectralModel)
        self._InversionDatabase = _cast(None, InversionDatabase)
        self._databaseName = _cast(None, databaseName)
        self._InversionCoefficientModelName = _cast(None, InversionCoefficientModelName)
        update_node(self,self.troot,'inversion')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_InversionDatabase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_InversionDatabase.subclass:
            return create_InversionDatabase.subclass(*args_, **kwargs_)
        else:
            return create_InversionDatabase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GroundSpectralModel(self): return self._GroundSpectralModel
    def set_GroundSpectralModel(self, value):
        self._GroundSpectralModel = value
        update_node(self,self.troot,'inversion')
    GroundSpectralModel = property(get_GroundSpectralModel, set_GroundSpectralModel)
    def get_InversionDatabase(self): return self._InversionDatabase
    def set_InversionDatabase(self, value):
        self._InversionDatabase = value
        update_node(self,self.troot,'inversion')
    InversionDatabase = property(get_InversionDatabase, set_InversionDatabase)
    def get_databaseName(self): return self._databaseName
    def set_databaseName(self, value):
        self._databaseName = value
        update_node(self,self.troot,'inversion')
    databaseName = property(get_databaseName, set_databaseName)
    def get_InversionCoefficientModelName(self): return self._InversionCoefficientModelName
    def set_InversionCoefficientModelName(self, value):
        self._InversionCoefficientModelName = value
        update_node(self,self.troot,'inversion')
    InversionCoefficientModelName = property(get_InversionCoefficientModelName, set_InversionCoefficientModelName)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_InversionDatabase', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_InversionDatabase')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_InversionDatabase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_InversionDatabase', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_InversionDatabase'):
        if self.GroundSpectralModel is not None and 'GroundSpectralModel' not in already_processed:
            already_processed.add('GroundSpectralModel')
            outfile.write(' GroundSpectralModel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.GroundSpectralModel), input_name='GroundSpectralModel')), ))
        if self.InversionDatabase is not None and 'InversionDatabase' not in already_processed:
            already_processed.add('InversionDatabase')
            outfile.write(' InversionDatabase=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.InversionDatabase), input_name='InversionDatabase')), ))
        if self.databaseName is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            outfile.write(' databaseName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.databaseName), input_name='databaseName')), ))
        if self.InversionCoefficientModelName is not None and 'InversionCoefficientModelName' not in already_processed:
            already_processed.add('InversionCoefficientModelName')
            outfile.write(' InversionCoefficientModelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.InversionCoefficientModelName), input_name='InversionCoefficientModelName')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_InversionDatabase', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_InversionDatabase', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.GroundSpectralModel is not None:
            element.set('GroundSpectralModel', self.gds_format_string(self.GroundSpectralModel))
        if self.InversionDatabase is not None:
            element.set('InversionDatabase', self.gds_format_string(self.InversionDatabase))
        if self.databaseName is not None:
            element.set('databaseName', self.gds_format_string(self.databaseName))
        if self.InversionCoefficientModelName is not None:
            element.set('InversionCoefficientModelName', self.gds_format_string(self.InversionCoefficientModelName))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_InversionDatabase'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.GroundSpectralModel is not None and 'GroundSpectralModel' not in already_processed:
            already_processed.add('GroundSpectralModel')
            showIndent(outfile, level)
            outfile.write('GroundSpectralModel="%s",\n' % (self.GroundSpectralModel,))
        if self.InversionDatabase is not None and 'InversionDatabase' not in already_processed:
            already_processed.add('InversionDatabase')
            showIndent(outfile, level)
            outfile.write('InversionDatabase="%s",\n' % (self.InversionDatabase,))
        if self.databaseName is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            showIndent(outfile, level)
            outfile.write('databaseName="%s",\n' % (self.databaseName,))
        if self.InversionCoefficientModelName is not None and 'InversionCoefficientModelName' not in already_processed:
            already_processed.add('InversionCoefficientModelName')
            showIndent(outfile, level)
            outfile.write('InversionCoefficientModelName="%s",\n' % (self.InversionCoefficientModelName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('GroundSpectralModel', node)
        if value is not None and 'GroundSpectralModel' not in already_processed:
            already_processed.add('GroundSpectralModel')
            self.GroundSpectralModel = value
        value = find_attr_value_('InversionDatabase', node)
        if value is not None and 'InversionDatabase' not in already_processed:
            already_processed.add('InversionDatabase')
            self.InversionDatabase = value
        value = find_attr_value_('databaseName', node)
        if value is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            self.databaseName = value
        value = find_attr_value_('InversionCoefficientModelName', node)
        if value is not None and 'InversionCoefficientModelName' not in already_processed:
            already_processed.add('InversionCoefficientModelName')
            self.InversionCoefficientModelName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_InversionDatabase


class create_InversionInterpolation(GeneratedsSuper):
    """Number of interpolations points on each side of the point that is
    calculated (interpolated). Number of interpolations points on
    each side of the point that is calculated (interpolated).
    Interpolation method Interpolation method"""
    member_data_items_ = [
        MemberSpec_('interpolationPoints', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('interpolationMethod', 'xsd:int', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, interpolationPoints=3, interpolationMethod=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('inversion','_InversionInterpolation')
        self.attrib = ['interpolationPoints', 'interpolationMethod']
        self.children = []
        self.parent = None
        self._interpolationPoints = _cast(int, interpolationPoints)
        self._interpolationMethod = _cast(int, interpolationMethod)
        update_node(self,self.troot,'inversion')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_InversionInterpolation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_InversionInterpolation.subclass:
            return create_InversionInterpolation.subclass(*args_, **kwargs_)
        else:
            return create_InversionInterpolation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_interpolationPoints(self): return self._interpolationPoints
    def set_interpolationPoints(self, value):
        self._interpolationPoints = value
        update_node(self,self.troot,'inversion')
    interpolationPoints = property(get_interpolationPoints, set_interpolationPoints)
    def get_interpolationMethod(self): return self._interpolationMethod
    def set_interpolationMethod(self, value):
        self._interpolationMethod = value
        update_node(self,self.troot,'inversion')
    interpolationMethod = property(get_interpolationMethod, set_interpolationMethod)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_InversionInterpolation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_InversionInterpolation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_InversionInterpolation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_InversionInterpolation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_InversionInterpolation'):
        if self.interpolationPoints is not None and 'interpolationPoints' not in already_processed:
            already_processed.add('interpolationPoints')
            outfile.write(' interpolationPoints="%s"' % self.gds_format_integer(self.interpolationPoints, input_name='interpolationPoints'))
        if self.interpolationMethod is not None and 'interpolationMethod' not in already_processed:
            already_processed.add('interpolationMethod')
            outfile.write(' interpolationMethod="%s"' % self.gds_format_integer(self.interpolationMethod, input_name='interpolationMethod'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_InversionInterpolation', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_InversionInterpolation', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.interpolationPoints is not None:
            element.set('interpolationPoints', self.gds_format_integer(self.interpolationPoints))
        if self.interpolationMethod is not None:
            element.set('interpolationMethod', self.gds_format_integer(self.interpolationMethod))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_InversionInterpolation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.interpolationPoints is not None and 'interpolationPoints' not in already_processed:
            already_processed.add('interpolationPoints')
            showIndent(outfile, level)
            outfile.write('interpolationPoints=%d,\n' % (self.interpolationPoints,))
        if self.interpolationMethod is not None and 'interpolationMethod' not in already_processed:
            already_processed.add('interpolationMethod')
            showIndent(outfile, level)
            outfile.write('interpolationMethod=%d,\n' % (self.interpolationMethod,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('interpolationPoints', node)
        if value is not None and 'interpolationPoints' not in already_processed:
            already_processed.add('interpolationPoints')
            try:
                self.interpolationPoints = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('interpolationMethod', node)
        if value is not None and 'interpolationMethod' not in already_processed:
            already_processed.add('interpolationMethod')
            try:
                self.interpolationMethod = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_InversionInterpolation


class create_InversionSimplexConvergence(GeneratedsSuper):
    """It is a error that is computed in the inversion procedure More
    details in p.51 PHD of P.Esteve (1998) (http://www.cesbio.ups-
    tlse.fr/data_all/theses/Th_esteve.pdf) A simplex is made of 3
    points that are iteratively up-dated, one per iteration. The
    iteration stops when the 3 points give identical errors (When
    difference between values of errors is less than value setted in
    next case) . The error is the difference between the predicted
    and image reflectance values. The larger number of iterations is
    5000/(number of free variables to invert + 1). Next simplex is
    launch if maximum simplexes number is not reached and if error
    of best simplex computed is upper than error given. It is a
    error that is computed in the inversion procedure More details
    in p.51 PHD of P.Esteve (1998) (http://www.cesbio.ups-
    tlse.fr/data_all/theses/Th_esteve.pdf) A simplex is made of 3
    points that are iteratively up-dated, one per iteration. The
    iteration stops when the 3 points give identical errors (When
    difference between values of errors is less than value setted in
    next case) . The error is the difference between the predicted
    and image reflectance values. The larger number of iterations is
    5000/(number of free variables to invert + 1). Next simplex is
    launch if maximum simplexes number is not reached and if error
    of best simplex computed is upper than error given. Difference
    between worst and best error of simplexes computed. Difference
    between worst and best error of simplexes computed. The creation
    of simplex is stopped if the error of the simplex is less than
    the error (and if the maximum number of simplexes is not
    reached). The creation of simplex is stopped if the error of the
    simplex is less than the error (and if the maximum number of
    simplexes is not reached). Maximum number of simplexes (if
    simplex relative error threshold is not reached) Maximum number
    of simplexes (if simplex relative error threshold is not
    reached)"""
    member_data_items_ = [
        MemberSpec_('errorKind', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('errorValueConvergence', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('errorValueStop', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('maxSimplexNumber', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('ThresholdRelativeError', '_ThresholdRelativeError', 0, 0, {'name': 'ThresholdRelativeError', 'type': '_ThresholdRelativeError', 'minOccurs': '1', 'maxOccurs': '1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, errorKind=0, errorValueConvergence=0.00017205, errorValueStop=0.01, maxSimplexNumber=5, ThresholdRelativeError=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('inversion','_InversionSimplexConvergence')
        self.attrib = ['errorKind', 'errorValueConvergence', 'errorValueStop', 'maxSimplexNumber']
        self.children = ['ThresholdRelativeError']
        self.parent = None
        self._errorKind = _cast(int, errorKind)
        self._errorValueConvergence = _cast(float, errorValueConvergence)
        self._errorValueStop = _cast(float, errorValueStop)
        self._maxSimplexNumber = _cast(int, maxSimplexNumber)
        self._ThresholdRelativeError = ThresholdRelativeError
        update_node(self,self.troot,'inversion')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_InversionSimplexConvergence)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_InversionSimplexConvergence.subclass:
            return create_InversionSimplexConvergence.subclass(*args_, **kwargs_)
        else:
            return create_InversionSimplexConvergence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ThresholdRelativeError(self): return self._ThresholdRelativeError
    def set_ThresholdRelativeError(self, value):
        if value is not None:
            checkclass(value, create_ThresholdRelativeError)
            value.parent = self
        self._ThresholdRelativeError = value
    ThresholdRelativeError = property(get_ThresholdRelativeError, set_ThresholdRelativeError)
    def get_errorKind(self): return self._errorKind
    def set_errorKind(self, value):
        self._errorKind = value
        update_node(self,self.troot,'inversion')
    errorKind = property(get_errorKind, set_errorKind)
    def get_errorValueConvergence(self): return self._errorValueConvergence
    def set_errorValueConvergence(self, value):
        self._errorValueConvergence = value
        update_node(self,self.troot,'inversion')
    errorValueConvergence = property(get_errorValueConvergence, set_errorValueConvergence)
    def get_errorValueStop(self): return self._errorValueStop
    def set_errorValueStop(self, value):
        self._errorValueStop = value
        update_node(self,self.troot,'inversion')
    errorValueStop = property(get_errorValueStop, set_errorValueStop)
    def get_maxSimplexNumber(self): return self._maxSimplexNumber
    def set_maxSimplexNumber(self, value):
        self._maxSimplexNumber = value
        update_node(self,self.troot,'inversion')
    maxSimplexNumber = property(get_maxSimplexNumber, set_maxSimplexNumber)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.ThresholdRelativeError is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_InversionSimplexConvergence', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_InversionSimplexConvergence')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_InversionSimplexConvergence')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_InversionSimplexConvergence', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_InversionSimplexConvergence'):
        if self.errorKind is not None and 'errorKind' not in already_processed:
            already_processed.add('errorKind')
            outfile.write(' errorKind="%s"' % self.gds_format_integer(self.errorKind, input_name='errorKind'))
        if self.errorValueConvergence is not None and 'errorValueConvergence' not in already_processed:
            already_processed.add('errorValueConvergence')
            outfile.write(' errorValueConvergence="%s"' % self.gds_format_double(self.errorValueConvergence, input_name='errorValueConvergence'))
        if self.errorValueStop is not None and 'errorValueStop' not in already_processed:
            already_processed.add('errorValueStop')
            outfile.write(' errorValueStop="%s"' % self.gds_format_double(self.errorValueStop, input_name='errorValueStop'))
        if self.maxSimplexNumber is not None and 'maxSimplexNumber' not in already_processed:
            already_processed.add('maxSimplexNumber')
            outfile.write(' maxSimplexNumber="%s"' % self.gds_format_integer(self.maxSimplexNumber, input_name='maxSimplexNumber'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_InversionSimplexConvergence', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ThresholdRelativeError is not None:
            self.ThresholdRelativeError.export(outfile, level, namespaceprefix_, name_='ThresholdRelativeError', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_InversionSimplexConvergence', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.errorKind is not None:
            element.set('errorKind', self.gds_format_integer(self.errorKind))
        if self.errorValueConvergence is not None:
            element.set('errorValueConvergence', self.gds_format_double(self.errorValueConvergence))
        if self.errorValueStop is not None:
            element.set('errorValueStop', self.gds_format_double(self.errorValueStop))
        if self.maxSimplexNumber is not None:
            element.set('maxSimplexNumber', self.gds_format_integer(self.maxSimplexNumber))
        if self.ThresholdRelativeError is not None:
            ThresholdRelativeError_ = self.ThresholdRelativeError
            ThresholdRelativeError_.to_etree(element, name_='ThresholdRelativeError', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_InversionSimplexConvergence'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.errorKind is not None and 'errorKind' not in already_processed:
            already_processed.add('errorKind')
            showIndent(outfile, level)
            outfile.write('errorKind=%d,\n' % (self.errorKind,))
        if self.errorValueConvergence is not None and 'errorValueConvergence' not in already_processed:
            already_processed.add('errorValueConvergence')
            showIndent(outfile, level)
            outfile.write('errorValueConvergence=%e,\n' % (self.errorValueConvergence,))
        if self.errorValueStop is not None and 'errorValueStop' not in already_processed:
            already_processed.add('errorValueStop')
            showIndent(outfile, level)
            outfile.write('errorValueStop=%e,\n' % (self.errorValueStop,))
        if self.maxSimplexNumber is not None and 'maxSimplexNumber' not in already_processed:
            already_processed.add('maxSimplexNumber')
            showIndent(outfile, level)
            outfile.write('maxSimplexNumber=%d,\n' % (self.maxSimplexNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ThresholdRelativeError is not None:
            showIndent(outfile, level)
            outfile.write('ThresholdRelativeError=model_._ThresholdRelativeError(\n')
            self.ThresholdRelativeError.exportLiteral(outfile, level, name_='ThresholdRelativeError')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('errorKind', node)
        if value is not None and 'errorKind' not in already_processed:
            already_processed.add('errorKind')
            try:
                self.errorKind = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('errorValueConvergence', node)
        if value is not None and 'errorValueConvergence' not in already_processed:
            already_processed.add('errorValueConvergence')
            try:
                self.errorValueConvergence = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (errorValueConvergence): %s' % exp)
        value = find_attr_value_('errorValueStop', node)
        if value is not None and 'errorValueStop' not in already_processed:
            already_processed.add('errorValueStop')
            try:
                self.errorValueStop = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (errorValueStop): %s' % exp)
        value = find_attr_value_('maxSimplexNumber', node)
        if value is not None and 'maxSimplexNumber' not in already_processed:
            already_processed.add('maxSimplexNumber')
            try:
                self.maxSimplexNumber = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ThresholdRelativeError':
            obj_ = create_ThresholdRelativeError.factory()
            obj_.build(child_)
            self.set_ThresholdRelativeError(obj_)
            obj_.original_tagname_ = 'ThresholdRelativeError'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_InversionSimplexConvergence


class create_ThresholdRelativeError(GeneratedsSuper):
    """Threshold value Threshold value"""
    member_data_items_ = [
        MemberSpec_('errorValueThreshold', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, errorValueThreshold=0.03):
        self.original_tagname_ = None
        self.troot=get_gs_troot('inversion','_ThresholdRelativeError')
        self.attrib = ['errorValueThreshold']
        self.children = []
        self.parent = None
        self._errorValueThreshold = _cast(float, errorValueThreshold)
        update_node(self,self.troot,'inversion')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ThresholdRelativeError)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ThresholdRelativeError.subclass:
            return create_ThresholdRelativeError.subclass(*args_, **kwargs_)
        else:
            return create_ThresholdRelativeError(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_errorValueThreshold(self): return self._errorValueThreshold
    def set_errorValueThreshold(self, value):
        self._errorValueThreshold = value
        update_node(self,self.troot,'inversion')
    errorValueThreshold = property(get_errorValueThreshold, set_errorValueThreshold)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ThresholdRelativeError', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ThresholdRelativeError')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ThresholdRelativeError')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ThresholdRelativeError', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ThresholdRelativeError'):
        if self.errorValueThreshold is not None and 'errorValueThreshold' not in already_processed:
            already_processed.add('errorValueThreshold')
            outfile.write(' errorValueThreshold="%s"' % self.gds_format_double(self.errorValueThreshold, input_name='errorValueThreshold'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ThresholdRelativeError', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_ThresholdRelativeError', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.errorValueThreshold is not None:
            element.set('errorValueThreshold', self.gds_format_double(self.errorValueThreshold))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ThresholdRelativeError'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.errorValueThreshold is not None and 'errorValueThreshold' not in already_processed:
            already_processed.add('errorValueThreshold')
            showIndent(outfile, level)
            outfile.write('errorValueThreshold=%e,\n' % (self.errorValueThreshold,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('errorValueThreshold', node)
        if value is not None and 'errorValueThreshold' not in already_processed:
            already_processed.add('errorValueThreshold')
            try:
                self.errorValueThreshold = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (errorValueThreshold): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_ThresholdRelativeError


class create_InversionParameters(GeneratedsSuper):
    """Inversion parameters Inversion parameters"""
    member_data_items_ = [
        MemberSpec_('freeParameters', '_freeParameters', 1, 0, {'name': 'freeParameters', 'type': '_freeParameters', 'minOccurs': '1', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, freeParameters=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('inversion','_InversionParameters')
        self.attrib = ['']
        self.children = ['freeParameters']
        self.parent = None
        if freeParameters is None:
            self._freeParameters = []
        else:
            self._freeParameters = freeParameters
        update_node(self,self.troot,'inversion')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_InversionParameters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_InversionParameters.subclass:
            return create_InversionParameters.subclass(*args_, **kwargs_)
        else:
            return create_InversionParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_freeParameters(self): return self._freeParameters
    def set_freeParameters(self, value):
        if value is not None:
            checkclass(value, create_freeParameters)
            for v in value:
                v.parent = self
        self._freeParameters = value
    def add_freeParameters(self, value):
        value.parent = self
        self._freeParameters.append(value)
    def insert_freeParameters_at(self, index, value):
        value.parent = self
        self.freeParameters.insert(index, value)
    def replace_freeParameters_at(self, index, value):
        value.parent = self
        self.freeParameters[index] = value
    freeParameters = property(get_freeParameters, set_freeParameters)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.freeParameters
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_InversionParameters', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_InversionParameters')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_InversionParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_InversionParameters', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_InversionParameters'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_InversionParameters', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for freeParameters_ in self.freeParameters:
            freeParameters_.export(outfile, level, namespaceprefix_, name_='freeParameters', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_InversionParameters', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for freeParameters_ in self.freeParameters:
            freeParameters_.to_etree(element, name_='freeParameters', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_InversionParameters'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('freeParameters=[\n')
        level += 1
        for freeParameters_ in self.freeParameters:
            showIndent(outfile, level)
            outfile.write('model_._freeParameters(\n')
            freeParameters_.exportLiteral(outfile, level, name_='_freeParameters')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.freeParameters = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'freeParameters':
            obj_ = create_freeParameters.factory()
            obj_.build(child_)
            self.add_freeParameters(obj_)
            obj_.original_tagname_ = 'freeParameters'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_InversionParameters


class create_freeParameters(GeneratedsSuper):
    """Free parameter Free parameter Type of the parameter used for
    inversion Type of the parameter used for inversion This index
    have to be specified for giving equivalence between inversion
    parameters and LUT free parameters. The index 0 means to the
    first free parameter. This index have to be specified for giving
    equivalence between inversion parameters and LUT free
    parameters. The index 0 means to the first free parameter."""
    member_data_items_ = [
        MemberSpec_('ParameterType', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('indexLUTEquivalent', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('freeParameterGlobalValue', '_freeParameterGlobalValue', 0, 0, {'name': 'freeParameterGlobalValue', 'type': '_freeParameterGlobalValue', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('freeParameterValue', '_freeParameterValue', 1, 0, {'name': 'freeParameterValue', 'type': '_freeParameterValue', 'minOccurs': '1', 'maxOccurs': 'unbounded'}, None),
        MemberSpec_('InversionSpectra', '_InversionSpectra', 0, 0, {'name': 'InversionSpectra', 'type': '_InversionSpectra', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('InversionSpectra1', '_InversionSpectra1', 0, 0, {'name': 'InversionSpectra1', 'type': '_InversionSpectra1', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('InversionSpectra2', '_InversionSpectra2', 0, 0, {'name': 'InversionSpectra2', 'type': '_InversionSpectra2', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('InversionSpectra3', '_InversionSpectra3', 0, 0, {'name': 'InversionSpectra3', 'type': '_InversionSpectra3', 'minOccurs': '1', 'maxOccurs': '1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ParameterType=0, indexLUTEquivalent='', freeParameterGlobalValue=None, freeParameterValue=None, InversionSpectra=None, InversionSpectra1=None, InversionSpectra2=None, InversionSpectra3=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('inversion','_freeParameters')
        self.attrib = ['ParameterType', 'indexLUTEquivalent']
        self.children = ['freeParameterGlobalValue', 'freeParameterValue', 'InversionSpectra', 'InversionSpectra1', 'InversionSpectra2', 'InversionSpectra3']
        self.parent = None
        self._ParameterType = _cast(int, ParameterType)
        self._indexLUTEquivalent = _cast(None, indexLUTEquivalent)
        self._freeParameterGlobalValue = freeParameterGlobalValue
        if freeParameterValue is None:
            self._freeParameterValue = []
        else:
            self._freeParameterValue = freeParameterValue
        self._InversionSpectra = InversionSpectra
        self._InversionSpectra1 = InversionSpectra1
        self._InversionSpectra2 = InversionSpectra2
        self._InversionSpectra3 = InversionSpectra3
        update_node(self,self.troot,'inversion')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_freeParameters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_freeParameters.subclass:
            return create_freeParameters.subclass(*args_, **kwargs_)
        else:
            return create_freeParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_freeParameterGlobalValue(self): return self._freeParameterGlobalValue
    def set_freeParameterGlobalValue(self, value):
        if value is not None:
            checkclass(value, create_freeParameterGlobalValue)
            value.parent = self
        self._freeParameterGlobalValue = value
    freeParameterGlobalValue = property(get_freeParameterGlobalValue, set_freeParameterGlobalValue)
    def get_freeParameterValue(self): return self._freeParameterValue
    def set_freeParameterValue(self, value):
        if value is not None:
            checkclass(value, create_freeParameterValue)
            for v in value:
                v.parent = self
        self._freeParameterValue = value
    def add_freeParameterValue(self, value):
        value.parent = self
        self._freeParameterValue.append(value)
    def insert_freeParameterValue_at(self, index, value):
        value.parent = self
        self.freeParameterValue.insert(index, value)
    def replace_freeParameterValue_at(self, index, value):
        value.parent = self
        self.freeParameterValue[index] = value
    freeParameterValue = property(get_freeParameterValue, set_freeParameterValue)
    def get_InversionSpectra(self): return self._InversionSpectra
    def set_InversionSpectra(self, value):
        if value is not None:
            checkclass(value, create_InversionSpectra)
            value.parent = self
        self._InversionSpectra = value
    InversionSpectra = property(get_InversionSpectra, set_InversionSpectra)
    def get_InversionSpectra1(self): return self._InversionSpectra1
    def set_InversionSpectra1(self, value):
        if value is not None:
            checkclass(value, create_InversionSpectra1)
            value.parent = self
        self._InversionSpectra1 = value
    InversionSpectra1 = property(get_InversionSpectra1, set_InversionSpectra1)
    def get_InversionSpectra2(self): return self._InversionSpectra2
    def set_InversionSpectra2(self, value):
        if value is not None:
            checkclass(value, create_InversionSpectra2)
            value.parent = self
        self._InversionSpectra2 = value
    InversionSpectra2 = property(get_InversionSpectra2, set_InversionSpectra2)
    def get_InversionSpectra3(self): return self._InversionSpectra3
    def set_InversionSpectra3(self, value):
        if value is not None:
            checkclass(value, create_InversionSpectra3)
            value.parent = self
        self._InversionSpectra3 = value
    InversionSpectra3 = property(get_InversionSpectra3, set_InversionSpectra3)
    def get_ParameterType(self): return self._ParameterType
    def set_ParameterType(self, value):
        self._ParameterType = value
        update_node(self,self.troot,'inversion')
    ParameterType = property(get_ParameterType, set_ParameterType)
    def get_indexLUTEquivalent(self): return self._indexLUTEquivalent
    def set_indexLUTEquivalent(self, value):
        self._indexLUTEquivalent = value
        update_node(self,self.troot,'inversion')
    indexLUTEquivalent = property(get_indexLUTEquivalent, set_indexLUTEquivalent)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.freeParameterGlobalValue is not None or
            self.freeParameterValue or
            self.InversionSpectra is not None or
            self.InversionSpectra1 is not None or
            self.InversionSpectra2 is not None or
            self.InversionSpectra3 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_freeParameters', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_freeParameters')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_freeParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_freeParameters', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_freeParameters'):
        if self.ParameterType is not None and 'ParameterType' not in already_processed:
            already_processed.add('ParameterType')
            outfile.write(' ParameterType="%s"' % self.gds_format_integer(self.ParameterType, input_name='ParameterType'))
        if self.indexLUTEquivalent is not None and 'indexLUTEquivalent' not in already_processed:
            already_processed.add('indexLUTEquivalent')
            outfile.write(' indexLUTEquivalent=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.indexLUTEquivalent), input_name='indexLUTEquivalent')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_freeParameters', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.freeParameterGlobalValue is not None:
            self.freeParameterGlobalValue.export(outfile, level, namespaceprefix_, name_='freeParameterGlobalValue', pretty_print=pretty_print)
        for freeParameterValue_ in self.freeParameterValue:
            freeParameterValue_.export(outfile, level, namespaceprefix_, name_='freeParameterValue', pretty_print=pretty_print)
        if self.InversionSpectra is not None:
            self.InversionSpectra.export(outfile, level, namespaceprefix_, name_='InversionSpectra', pretty_print=pretty_print)
        if self.InversionSpectra1 is not None:
            self.InversionSpectra1.export(outfile, level, namespaceprefix_, name_='InversionSpectra1', pretty_print=pretty_print)
        if self.InversionSpectra2 is not None:
            self.InversionSpectra2.export(outfile, level, namespaceprefix_, name_='InversionSpectra2', pretty_print=pretty_print)
        if self.InversionSpectra3 is not None:
            self.InversionSpectra3.export(outfile, level, namespaceprefix_, name_='InversionSpectra3', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_freeParameters', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ParameterType is not None:
            element.set('ParameterType', self.gds_format_integer(self.ParameterType))
        if self.indexLUTEquivalent is not None:
            element.set('indexLUTEquivalent', self.gds_format_string(self.indexLUTEquivalent))
        if self.freeParameterGlobalValue is not None:
            freeParameterGlobalValue_ = self.freeParameterGlobalValue
            freeParameterGlobalValue_.to_etree(element, name_='freeParameterGlobalValue', mapping_=mapping_)
        for freeParameterValue_ in self.freeParameterValue:
            freeParameterValue_.to_etree(element, name_='freeParameterValue', mapping_=mapping_)
        if self.InversionSpectra is not None:
            InversionSpectra_ = self.InversionSpectra
            InversionSpectra_.to_etree(element, name_='InversionSpectra', mapping_=mapping_)
        if self.InversionSpectra1 is not None:
            InversionSpectra1_ = self.InversionSpectra1
            InversionSpectra1_.to_etree(element, name_='InversionSpectra1', mapping_=mapping_)
        if self.InversionSpectra2 is not None:
            InversionSpectra2_ = self.InversionSpectra2
            InversionSpectra2_.to_etree(element, name_='InversionSpectra2', mapping_=mapping_)
        if self.InversionSpectra3 is not None:
            InversionSpectra3_ = self.InversionSpectra3
            InversionSpectra3_.to_etree(element, name_='InversionSpectra3', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_freeParameters'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ParameterType is not None and 'ParameterType' not in already_processed:
            already_processed.add('ParameterType')
            showIndent(outfile, level)
            outfile.write('ParameterType=%d,\n' % (self.ParameterType,))
        if self.indexLUTEquivalent is not None and 'indexLUTEquivalent' not in already_processed:
            already_processed.add('indexLUTEquivalent')
            showIndent(outfile, level)
            outfile.write('indexLUTEquivalent="%s",\n' % (self.indexLUTEquivalent,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.freeParameterGlobalValue is not None:
            showIndent(outfile, level)
            outfile.write('freeParameterGlobalValue=model_._freeParameterGlobalValue(\n')
            self.freeParameterGlobalValue.exportLiteral(outfile, level, name_='freeParameterGlobalValue')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('freeParameterValue=[\n')
        level += 1
        for freeParameterValue_ in self.freeParameterValue:
            showIndent(outfile, level)
            outfile.write('model_._freeParameterValue(\n')
            freeParameterValue_.exportLiteral(outfile, level, name_='_freeParameterValue')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.InversionSpectra is not None:
            showIndent(outfile, level)
            outfile.write('InversionSpectra=model_._InversionSpectra(\n')
            self.InversionSpectra.exportLiteral(outfile, level, name_='InversionSpectra')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InversionSpectra1 is not None:
            showIndent(outfile, level)
            outfile.write('InversionSpectra1=model_._InversionSpectra1(\n')
            self.InversionSpectra1.exportLiteral(outfile, level, name_='InversionSpectra1')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InversionSpectra2 is not None:
            showIndent(outfile, level)
            outfile.write('InversionSpectra2=model_._InversionSpectra2(\n')
            self.InversionSpectra2.exportLiteral(outfile, level, name_='InversionSpectra2')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InversionSpectra3 is not None:
            showIndent(outfile, level)
            outfile.write('InversionSpectra3=model_._InversionSpectra3(\n')
            self.InversionSpectra3.exportLiteral(outfile, level, name_='InversionSpectra3')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.freeParameterValue = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ParameterType', node)
        if value is not None and 'ParameterType' not in already_processed:
            already_processed.add('ParameterType')
            try:
                self.ParameterType = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('indexLUTEquivalent', node)
        if value is not None and 'indexLUTEquivalent' not in already_processed:
            already_processed.add('indexLUTEquivalent')
            self.indexLUTEquivalent = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'freeParameterGlobalValue':
            obj_ = create_freeParameterGlobalValue.factory()
            obj_.build(child_)
            self.set_freeParameterGlobalValue(obj_)
            obj_.original_tagname_ = 'freeParameterGlobalValue'
        elif nodeName_ == 'freeParameterValue':
            obj_ = create_freeParameterValue.factory()
            obj_.build(child_)
            self.add_freeParameterValue(obj_)
            obj_.original_tagname_ = 'freeParameterValue'
        elif nodeName_ == 'InversionSpectra':
            obj_ = create_InversionSpectra.factory()
            obj_.build(child_)
            self.set_InversionSpectra(obj_)
            obj_.original_tagname_ = 'InversionSpectra'
        elif nodeName_ == 'InversionSpectra1':
            obj_ = create_InversionSpectra1.factory()
            obj_.build(child_)
            self.set_InversionSpectra1(obj_)
            obj_.original_tagname_ = 'InversionSpectra1'
        elif nodeName_ == 'InversionSpectra2':
            obj_ = create_InversionSpectra2.factory()
            obj_.build(child_)
            self.set_InversionSpectra2(obj_)
            obj_.original_tagname_ = 'InversionSpectra2'
        elif nodeName_ == 'InversionSpectra3':
            obj_ = create_InversionSpectra3.factory()
            obj_.build(child_)
            self.set_InversionSpectra3(obj_)
            obj_.original_tagname_ = 'InversionSpectra3'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_freeParameters


class create_freeParameterGlobalValue(GeneratedsSuper):
    """freeParameterGlobalValue freeParameterGlobalValue Value of the
    parameter Value of the parameter"""
    member_data_items_ = [
        MemberSpec_('ParamValue', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, ParamValue=0.1):
        self.original_tagname_ = None
        self.troot=get_gs_troot('inversion','_freeParameterGlobalValue')
        self.attrib = ['ParamValue']
        self.children = []
        self.parent = None
        self._ParamValue = _cast(float, ParamValue)
        update_node(self,self.troot,'inversion')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_freeParameterGlobalValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_freeParameterGlobalValue.subclass:
            return create_freeParameterGlobalValue.subclass(*args_, **kwargs_)
        else:
            return create_freeParameterGlobalValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ParamValue(self): return self._ParamValue
    def set_ParamValue(self, value):
        self._ParamValue = value
        update_node(self,self.troot,'inversion')
    ParamValue = property(get_ParamValue, set_ParamValue)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_freeParameterGlobalValue', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_freeParameterGlobalValue')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_freeParameterGlobalValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_freeParameterGlobalValue', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_freeParameterGlobalValue'):
        if self.ParamValue is not None and 'ParamValue' not in already_processed:
            already_processed.add('ParamValue')
            outfile.write(' ParamValue="%s"' % self.gds_format_double(self.ParamValue, input_name='ParamValue'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_freeParameterGlobalValue', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_freeParameterGlobalValue', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ParamValue is not None:
            element.set('ParamValue', self.gds_format_double(self.ParamValue))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_freeParameterGlobalValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ParamValue is not None and 'ParamValue' not in already_processed:
            already_processed.add('ParamValue')
            showIndent(outfile, level)
            outfile.write('ParamValue=%e,\n' % (self.ParamValue,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ParamValue', node)
        if value is not None and 'ParamValue' not in already_processed:
            already_processed.add('ParamValue')
            try:
                self.ParamValue = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (ParamValue): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_freeParameterGlobalValue


class create_freeParameterValue(GeneratedsSuper):
    """Free parameter value Free parameter value Value of the parameter
    Value of the parameter Image number Image number"""
    member_data_items_ = [
        MemberSpec_('ParamValue', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('ImageNumber_coef', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, ParamValue=0.1, ImageNumber_coef=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('inversion','_freeParameterValue')
        self.attrib = ['ParamValue', 'ImageNumber_coef']
        self.children = []
        self.parent = None
        self._ParamValue = _cast(float, ParamValue)
        self._ImageNumber_coef = _cast(float, ImageNumber_coef)
        update_node(self,self.troot,'inversion')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_freeParameterValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_freeParameterValue.subclass:
            return create_freeParameterValue.subclass(*args_, **kwargs_)
        else:
            return create_freeParameterValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ParamValue(self): return self._ParamValue
    def set_ParamValue(self, value):
        self._ParamValue = value
        update_node(self,self.troot,'inversion')
    ParamValue = property(get_ParamValue, set_ParamValue)
    def get_ImageNumber_coef(self): return self._ImageNumber_coef
    def set_ImageNumber_coef(self, value):
        self._ImageNumber_coef = value
        update_node(self,self.troot,'inversion')
    ImageNumber_coef = property(get_ImageNumber_coef, set_ImageNumber_coef)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_freeParameterValue', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_freeParameterValue')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_freeParameterValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_freeParameterValue', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_freeParameterValue'):
        if self.ParamValue is not None and 'ParamValue' not in already_processed:
            already_processed.add('ParamValue')
            outfile.write(' ParamValue="%s"' % self.gds_format_double(self.ParamValue, input_name='ParamValue'))
        if self.ImageNumber_coef is not None and 'ImageNumber_coef' not in already_processed:
            already_processed.add('ImageNumber_coef')
            outfile.write(' ImageNumber_coef="%s"' % self.gds_format_double(self.ImageNumber_coef, input_name='ImageNumber_coef'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_freeParameterValue', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_freeParameterValue', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ParamValue is not None:
            element.set('ParamValue', self.gds_format_double(self.ParamValue))
        if self.ImageNumber_coef is not None:
            element.set('ImageNumber_coef', self.gds_format_double(self.ImageNumber_coef))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_freeParameterValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ParamValue is not None and 'ParamValue' not in already_processed:
            already_processed.add('ParamValue')
            showIndent(outfile, level)
            outfile.write('ParamValue=%e,\n' % (self.ParamValue,))
        if self.ImageNumber_coef is not None and 'ImageNumber_coef' not in already_processed:
            already_processed.add('ImageNumber_coef')
            showIndent(outfile, level)
            outfile.write('ImageNumber_coef=%e,\n' % (self.ImageNumber_coef,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ParamValue', node)
        if value is not None and 'ParamValue' not in already_processed:
            already_processed.add('ParamValue')
            try:
                self.ParamValue = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (ParamValue): %s' % exp)
        value = find_attr_value_('ImageNumber_coef', node)
        if value is not None and 'ImageNumber_coef' not in already_processed:
            already_processed.add('ImageNumber_coef')
            try:
                self.ImageNumber_coef = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (ImageNumber_coef): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_freeParameterValue


class create_InversionSpectra(GeneratedsSuper):
    """Ground spectra Ground spectra Spectra Spectra Reflectance database
    Reflectance database"""
    member_data_items_ = [
        MemberSpec_('spectra', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('databaseName', 'xsd:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, spectra='', databaseName='Lambertian.db'):
        self.original_tagname_ = None
        self.troot=get_gs_troot('inversion','_InversionSpectra')
        self.attrib = ['spectra', 'databaseName']
        self.children = []
        self.parent = None
        self._spectra = _cast(None, spectra)
        self._databaseName = _cast(None, databaseName)
        update_node(self,self.troot,'inversion')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_InversionSpectra)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_InversionSpectra.subclass:
            return create_InversionSpectra.subclass(*args_, **kwargs_)
        else:
            return create_InversionSpectra(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_spectra(self): return self._spectra
    def set_spectra(self, value):
        self._spectra = value
        update_node(self,self.troot,'inversion')
    spectra = property(get_spectra, set_spectra)
    def get_databaseName(self): return self._databaseName
    def set_databaseName(self, value):
        self._databaseName = value
        update_node(self,self.troot,'inversion')
    databaseName = property(get_databaseName, set_databaseName)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_InversionSpectra', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_InversionSpectra')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_InversionSpectra')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_InversionSpectra', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_InversionSpectra'):
        if self.spectra is not None and 'spectra' not in already_processed:
            already_processed.add('spectra')
            outfile.write(' spectra=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.spectra), input_name='spectra')), ))
        if self.databaseName is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            outfile.write(' databaseName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.databaseName), input_name='databaseName')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_InversionSpectra', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_InversionSpectra', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.spectra is not None:
            element.set('spectra', self.gds_format_string(self.spectra))
        if self.databaseName is not None:
            element.set('databaseName', self.gds_format_string(self.databaseName))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_InversionSpectra'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.spectra is not None and 'spectra' not in already_processed:
            already_processed.add('spectra')
            showIndent(outfile, level)
            outfile.write('spectra="%s",\n' % (self.spectra,))
        if self.databaseName is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            showIndent(outfile, level)
            outfile.write('databaseName="%s",\n' % (self.databaseName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('spectra', node)
        if value is not None and 'spectra' not in already_processed:
            already_processed.add('spectra')
            self.spectra = value
        value = find_attr_value_('databaseName', node)
        if value is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            self.databaseName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_InversionSpectra


class create_InversionSpectra1(GeneratedsSuper):
    """Ground 1 spectra Ground 1 spectra Spectra 1 Spectra 1 Reflectance
    database Reflectance database"""
    member_data_items_ = [
        MemberSpec_('spectra1', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('databaseName', 'xsd:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, spectra1='', databaseName='Lambertian.db'):
        self.original_tagname_ = None
        self.troot=get_gs_troot('inversion','_InversionSpectra1')
        self.attrib = ['spectra1', 'databaseName']
        self.children = []
        self.parent = None
        self._spectra1 = _cast(None, spectra1)
        self._databaseName = _cast(None, databaseName)
        update_node(self,self.troot,'inversion')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_InversionSpectra1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_InversionSpectra1.subclass:
            return create_InversionSpectra1.subclass(*args_, **kwargs_)
        else:
            return create_InversionSpectra1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_spectra1(self): return self._spectra1
    def set_spectra1(self, value):
        self._spectra1 = value
        update_node(self,self.troot,'inversion')
    spectra1 = property(get_spectra1, set_spectra1)
    def get_databaseName(self): return self._databaseName
    def set_databaseName(self, value):
        self._databaseName = value
        update_node(self,self.troot,'inversion')
    databaseName = property(get_databaseName, set_databaseName)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_InversionSpectra1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_InversionSpectra1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_InversionSpectra1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_InversionSpectra1', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_InversionSpectra1'):
        if self.spectra1 is not None and 'spectra1' not in already_processed:
            already_processed.add('spectra1')
            outfile.write(' spectra1=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.spectra1), input_name='spectra1')), ))
        if self.databaseName is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            outfile.write(' databaseName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.databaseName), input_name='databaseName')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_InversionSpectra1', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_InversionSpectra1', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.spectra1 is not None:
            element.set('spectra1', self.gds_format_string(self.spectra1))
        if self.databaseName is not None:
            element.set('databaseName', self.gds_format_string(self.databaseName))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_InversionSpectra1'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.spectra1 is not None and 'spectra1' not in already_processed:
            already_processed.add('spectra1')
            showIndent(outfile, level)
            outfile.write('spectra1="%s",\n' % (self.spectra1,))
        if self.databaseName is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            showIndent(outfile, level)
            outfile.write('databaseName="%s",\n' % (self.databaseName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('spectra1', node)
        if value is not None and 'spectra1' not in already_processed:
            already_processed.add('spectra1')
            self.spectra1 = value
        value = find_attr_value_('databaseName', node)
        if value is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            self.databaseName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_InversionSpectra1


class create_InversionSpectra2(GeneratedsSuper):
    """Ground 1 spectra Ground 1 spectra Reflectance database Reflectance
    database Spectra 1 Spectra 1 Spectra 2 Spectra 2"""
    member_data_items_ = [
        MemberSpec_('databaseName', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('spectra1', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('spectra2', 'xsd:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, databaseName='Lambertian.db', spectra1='', spectra2=''):
        self.original_tagname_ = None
        self.troot=get_gs_troot('inversion','_InversionSpectra2')
        self.attrib = ['databaseName', 'spectra1', 'spectra2']
        self.children = []
        self.parent = None
        self._databaseName = _cast(None, databaseName)
        self._spectra1 = _cast(None, spectra1)
        self._spectra2 = _cast(None, spectra2)
        update_node(self,self.troot,'inversion')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_InversionSpectra2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_InversionSpectra2.subclass:
            return create_InversionSpectra2.subclass(*args_, **kwargs_)
        else:
            return create_InversionSpectra2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_databaseName(self): return self._databaseName
    def set_databaseName(self, value):
        self._databaseName = value
        update_node(self,self.troot,'inversion')
    databaseName = property(get_databaseName, set_databaseName)
    def get_spectra1(self): return self._spectra1
    def set_spectra1(self, value):
        self._spectra1 = value
        update_node(self,self.troot,'inversion')
    spectra1 = property(get_spectra1, set_spectra1)
    def get_spectra2(self): return self._spectra2
    def set_spectra2(self, value):
        self._spectra2 = value
        update_node(self,self.troot,'inversion')
    spectra2 = property(get_spectra2, set_spectra2)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_InversionSpectra2', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_InversionSpectra2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_InversionSpectra2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_InversionSpectra2', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_InversionSpectra2'):
        if self.databaseName is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            outfile.write(' databaseName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.databaseName), input_name='databaseName')), ))
        if self.spectra1 is not None and 'spectra1' not in already_processed:
            already_processed.add('spectra1')
            outfile.write(' spectra1=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.spectra1), input_name='spectra1')), ))
        if self.spectra2 is not None and 'spectra2' not in already_processed:
            already_processed.add('spectra2')
            outfile.write(' spectra2=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.spectra2), input_name='spectra2')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_InversionSpectra2', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_InversionSpectra2', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.databaseName is not None:
            element.set('databaseName', self.gds_format_string(self.databaseName))
        if self.spectra1 is not None:
            element.set('spectra1', self.gds_format_string(self.spectra1))
        if self.spectra2 is not None:
            element.set('spectra2', self.gds_format_string(self.spectra2))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_InversionSpectra2'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.databaseName is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            showIndent(outfile, level)
            outfile.write('databaseName="%s",\n' % (self.databaseName,))
        if self.spectra1 is not None and 'spectra1' not in already_processed:
            already_processed.add('spectra1')
            showIndent(outfile, level)
            outfile.write('spectra1="%s",\n' % (self.spectra1,))
        if self.spectra2 is not None and 'spectra2' not in already_processed:
            already_processed.add('spectra2')
            showIndent(outfile, level)
            outfile.write('spectra2="%s",\n' % (self.spectra2,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('databaseName', node)
        if value is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            self.databaseName = value
        value = find_attr_value_('spectra1', node)
        if value is not None and 'spectra1' not in already_processed:
            already_processed.add('spectra1')
            self.spectra1 = value
        value = find_attr_value_('spectra2', node)
        if value is not None and 'spectra2' not in already_processed:
            already_processed.add('spectra2')
            self.spectra2 = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_InversionSpectra2


class create_InversionSpectra3(GeneratedsSuper):
    """Ground 1 spectra Ground 1 spectra Reflectance database Reflectance
    database Spectra 1 Spectra 1 Spectra 2 Spectra 2 Spectra 3
    Spectra 3"""
    member_data_items_ = [
        MemberSpec_('databaseName', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('spectra1', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('spectra2', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('spectra3', 'xsd:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, databaseName='Lambertian.db', spectra1='', spectra2='', spectra3=''):
        self.original_tagname_ = None
        self.troot=get_gs_troot('inversion','_InversionSpectra3')
        self.attrib = ['databaseName', 'spectra1', 'spectra2', 'spectra3']
        self.children = []
        self.parent = None
        self._databaseName = _cast(None, databaseName)
        self._spectra1 = _cast(None, spectra1)
        self._spectra2 = _cast(None, spectra2)
        self._spectra3 = _cast(None, spectra3)
        update_node(self,self.troot,'inversion')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_InversionSpectra3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_InversionSpectra3.subclass:
            return create_InversionSpectra3.subclass(*args_, **kwargs_)
        else:
            return create_InversionSpectra3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_databaseName(self): return self._databaseName
    def set_databaseName(self, value):
        self._databaseName = value
        update_node(self,self.troot,'inversion')
    databaseName = property(get_databaseName, set_databaseName)
    def get_spectra1(self): return self._spectra1
    def set_spectra1(self, value):
        self._spectra1 = value
        update_node(self,self.troot,'inversion')
    spectra1 = property(get_spectra1, set_spectra1)
    def get_spectra2(self): return self._spectra2
    def set_spectra2(self, value):
        self._spectra2 = value
        update_node(self,self.troot,'inversion')
    spectra2 = property(get_spectra2, set_spectra2)
    def get_spectra3(self): return self._spectra3
    def set_spectra3(self, value):
        self._spectra3 = value
        update_node(self,self.troot,'inversion')
    spectra3 = property(get_spectra3, set_spectra3)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_InversionSpectra3', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_InversionSpectra3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_InversionSpectra3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_InversionSpectra3', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_InversionSpectra3'):
        if self.databaseName is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            outfile.write(' databaseName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.databaseName), input_name='databaseName')), ))
        if self.spectra1 is not None and 'spectra1' not in already_processed:
            already_processed.add('spectra1')
            outfile.write(' spectra1=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.spectra1), input_name='spectra1')), ))
        if self.spectra2 is not None and 'spectra2' not in already_processed:
            already_processed.add('spectra2')
            outfile.write(' spectra2=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.spectra2), input_name='spectra2')), ))
        if self.spectra3 is not None and 'spectra3' not in already_processed:
            already_processed.add('spectra3')
            outfile.write(' spectra3=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.spectra3), input_name='spectra3')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_InversionSpectra3', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_InversionSpectra3', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.databaseName is not None:
            element.set('databaseName', self.gds_format_string(self.databaseName))
        if self.spectra1 is not None:
            element.set('spectra1', self.gds_format_string(self.spectra1))
        if self.spectra2 is not None:
            element.set('spectra2', self.gds_format_string(self.spectra2))
        if self.spectra3 is not None:
            element.set('spectra3', self.gds_format_string(self.spectra3))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_InversionSpectra3'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.databaseName is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            showIndent(outfile, level)
            outfile.write('databaseName="%s",\n' % (self.databaseName,))
        if self.spectra1 is not None and 'spectra1' not in already_processed:
            already_processed.add('spectra1')
            showIndent(outfile, level)
            outfile.write('spectra1="%s",\n' % (self.spectra1,))
        if self.spectra2 is not None and 'spectra2' not in already_processed:
            already_processed.add('spectra2')
            showIndent(outfile, level)
            outfile.write('spectra2="%s",\n' % (self.spectra2,))
        if self.spectra3 is not None and 'spectra3' not in already_processed:
            already_processed.add('spectra3')
            showIndent(outfile, level)
            outfile.write('spectra3="%s",\n' % (self.spectra3,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('databaseName', node)
        if value is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            self.databaseName = value
        value = find_attr_value_('spectra1', node)
        if value is not None and 'spectra1' not in already_processed:
            already_processed.add('spectra1')
            self.spectra1 = value
        value = find_attr_value_('spectra2', node)
        if value is not None and 'spectra2' not in already_processed:
            already_processed.add('spectra2')
            self.spectra2 = value
        value = find_attr_value_('spectra3', node)
        if value is not None and 'spectra3' not in already_processed:
            already_processed.add('spectra3')
            self.spectra3 = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_InversionSpectra3


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <createParser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from inversion import *\n\n')
        sys.stdout.write('import inversion as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "createDartFile",
    "create_DartInversion",
    "create_ImageProperties",
    "create_Inversion",
    "create_InversionDatabase",
    "create_InversionImages",
    "create_InversionInterpolation",
    "create_InversionParameters",
    "create_InversionSimplexConvergence",
    "create_InversionSpectra",
    "create_InversionSpectra1",
    "create_InversionSpectra2",
    "create_InversionSpectra3",
    "create_MaskProperties",
    "create_SunViewAngleProperties",
    "create_ThresholdRelativeError",
    "create_freeParameterGlobalValue",
    "create_freeParameterValue",
    "create_freeParameters"
]
