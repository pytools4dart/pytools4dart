#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Oct 31 15:06:24 2018 by generateDS.py version 2.29.25.
# Python 2.7.15rc1 (default, Apr 15 2018, 21:51:34)  [GCC 7.3.0]
#
# Command line options:
#   ('-m', '')
#   ('--always-export-default', '')
#   ('--export', 'write literal etree')
#   ('-p', 'create')
#   ('--post-attrib-setter', 'update_node(self,self.troot,"coeff_diff")')
#   ('--pre-ctor', 'self.troot=get_gs_troot("coeff_diff","{classname}")')
#   ('--post-ctor', 'update_node(self,self.troot,"coeff_diff")')
#   ('--imports', 'from pytools4dart.core_ui.utils import get_gs_troot, update_node')
#   ('-o', '/home/claudia/tmp/coeff_diff.py')
#
# Command line arguments:
#   /home/claudia/DEV/pytools4dartMTD/pytools4dart/core_ui/coeff_diff.xsd
#
# Command line:
#   /home/claudia/DEV/pytools4dartMTD/venv/bin/generateDS.py -m --always-export-default --export="write literal etree" -p "create" --post-attrib-setter="update_node(self,self.troot,"coeff_diff")" --pre-ctor="self.troot=get_gs_troot("coeff_diff","{classname}")" --post-ctor="update_node(self,self.troot,"coeff_diff")" --imports="from pytools4dart.core_ui.utils import get_gs_troot, update_node" -o "/home/claudia/tmp/coeff_diff.py" /home/claudia/DEV/pytools4dartMTD/pytools4dart/core_ui/coeff_diff.xsd
#
# Current working directory (os.getcwd()):
#   generateds
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_
from pytools4dart.core_ui.utils import get_gs_troot, update_node


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#

def checkclass(value, cl):
    if isinstance(value, list):
        for v in value:
            if not isinstance(v, cl):
                raise ValueError("invalid class")
    else:
        if not isinstance(value, cl):
            raise ValueError("invalid class")

def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class createDartFile(GeneratedsSuper):
    """Version of the plots.xml file. Depends of the version on DART
    itself. Version of the plots.xml file. Depends of the version on
    DART itself."""
    subclass = None
    superclass = None
    def __init__(self, version='5.7.1', build_='0', Coeff_diff=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","DartFile")
        self.attrib = ['version', 'build_']
        self.children = ['Coeff_diff']
        self.parent = None
        self._version = _cast(None, version)
        self._build_ = _cast(None, build_)
        self._Coeff_diff = Coeff_diff
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, createDartFile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if createDartFile.subclass:
            return createDartFile.subclass(*args_, **kwargs_)
        else:
            return createDartFile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Coeff_diff(self): return self._Coeff_diff
    def set_Coeff_diff(self, value):
        if value is not None:
            checkclass(value, create_Coeff_diff)
            value.parent = self
        self._Coeff_diff = value
    Coeff_diff = property(get_Coeff_diff, set_Coeff_diff)
    def get_version(self): return self._version
    def set_version(self, value):
        self._version = value
        update_node(self,self.troot,"coeff_diff")
    version = property(get_version, set_version)
    def get_build(self): return self._build_
    def set_build(self, value):
        self._build_ = value
        update_node(self,self.troot,"coeff_diff")
    build_ = property(get_build, set_build)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Coeff_diff is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='DartFile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DartFile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DartFile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='DartFile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DartFile'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
        if self.build_ is not None and 'build_' not in already_processed:
            already_processed.add('build_')
            outfile.write(' build=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.build_), input_name='build')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='DartFile', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Coeff_diff is not None:
            self.Coeff_diff.export(outfile, level, namespaceprefix_, name_='Coeff_diff', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='DartFile', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.version is not None:
            element.set('version', self.gds_format_string(self.version))
        if self.build_ is not None:
            element.set('build', self.gds_format_string(self.build_))
        if self.Coeff_diff is not None:
            Coeff_diff_ = self.Coeff_diff
            Coeff_diff_.to_etree(element, name_='Coeff_diff', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='DartFile'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.build_ is not None and 'build_' not in already_processed:
            already_processed.add('build_')
            showIndent(outfile, level)
            outfile.write('build_="%s",\n' % (self.build_,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Coeff_diff is not None:
            showIndent(outfile, level)
            outfile.write('Coeff_diff=model_._Coeff_diff(\n')
            self.Coeff_diff.exportLiteral(outfile, level, name_='Coeff_diff')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('build', node)
        if value is not None and 'build' not in already_processed:
            already_processed.add('build')
            self.build_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Coeff_diff':
            obj_ = create_Coeff_diff.factory()
            obj_.build(child_)
            self.set_Coeff_diff(obj_)
            obj_.original_tagname_ = 'Coeff_diff'
# end class createDartFile


class create_Coeff_diff(GeneratedsSuper):
    """Define yields (PSI, PSII) per triangle - in the order generated by
    maket. Define yields (PSI, PSII) per triangle - in the order
    generated by maket. Elements which have been defined as
    fluorescent will fluoresce. Separated images and BRFs will be
    generated for Photo-System I and II. Elements which have been
    defined as fluorescent will fluoresce. Separated images and BRFs
    will be generated for Photo-System I and II."""
    subclass = None
    superclass = None
    def __init__(self, fluorescenceFile=0, fluorescenceProducts=0, FluorescenceProductsProperties=None, LambertianMultiFunctions=None, HapkeSpecularMultiFunctions=None, RPVMultiFunctions=None, UnderstoryMultiFunctions=None, AirMultiFunctions=None, Temperatures=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_Coeff_diff")
        self.attrib = ['fluorescenceFile', 'fluorescenceProducts']
        self.children = ['FluorescenceProductsProperties', 'LambertianMultiFunctions', 'HapkeSpecularMultiFunctions', 'RPVMultiFunctions', 'UnderstoryMultiFunctions', 'AirMultiFunctions', 'Temperatures']
        self.parent = None
        self._fluorescenceFile = _cast(int, fluorescenceFile)
        self._fluorescenceProducts = _cast(int, fluorescenceProducts)
        self._FluorescenceProductsProperties = FluorescenceProductsProperties
        self._LambertianMultiFunctions = LambertianMultiFunctions
        self._HapkeSpecularMultiFunctions = HapkeSpecularMultiFunctions
        self._RPVMultiFunctions = RPVMultiFunctions
        self._UnderstoryMultiFunctions = UnderstoryMultiFunctions
        self._AirMultiFunctions = AirMultiFunctions
        self._Temperatures = Temperatures
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Coeff_diff)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Coeff_diff.subclass:
            return create_Coeff_diff.subclass(*args_, **kwargs_)
        else:
            return create_Coeff_diff(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FluorescenceProductsProperties(self): return self._FluorescenceProductsProperties
    def set_FluorescenceProductsProperties(self, value):
        if value is not None:
            checkclass(value, create_FluorescenceProductsProperties)
            value.parent = self
        self._FluorescenceProductsProperties = value
    FluorescenceProductsProperties = property(get_FluorescenceProductsProperties, set_FluorescenceProductsProperties)
    def get_LambertianMultiFunctions(self): return self._LambertianMultiFunctions
    def set_LambertianMultiFunctions(self, value):
        if value is not None:
            checkclass(value, create_LambertianMultiFunctions)
            value.parent = self
        self._LambertianMultiFunctions = value
    LambertianMultiFunctions = property(get_LambertianMultiFunctions, set_LambertianMultiFunctions)
    def get_HapkeSpecularMultiFunctions(self): return self._HapkeSpecularMultiFunctions
    def set_HapkeSpecularMultiFunctions(self, value):
        if value is not None:
            checkclass(value, create_HapkeSpecularMultiFunctions)
            value.parent = self
        self._HapkeSpecularMultiFunctions = value
    HapkeSpecularMultiFunctions = property(get_HapkeSpecularMultiFunctions, set_HapkeSpecularMultiFunctions)
    def get_RPVMultiFunctions(self): return self._RPVMultiFunctions
    def set_RPVMultiFunctions(self, value):
        if value is not None:
            checkclass(value, create_RPVMultiFunctions)
            value.parent = self
        self._RPVMultiFunctions = value
    RPVMultiFunctions = property(get_RPVMultiFunctions, set_RPVMultiFunctions)
    def get_UnderstoryMultiFunctions(self): return self._UnderstoryMultiFunctions
    def set_UnderstoryMultiFunctions(self, value):
        if value is not None:
            checkclass(value, create_UnderstoryMultiFunctions)
            value.parent = self
        self._UnderstoryMultiFunctions = value
    UnderstoryMultiFunctions = property(get_UnderstoryMultiFunctions, set_UnderstoryMultiFunctions)
    def get_AirMultiFunctions(self): return self._AirMultiFunctions
    def set_AirMultiFunctions(self, value):
        if value is not None:
            checkclass(value, create_AirMultiFunctions)
            value.parent = self
        self._AirMultiFunctions = value
    AirMultiFunctions = property(get_AirMultiFunctions, set_AirMultiFunctions)
    def get_Temperatures(self): return self._Temperatures
    def set_Temperatures(self, value):
        if value is not None:
            checkclass(value, create_Temperatures)
            value.parent = self
        self._Temperatures = value
    Temperatures = property(get_Temperatures, set_Temperatures)
    def get_fluorescenceFile(self): return self._fluorescenceFile
    def set_fluorescenceFile(self, value):
        self._fluorescenceFile = value
        update_node(self,self.troot,"coeff_diff")
    fluorescenceFile = property(get_fluorescenceFile, set_fluorescenceFile)
    def get_fluorescenceProducts(self): return self._fluorescenceProducts
    def set_fluorescenceProducts(self, value):
        self._fluorescenceProducts = value
        update_node(self,self.troot,"coeff_diff")
    fluorescenceProducts = property(get_fluorescenceProducts, set_fluorescenceProducts)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.FluorescenceProductsProperties is not None or
            self.LambertianMultiFunctions is not None or
            self.HapkeSpecularMultiFunctions is not None or
            self.RPVMultiFunctions is not None or
            self.UnderstoryMultiFunctions is not None or
            self.AirMultiFunctions is not None or
            self.Temperatures is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Coeff_diff', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Coeff_diff')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Coeff_diff')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Coeff_diff', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Coeff_diff'):
        if self.fluorescenceFile is not None and 'fluorescenceFile' not in already_processed:
            already_processed.add('fluorescenceFile')
            outfile.write(' fluorescenceFile="%s"' % self.gds_format_integer(self.fluorescenceFile, input_name='fluorescenceFile'))
        if self.fluorescenceProducts is not None and 'fluorescenceProducts' not in already_processed:
            already_processed.add('fluorescenceProducts')
            outfile.write(' fluorescenceProducts="%s"' % self.gds_format_integer(self.fluorescenceProducts, input_name='fluorescenceProducts'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Coeff_diff', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FluorescenceProductsProperties is not None:
            self.FluorescenceProductsProperties.export(outfile, level, namespaceprefix_, name_='FluorescenceProductsProperties', pretty_print=pretty_print)
        if self.LambertianMultiFunctions is not None:
            self.LambertianMultiFunctions.export(outfile, level, namespaceprefix_, name_='LambertianMultiFunctions', pretty_print=pretty_print)
        if self.HapkeSpecularMultiFunctions is not None:
            self.HapkeSpecularMultiFunctions.export(outfile, level, namespaceprefix_, name_='HapkeSpecularMultiFunctions', pretty_print=pretty_print)
        if self.RPVMultiFunctions is not None:
            self.RPVMultiFunctions.export(outfile, level, namespaceprefix_, name_='RPVMultiFunctions', pretty_print=pretty_print)
        if self.UnderstoryMultiFunctions is not None:
            self.UnderstoryMultiFunctions.export(outfile, level, namespaceprefix_, name_='UnderstoryMultiFunctions', pretty_print=pretty_print)
        if self.AirMultiFunctions is not None:
            self.AirMultiFunctions.export(outfile, level, namespaceprefix_, name_='AirMultiFunctions', pretty_print=pretty_print)
        if self.Temperatures is not None:
            self.Temperatures.export(outfile, level, namespaceprefix_, name_='Temperatures', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Coeff_diff', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.fluorescenceFile is not None:
            element.set('fluorescenceFile', self.gds_format_integer(self.fluorescenceFile))
        if self.fluorescenceProducts is not None:
            element.set('fluorescenceProducts', self.gds_format_integer(self.fluorescenceProducts))
        if self.FluorescenceProductsProperties is not None:
            FluorescenceProductsProperties_ = self.FluorescenceProductsProperties
            FluorescenceProductsProperties_.to_etree(element, name_='FluorescenceProductsProperties', mapping_=mapping_)
        if self.LambertianMultiFunctions is not None:
            LambertianMultiFunctions_ = self.LambertianMultiFunctions
            LambertianMultiFunctions_.to_etree(element, name_='LambertianMultiFunctions', mapping_=mapping_)
        if self.HapkeSpecularMultiFunctions is not None:
            HapkeSpecularMultiFunctions_ = self.HapkeSpecularMultiFunctions
            HapkeSpecularMultiFunctions_.to_etree(element, name_='HapkeSpecularMultiFunctions', mapping_=mapping_)
        if self.RPVMultiFunctions is not None:
            RPVMultiFunctions_ = self.RPVMultiFunctions
            RPVMultiFunctions_.to_etree(element, name_='RPVMultiFunctions', mapping_=mapping_)
        if self.UnderstoryMultiFunctions is not None:
            UnderstoryMultiFunctions_ = self.UnderstoryMultiFunctions
            UnderstoryMultiFunctions_.to_etree(element, name_='UnderstoryMultiFunctions', mapping_=mapping_)
        if self.AirMultiFunctions is not None:
            AirMultiFunctions_ = self.AirMultiFunctions
            AirMultiFunctions_.to_etree(element, name_='AirMultiFunctions', mapping_=mapping_)
        if self.Temperatures is not None:
            Temperatures_ = self.Temperatures
            Temperatures_.to_etree(element, name_='Temperatures', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Coeff_diff'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.fluorescenceFile is not None and 'fluorescenceFile' not in already_processed:
            already_processed.add('fluorescenceFile')
            showIndent(outfile, level)
            outfile.write('fluorescenceFile=%d,\n' % (self.fluorescenceFile,))
        if self.fluorescenceProducts is not None and 'fluorescenceProducts' not in already_processed:
            already_processed.add('fluorescenceProducts')
            showIndent(outfile, level)
            outfile.write('fluorescenceProducts=%d,\n' % (self.fluorescenceProducts,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FluorescenceProductsProperties is not None:
            showIndent(outfile, level)
            outfile.write('FluorescenceProductsProperties=model_._FluorescenceProductsProperties(\n')
            self.FluorescenceProductsProperties.exportLiteral(outfile, level, name_='FluorescenceProductsProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LambertianMultiFunctions is not None:
            showIndent(outfile, level)
            outfile.write('LambertianMultiFunctions=model_._LambertianMultiFunctions(\n')
            self.LambertianMultiFunctions.exportLiteral(outfile, level, name_='LambertianMultiFunctions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HapkeSpecularMultiFunctions is not None:
            showIndent(outfile, level)
            outfile.write('HapkeSpecularMultiFunctions=model_._HapkeSpecularMultiFunctions(\n')
            self.HapkeSpecularMultiFunctions.exportLiteral(outfile, level, name_='HapkeSpecularMultiFunctions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RPVMultiFunctions is not None:
            showIndent(outfile, level)
            outfile.write('RPVMultiFunctions=model_._RPVMultiFunctions(\n')
            self.RPVMultiFunctions.exportLiteral(outfile, level, name_='RPVMultiFunctions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.UnderstoryMultiFunctions is not None:
            showIndent(outfile, level)
            outfile.write('UnderstoryMultiFunctions=model_._UnderstoryMultiFunctions(\n')
            self.UnderstoryMultiFunctions.exportLiteral(outfile, level, name_='UnderstoryMultiFunctions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AirMultiFunctions is not None:
            showIndent(outfile, level)
            outfile.write('AirMultiFunctions=model_._AirMultiFunctions(\n')
            self.AirMultiFunctions.exportLiteral(outfile, level, name_='AirMultiFunctions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Temperatures is not None:
            showIndent(outfile, level)
            outfile.write('Temperatures=model_._Temperatures(\n')
            self.Temperatures.exportLiteral(outfile, level, name_='Temperatures')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fluorescenceFile', node)
        if value is not None and 'fluorescenceFile' not in already_processed:
            already_processed.add('fluorescenceFile')
            try:
                self.fluorescenceFile = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('fluorescenceProducts', node)
        if value is not None and 'fluorescenceProducts' not in already_processed:
            already_processed.add('fluorescenceProducts')
            try:
                self.fluorescenceProducts = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FluorescenceProductsProperties':
            obj_ = create_FluorescenceProductsProperties.factory()
            obj_.build(child_)
            self.set_FluorescenceProductsProperties(obj_)
            obj_.original_tagname_ = 'FluorescenceProductsProperties'
        elif nodeName_ == 'LambertianMultiFunctions':
            obj_ = create_LambertianMultiFunctions.factory()
            obj_.build(child_)
            self.set_LambertianMultiFunctions(obj_)
            obj_.original_tagname_ = 'LambertianMultiFunctions'
        elif nodeName_ == 'HapkeSpecularMultiFunctions':
            obj_ = create_HapkeSpecularMultiFunctions.factory()
            obj_.build(child_)
            self.set_HapkeSpecularMultiFunctions(obj_)
            obj_.original_tagname_ = 'HapkeSpecularMultiFunctions'
        elif nodeName_ == 'RPVMultiFunctions':
            obj_ = create_RPVMultiFunctions.factory()
            obj_.build(child_)
            self.set_RPVMultiFunctions(obj_)
            obj_.original_tagname_ = 'RPVMultiFunctions'
        elif nodeName_ == 'UnderstoryMultiFunctions':
            obj_ = create_UnderstoryMultiFunctions.factory()
            obj_.build(child_)
            self.set_UnderstoryMultiFunctions(obj_)
            obj_.original_tagname_ = 'UnderstoryMultiFunctions'
        elif nodeName_ == 'AirMultiFunctions':
            obj_ = create_AirMultiFunctions.factory()
            obj_.build(child_)
            self.set_AirMultiFunctions(obj_)
            obj_.original_tagname_ = 'AirMultiFunctions'
        elif nodeName_ == 'Temperatures':
            obj_ = create_Temperatures.factory()
            obj_.build(child_)
            self.set_Temperatures(obj_)
            obj_.original_tagname_ = 'Temperatures'
# end class create_Coeff_diff


class create_FluorescenceProductsProperties(GeneratedsSuper):
    """Name of the text file that allows one to compute fluorescence
    mechanims, using radiation already absorbed by the scene. Name
    of the text file that allows one to compute fluorescence
    mechanims, using radiation already absorbed by the scene."""
    subclass = None
    superclass = None
    def __init__(self, fluorescenceFileName='yieldsPerTriangle.txt'):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_FluorescenceProductsProperties")
        self.attrib = ['fluorescenceFileName']
        self.children = []
        self.parent = None
        self._fluorescenceFileName = _cast(None, fluorescenceFileName)
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_FluorescenceProductsProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_FluorescenceProductsProperties.subclass:
            return create_FluorescenceProductsProperties.subclass(*args_, **kwargs_)
        else:
            return create_FluorescenceProductsProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fluorescenceFileName(self): return self._fluorescenceFileName
    def set_fluorescenceFileName(self, value):
        self._fluorescenceFileName = value
        update_node(self,self.troot,"coeff_diff")
    fluorescenceFileName = property(get_fluorescenceFileName, set_fluorescenceFileName)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_FluorescenceProductsProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_FluorescenceProductsProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_FluorescenceProductsProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_FluorescenceProductsProperties', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_FluorescenceProductsProperties'):
        if self.fluorescenceFileName is not None and 'fluorescenceFileName' not in already_processed:
            already_processed.add('fluorescenceFileName')
            outfile.write(' fluorescenceFileName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fluorescenceFileName), input_name='fluorescenceFileName')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_FluorescenceProductsProperties', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_FluorescenceProductsProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.fluorescenceFileName is not None:
            element.set('fluorescenceFileName', self.gds_format_string(self.fluorescenceFileName))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_FluorescenceProductsProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.fluorescenceFileName is not None and 'fluorescenceFileName' not in already_processed:
            already_processed.add('fluorescenceFileName')
            showIndent(outfile, level)
            outfile.write('fluorescenceFileName="%s",\n' % (self.fluorescenceFileName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fluorescenceFileName', node)
        if value is not None and 'fluorescenceFileName' not in already_processed:
            already_processed.add('fluorescenceFileName')
            self.fluorescenceFileName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_FluorescenceProductsProperties


class create_LambertianMultiFunctions(GeneratedsSuper):
    """LambertianMultiFunctions LambertianMultiFunctions"""
    subclass = None
    superclass = None
    def __init__(self, LambertianMulti=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_LambertianMultiFunctions")
        self.attrib = ['']
        self.children = ['LambertianMulti']
        self.parent = None
        if LambertianMulti is None:
            self._LambertianMulti = []
        else:
            self._LambertianMulti = LambertianMulti
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_LambertianMultiFunctions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_LambertianMultiFunctions.subclass:
            return create_LambertianMultiFunctions.subclass(*args_, **kwargs_)
        else:
            return create_LambertianMultiFunctions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LambertianMulti(self): return self._LambertianMulti
    def set_LambertianMulti(self, value):
        if value is not None:
            checkclass(value, create_LambertianMulti)
            for v in value:
                v.parent = self
        self._LambertianMulti = value
    def add_LambertianMulti(self, value):
        value.parent = self
        self._LambertianMulti.append(value)
    def insert_LambertianMulti_at(self, index, value):
        value.parent = self
        self.LambertianMulti.insert(index, value)
    def replace_LambertianMulti_at(self, index, value):
        value.parent = self
        self.LambertianMulti[index] = value
    LambertianMulti = property(get_LambertianMulti, set_LambertianMulti)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.LambertianMulti
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_LambertianMultiFunctions', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_LambertianMultiFunctions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_LambertianMultiFunctions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_LambertianMultiFunctions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_LambertianMultiFunctions'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_LambertianMultiFunctions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LambertianMulti_ in self.LambertianMulti:
            LambertianMulti_.export(outfile, level, namespaceprefix_, name_='LambertianMulti', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_LambertianMultiFunctions', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for LambertianMulti_ in self.LambertianMulti:
            LambertianMulti_.to_etree(element, name_='LambertianMulti', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_LambertianMultiFunctions'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('LambertianMulti=[\n')
        level += 1
        for LambertianMulti_ in self.LambertianMulti:
            showIndent(outfile, level)
            outfile.write('model_._LambertianMulti(\n')
            LambertianMulti_.exportLiteral(outfile, level, name_='_LambertianMulti')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.LambertianMulti = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LambertianMulti':
            obj_ = create_LambertianMulti.factory()
            obj_.build(child_)
            self.add_LambertianMulti(obj_)
            obj_.original_tagname_ = 'LambertianMulti'
# end class create_LambertianMultiFunctions


class create_LambertianMulti(GeneratedsSuper):
    """LambertianMulti LambertianMulti Name of the spectral data base (text
    file) used to compute the spectral phase function(s) Name of the
    spectral data base (text file) used to compute the spectral
    phase function(s) Reflectance database Reflectance database
    useMultiplicativeFactorForLUT useMultiplicativeFactorForLUT
    proportion of photons intercepted along an incident direction
    that are scattered within a solid angle along a given direction
    proportion of photons intercepted along an incident direction
    that are scattered within a solid angle along a given direction
    Use specular Use specular Coefficient of determination :
    standard deviation / mean. The value provided is considered as
    corresponding to 3 sigmas. Coefficient of determination :
    standard deviation / mean. The value provided is considered as
    corresponding to 3 sigmas."""
    subclass = None
    superclass = None
    def __init__(self, ModelName='reflect_equal_1_trans_equal_0_0', databaseName='Lambertian_vegetation.db', useMultiplicativeFactorForLUT=1, ident='Lambertian_Phase_Function_1', useSpecular=0, roStDev=0.000, SpecularData=None, ProspectExternalModule=None, lambertianNodeMultiplicativeFactorForLUT=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_LambertianMulti")
        self.attrib = ['ModelName', 'databaseName', 'useMultiplicativeFactorForLUT', 'ident', 'useSpecular', 'roStDev']
        self.children = ['SpecularData', 'ProspectExternalModule', 'lambertianNodeMultiplicativeFactorForLUT']
        self.parent = None
        self._ModelName = _cast(None, ModelName)
        self._databaseName = _cast(None, databaseName)
        self._useMultiplicativeFactorForLUT = _cast(int, useMultiplicativeFactorForLUT)
        self._ident = _cast(None, ident)
        self._useSpecular = _cast(int, useSpecular)
        self._roStDev = _cast(float, roStDev)
        self._SpecularData = SpecularData
        self._ProspectExternalModule = ProspectExternalModule
        self._lambertianNodeMultiplicativeFactorForLUT = lambertianNodeMultiplicativeFactorForLUT
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_LambertianMulti)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_LambertianMulti.subclass:
            return create_LambertianMulti.subclass(*args_, **kwargs_)
        else:
            return create_LambertianMulti(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SpecularData(self): return self._SpecularData
    def set_SpecularData(self, value):
        if value is not None:
            checkclass(value, create_SpecularData)
            value.parent = self
        self._SpecularData = value
    SpecularData = property(get_SpecularData, set_SpecularData)
    def get_ProspectExternalModule(self): return self._ProspectExternalModule
    def set_ProspectExternalModule(self, value):
        if value is not None:
            checkclass(value, create_ProspectExternalModule)
            value.parent = self
        self._ProspectExternalModule = value
    ProspectExternalModule = property(get_ProspectExternalModule, set_ProspectExternalModule)
    def get_lambertianNodeMultiplicativeFactorForLUT(self): return self._lambertianNodeMultiplicativeFactorForLUT
    def set_lambertianNodeMultiplicativeFactorForLUT(self, value):
        if value is not None:
            checkclass(value, create_lambertianNodeMultiplicativeFactorForLUT)
            value.parent = self
        self._lambertianNodeMultiplicativeFactorForLUT = value
    lambertianNodeMultiplicativeFactorForLUT = property(get_lambertianNodeMultiplicativeFactorForLUT, set_lambertianNodeMultiplicativeFactorForLUT)
    def get_ModelName(self): return self._ModelName
    def set_ModelName(self, value):
        self._ModelName = value
        update_node(self,self.troot,"coeff_diff")
    ModelName = property(get_ModelName, set_ModelName)
    def get_databaseName(self): return self._databaseName
    def set_databaseName(self, value):
        self._databaseName = value
        update_node(self,self.troot,"coeff_diff")
    databaseName = property(get_databaseName, set_databaseName)
    def get_useMultiplicativeFactorForLUT(self): return self._useMultiplicativeFactorForLUT
    def set_useMultiplicativeFactorForLUT(self, value):
        self._useMultiplicativeFactorForLUT = value
        update_node(self,self.troot,"coeff_diff")
    useMultiplicativeFactorForLUT = property(get_useMultiplicativeFactorForLUT, set_useMultiplicativeFactorForLUT)
    def get_ident(self): return self._ident
    def set_ident(self, value):
        self._ident = value
        update_node(self,self.troot,"coeff_diff")
    ident = property(get_ident, set_ident)
    def get_useSpecular(self): return self._useSpecular
    def set_useSpecular(self, value):
        self._useSpecular = value
        update_node(self,self.troot,"coeff_diff")
    useSpecular = property(get_useSpecular, set_useSpecular)
    def get_roStDev(self): return self._roStDev
    def set_roStDev(self, value):
        self._roStDev = value
        update_node(self,self.troot,"coeff_diff")
    roStDev = property(get_roStDev, set_roStDev)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.SpecularData is not None or
            self.ProspectExternalModule is not None or
            self.lambertianNodeMultiplicativeFactorForLUT is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_LambertianMulti', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_LambertianMulti')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_LambertianMulti')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_LambertianMulti', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_LambertianMulti'):
        if self.ModelName is not None and 'ModelName' not in already_processed:
            already_processed.add('ModelName')
            outfile.write(' ModelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ModelName), input_name='ModelName')), ))
        if self.databaseName is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            outfile.write(' databaseName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.databaseName), input_name='databaseName')), ))
        if self.useMultiplicativeFactorForLUT is not None and 'useMultiplicativeFactorForLUT' not in already_processed:
            already_processed.add('useMultiplicativeFactorForLUT')
            outfile.write(' useMultiplicativeFactorForLUT="%s"' % self.gds_format_integer(self.useMultiplicativeFactorForLUT, input_name='useMultiplicativeFactorForLUT'))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            outfile.write(' ident=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ident), input_name='ident')), ))
        if self.useSpecular is not None and 'useSpecular' not in already_processed:
            already_processed.add('useSpecular')
            outfile.write(' useSpecular="%s"' % self.gds_format_integer(self.useSpecular, input_name='useSpecular'))
        if self.roStDev is not None and 'roStDev' not in already_processed:
            already_processed.add('roStDev')
            outfile.write(' roStDev="%s"' % self.gds_format_double(self.roStDev, input_name='roStDev'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_LambertianMulti', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SpecularData is not None:
            self.SpecularData.export(outfile, level, namespaceprefix_, name_='SpecularData', pretty_print=pretty_print)
        if self.ProspectExternalModule is not None:
            self.ProspectExternalModule.export(outfile, level, namespaceprefix_, name_='ProspectExternalModule', pretty_print=pretty_print)
        if self.lambertianNodeMultiplicativeFactorForLUT is not None:
            self.lambertianNodeMultiplicativeFactorForLUT.export(outfile, level, namespaceprefix_, name_='lambertianNodeMultiplicativeFactorForLUT', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_LambertianMulti', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ModelName is not None:
            element.set('ModelName', self.gds_format_string(self.ModelName))
        if self.databaseName is not None:
            element.set('databaseName', self.gds_format_string(self.databaseName))
        if self.useMultiplicativeFactorForLUT is not None:
            element.set('useMultiplicativeFactorForLUT', self.gds_format_integer(self.useMultiplicativeFactorForLUT))
        if self.ident is not None:
            element.set('ident', self.gds_format_string(self.ident))
        if self.useSpecular is not None:
            element.set('useSpecular', self.gds_format_integer(self.useSpecular))
        if self.roStDev is not None:
            element.set('roStDev', self.gds_format_double(self.roStDev))
        if self.SpecularData is not None:
            SpecularData_ = self.SpecularData
            SpecularData_.to_etree(element, name_='SpecularData', mapping_=mapping_)
        if self.ProspectExternalModule is not None:
            ProspectExternalModule_ = self.ProspectExternalModule
            ProspectExternalModule_.to_etree(element, name_='ProspectExternalModule', mapping_=mapping_)
        if self.lambertianNodeMultiplicativeFactorForLUT is not None:
            lambertianNodeMultiplicativeFactorForLUT_ = self.lambertianNodeMultiplicativeFactorForLUT
            lambertianNodeMultiplicativeFactorForLUT_.to_etree(element, name_='lambertianNodeMultiplicativeFactorForLUT', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_LambertianMulti'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ModelName is not None and 'ModelName' not in already_processed:
            already_processed.add('ModelName')
            showIndent(outfile, level)
            outfile.write('ModelName="%s",\n' % (self.ModelName,))
        if self.databaseName is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            showIndent(outfile, level)
            outfile.write('databaseName="%s",\n' % (self.databaseName,))
        if self.useMultiplicativeFactorForLUT is not None and 'useMultiplicativeFactorForLUT' not in already_processed:
            already_processed.add('useMultiplicativeFactorForLUT')
            showIndent(outfile, level)
            outfile.write('useMultiplicativeFactorForLUT=%d,\n' % (self.useMultiplicativeFactorForLUT,))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            showIndent(outfile, level)
            outfile.write('ident="%s",\n' % (self.ident,))
        if self.useSpecular is not None and 'useSpecular' not in already_processed:
            already_processed.add('useSpecular')
            showIndent(outfile, level)
            outfile.write('useSpecular=%d,\n' % (self.useSpecular,))
        if self.roStDev is not None and 'roStDev' not in already_processed:
            already_processed.add('roStDev')
            showIndent(outfile, level)
            outfile.write('roStDev=%e,\n' % (self.roStDev,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SpecularData is not None:
            showIndent(outfile, level)
            outfile.write('SpecularData=model_._SpecularData(\n')
            self.SpecularData.exportLiteral(outfile, level, name_='SpecularData')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ProspectExternalModule is not None:
            showIndent(outfile, level)
            outfile.write('ProspectExternalModule=model_._ProspectExternalModule(\n')
            self.ProspectExternalModule.exportLiteral(outfile, level, name_='ProspectExternalModule')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.lambertianNodeMultiplicativeFactorForLUT is not None:
            showIndent(outfile, level)
            outfile.write('lambertianNodeMultiplicativeFactorForLUT=model_._lambertianNodeMultiplicativeFactorForLUT(\n')
            self.lambertianNodeMultiplicativeFactorForLUT.exportLiteral(outfile, level, name_='lambertianNodeMultiplicativeFactorForLUT')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ModelName', node)
        if value is not None and 'ModelName' not in already_processed:
            already_processed.add('ModelName')
            self.ModelName = value
        value = find_attr_value_('databaseName', node)
        if value is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            self.databaseName = value
        value = find_attr_value_('useMultiplicativeFactorForLUT', node)
        if value is not None and 'useMultiplicativeFactorForLUT' not in already_processed:
            already_processed.add('useMultiplicativeFactorForLUT')
            try:
                self.useMultiplicativeFactorForLUT = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ident', node)
        if value is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            self.ident = value
        value = find_attr_value_('useSpecular', node)
        if value is not None and 'useSpecular' not in already_processed:
            already_processed.add('useSpecular')
            try:
                self.useSpecular = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('roStDev', node)
        if value is not None and 'roStDev' not in already_processed:
            already_processed.add('roStDev')
            try:
                self.roStDev = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (roStDev): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SpecularData':
            obj_ = create_SpecularData.factory()
            obj_.build(child_)
            self.set_SpecularData(obj_)
            obj_.original_tagname_ = 'SpecularData'
        elif nodeName_ == 'ProspectExternalModule':
            obj_ = create_ProspectExternalModule.factory()
            obj_.build(child_)
            self.set_ProspectExternalModule(obj_)
            obj_.original_tagname_ = 'ProspectExternalModule'
        elif nodeName_ == 'lambertianNodeMultiplicativeFactorForLUT':
            obj_ = create_lambertianNodeMultiplicativeFactorForLUT.factory()
            obj_.build(child_)
            self.set_lambertianNodeMultiplicativeFactorForLUT(obj_)
            obj_.original_tagname_ = 'lambertianNodeMultiplicativeFactorForLUT'
# end class create_LambertianMulti


class create_SpecularData(GeneratedsSuper):
    """Specular database Specular database Radiance distribution around the
    specular direction (cf. DART handbook ch. II.5.1). Radiance
    distribution around the specular direction (cf. DART handbook
    ch. II.5.1). This option requires:\n - to simulate the specular
    surface with the "double face" option,\n - to store fluxes per
    direction (it is an option of the DART advanced mode)\nIn the
    absence of double face, the surface is transparent for fluxes
    along directions which have an angle smaller than 90deg relative
    to the surface normal\nIf fluxes are not stored per direction,
    there is no refraction for fluxes other than sun flux. This
    option requires:\n - to simulate the specular surface with the
    "double face" option,\n - to store fluxes per direction (it is
    an option of the DART advanced mode)\nIn the absence of double
    face, the surface is transparent for fluxes along directions
    which have an angle smaller than 90deg relative to the surface
    normal\nIf fluxes are not stored per direction, there is no
    refraction for fluxes other than sun flux. Specular model
    Specular model"""
    subclass = None
    superclass = None
    def __init__(self, specularDatabaseName='Specular.db', specularRadianceDistribution=0, useRefraction=0, specularModelName='basic'):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_SpecularData")
        self.attrib = ['specularDatabaseName', 'specularRadianceDistribution', 'useRefraction', 'specularModelName']
        self.children = []
        self.parent = None
        self._specularDatabaseName = _cast(None, specularDatabaseName)
        self._specularRadianceDistribution = _cast(int, specularRadianceDistribution)
        self._useRefraction = _cast(int, useRefraction)
        self._specularModelName = _cast(None, specularModelName)
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_SpecularData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_SpecularData.subclass:
            return create_SpecularData.subclass(*args_, **kwargs_)
        else:
            return create_SpecularData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_specularDatabaseName(self): return self._specularDatabaseName
    def set_specularDatabaseName(self, value):
        self._specularDatabaseName = value
        update_node(self,self.troot,"coeff_diff")
    specularDatabaseName = property(get_specularDatabaseName, set_specularDatabaseName)
    def get_specularRadianceDistribution(self): return self._specularRadianceDistribution
    def set_specularRadianceDistribution(self, value):
        self._specularRadianceDistribution = value
        update_node(self,self.troot,"coeff_diff")
    specularRadianceDistribution = property(get_specularRadianceDistribution, set_specularRadianceDistribution)
    def get_useRefraction(self): return self._useRefraction
    def set_useRefraction(self, value):
        self._useRefraction = value
        update_node(self,self.troot,"coeff_diff")
    useRefraction = property(get_useRefraction, set_useRefraction)
    def get_specularModelName(self): return self._specularModelName
    def set_specularModelName(self, value):
        self._specularModelName = value
        update_node(self,self.troot,"coeff_diff")
    specularModelName = property(get_specularModelName, set_specularModelName)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_SpecularData', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_SpecularData')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_SpecularData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_SpecularData', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_SpecularData'):
        if self.specularDatabaseName is not None and 'specularDatabaseName' not in already_processed:
            already_processed.add('specularDatabaseName')
            outfile.write(' specularDatabaseName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.specularDatabaseName), input_name='specularDatabaseName')), ))
        if self.specularRadianceDistribution is not None and 'specularRadianceDistribution' not in already_processed:
            already_processed.add('specularRadianceDistribution')
            outfile.write(' specularRadianceDistribution="%s"' % self.gds_format_integer(self.specularRadianceDistribution, input_name='specularRadianceDistribution'))
        if self.useRefraction is not None and 'useRefraction' not in already_processed:
            already_processed.add('useRefraction')
            outfile.write(' useRefraction="%s"' % self.gds_format_integer(self.useRefraction, input_name='useRefraction'))
        if self.specularModelName is not None and 'specularModelName' not in already_processed:
            already_processed.add('specularModelName')
            outfile.write(' specularModelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.specularModelName), input_name='specularModelName')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_SpecularData', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_SpecularData', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.specularDatabaseName is not None:
            element.set('specularDatabaseName', self.gds_format_string(self.specularDatabaseName))
        if self.specularRadianceDistribution is not None:
            element.set('specularRadianceDistribution', self.gds_format_integer(self.specularRadianceDistribution))
        if self.useRefraction is not None:
            element.set('useRefraction', self.gds_format_integer(self.useRefraction))
        if self.specularModelName is not None:
            element.set('specularModelName', self.gds_format_string(self.specularModelName))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_SpecularData'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.specularDatabaseName is not None and 'specularDatabaseName' not in already_processed:
            already_processed.add('specularDatabaseName')
            showIndent(outfile, level)
            outfile.write('specularDatabaseName="%s",\n' % (self.specularDatabaseName,))
        if self.specularRadianceDistribution is not None and 'specularRadianceDistribution' not in already_processed:
            already_processed.add('specularRadianceDistribution')
            showIndent(outfile, level)
            outfile.write('specularRadianceDistribution=%d,\n' % (self.specularRadianceDistribution,))
        if self.useRefraction is not None and 'useRefraction' not in already_processed:
            already_processed.add('useRefraction')
            showIndent(outfile, level)
            outfile.write('useRefraction=%d,\n' % (self.useRefraction,))
        if self.specularModelName is not None and 'specularModelName' not in already_processed:
            already_processed.add('specularModelName')
            showIndent(outfile, level)
            outfile.write('specularModelName="%s",\n' % (self.specularModelName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('specularDatabaseName', node)
        if value is not None and 'specularDatabaseName' not in already_processed:
            already_processed.add('specularDatabaseName')
            self.specularDatabaseName = value
        value = find_attr_value_('specularRadianceDistribution', node)
        if value is not None and 'specularRadianceDistribution' not in already_processed:
            already_processed.add('specularRadianceDistribution')
            try:
                self.specularRadianceDistribution = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('useRefraction', node)
        if value is not None and 'useRefraction' not in already_processed:
            already_processed.add('useRefraction')
            try:
                self.useRefraction = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('specularModelName', node)
        if value is not None and 'specularModelName' not in already_processed:
            already_processed.add('specularModelName')
            self.specularModelName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_SpecularData


class create_ProspectExternalModule(GeneratedsSuper):
    """Using Prospect external module. With this option, vegetation optical
    properties (reflectance and transmittance) come from PROSPECT
    model (version 3.01) simulation. Using Prospect external module.
    With this option, vegetation optical properties (reflectance and
    transmittance) come from PROSPECT model (version 3.01)
    simulation. This optical properties generated fluorescence,
    based on the prospect parameters. This optical properties
    generated fluorescence, based on the prospect parameters."""
    subclass = None
    superclass = None
    def __init__(self, useProspectExternalModule=0, isFluorescent=0, ProspectExternParameters=None, FluorescenceYields=None, WindProfileEta=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_ProspectExternalModule")
        self.attrib = ['useProspectExternalModule', 'isFluorescent']
        self.children = ['ProspectExternParameters', 'FluorescenceYields', 'WindProfileEta']
        self.parent = None
        self._useProspectExternalModule = _cast(int, useProspectExternalModule)
        self._isFluorescent = _cast(int, isFluorescent)
        self._ProspectExternParameters = ProspectExternParameters
        self._FluorescenceYields = FluorescenceYields
        self._WindProfileEta = WindProfileEta
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ProspectExternalModule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ProspectExternalModule.subclass:
            return create_ProspectExternalModule.subclass(*args_, **kwargs_)
        else:
            return create_ProspectExternalModule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ProspectExternParameters(self): return self._ProspectExternParameters
    def set_ProspectExternParameters(self, value):
        if value is not None:
            checkclass(value, create_ProspectExternParameters)
            value.parent = self
        self._ProspectExternParameters = value
    ProspectExternParameters = property(get_ProspectExternParameters, set_ProspectExternParameters)
    def get_FluorescenceYields(self): return self._FluorescenceYields
    def set_FluorescenceYields(self, value):
        if value is not None:
            checkclass(value, create_FluorescenceYields)
            value.parent = self
        self._FluorescenceYields = value
    FluorescenceYields = property(get_FluorescenceYields, set_FluorescenceYields)
    def get_WindProfileEta(self): return self._WindProfileEta
    def set_WindProfileEta(self, value):
        if value is not None:
            checkclass(value, create_WindProfileEta)
            value.parent = self
        self._WindProfileEta = value
    WindProfileEta = property(get_WindProfileEta, set_WindProfileEta)
    def get_useProspectExternalModule(self): return self._useProspectExternalModule
    def set_useProspectExternalModule(self, value):
        self._useProspectExternalModule = value
        update_node(self,self.troot,"coeff_diff")
    useProspectExternalModule = property(get_useProspectExternalModule, set_useProspectExternalModule)
    def get_isFluorescent(self): return self._isFluorescent
    def set_isFluorescent(self, value):
        self._isFluorescent = value
        update_node(self,self.troot,"coeff_diff")
    isFluorescent = property(get_isFluorescent, set_isFluorescent)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.ProspectExternParameters is not None or
            self.FluorescenceYields is not None or
            self.WindProfileEta is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ProspectExternalModule', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ProspectExternalModule')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ProspectExternalModule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ProspectExternalModule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ProspectExternalModule'):
        if self.useProspectExternalModule is not None and 'useProspectExternalModule' not in already_processed:
            already_processed.add('useProspectExternalModule')
            outfile.write(' useProspectExternalModule="%s"' % self.gds_format_integer(self.useProspectExternalModule, input_name='useProspectExternalModule'))
        if self.isFluorescent is not None and 'isFluorescent' not in already_processed:
            already_processed.add('isFluorescent')
            outfile.write(' isFluorescent="%s"' % self.gds_format_integer(self.isFluorescent, input_name='isFluorescent'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ProspectExternalModule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ProspectExternParameters is not None:
            self.ProspectExternParameters.export(outfile, level, namespaceprefix_, name_='ProspectExternParameters', pretty_print=pretty_print)
        if self.FluorescenceYields is not None:
            self.FluorescenceYields.export(outfile, level, namespaceprefix_, name_='FluorescenceYields', pretty_print=pretty_print)
        if self.WindProfileEta is not None:
            self.WindProfileEta.export(outfile, level, namespaceprefix_, name_='WindProfileEta', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_ProspectExternalModule', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.useProspectExternalModule is not None:
            element.set('useProspectExternalModule', self.gds_format_integer(self.useProspectExternalModule))
        if self.isFluorescent is not None:
            element.set('isFluorescent', self.gds_format_integer(self.isFluorescent))
        if self.ProspectExternParameters is not None:
            ProspectExternParameters_ = self.ProspectExternParameters
            ProspectExternParameters_.to_etree(element, name_='ProspectExternParameters', mapping_=mapping_)
        if self.FluorescenceYields is not None:
            FluorescenceYields_ = self.FluorescenceYields
            FluorescenceYields_.to_etree(element, name_='FluorescenceYields', mapping_=mapping_)
        if self.WindProfileEta is not None:
            WindProfileEta_ = self.WindProfileEta
            WindProfileEta_.to_etree(element, name_='WindProfileEta', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ProspectExternalModule'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.useProspectExternalModule is not None and 'useProspectExternalModule' not in already_processed:
            already_processed.add('useProspectExternalModule')
            showIndent(outfile, level)
            outfile.write('useProspectExternalModule=%d,\n' % (self.useProspectExternalModule,))
        if self.isFluorescent is not None and 'isFluorescent' not in already_processed:
            already_processed.add('isFluorescent')
            showIndent(outfile, level)
            outfile.write('isFluorescent=%d,\n' % (self.isFluorescent,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ProspectExternParameters is not None:
            showIndent(outfile, level)
            outfile.write('ProspectExternParameters=model_._ProspectExternParameters(\n')
            self.ProspectExternParameters.exportLiteral(outfile, level, name_='ProspectExternParameters')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FluorescenceYields is not None:
            showIndent(outfile, level)
            outfile.write('FluorescenceYields=model_._FluorescenceYields(\n')
            self.FluorescenceYields.exportLiteral(outfile, level, name_='FluorescenceYields')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.WindProfileEta is not None:
            showIndent(outfile, level)
            outfile.write('WindProfileEta=model_._WindProfileEta(\n')
            self.WindProfileEta.exportLiteral(outfile, level, name_='WindProfileEta')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('useProspectExternalModule', node)
        if value is not None and 'useProspectExternalModule' not in already_processed:
            already_processed.add('useProspectExternalModule')
            try:
                self.useProspectExternalModule = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isFluorescent', node)
        if value is not None and 'isFluorescent' not in already_processed:
            already_processed.add('isFluorescent')
            try:
                self.isFluorescent = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ProspectExternParameters':
            obj_ = create_ProspectExternParameters.factory()
            obj_.build(child_)
            self.set_ProspectExternParameters(obj_)
            obj_.original_tagname_ = 'ProspectExternParameters'
        elif nodeName_ == 'FluorescenceYields':
            obj_ = create_FluorescenceYields.factory()
            obj_.build(child_)
            self.set_FluorescenceYields(obj_)
            obj_.original_tagname_ = 'FluorescenceYields'
        elif nodeName_ == 'WindProfileEta':
            obj_ = create_WindProfileEta.factory()
            obj_.build(child_)
            self.set_WindProfileEta(obj_)
            obj_.original_tagname_ = 'WindProfileEta'
# end class create_ProspectExternalModule


class create_ProspectExternParameters(GeneratedsSuper):
    """Brown pigment content - CBrown (arbitrary unit) Brown pigment
    content - CBrown (arbitrary unit) Leaf dry matter content - Cm
    (g.cm-2) Leaf dry matter content - Cm (g.cm-2) Leaf carotenoid
    content - Car (\u03BCg.cm-2) Leaf carotenoid content - Car
    (\u03BCg.cm-2) Anthocyanin content (\u03BCg.cm-2) Anthocyanin
    content (\u03BCg.cm-2) Leaf internal structure parameter - N
    Leaf internal structure parameter - N Input prospect database
    file Input prospect database file Leaf chlorophyll a+b content -
    Cab (\u03BCg.cm-2) Leaf chlorophyll a+b content - Cab
    (\u03BCg.cm-2) Leaf equivalent water thickness - Cw (cm) Leaf
    equivalent water thickness - Cw (cm)"""
    subclass = None
    superclass = None
    def __init__(self, CBrown=0.0, Cm=0.01, Car=10., anthocyanin=0, N=1.8, inputProspectFile='Prospect_Fluspect/Prospect_6D_2015.txt', Cab=30, Cw=0.012):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_ProspectExternParameters")
        self.attrib = ['CBrown', 'Cm', 'Car', 'anthocyanin', 'N', 'inputProspectFile', 'Cab', 'Cw']
        self.children = []
        self.parent = None
        self._CBrown = _cast(float, CBrown)
        self._Cm = _cast(float, Cm)
        self._Car = _cast(float, Car)
        self._anthocyanin = _cast(float, anthocyanin)
        self._N = _cast(float, N)
        self._inputProspectFile = _cast(None, inputProspectFile)
        self._Cab = _cast(float, Cab)
        self._Cw = _cast(float, Cw)
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ProspectExternParameters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ProspectExternParameters.subclass:
            return create_ProspectExternParameters.subclass(*args_, **kwargs_)
        else:
            return create_ProspectExternParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CBrown(self): return self._CBrown
    def set_CBrown(self, value):
        self._CBrown = value
        update_node(self,self.troot,"coeff_diff")
    CBrown = property(get_CBrown, set_CBrown)
    def get_Cm(self): return self._Cm
    def set_Cm(self, value):
        self._Cm = value
        update_node(self,self.troot,"coeff_diff")
    Cm = property(get_Cm, set_Cm)
    def get_Car(self): return self._Car
    def set_Car(self, value):
        self._Car = value
        update_node(self,self.troot,"coeff_diff")
    Car = property(get_Car, set_Car)
    def get_anthocyanin(self): return self._anthocyanin
    def set_anthocyanin(self, value):
        self._anthocyanin = value
        update_node(self,self.troot,"coeff_diff")
    anthocyanin = property(get_anthocyanin, set_anthocyanin)
    def get_N(self): return self._N
    def set_N(self, value):
        self._N = value
        update_node(self,self.troot,"coeff_diff")
    N = property(get_N, set_N)
    def get_inputProspectFile(self): return self._inputProspectFile
    def set_inputProspectFile(self, value):
        self._inputProspectFile = value
        update_node(self,self.troot,"coeff_diff")
    inputProspectFile = property(get_inputProspectFile, set_inputProspectFile)
    def get_Cab(self): return self._Cab
    def set_Cab(self, value):
        self._Cab = value
        update_node(self,self.troot,"coeff_diff")
    Cab = property(get_Cab, set_Cab)
    def get_Cw(self): return self._Cw
    def set_Cw(self, value):
        self._Cw = value
        update_node(self,self.troot,"coeff_diff")
    Cw = property(get_Cw, set_Cw)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ProspectExternParameters', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ProspectExternParameters')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ProspectExternParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ProspectExternParameters', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ProspectExternParameters'):
        if self.CBrown is not None and 'CBrown' not in already_processed:
            already_processed.add('CBrown')
            outfile.write(' CBrown="%s"' % self.gds_format_double(self.CBrown, input_name='CBrown'))
        if self.Cm is not None and 'Cm' not in already_processed:
            already_processed.add('Cm')
            outfile.write(' Cm="%s"' % self.gds_format_double(self.Cm, input_name='Cm'))
        if self.Car is not None and 'Car' not in already_processed:
            already_processed.add('Car')
            outfile.write(' Car="%s"' % self.gds_format_double(self.Car, input_name='Car'))
        if self.anthocyanin is not None and 'anthocyanin' not in already_processed:
            already_processed.add('anthocyanin')
            outfile.write(' anthocyanin="%s"' % self.gds_format_double(self.anthocyanin, input_name='anthocyanin'))
        if self.N is not None and 'N' not in already_processed:
            already_processed.add('N')
            outfile.write(' N="%s"' % self.gds_format_double(self.N, input_name='N'))
        if self.inputProspectFile is not None and 'inputProspectFile' not in already_processed:
            already_processed.add('inputProspectFile')
            outfile.write(' inputProspectFile=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.inputProspectFile), input_name='inputProspectFile')), ))
        if self.Cab is not None and 'Cab' not in already_processed:
            already_processed.add('Cab')
            outfile.write(' Cab="%s"' % self.gds_format_double(self.Cab, input_name='Cab'))
        if self.Cw is not None and 'Cw' not in already_processed:
            already_processed.add('Cw')
            outfile.write(' Cw="%s"' % self.gds_format_double(self.Cw, input_name='Cw'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ProspectExternParameters', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_ProspectExternParameters', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.CBrown is not None:
            element.set('CBrown', self.gds_format_double(self.CBrown))
        if self.Cm is not None:
            element.set('Cm', self.gds_format_double(self.Cm))
        if self.Car is not None:
            element.set('Car', self.gds_format_double(self.Car))
        if self.anthocyanin is not None:
            element.set('anthocyanin', self.gds_format_double(self.anthocyanin))
        if self.N is not None:
            element.set('N', self.gds_format_double(self.N))
        if self.inputProspectFile is not None:
            element.set('inputProspectFile', self.gds_format_string(self.inputProspectFile))
        if self.Cab is not None:
            element.set('Cab', self.gds_format_double(self.Cab))
        if self.Cw is not None:
            element.set('Cw', self.gds_format_double(self.Cw))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ProspectExternParameters'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.CBrown is not None and 'CBrown' not in already_processed:
            already_processed.add('CBrown')
            showIndent(outfile, level)
            outfile.write('CBrown=%e,\n' % (self.CBrown,))
        if self.Cm is not None and 'Cm' not in already_processed:
            already_processed.add('Cm')
            showIndent(outfile, level)
            outfile.write('Cm=%e,\n' % (self.Cm,))
        if self.Car is not None and 'Car' not in already_processed:
            already_processed.add('Car')
            showIndent(outfile, level)
            outfile.write('Car=%e,\n' % (self.Car,))
        if self.anthocyanin is not None and 'anthocyanin' not in already_processed:
            already_processed.add('anthocyanin')
            showIndent(outfile, level)
            outfile.write('anthocyanin=%e,\n' % (self.anthocyanin,))
        if self.N is not None and 'N' not in already_processed:
            already_processed.add('N')
            showIndent(outfile, level)
            outfile.write('N=%e,\n' % (self.N,))
        if self.inputProspectFile is not None and 'inputProspectFile' not in already_processed:
            already_processed.add('inputProspectFile')
            showIndent(outfile, level)
            outfile.write('inputProspectFile="%s",\n' % (self.inputProspectFile,))
        if self.Cab is not None and 'Cab' not in already_processed:
            already_processed.add('Cab')
            showIndent(outfile, level)
            outfile.write('Cab=%e,\n' % (self.Cab,))
        if self.Cw is not None and 'Cw' not in already_processed:
            already_processed.add('Cw')
            showIndent(outfile, level)
            outfile.write('Cw=%e,\n' % (self.Cw,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('CBrown', node)
        if value is not None and 'CBrown' not in already_processed:
            already_processed.add('CBrown')
            try:
                self.CBrown = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (CBrown): %s' % exp)
        value = find_attr_value_('Cm', node)
        if value is not None and 'Cm' not in already_processed:
            already_processed.add('Cm')
            try:
                self.Cm = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Cm): %s' % exp)
        value = find_attr_value_('Car', node)
        if value is not None and 'Car' not in already_processed:
            already_processed.add('Car')
            try:
                self.Car = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Car): %s' % exp)
        value = find_attr_value_('anthocyanin', node)
        if value is not None and 'anthocyanin' not in already_processed:
            already_processed.add('anthocyanin')
            try:
                self.anthocyanin = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (anthocyanin): %s' % exp)
        value = find_attr_value_('N', node)
        if value is not None and 'N' not in already_processed:
            already_processed.add('N')
            try:
                self.N = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (N): %s' % exp)
        value = find_attr_value_('inputProspectFile', node)
        if value is not None and 'inputProspectFile' not in already_processed:
            already_processed.add('inputProspectFile')
            self.inputProspectFile = value
        value = find_attr_value_('Cab', node)
        if value is not None and 'Cab' not in already_processed:
            already_processed.add('Cab')
            try:
                self.Cab = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Cab): %s' % exp)
        value = find_attr_value_('Cw', node)
        if value is not None and 'Cw' not in already_processed:
            already_processed.add('Cw')
            try:
                self.Cw = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Cw): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_ProspectExternParameters


class create_FluorescenceYields(GeneratedsSuper):
    """Override the yields par triangle file Override the yields par
    triangle file"""
    subclass = None
    superclass = None
    def __init__(self, forceYields=0, Yields=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_FluorescenceYields")
        self.attrib = ['forceYields']
        self.children = ['Yields']
        self.parent = None
        self._forceYields = _cast(int, forceYields)
        self._Yields = Yields
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_FluorescenceYields)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_FluorescenceYields.subclass:
            return create_FluorescenceYields.subclass(*args_, **kwargs_)
        else:
            return create_FluorescenceYields(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Yields(self): return self._Yields
    def set_Yields(self, value):
        if value is not None:
            checkclass(value, create_Yields)
            value.parent = self
        self._Yields = value
    Yields = property(get_Yields, set_Yields)
    def get_forceYields(self): return self._forceYields
    def set_forceYields(self, value):
        self._forceYields = value
        update_node(self,self.troot,"coeff_diff")
    forceYields = property(get_forceYields, set_forceYields)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Yields is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_FluorescenceYields', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_FluorescenceYields')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_FluorescenceYields')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_FluorescenceYields', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_FluorescenceYields'):
        if self.forceYields is not None and 'forceYields' not in already_processed:
            already_processed.add('forceYields')
            outfile.write(' forceYields="%s"' % self.gds_format_integer(self.forceYields, input_name='forceYields'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_FluorescenceYields', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Yields is not None:
            self.Yields.export(outfile, level, namespaceprefix_, name_='Yields', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_FluorescenceYields', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.forceYields is not None:
            element.set('forceYields', self.gds_format_integer(self.forceYields))
        if self.Yields is not None:
            Yields_ = self.Yields
            Yields_.to_etree(element, name_='Yields', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_FluorescenceYields'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.forceYields is not None and 'forceYields' not in already_processed:
            already_processed.add('forceYields')
            showIndent(outfile, level)
            outfile.write('forceYields=%d,\n' % (self.forceYields,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Yields is not None:
            showIndent(outfile, level)
            outfile.write('Yields=model_._Yields(\n')
            self.Yields.exportLiteral(outfile, level, name_='Yields')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('forceYields', node)
        if value is not None and 'forceYields' not in already_processed:
            already_processed.add('forceYields')
            try:
                self.forceYields = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Yields':
            obj_ = create_Yields.factory()
            obj_.build(child_)
            self.set_Yields(obj_)
            obj_.original_tagname_ = 'Yields'
# end class create_FluorescenceYields


class create_Yields(GeneratedsSuper):
    """Yield of the photo-system I Yield of the photo-system I Yield of the
    photo-system II Yield of the photo-system II"""
    subclass = None
    superclass = None
    def __init__(self, yieldPSI=0.002, yieldPSII=0.01):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_Yields")
        self.attrib = ['yieldPSI', 'yieldPSII']
        self.children = []
        self.parent = None
        self._yieldPSI = _cast(float, yieldPSI)
        self._yieldPSII = _cast(float, yieldPSII)
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Yields)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Yields.subclass:
            return create_Yields.subclass(*args_, **kwargs_)
        else:
            return create_Yields(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_yieldPSI(self): return self._yieldPSI
    def set_yieldPSI(self, value):
        self._yieldPSI = value
        update_node(self,self.troot,"coeff_diff")
    yieldPSI = property(get_yieldPSI, set_yieldPSI)
    def get_yieldPSII(self): return self._yieldPSII
    def set_yieldPSII(self, value):
        self._yieldPSII = value
        update_node(self,self.troot,"coeff_diff")
    yieldPSII = property(get_yieldPSII, set_yieldPSII)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Yields', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Yields')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Yields')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Yields', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Yields'):
        if self.yieldPSI is not None and 'yieldPSI' not in already_processed:
            already_processed.add('yieldPSI')
            outfile.write(' yieldPSI="%s"' % self.gds_format_double(self.yieldPSI, input_name='yieldPSI'))
        if self.yieldPSII is not None and 'yieldPSII' not in already_processed:
            already_processed.add('yieldPSII')
            outfile.write(' yieldPSII="%s"' % self.gds_format_double(self.yieldPSII, input_name='yieldPSII'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Yields', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_Yields', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.yieldPSI is not None:
            element.set('yieldPSI', self.gds_format_double(self.yieldPSI))
        if self.yieldPSII is not None:
            element.set('yieldPSII', self.gds_format_double(self.yieldPSII))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Yields'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.yieldPSI is not None and 'yieldPSI' not in already_processed:
            already_processed.add('yieldPSI')
            showIndent(outfile, level)
            outfile.write('yieldPSI=%e,\n' % (self.yieldPSI,))
        if self.yieldPSII is not None and 'yieldPSII' not in already_processed:
            already_processed.add('yieldPSII')
            showIndent(outfile, level)
            outfile.write('yieldPSII=%e,\n' % (self.yieldPSII,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('yieldPSI', node)
        if value is not None and 'yieldPSI' not in already_processed:
            already_processed.add('yieldPSI')
            try:
                self.yieldPSI = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (yieldPSI): %s' % exp)
        value = find_attr_value_('yieldPSII', node)
        if value is not None and 'yieldPSII' not in already_processed:
            already_processed.add('yieldPSII')
            try:
                self.yieldPSII = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (yieldPSII): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_Yields


class create_WindProfileEta(GeneratedsSuper):
    """Provides to DART a profile of coefficient for the thermal emission
    depending on the height and angles of the fluorescing surface.
    These coefficients depend on the profile of winds and
    temperature and can provided by the SCOPE model, for example.
    Provides to DART a profile of coefficient for the thermal
    emission depending on the height and angles of the fluorescing
    surface. These coefficients depend on the profile of winds and
    temperature and can provided by the SCOPE model, for example."""
    subclass = None
    superclass = None
    def __init__(self, useBioClimaticWeighting=0, BioClimaticWeighting=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_WindProfileEta")
        self.attrib = ['useBioClimaticWeighting']
        self.children = ['BioClimaticWeighting']
        self.parent = None
        self._useBioClimaticWeighting = _cast(int, useBioClimaticWeighting)
        self._BioClimaticWeighting = BioClimaticWeighting
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_WindProfileEta)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_WindProfileEta.subclass:
            return create_WindProfileEta.subclass(*args_, **kwargs_)
        else:
            return create_WindProfileEta(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BioClimaticWeighting(self): return self._BioClimaticWeighting
    def set_BioClimaticWeighting(self, value):
        if value is not None:
            checkclass(value, create_BioClimaticWeighting)
            value.parent = self
        self._BioClimaticWeighting = value
    BioClimaticWeighting = property(get_BioClimaticWeighting, set_BioClimaticWeighting)
    def get_useBioClimaticWeighting(self): return self._useBioClimaticWeighting
    def set_useBioClimaticWeighting(self, value):
        self._useBioClimaticWeighting = value
        update_node(self,self.troot,"coeff_diff")
    useBioClimaticWeighting = property(get_useBioClimaticWeighting, set_useBioClimaticWeighting)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.BioClimaticWeighting is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_WindProfileEta', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_WindProfileEta')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_WindProfileEta')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_WindProfileEta', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_WindProfileEta'):
        if self.useBioClimaticWeighting is not None and 'useBioClimaticWeighting' not in already_processed:
            already_processed.add('useBioClimaticWeighting')
            outfile.write(' useBioClimaticWeighting="%s"' % self.gds_format_integer(self.useBioClimaticWeighting, input_name='useBioClimaticWeighting'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_WindProfileEta', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BioClimaticWeighting is not None:
            self.BioClimaticWeighting.export(outfile, level, namespaceprefix_, name_='BioClimaticWeighting', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_WindProfileEta', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.useBioClimaticWeighting is not None:
            element.set('useBioClimaticWeighting', self.gds_format_integer(self.useBioClimaticWeighting))
        if self.BioClimaticWeighting is not None:
            BioClimaticWeighting_ = self.BioClimaticWeighting
            BioClimaticWeighting_.to_etree(element, name_='BioClimaticWeighting', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_WindProfileEta'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.useBioClimaticWeighting is not None and 'useBioClimaticWeighting' not in already_processed:
            already_processed.add('useBioClimaticWeighting')
            showIndent(outfile, level)
            outfile.write('useBioClimaticWeighting=%d,\n' % (self.useBioClimaticWeighting,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.BioClimaticWeighting is not None:
            showIndent(outfile, level)
            outfile.write('BioClimaticWeighting=model_._BioClimaticWeighting(\n')
            self.BioClimaticWeighting.exportLiteral(outfile, level, name_='BioClimaticWeighting')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('useBioClimaticWeighting', node)
        if value is not None and 'useBioClimaticWeighting' not in already_processed:
            already_processed.add('useBioClimaticWeighting')
            try:
                self.useBioClimaticWeighting = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BioClimaticWeighting':
            obj_ = create_BioClimaticWeighting.factory()
            obj_.build(child_)
            self.set_BioClimaticWeighting(obj_)
            obj_.original_tagname_ = 'BioClimaticWeighting'
# end class create_WindProfileEta


class create_BioClimaticWeighting(GeneratedsSuper):
    """The path to the Bio-Climatic file The path to the Bio-Climatic file
    In order to define which layer a scene element belongs to, DART
    will compute the minimum and maximum altitude of all the objects
    using this optical property.\nThe layers are then distributed
    equaly between this minimum and maximum.\nIf 2 optical
    properties are linked, then the minimum and maximum will be
    computed using their combined associated objects.\n In order to
    define which layer a scene element belongs to, DART will compute
    the minimum and maximum altitude of all the objects using this
    optical property.\nThe layers are then distributed equaly
    between this minimum and maximum.\nIf 2 optical properties are
    linked, then the minimum and maximum will be computed using
    their combined associated objects.\n"""
    subclass = None
    superclass = None
    def __init__(self, profileFilePath='profileEta.bin', linkedOpticalProperty=0, OpticalPropertyLink=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_BioClimaticWeighting")
        self.attrib = ['profileFilePath', 'linkedOpticalProperty']
        self.children = ['OpticalPropertyLink']
        self.parent = None
        self._profileFilePath = _cast(None, profileFilePath)
        self._linkedOpticalProperty = _cast(int, linkedOpticalProperty)
        self._OpticalPropertyLink = OpticalPropertyLink
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_BioClimaticWeighting)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_BioClimaticWeighting.subclass:
            return create_BioClimaticWeighting.subclass(*args_, **kwargs_)
        else:
            return create_BioClimaticWeighting(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OpticalPropertyLink(self): return self._OpticalPropertyLink
    def set_OpticalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_OpticalPropertyLink)
            value.parent = self
        self._OpticalPropertyLink = value
    OpticalPropertyLink = property(get_OpticalPropertyLink, set_OpticalPropertyLink)
    def get_profileFilePath(self): return self._profileFilePath
    def set_profileFilePath(self, value):
        self._profileFilePath = value
        update_node(self,self.troot,"coeff_diff")
    profileFilePath = property(get_profileFilePath, set_profileFilePath)
    def get_linkedOpticalProperty(self): return self._linkedOpticalProperty
    def set_linkedOpticalProperty(self, value):
        self._linkedOpticalProperty = value
        update_node(self,self.troot,"coeff_diff")
    linkedOpticalProperty = property(get_linkedOpticalProperty, set_linkedOpticalProperty)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.OpticalPropertyLink is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_BioClimaticWeighting', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_BioClimaticWeighting')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_BioClimaticWeighting')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_BioClimaticWeighting', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_BioClimaticWeighting'):
        if self.profileFilePath is not None and 'profileFilePath' not in already_processed:
            already_processed.add('profileFilePath')
            outfile.write(' profileFilePath=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.profileFilePath), input_name='profileFilePath')), ))
        if self.linkedOpticalProperty is not None and 'linkedOpticalProperty' not in already_processed:
            already_processed.add('linkedOpticalProperty')
            outfile.write(' linkedOpticalProperty="%s"' % self.gds_format_integer(self.linkedOpticalProperty, input_name='linkedOpticalProperty'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_BioClimaticWeighting', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OpticalPropertyLink is not None:
            self.OpticalPropertyLink.export(outfile, level, namespaceprefix_, name_='OpticalPropertyLink', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_BioClimaticWeighting', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.profileFilePath is not None:
            element.set('profileFilePath', self.gds_format_string(self.profileFilePath))
        if self.linkedOpticalProperty is not None:
            element.set('linkedOpticalProperty', self.gds_format_integer(self.linkedOpticalProperty))
        if self.OpticalPropertyLink is not None:
            OpticalPropertyLink_ = self.OpticalPropertyLink
            OpticalPropertyLink_.to_etree(element, name_='OpticalPropertyLink', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_BioClimaticWeighting'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.profileFilePath is not None and 'profileFilePath' not in already_processed:
            already_processed.add('profileFilePath')
            showIndent(outfile, level)
            outfile.write('profileFilePath="%s",\n' % (self.profileFilePath,))
        if self.linkedOpticalProperty is not None and 'linkedOpticalProperty' not in already_processed:
            already_processed.add('linkedOpticalProperty')
            showIndent(outfile, level)
            outfile.write('linkedOpticalProperty=%d,\n' % (self.linkedOpticalProperty,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.OpticalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('OpticalPropertyLink=model_._OpticalPropertyLink(\n')
            self.OpticalPropertyLink.exportLiteral(outfile, level, name_='OpticalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('profileFilePath', node)
        if value is not None and 'profileFilePath' not in already_processed:
            already_processed.add('profileFilePath')
            self.profileFilePath = value
        value = find_attr_value_('linkedOpticalProperty', node)
        if value is not None and 'linkedOpticalProperty' not in already_processed:
            already_processed.add('linkedOpticalProperty')
            try:
                self.linkedOpticalProperty = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OpticalPropertyLink':
            obj_ = create_OpticalPropertyLink.factory()
            obj_.build(child_)
            self.set_OpticalPropertyLink(obj_)
            obj_.original_tagname_ = 'OpticalPropertyLink'
# end class create_BioClimaticWeighting


class create_OpticalPropertyLink(GeneratedsSuper):
    """Optical property index Optical property index Linked Optical
    property name Linked Optical property name Type of optical
    property Type of optical property"""
    subclass = None
    superclass = None
    def __init__(self, indexFctPhase=0, ident='linkedOpticalProperty', type_=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_OpticalPropertyLink")
        self.attrib = ['indexFctPhase', 'ident', 'type_']
        self.children = []
        self.parent = None
        self._indexFctPhase = _cast(int, indexFctPhase)
        self._ident = _cast(None, ident)
        self._type_ = _cast(int, type_)
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_OpticalPropertyLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_OpticalPropertyLink.subclass:
            return create_OpticalPropertyLink.subclass(*args_, **kwargs_)
        else:
            return create_OpticalPropertyLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexFctPhase(self): return self._indexFctPhase
    def set_indexFctPhase(self, value):
        self._indexFctPhase = value
        update_node(self,self.troot,"coeff_diff")
    indexFctPhase = property(get_indexFctPhase, set_indexFctPhase)
    def get_ident(self): return self._ident
    def set_ident(self, value):
        self._ident = value
        update_node(self,self.troot,"coeff_diff")
    ident = property(get_ident, set_ident)
    def get_type(self): return self._type_
    def set_type(self, value):
        self._type_ = value
        update_node(self,self.troot,"coeff_diff")
    type_ = property(get_type, set_type)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_OpticalPropertyLink', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_OpticalPropertyLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_OpticalPropertyLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_OpticalPropertyLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_OpticalPropertyLink'):
        if self.indexFctPhase is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            outfile.write(' indexFctPhase="%s"' % self.gds_format_integer(self.indexFctPhase, input_name='indexFctPhase'))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            outfile.write(' ident=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ident), input_name='ident')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type="%s"' % self.gds_format_integer(self.type_, input_name='type'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_OpticalPropertyLink', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_OpticalPropertyLink', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.indexFctPhase is not None:
            element.set('indexFctPhase', self.gds_format_integer(self.indexFctPhase))
        if self.ident is not None:
            element.set('ident', self.gds_format_string(self.ident))
        if self.type_ is not None:
            element.set('type', self.gds_format_integer(self.type_))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_OpticalPropertyLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.indexFctPhase is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            showIndent(outfile, level)
            outfile.write('indexFctPhase=%d,\n' % (self.indexFctPhase,))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            showIndent(outfile, level)
            outfile.write('ident="%s",\n' % (self.ident,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_=%d,\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('indexFctPhase', node)
        if value is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            try:
                self.indexFctPhase = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ident', node)
        if value is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            self.ident = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            try:
                self.type_ = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_OpticalPropertyLink


class create_lambertianNodeMultiplicativeFactorForLUT(GeneratedsSuper):
    """nodeMultiplicativeFactorForLUT nodeMultiplicativeFactorForLUT
    Diffuse transmittance Diffuse transmittance Direct transmittance
    Direct transmittance When selected, the parameters values of
    every spectral band will be equal to these parameters. When
    selected, the parameters values of every spectral band will be
    equal to these parameters. Apply the same 3D factor matrix per
    cell on optical properties to all the spectral bands Apply the
    same 3D factor matrix per cell on optical properties to all the
    spectral bands Specular intensity Specular intensity"""
    subclass = None
    superclass = None
    def __init__(self, diffuseTransmittanceFactor=1, reflectanceFactor=1, directTransmittanceFactor=1, useSameFactorForAllBands=1, useSameOpticalFactorMatrixForAllBands=0, specularIntensityFactor=1, lambertianMultiplicativeFactorForLUT=None, opticalFactorMatrix=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_lambertianNodeMultiplicativeFactorForLUT")
        self.attrib = ['diffuseTransmittanceFactor', 'reflectanceFactor', 'directTransmittanceFactor', 'useSameFactorForAllBands', 'useSameOpticalFactorMatrixForAllBands', 'specularIntensityFactor']
        self.children = ['lambertianMultiplicativeFactorForLUT', 'opticalFactorMatrix']
        self.parent = None
        self._diffuseTransmittanceFactor = _cast(float, diffuseTransmittanceFactor)
        self._reflectanceFactor = _cast(float, reflectanceFactor)
        self._directTransmittanceFactor = _cast(float, directTransmittanceFactor)
        self._useSameFactorForAllBands = _cast(int, useSameFactorForAllBands)
        self._useSameOpticalFactorMatrixForAllBands = _cast(int, useSameOpticalFactorMatrixForAllBands)
        self._specularIntensityFactor = _cast(float, specularIntensityFactor)
        if lambertianMultiplicativeFactorForLUT is None:
            self._lambertianMultiplicativeFactorForLUT = []
        else:
            self._lambertianMultiplicativeFactorForLUT = lambertianMultiplicativeFactorForLUT
        self._opticalFactorMatrix = opticalFactorMatrix
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_lambertianNodeMultiplicativeFactorForLUT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_lambertianNodeMultiplicativeFactorForLUT.subclass:
            return create_lambertianNodeMultiplicativeFactorForLUT.subclass(*args_, **kwargs_)
        else:
            return create_lambertianNodeMultiplicativeFactorForLUT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lambertianMultiplicativeFactorForLUT(self): return self._lambertianMultiplicativeFactorForLUT
    def set_lambertianMultiplicativeFactorForLUT(self, value):
        if value is not None:
            checkclass(value, create_lambertianMultiplicativeFactorForLUT)
            for v in value:
                v.parent = self
        self._lambertianMultiplicativeFactorForLUT = value
    def add_lambertianMultiplicativeFactorForLUT(self, value):
        value.parent = self
        self._lambertianMultiplicativeFactorForLUT.append(value)
    def insert_lambertianMultiplicativeFactorForLUT_at(self, index, value):
        value.parent = self
        self.lambertianMultiplicativeFactorForLUT.insert(index, value)
    def replace_lambertianMultiplicativeFactorForLUT_at(self, index, value):
        value.parent = self
        self.lambertianMultiplicativeFactorForLUT[index] = value
    lambertianMultiplicativeFactorForLUT = property(get_lambertianMultiplicativeFactorForLUT, set_lambertianMultiplicativeFactorForLUT)
    def get_opticalFactorMatrix(self): return self._opticalFactorMatrix
    def set_opticalFactorMatrix(self, value):
        if value is not None:
            checkclass(value, create_opticalFactorMatrix)
            value.parent = self
        self._opticalFactorMatrix = value
    opticalFactorMatrix = property(get_opticalFactorMatrix, set_opticalFactorMatrix)
    def get_diffuseTransmittanceFactor(self): return self._diffuseTransmittanceFactor
    def set_diffuseTransmittanceFactor(self, value):
        self._diffuseTransmittanceFactor = value
        update_node(self,self.troot,"coeff_diff")
    diffuseTransmittanceFactor = property(get_diffuseTransmittanceFactor, set_diffuseTransmittanceFactor)
    def get_reflectanceFactor(self): return self._reflectanceFactor
    def set_reflectanceFactor(self, value):
        self._reflectanceFactor = value
        update_node(self,self.troot,"coeff_diff")
    reflectanceFactor = property(get_reflectanceFactor, set_reflectanceFactor)
    def get_directTransmittanceFactor(self): return self._directTransmittanceFactor
    def set_directTransmittanceFactor(self, value):
        self._directTransmittanceFactor = value
        update_node(self,self.troot,"coeff_diff")
    directTransmittanceFactor = property(get_directTransmittanceFactor, set_directTransmittanceFactor)
    def get_useSameFactorForAllBands(self): return self._useSameFactorForAllBands
    def set_useSameFactorForAllBands(self, value):
        self._useSameFactorForAllBands = value
        update_node(self,self.troot,"coeff_diff")
    useSameFactorForAllBands = property(get_useSameFactorForAllBands, set_useSameFactorForAllBands)
    def get_useSameOpticalFactorMatrixForAllBands(self): return self._useSameOpticalFactorMatrixForAllBands
    def set_useSameOpticalFactorMatrixForAllBands(self, value):
        self._useSameOpticalFactorMatrixForAllBands = value
        update_node(self,self.troot,"coeff_diff")
    useSameOpticalFactorMatrixForAllBands = property(get_useSameOpticalFactorMatrixForAllBands, set_useSameOpticalFactorMatrixForAllBands)
    def get_specularIntensityFactor(self): return self._specularIntensityFactor
    def set_specularIntensityFactor(self, value):
        self._specularIntensityFactor = value
        update_node(self,self.troot,"coeff_diff")
    specularIntensityFactor = property(get_specularIntensityFactor, set_specularIntensityFactor)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.lambertianMultiplicativeFactorForLUT or
            self.opticalFactorMatrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_lambertianNodeMultiplicativeFactorForLUT', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_lambertianNodeMultiplicativeFactorForLUT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_lambertianNodeMultiplicativeFactorForLUT')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_lambertianNodeMultiplicativeFactorForLUT', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_lambertianNodeMultiplicativeFactorForLUT'):
        if self.diffuseTransmittanceFactor is not None and 'diffuseTransmittanceFactor' not in already_processed:
            already_processed.add('diffuseTransmittanceFactor')
            outfile.write(' diffuseTransmittanceFactor="%s"' % self.gds_format_double(self.diffuseTransmittanceFactor, input_name='diffuseTransmittanceFactor'))
        if self.reflectanceFactor is not None and 'reflectanceFactor' not in already_processed:
            already_processed.add('reflectanceFactor')
            outfile.write(' reflectanceFactor="%s"' % self.gds_format_double(self.reflectanceFactor, input_name='reflectanceFactor'))
        if self.directTransmittanceFactor is not None and 'directTransmittanceFactor' not in already_processed:
            already_processed.add('directTransmittanceFactor')
            outfile.write(' directTransmittanceFactor="%s"' % self.gds_format_double(self.directTransmittanceFactor, input_name='directTransmittanceFactor'))
        if self.useSameFactorForAllBands is not None and 'useSameFactorForAllBands' not in already_processed:
            already_processed.add('useSameFactorForAllBands')
            outfile.write(' useSameFactorForAllBands="%s"' % self.gds_format_integer(self.useSameFactorForAllBands, input_name='useSameFactorForAllBands'))
        if self.useSameOpticalFactorMatrixForAllBands is not None and 'useSameOpticalFactorMatrixForAllBands' not in already_processed:
            already_processed.add('useSameOpticalFactorMatrixForAllBands')
            outfile.write(' useSameOpticalFactorMatrixForAllBands="%s"' % self.gds_format_integer(self.useSameOpticalFactorMatrixForAllBands, input_name='useSameOpticalFactorMatrixForAllBands'))
        if self.specularIntensityFactor is not None and 'specularIntensityFactor' not in already_processed:
            already_processed.add('specularIntensityFactor')
            outfile.write(' specularIntensityFactor="%s"' % self.gds_format_double(self.specularIntensityFactor, input_name='specularIntensityFactor'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_lambertianNodeMultiplicativeFactorForLUT', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for lambertianMultiplicativeFactorForLUT_ in self.lambertianMultiplicativeFactorForLUT:
            lambertianMultiplicativeFactorForLUT_.export(outfile, level, namespaceprefix_, name_='lambertianMultiplicativeFactorForLUT', pretty_print=pretty_print)
        if self.opticalFactorMatrix is not None:
            self.opticalFactorMatrix.export(outfile, level, namespaceprefix_, name_='opticalFactorMatrix', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_lambertianNodeMultiplicativeFactorForLUT', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.diffuseTransmittanceFactor is not None:
            element.set('diffuseTransmittanceFactor', self.gds_format_double(self.diffuseTransmittanceFactor))
        if self.reflectanceFactor is not None:
            element.set('reflectanceFactor', self.gds_format_double(self.reflectanceFactor))
        if self.directTransmittanceFactor is not None:
            element.set('directTransmittanceFactor', self.gds_format_double(self.directTransmittanceFactor))
        if self.useSameFactorForAllBands is not None:
            element.set('useSameFactorForAllBands', self.gds_format_integer(self.useSameFactorForAllBands))
        if self.useSameOpticalFactorMatrixForAllBands is not None:
            element.set('useSameOpticalFactorMatrixForAllBands', self.gds_format_integer(self.useSameOpticalFactorMatrixForAllBands))
        if self.specularIntensityFactor is not None:
            element.set('specularIntensityFactor', self.gds_format_double(self.specularIntensityFactor))
        for lambertianMultiplicativeFactorForLUT_ in self.lambertianMultiplicativeFactorForLUT:
            lambertianMultiplicativeFactorForLUT_.to_etree(element, name_='lambertianMultiplicativeFactorForLUT', mapping_=mapping_)
        if self.opticalFactorMatrix is not None:
            opticalFactorMatrix_ = self.opticalFactorMatrix
            opticalFactorMatrix_.to_etree(element, name_='opticalFactorMatrix', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_lambertianNodeMultiplicativeFactorForLUT'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.diffuseTransmittanceFactor is not None and 'diffuseTransmittanceFactor' not in already_processed:
            already_processed.add('diffuseTransmittanceFactor')
            showIndent(outfile, level)
            outfile.write('diffuseTransmittanceFactor=%e,\n' % (self.diffuseTransmittanceFactor,))
        if self.reflectanceFactor is not None and 'reflectanceFactor' not in already_processed:
            already_processed.add('reflectanceFactor')
            showIndent(outfile, level)
            outfile.write('reflectanceFactor=%e,\n' % (self.reflectanceFactor,))
        if self.directTransmittanceFactor is not None and 'directTransmittanceFactor' not in already_processed:
            already_processed.add('directTransmittanceFactor')
            showIndent(outfile, level)
            outfile.write('directTransmittanceFactor=%e,\n' % (self.directTransmittanceFactor,))
        if self.useSameFactorForAllBands is not None and 'useSameFactorForAllBands' not in already_processed:
            already_processed.add('useSameFactorForAllBands')
            showIndent(outfile, level)
            outfile.write('useSameFactorForAllBands=%d,\n' % (self.useSameFactorForAllBands,))
        if self.useSameOpticalFactorMatrixForAllBands is not None and 'useSameOpticalFactorMatrixForAllBands' not in already_processed:
            already_processed.add('useSameOpticalFactorMatrixForAllBands')
            showIndent(outfile, level)
            outfile.write('useSameOpticalFactorMatrixForAllBands=%d,\n' % (self.useSameOpticalFactorMatrixForAllBands,))
        if self.specularIntensityFactor is not None and 'specularIntensityFactor' not in already_processed:
            already_processed.add('specularIntensityFactor')
            showIndent(outfile, level)
            outfile.write('specularIntensityFactor=%e,\n' % (self.specularIntensityFactor,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('lambertianMultiplicativeFactorForLUT=[\n')
        level += 1
        for lambertianMultiplicativeFactorForLUT_ in self.lambertianMultiplicativeFactorForLUT:
            showIndent(outfile, level)
            outfile.write('model_._lambertianMultiplicativeFactorForLUT(\n')
            lambertianMultiplicativeFactorForLUT_.exportLiteral(outfile, level, name_='_lambertianMultiplicativeFactorForLUT')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.opticalFactorMatrix is not None:
            showIndent(outfile, level)
            outfile.write('opticalFactorMatrix=model_._opticalFactorMatrix(\n')
            self.opticalFactorMatrix.exportLiteral(outfile, level, name_='opticalFactorMatrix')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.lambertianMultiplicativeFactorForLUT = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('diffuseTransmittanceFactor', node)
        if value is not None and 'diffuseTransmittanceFactor' not in already_processed:
            already_processed.add('diffuseTransmittanceFactor')
            try:
                self.diffuseTransmittanceFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (diffuseTransmittanceFactor): %s' % exp)
        value = find_attr_value_('reflectanceFactor', node)
        if value is not None and 'reflectanceFactor' not in already_processed:
            already_processed.add('reflectanceFactor')
            try:
                self.reflectanceFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (reflectanceFactor): %s' % exp)
        value = find_attr_value_('directTransmittanceFactor', node)
        if value is not None and 'directTransmittanceFactor' not in already_processed:
            already_processed.add('directTransmittanceFactor')
            try:
                self.directTransmittanceFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (directTransmittanceFactor): %s' % exp)
        value = find_attr_value_('useSameFactorForAllBands', node)
        if value is not None and 'useSameFactorForAllBands' not in already_processed:
            already_processed.add('useSameFactorForAllBands')
            try:
                self.useSameFactorForAllBands = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('useSameOpticalFactorMatrixForAllBands', node)
        if value is not None and 'useSameOpticalFactorMatrixForAllBands' not in already_processed:
            already_processed.add('useSameOpticalFactorMatrixForAllBands')
            try:
                self.useSameOpticalFactorMatrixForAllBands = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('specularIntensityFactor', node)
        if value is not None and 'specularIntensityFactor' not in already_processed:
            already_processed.add('specularIntensityFactor')
            try:
                self.specularIntensityFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (specularIntensityFactor): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'lambertianMultiplicativeFactorForLUT':
            obj_ = create_lambertianMultiplicativeFactorForLUT.factory()
            obj_.build(child_)
            self.add_lambertianMultiplicativeFactorForLUT(obj_)
            obj_.original_tagname_ = 'lambertianMultiplicativeFactorForLUT'
        elif nodeName_ == 'opticalFactorMatrix':
            obj_ = create_opticalFactorMatrix.factory()
            obj_.build(child_)
            self.set_opticalFactorMatrix(obj_)
            obj_.original_tagname_ = 'opticalFactorMatrix'
# end class create_lambertianNodeMultiplicativeFactorForLUT


class create_lambertianMultiplicativeFactorForLUT(GeneratedsSuper):
    """lambertianMultiplicativeFactorForLUT
    lambertianMultiplicativeFactorForLUT Diffuse transmittance
    Diffuse transmittance Direct transmittance Direct transmittance
    reflectanceFactor reflectanceFactor Specular intensity Specular
    intensity Apply a 3D factor matrix per cell on optical
    properties Apply a 3D factor matrix per cell on optical
    properties"""
    subclass = None
    superclass = None
    def __init__(self, diffuseTransmittanceFactor=1, directTransmittanceFactor=1, reflectanceFactor=1, specularIntensityFactor=1, useOpticalFactorMatrix=0, opticalFactorMatrix=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_lambertianMultiplicativeFactorForLUT")
        self.attrib = ['diffuseTransmittanceFactor', 'directTransmittanceFactor', 'reflectanceFactor', 'specularIntensityFactor', 'useOpticalFactorMatrix']
        self.children = ['opticalFactorMatrix']
        self.parent = None
        self._diffuseTransmittanceFactor = _cast(float, diffuseTransmittanceFactor)
        self._directTransmittanceFactor = _cast(float, directTransmittanceFactor)
        self._reflectanceFactor = _cast(float, reflectanceFactor)
        self._specularIntensityFactor = _cast(float, specularIntensityFactor)
        self._useOpticalFactorMatrix = _cast(int, useOpticalFactorMatrix)
        self._opticalFactorMatrix = opticalFactorMatrix
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_lambertianMultiplicativeFactorForLUT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_lambertianMultiplicativeFactorForLUT.subclass:
            return create_lambertianMultiplicativeFactorForLUT.subclass(*args_, **kwargs_)
        else:
            return create_lambertianMultiplicativeFactorForLUT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_opticalFactorMatrix(self): return self._opticalFactorMatrix
    def set_opticalFactorMatrix(self, value):
        if value is not None:
            checkclass(value, create_opticalFactorMatrix)
            value.parent = self
        self._opticalFactorMatrix = value
    opticalFactorMatrix = property(get_opticalFactorMatrix, set_opticalFactorMatrix)
    def get_diffuseTransmittanceFactor(self): return self._diffuseTransmittanceFactor
    def set_diffuseTransmittanceFactor(self, value):
        self._diffuseTransmittanceFactor = value
        update_node(self,self.troot,"coeff_diff")
    diffuseTransmittanceFactor = property(get_diffuseTransmittanceFactor, set_diffuseTransmittanceFactor)
    def get_directTransmittanceFactor(self): return self._directTransmittanceFactor
    def set_directTransmittanceFactor(self, value):
        self._directTransmittanceFactor = value
        update_node(self,self.troot,"coeff_diff")
    directTransmittanceFactor = property(get_directTransmittanceFactor, set_directTransmittanceFactor)
    def get_reflectanceFactor(self): return self._reflectanceFactor
    def set_reflectanceFactor(self, value):
        self._reflectanceFactor = value
        update_node(self,self.troot,"coeff_diff")
    reflectanceFactor = property(get_reflectanceFactor, set_reflectanceFactor)
    def get_specularIntensityFactor(self): return self._specularIntensityFactor
    def set_specularIntensityFactor(self, value):
        self._specularIntensityFactor = value
        update_node(self,self.troot,"coeff_diff")
    specularIntensityFactor = property(get_specularIntensityFactor, set_specularIntensityFactor)
    def get_useOpticalFactorMatrix(self): return self._useOpticalFactorMatrix
    def set_useOpticalFactorMatrix(self, value):
        self._useOpticalFactorMatrix = value
        update_node(self,self.troot,"coeff_diff")
    useOpticalFactorMatrix = property(get_useOpticalFactorMatrix, set_useOpticalFactorMatrix)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.opticalFactorMatrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_lambertianMultiplicativeFactorForLUT', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_lambertianMultiplicativeFactorForLUT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_lambertianMultiplicativeFactorForLUT')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_lambertianMultiplicativeFactorForLUT', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_lambertianMultiplicativeFactorForLUT'):
        if self.diffuseTransmittanceFactor is not None and 'diffuseTransmittanceFactor' not in already_processed:
            already_processed.add('diffuseTransmittanceFactor')
            outfile.write(' diffuseTransmittanceFactor="%s"' % self.gds_format_double(self.diffuseTransmittanceFactor, input_name='diffuseTransmittanceFactor'))
        if self.directTransmittanceFactor is not None and 'directTransmittanceFactor' not in already_processed:
            already_processed.add('directTransmittanceFactor')
            outfile.write(' directTransmittanceFactor="%s"' % self.gds_format_double(self.directTransmittanceFactor, input_name='directTransmittanceFactor'))
        if self.reflectanceFactor is not None and 'reflectanceFactor' not in already_processed:
            already_processed.add('reflectanceFactor')
            outfile.write(' reflectanceFactor="%s"' % self.gds_format_double(self.reflectanceFactor, input_name='reflectanceFactor'))
        if self.specularIntensityFactor is not None and 'specularIntensityFactor' not in already_processed:
            already_processed.add('specularIntensityFactor')
            outfile.write(' specularIntensityFactor="%s"' % self.gds_format_double(self.specularIntensityFactor, input_name='specularIntensityFactor'))
        if self.useOpticalFactorMatrix is not None and 'useOpticalFactorMatrix' not in already_processed:
            already_processed.add('useOpticalFactorMatrix')
            outfile.write(' useOpticalFactorMatrix="%s"' % self.gds_format_integer(self.useOpticalFactorMatrix, input_name='useOpticalFactorMatrix'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_lambertianMultiplicativeFactorForLUT', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.opticalFactorMatrix is not None:
            self.opticalFactorMatrix.export(outfile, level, namespaceprefix_, name_='opticalFactorMatrix', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_lambertianMultiplicativeFactorForLUT', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.diffuseTransmittanceFactor is not None:
            element.set('diffuseTransmittanceFactor', self.gds_format_double(self.diffuseTransmittanceFactor))
        if self.directTransmittanceFactor is not None:
            element.set('directTransmittanceFactor', self.gds_format_double(self.directTransmittanceFactor))
        if self.reflectanceFactor is not None:
            element.set('reflectanceFactor', self.gds_format_double(self.reflectanceFactor))
        if self.specularIntensityFactor is not None:
            element.set('specularIntensityFactor', self.gds_format_double(self.specularIntensityFactor))
        if self.useOpticalFactorMatrix is not None:
            element.set('useOpticalFactorMatrix', self.gds_format_integer(self.useOpticalFactorMatrix))
        if self.opticalFactorMatrix is not None:
            opticalFactorMatrix_ = self.opticalFactorMatrix
            opticalFactorMatrix_.to_etree(element, name_='opticalFactorMatrix', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_lambertianMultiplicativeFactorForLUT'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.diffuseTransmittanceFactor is not None and 'diffuseTransmittanceFactor' not in already_processed:
            already_processed.add('diffuseTransmittanceFactor')
            showIndent(outfile, level)
            outfile.write('diffuseTransmittanceFactor=%e,\n' % (self.diffuseTransmittanceFactor,))
        if self.directTransmittanceFactor is not None and 'directTransmittanceFactor' not in already_processed:
            already_processed.add('directTransmittanceFactor')
            showIndent(outfile, level)
            outfile.write('directTransmittanceFactor=%e,\n' % (self.directTransmittanceFactor,))
        if self.reflectanceFactor is not None and 'reflectanceFactor' not in already_processed:
            already_processed.add('reflectanceFactor')
            showIndent(outfile, level)
            outfile.write('reflectanceFactor=%e,\n' % (self.reflectanceFactor,))
        if self.specularIntensityFactor is not None and 'specularIntensityFactor' not in already_processed:
            already_processed.add('specularIntensityFactor')
            showIndent(outfile, level)
            outfile.write('specularIntensityFactor=%e,\n' % (self.specularIntensityFactor,))
        if self.useOpticalFactorMatrix is not None and 'useOpticalFactorMatrix' not in already_processed:
            already_processed.add('useOpticalFactorMatrix')
            showIndent(outfile, level)
            outfile.write('useOpticalFactorMatrix=%d,\n' % (self.useOpticalFactorMatrix,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.opticalFactorMatrix is not None:
            showIndent(outfile, level)
            outfile.write('opticalFactorMatrix=model_._opticalFactorMatrix(\n')
            self.opticalFactorMatrix.exportLiteral(outfile, level, name_='opticalFactorMatrix')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('diffuseTransmittanceFactor', node)
        if value is not None and 'diffuseTransmittanceFactor' not in already_processed:
            already_processed.add('diffuseTransmittanceFactor')
            try:
                self.diffuseTransmittanceFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (diffuseTransmittanceFactor): %s' % exp)
        value = find_attr_value_('directTransmittanceFactor', node)
        if value is not None and 'directTransmittanceFactor' not in already_processed:
            already_processed.add('directTransmittanceFactor')
            try:
                self.directTransmittanceFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (directTransmittanceFactor): %s' % exp)
        value = find_attr_value_('reflectanceFactor', node)
        if value is not None and 'reflectanceFactor' not in already_processed:
            already_processed.add('reflectanceFactor')
            try:
                self.reflectanceFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (reflectanceFactor): %s' % exp)
        value = find_attr_value_('specularIntensityFactor', node)
        if value is not None and 'specularIntensityFactor' not in already_processed:
            already_processed.add('specularIntensityFactor')
            try:
                self.specularIntensityFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (specularIntensityFactor): %s' % exp)
        value = find_attr_value_('useOpticalFactorMatrix', node)
        if value is not None and 'useOpticalFactorMatrix' not in already_processed:
            already_processed.add('useOpticalFactorMatrix')
            try:
                self.useOpticalFactorMatrix = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'opticalFactorMatrix':
            obj_ = create_opticalFactorMatrix.factory()
            obj_.build(child_)
            self.set_opticalFactorMatrix(obj_)
            obj_.original_tagname_ = 'opticalFactorMatrix'
# end class create_lambertianMultiplicativeFactorForLUT


class create_opticalFactorMatrix(GeneratedsSuper):
    """3D factor matrix text file, organized from bottom to top altitude
    layers\nOrdered like the schematic view in simulation editor,
    origin top-left:\ncolumns (y) - lines (x) - altitudes
    (z)\nAccepted field separators: semi-column, space, tab 3D
    factor matrix text file, organized from bottom to top altitude
    layers\nOrdered like the schematic view in simulation editor,
    origin top-left:\ncolumns (y) - lines (x) - altitudes
    (z)\nAccepted field separators: semi-column, space, tab"""
    subclass = None
    superclass = None
    def __init__(self, duplicateFirstMatrixLayer=0, opticalFactorMatrixFile='choose'):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_opticalFactorMatrix")
        self.attrib = ['duplicateFirstMatrixLayer', 'opticalFactorMatrixFile']
        self.children = []
        self.parent = None
        self._duplicateFirstMatrixLayer = _cast(int, duplicateFirstMatrixLayer)
        self._opticalFactorMatrixFile = _cast(None, opticalFactorMatrixFile)
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_opticalFactorMatrix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_opticalFactorMatrix.subclass:
            return create_opticalFactorMatrix.subclass(*args_, **kwargs_)
        else:
            return create_opticalFactorMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_duplicateFirstMatrixLayer(self): return self._duplicateFirstMatrixLayer
    def set_duplicateFirstMatrixLayer(self, value):
        self._duplicateFirstMatrixLayer = value
        update_node(self,self.troot,"coeff_diff")
    duplicateFirstMatrixLayer = property(get_duplicateFirstMatrixLayer, set_duplicateFirstMatrixLayer)
    def get_opticalFactorMatrixFile(self): return self._opticalFactorMatrixFile
    def set_opticalFactorMatrixFile(self, value):
        self._opticalFactorMatrixFile = value
        update_node(self,self.troot,"coeff_diff")
    opticalFactorMatrixFile = property(get_opticalFactorMatrixFile, set_opticalFactorMatrixFile)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_opticalFactorMatrix', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_opticalFactorMatrix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_opticalFactorMatrix')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_opticalFactorMatrix', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_opticalFactorMatrix'):
        if self.duplicateFirstMatrixLayer is not None and 'duplicateFirstMatrixLayer' not in already_processed:
            already_processed.add('duplicateFirstMatrixLayer')
            outfile.write(' duplicateFirstMatrixLayer="%s"' % self.gds_format_integer(self.duplicateFirstMatrixLayer, input_name='duplicateFirstMatrixLayer'))
        if self.opticalFactorMatrixFile is not None and 'opticalFactorMatrixFile' not in already_processed:
            already_processed.add('opticalFactorMatrixFile')
            outfile.write(' opticalFactorMatrixFile=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.opticalFactorMatrixFile), input_name='opticalFactorMatrixFile')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_opticalFactorMatrix', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_opticalFactorMatrix', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.duplicateFirstMatrixLayer is not None:
            element.set('duplicateFirstMatrixLayer', self.gds_format_integer(self.duplicateFirstMatrixLayer))
        if self.opticalFactorMatrixFile is not None:
            element.set('opticalFactorMatrixFile', self.gds_format_string(self.opticalFactorMatrixFile))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_opticalFactorMatrix'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.duplicateFirstMatrixLayer is not None and 'duplicateFirstMatrixLayer' not in already_processed:
            already_processed.add('duplicateFirstMatrixLayer')
            showIndent(outfile, level)
            outfile.write('duplicateFirstMatrixLayer=%d,\n' % (self.duplicateFirstMatrixLayer,))
        if self.opticalFactorMatrixFile is not None and 'opticalFactorMatrixFile' not in already_processed:
            already_processed.add('opticalFactorMatrixFile')
            showIndent(outfile, level)
            outfile.write('opticalFactorMatrixFile="%s",\n' % (self.opticalFactorMatrixFile,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('duplicateFirstMatrixLayer', node)
        if value is not None and 'duplicateFirstMatrixLayer' not in already_processed:
            already_processed.add('duplicateFirstMatrixLayer')
            try:
                self.duplicateFirstMatrixLayer = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('opticalFactorMatrixFile', node)
        if value is not None and 'opticalFactorMatrixFile' not in already_processed:
            already_processed.add('opticalFactorMatrixFile')
            self.opticalFactorMatrixFile = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_opticalFactorMatrix


class create_HapkeSpecularMultiFunctions(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, HapkeSpecularMulti=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_HapkeSpecularMultiFunctions")
        self.attrib = ['']
        self.children = ['HapkeSpecularMulti']
        self.parent = None
        if HapkeSpecularMulti is None:
            self._HapkeSpecularMulti = []
        else:
            self._HapkeSpecularMulti = HapkeSpecularMulti
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_HapkeSpecularMultiFunctions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_HapkeSpecularMultiFunctions.subclass:
            return create_HapkeSpecularMultiFunctions.subclass(*args_, **kwargs_)
        else:
            return create_HapkeSpecularMultiFunctions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HapkeSpecularMulti(self): return self._HapkeSpecularMulti
    def set_HapkeSpecularMulti(self, value):
        if value is not None:
            checkclass(value, create_HapkeSpecularMulti)
            for v in value:
                v.parent = self
        self._HapkeSpecularMulti = value
    def add_HapkeSpecularMulti(self, value):
        value.parent = self
        self._HapkeSpecularMulti.append(value)
    def insert_HapkeSpecularMulti_at(self, index, value):
        value.parent = self
        self.HapkeSpecularMulti.insert(index, value)
    def replace_HapkeSpecularMulti_at(self, index, value):
        value.parent = self
        self.HapkeSpecularMulti[index] = value
    HapkeSpecularMulti = property(get_HapkeSpecularMulti, set_HapkeSpecularMulti)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.HapkeSpecularMulti
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_HapkeSpecularMultiFunctions', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_HapkeSpecularMultiFunctions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_HapkeSpecularMultiFunctions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_HapkeSpecularMultiFunctions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_HapkeSpecularMultiFunctions'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_HapkeSpecularMultiFunctions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for HapkeSpecularMulti_ in self.HapkeSpecularMulti:
            HapkeSpecularMulti_.export(outfile, level, namespaceprefix_, name_='HapkeSpecularMulti', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_HapkeSpecularMultiFunctions', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for HapkeSpecularMulti_ in self.HapkeSpecularMulti:
            HapkeSpecularMulti_.to_etree(element, name_='HapkeSpecularMulti', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_HapkeSpecularMultiFunctions'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('HapkeSpecularMulti=[\n')
        level += 1
        for HapkeSpecularMulti_ in self.HapkeSpecularMulti:
            showIndent(outfile, level)
            outfile.write('model_._HapkeSpecularMulti(\n')
            HapkeSpecularMulti_.exportLiteral(outfile, level, name_='_HapkeSpecularMulti')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.HapkeSpecularMulti = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HapkeSpecularMulti':
            obj_ = create_HapkeSpecularMulti.factory()
            obj_.build(child_)
            self.add_HapkeSpecularMulti(obj_)
            obj_.original_tagname_ = 'HapkeSpecularMulti'
# end class create_HapkeSpecularMultiFunctions


class create_HapkeSpecularMulti(GeneratedsSuper):
    """Name of the spectral data base (text file) used to compute the
    spectral phase function(s) Name of the spectral data base (text
    file) used to compute the spectral phase function(s) Using Hapke
    external module. With this option, it's possible to retrieve
    (with genetic algorithm) Hapke model parameters from
    measurements or Dart simulations. Using Hapke external module.
    With this option, it's possible to retrieve (with genetic
    algorithm) Hapke model parameters from measurements or Dart
    simulations. Transmittance database Transmittance database Use
    specular Use specular proportion of photons intercepted along an
    incident direction that are scattered within a solid angle along
    a given direction proportion of photons intercepted along an
    incident direction that are scattered within a solid angle along
    a given direction Transmittance model Transmittance model
    Reflectance database Reflectance database
    useMultiplicativeFactorForLUT useMultiplicativeFactorForLUT"""
    subclass = None
    superclass = None
    def __init__(self, ModelName='all_equal_to_one', useExternalModule=0, transmittanceDatabaseName='Lambertian_vegetation.db', useSpecular=0, ident='Hapke_Phase_Function_1', transmittanceModelName='reflect_equal_1_trans_equal_1_1', databaseName='Hapke.db', useMultiplicativeFactorForLUT=1, SpecularData=None, HapkeExternalModules=None, hapkeNodeMultiplicativeFactorForLUT=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_HapkeSpecularMulti")
        self.attrib = ['ModelName', 'useExternalModule', 'transmittanceDatabaseName', 'useSpecular', 'ident', 'transmittanceModelName', 'databaseName', 'useMultiplicativeFactorForLUT']
        self.children = ['SpecularData', 'HapkeExternalModules', 'hapkeNodeMultiplicativeFactorForLUT']
        self.parent = None
        self._ModelName = _cast(None, ModelName)
        self._useExternalModule = _cast(int, useExternalModule)
        self._transmittanceDatabaseName = _cast(None, transmittanceDatabaseName)
        self._useSpecular = _cast(int, useSpecular)
        self._ident = _cast(None, ident)
        self._transmittanceModelName = _cast(None, transmittanceModelName)
        self._databaseName = _cast(None, databaseName)
        self._useMultiplicativeFactorForLUT = _cast(int, useMultiplicativeFactorForLUT)
        self._SpecularData = SpecularData
        self._HapkeExternalModules = HapkeExternalModules
        self._hapkeNodeMultiplicativeFactorForLUT = hapkeNodeMultiplicativeFactorForLUT
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_HapkeSpecularMulti)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_HapkeSpecularMulti.subclass:
            return create_HapkeSpecularMulti.subclass(*args_, **kwargs_)
        else:
            return create_HapkeSpecularMulti(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SpecularData(self): return self._SpecularData
    def set_SpecularData(self, value):
        if value is not None:
            checkclass(value, create_SpecularData)
            value.parent = self
        self._SpecularData = value
    SpecularData = property(get_SpecularData, set_SpecularData)
    def get_HapkeExternalModules(self): return self._HapkeExternalModules
    def set_HapkeExternalModules(self, value):
        if value is not None:
            checkclass(value, create_HapkeExternalModules)
            value.parent = self
        self._HapkeExternalModules = value
    HapkeExternalModules = property(get_HapkeExternalModules, set_HapkeExternalModules)
    def get_hapkeNodeMultiplicativeFactorForLUT(self): return self._hapkeNodeMultiplicativeFactorForLUT
    def set_hapkeNodeMultiplicativeFactorForLUT(self, value):
        if value is not None:
            checkclass(value, create_hapkeNodeMultiplicativeFactorForLUT)
            value.parent = self
        self._hapkeNodeMultiplicativeFactorForLUT = value
    hapkeNodeMultiplicativeFactorForLUT = property(get_hapkeNodeMultiplicativeFactorForLUT, set_hapkeNodeMultiplicativeFactorForLUT)
    def get_ModelName(self): return self._ModelName
    def set_ModelName(self, value):
        self._ModelName = value
        update_node(self,self.troot,"coeff_diff")
    ModelName = property(get_ModelName, set_ModelName)
    def get_useExternalModule(self): return self._useExternalModule
    def set_useExternalModule(self, value):
        self._useExternalModule = value
        update_node(self,self.troot,"coeff_diff")
    useExternalModule = property(get_useExternalModule, set_useExternalModule)
    def get_transmittanceDatabaseName(self): return self._transmittanceDatabaseName
    def set_transmittanceDatabaseName(self, value):
        self._transmittanceDatabaseName = value
        update_node(self,self.troot,"coeff_diff")
    transmittanceDatabaseName = property(get_transmittanceDatabaseName, set_transmittanceDatabaseName)
    def get_useSpecular(self): return self._useSpecular
    def set_useSpecular(self, value):
        self._useSpecular = value
        update_node(self,self.troot,"coeff_diff")
    useSpecular = property(get_useSpecular, set_useSpecular)
    def get_ident(self): return self._ident
    def set_ident(self, value):
        self._ident = value
        update_node(self,self.troot,"coeff_diff")
    ident = property(get_ident, set_ident)
    def get_transmittanceModelName(self): return self._transmittanceModelName
    def set_transmittanceModelName(self, value):
        self._transmittanceModelName = value
        update_node(self,self.troot,"coeff_diff")
    transmittanceModelName = property(get_transmittanceModelName, set_transmittanceModelName)
    def get_databaseName(self): return self._databaseName
    def set_databaseName(self, value):
        self._databaseName = value
        update_node(self,self.troot,"coeff_diff")
    databaseName = property(get_databaseName, set_databaseName)
    def get_useMultiplicativeFactorForLUT(self): return self._useMultiplicativeFactorForLUT
    def set_useMultiplicativeFactorForLUT(self, value):
        self._useMultiplicativeFactorForLUT = value
        update_node(self,self.troot,"coeff_diff")
    useMultiplicativeFactorForLUT = property(get_useMultiplicativeFactorForLUT, set_useMultiplicativeFactorForLUT)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.SpecularData is not None or
            self.HapkeExternalModules is not None or
            self.hapkeNodeMultiplicativeFactorForLUT is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_HapkeSpecularMulti', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_HapkeSpecularMulti')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_HapkeSpecularMulti')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_HapkeSpecularMulti', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_HapkeSpecularMulti'):
        if self.ModelName is not None and 'ModelName' not in already_processed:
            already_processed.add('ModelName')
            outfile.write(' ModelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ModelName), input_name='ModelName')), ))
        if self.useExternalModule is not None and 'useExternalModule' not in already_processed:
            already_processed.add('useExternalModule')
            outfile.write(' useExternalModule="%s"' % self.gds_format_integer(self.useExternalModule, input_name='useExternalModule'))
        if self.transmittanceDatabaseName is not None and 'transmittanceDatabaseName' not in already_processed:
            already_processed.add('transmittanceDatabaseName')
            outfile.write(' transmittanceDatabaseName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transmittanceDatabaseName), input_name='transmittanceDatabaseName')), ))
        if self.useSpecular is not None and 'useSpecular' not in already_processed:
            already_processed.add('useSpecular')
            outfile.write(' useSpecular="%s"' % self.gds_format_integer(self.useSpecular, input_name='useSpecular'))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            outfile.write(' ident=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ident), input_name='ident')), ))
        if self.transmittanceModelName is not None and 'transmittanceModelName' not in already_processed:
            already_processed.add('transmittanceModelName')
            outfile.write(' transmittanceModelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transmittanceModelName), input_name='transmittanceModelName')), ))
        if self.databaseName is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            outfile.write(' databaseName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.databaseName), input_name='databaseName')), ))
        if self.useMultiplicativeFactorForLUT is not None and 'useMultiplicativeFactorForLUT' not in already_processed:
            already_processed.add('useMultiplicativeFactorForLUT')
            outfile.write(' useMultiplicativeFactorForLUT="%s"' % self.gds_format_integer(self.useMultiplicativeFactorForLUT, input_name='useMultiplicativeFactorForLUT'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_HapkeSpecularMulti', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SpecularData is not None:
            self.SpecularData.export(outfile, level, namespaceprefix_, name_='SpecularData', pretty_print=pretty_print)
        if self.HapkeExternalModules is not None:
            self.HapkeExternalModules.export(outfile, level, namespaceprefix_, name_='HapkeExternalModules', pretty_print=pretty_print)
        if self.hapkeNodeMultiplicativeFactorForLUT is not None:
            self.hapkeNodeMultiplicativeFactorForLUT.export(outfile, level, namespaceprefix_, name_='hapkeNodeMultiplicativeFactorForLUT', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_HapkeSpecularMulti', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ModelName is not None:
            element.set('ModelName', self.gds_format_string(self.ModelName))
        if self.useExternalModule is not None:
            element.set('useExternalModule', self.gds_format_integer(self.useExternalModule))
        if self.transmittanceDatabaseName is not None:
            element.set('transmittanceDatabaseName', self.gds_format_string(self.transmittanceDatabaseName))
        if self.useSpecular is not None:
            element.set('useSpecular', self.gds_format_integer(self.useSpecular))
        if self.ident is not None:
            element.set('ident', self.gds_format_string(self.ident))
        if self.transmittanceModelName is not None:
            element.set('transmittanceModelName', self.gds_format_string(self.transmittanceModelName))
        if self.databaseName is not None:
            element.set('databaseName', self.gds_format_string(self.databaseName))
        if self.useMultiplicativeFactorForLUT is not None:
            element.set('useMultiplicativeFactorForLUT', self.gds_format_integer(self.useMultiplicativeFactorForLUT))
        if self.SpecularData is not None:
            SpecularData_ = self.SpecularData
            SpecularData_.to_etree(element, name_='SpecularData', mapping_=mapping_)
        if self.HapkeExternalModules is not None:
            HapkeExternalModules_ = self.HapkeExternalModules
            HapkeExternalModules_.to_etree(element, name_='HapkeExternalModules', mapping_=mapping_)
        if self.hapkeNodeMultiplicativeFactorForLUT is not None:
            hapkeNodeMultiplicativeFactorForLUT_ = self.hapkeNodeMultiplicativeFactorForLUT
            hapkeNodeMultiplicativeFactorForLUT_.to_etree(element, name_='hapkeNodeMultiplicativeFactorForLUT', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_HapkeSpecularMulti'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ModelName is not None and 'ModelName' not in already_processed:
            already_processed.add('ModelName')
            showIndent(outfile, level)
            outfile.write('ModelName="%s",\n' % (self.ModelName,))
        if self.useExternalModule is not None and 'useExternalModule' not in already_processed:
            already_processed.add('useExternalModule')
            showIndent(outfile, level)
            outfile.write('useExternalModule=%d,\n' % (self.useExternalModule,))
        if self.transmittanceDatabaseName is not None and 'transmittanceDatabaseName' not in already_processed:
            already_processed.add('transmittanceDatabaseName')
            showIndent(outfile, level)
            outfile.write('transmittanceDatabaseName="%s",\n' % (self.transmittanceDatabaseName,))
        if self.useSpecular is not None and 'useSpecular' not in already_processed:
            already_processed.add('useSpecular')
            showIndent(outfile, level)
            outfile.write('useSpecular=%d,\n' % (self.useSpecular,))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            showIndent(outfile, level)
            outfile.write('ident="%s",\n' % (self.ident,))
        if self.transmittanceModelName is not None and 'transmittanceModelName' not in already_processed:
            already_processed.add('transmittanceModelName')
            showIndent(outfile, level)
            outfile.write('transmittanceModelName="%s",\n' % (self.transmittanceModelName,))
        if self.databaseName is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            showIndent(outfile, level)
            outfile.write('databaseName="%s",\n' % (self.databaseName,))
        if self.useMultiplicativeFactorForLUT is not None and 'useMultiplicativeFactorForLUT' not in already_processed:
            already_processed.add('useMultiplicativeFactorForLUT')
            showIndent(outfile, level)
            outfile.write('useMultiplicativeFactorForLUT=%d,\n' % (self.useMultiplicativeFactorForLUT,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SpecularData is not None:
            showIndent(outfile, level)
            outfile.write('SpecularData=model_._SpecularData(\n')
            self.SpecularData.exportLiteral(outfile, level, name_='SpecularData')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HapkeExternalModules is not None:
            showIndent(outfile, level)
            outfile.write('HapkeExternalModules=model_._HapkeExternalModules(\n')
            self.HapkeExternalModules.exportLiteral(outfile, level, name_='HapkeExternalModules')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.hapkeNodeMultiplicativeFactorForLUT is not None:
            showIndent(outfile, level)
            outfile.write('hapkeNodeMultiplicativeFactorForLUT=model_._hapkeNodeMultiplicativeFactorForLUT(\n')
            self.hapkeNodeMultiplicativeFactorForLUT.exportLiteral(outfile, level, name_='hapkeNodeMultiplicativeFactorForLUT')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ModelName', node)
        if value is not None and 'ModelName' not in already_processed:
            already_processed.add('ModelName')
            self.ModelName = value
        value = find_attr_value_('useExternalModule', node)
        if value is not None and 'useExternalModule' not in already_processed:
            already_processed.add('useExternalModule')
            try:
                self.useExternalModule = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('transmittanceDatabaseName', node)
        if value is not None and 'transmittanceDatabaseName' not in already_processed:
            already_processed.add('transmittanceDatabaseName')
            self.transmittanceDatabaseName = value
        value = find_attr_value_('useSpecular', node)
        if value is not None and 'useSpecular' not in already_processed:
            already_processed.add('useSpecular')
            try:
                self.useSpecular = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ident', node)
        if value is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            self.ident = value
        value = find_attr_value_('transmittanceModelName', node)
        if value is not None and 'transmittanceModelName' not in already_processed:
            already_processed.add('transmittanceModelName')
            self.transmittanceModelName = value
        value = find_attr_value_('databaseName', node)
        if value is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            self.databaseName = value
        value = find_attr_value_('useMultiplicativeFactorForLUT', node)
        if value is not None and 'useMultiplicativeFactorForLUT' not in already_processed:
            already_processed.add('useMultiplicativeFactorForLUT')
            try:
                self.useMultiplicativeFactorForLUT = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SpecularData':
            obj_ = create_SpecularData.factory()
            obj_.build(child_)
            self.set_SpecularData(obj_)
            obj_.original_tagname_ = 'SpecularData'
        elif nodeName_ == 'HapkeExternalModules':
            obj_ = create_HapkeExternalModules.factory()
            obj_.build(child_)
            self.set_HapkeExternalModules(obj_)
            obj_.original_tagname_ = 'HapkeExternalModules'
        elif nodeName_ == 'hapkeNodeMultiplicativeFactorForLUT':
            obj_ = create_hapkeNodeMultiplicativeFactorForLUT.factory()
            obj_.build(child_)
            self.set_hapkeNodeMultiplicativeFactorForLUT(obj_)
            obj_.original_tagname_ = 'hapkeNodeMultiplicativeFactorForLUT'
# end class create_HapkeSpecularMulti


class create_HapkeExternalModules(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, HapkeExternalModule=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_HapkeExternalModules")
        self.attrib = ['']
        self.children = ['HapkeExternalModule']
        self.parent = None
        if HapkeExternalModule is None:
            self._HapkeExternalModule = []
        else:
            self._HapkeExternalModule = HapkeExternalModule
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_HapkeExternalModules)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_HapkeExternalModules.subclass:
            return create_HapkeExternalModules.subclass(*args_, **kwargs_)
        else:
            return create_HapkeExternalModules(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HapkeExternalModule(self): return self._HapkeExternalModule
    def set_HapkeExternalModule(self, value):
        if value is not None:
            checkclass(value, create_HapkeExternalModule)
            for v in value:
                v.parent = self
        self._HapkeExternalModule = value
    def add_HapkeExternalModule(self, value):
        value.parent = self
        self._HapkeExternalModule.append(value)
    def insert_HapkeExternalModule_at(self, index, value):
        value.parent = self
        self.HapkeExternalModule.insert(index, value)
    def replace_HapkeExternalModule_at(self, index, value):
        value.parent = self
        self.HapkeExternalModule[index] = value
    HapkeExternalModule = property(get_HapkeExternalModule, set_HapkeExternalModule)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.HapkeExternalModule
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_HapkeExternalModules', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_HapkeExternalModules')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_HapkeExternalModules')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_HapkeExternalModules', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_HapkeExternalModules'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_HapkeExternalModules', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for HapkeExternalModule_ in self.HapkeExternalModule:
            HapkeExternalModule_.export(outfile, level, namespaceprefix_, name_='HapkeExternalModule', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_HapkeExternalModules', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for HapkeExternalModule_ in self.HapkeExternalModule:
            HapkeExternalModule_.to_etree(element, name_='HapkeExternalModule', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_HapkeExternalModules'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('HapkeExternalModule=[\n')
        level += 1
        for HapkeExternalModule_ in self.HapkeExternalModule:
            showIndent(outfile, level)
            outfile.write('model_._HapkeExternalModule(\n')
            HapkeExternalModule_.exportLiteral(outfile, level, name_='_HapkeExternalModule')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.HapkeExternalModule = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HapkeExternalModule':
            obj_ = create_HapkeExternalModule.factory()
            obj_.build(child_)
            self.add_HapkeExternalModule(obj_)
            obj_.original_tagname_ = 'HapkeExternalModule'
# end class create_HapkeExternalModules


class create_HapkeExternalModule(GeneratedsSuper):
    """0) or 7 parameters of Hapke extend model. 0) or 7 parameters of
    Hapke extend model. Input FileName used by Hapke external module
    Input FileName used by Hapke external module Hapke model name
    Hapke model name"""
    subclass = None
    superclass = None
    def __init__(self, soilSpecFlag=0, hapkeInputFile='hapke_input.txt', choiceOfHapkeModel='New'):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_HapkeExternalModule")
        self.attrib = ['soilSpecFlag', 'hapkeInputFile', 'choiceOfHapkeModel']
        self.children = []
        self.parent = None
        self._soilSpecFlag = _cast(int, soilSpecFlag)
        self._hapkeInputFile = _cast(None, hapkeInputFile)
        self._choiceOfHapkeModel = _cast(None, choiceOfHapkeModel)
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_HapkeExternalModule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_HapkeExternalModule.subclass:
            return create_HapkeExternalModule.subclass(*args_, **kwargs_)
        else:
            return create_HapkeExternalModule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_soilSpecFlag(self): return self._soilSpecFlag
    def set_soilSpecFlag(self, value):
        self._soilSpecFlag = value
        update_node(self,self.troot,"coeff_diff")
    soilSpecFlag = property(get_soilSpecFlag, set_soilSpecFlag)
    def get_hapkeInputFile(self): return self._hapkeInputFile
    def set_hapkeInputFile(self, value):
        self._hapkeInputFile = value
        update_node(self,self.troot,"coeff_diff")
    hapkeInputFile = property(get_hapkeInputFile, set_hapkeInputFile)
    def get_choiceOfHapkeModel(self): return self._choiceOfHapkeModel
    def set_choiceOfHapkeModel(self, value):
        self._choiceOfHapkeModel = value
        update_node(self,self.troot,"coeff_diff")
    choiceOfHapkeModel = property(get_choiceOfHapkeModel, set_choiceOfHapkeModel)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_HapkeExternalModule', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_HapkeExternalModule')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_HapkeExternalModule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_HapkeExternalModule', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_HapkeExternalModule'):
        if self.soilSpecFlag is not None and 'soilSpecFlag' not in already_processed:
            already_processed.add('soilSpecFlag')
            outfile.write(' soilSpecFlag="%s"' % self.gds_format_integer(self.soilSpecFlag, input_name='soilSpecFlag'))
        if self.hapkeInputFile is not None and 'hapkeInputFile' not in already_processed:
            already_processed.add('hapkeInputFile')
            outfile.write(' hapkeInputFile=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.hapkeInputFile), input_name='hapkeInputFile')), ))
        if self.choiceOfHapkeModel is not None and 'choiceOfHapkeModel' not in already_processed:
            already_processed.add('choiceOfHapkeModel')
            outfile.write(' choiceOfHapkeModel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.choiceOfHapkeModel), input_name='choiceOfHapkeModel')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_HapkeExternalModule', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_HapkeExternalModule', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.soilSpecFlag is not None:
            element.set('soilSpecFlag', self.gds_format_integer(self.soilSpecFlag))
        if self.hapkeInputFile is not None:
            element.set('hapkeInputFile', self.gds_format_string(self.hapkeInputFile))
        if self.choiceOfHapkeModel is not None:
            element.set('choiceOfHapkeModel', self.gds_format_string(self.choiceOfHapkeModel))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_HapkeExternalModule'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.soilSpecFlag is not None and 'soilSpecFlag' not in already_processed:
            already_processed.add('soilSpecFlag')
            showIndent(outfile, level)
            outfile.write('soilSpecFlag=%d,\n' % (self.soilSpecFlag,))
        if self.hapkeInputFile is not None and 'hapkeInputFile' not in already_processed:
            already_processed.add('hapkeInputFile')
            showIndent(outfile, level)
            outfile.write('hapkeInputFile="%s",\n' % (self.hapkeInputFile,))
        if self.choiceOfHapkeModel is not None and 'choiceOfHapkeModel' not in already_processed:
            already_processed.add('choiceOfHapkeModel')
            showIndent(outfile, level)
            outfile.write('choiceOfHapkeModel="%s",\n' % (self.choiceOfHapkeModel,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('soilSpecFlag', node)
        if value is not None and 'soilSpecFlag' not in already_processed:
            already_processed.add('soilSpecFlag')
            try:
                self.soilSpecFlag = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('hapkeInputFile', node)
        if value is not None and 'hapkeInputFile' not in already_processed:
            already_processed.add('hapkeInputFile')
            self.hapkeInputFile = value
        value = find_attr_value_('choiceOfHapkeModel', node)
        if value is not None and 'choiceOfHapkeModel' not in already_processed:
            already_processed.add('choiceOfHapkeModel')
            self.choiceOfHapkeModel = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_HapkeExternalModule


class create_hapkeNodeMultiplicativeFactorForLUT(GeneratedsSuper):
    """Diffuse transmittance Diffuse transmittance Direct transmittance
    Direct transmittance H1 H1 H2 H2 Necessary for building up LUT
    tables with variable specular intensity values. \nA
    multispectral LUT can be computed applying the sequencer to DART
    mutispectral simulation with one spectral band each. Necessary
    for building up LUT tables with variable specular intensity
    values. \nA multispectral LUT can be computed applying the
    sequencer to DART mutispectral simulation with one spectral band
    each. Apply the same 3D factor matrix per cell on optical
    properties to all the spectral bands Apply the same 3D factor
    matrix per cell on optical properties to all the spectral bands
    C4 C4 C1 C1 C3 C3 C2 C2 When selected, the parameters values of
    every spectral band will be equal to these parameters. When
    selected, the parameters values of every spectral band will be
    equal to these parameters. W W"""
    subclass = None
    superclass = None
    def __init__(self, diffuseTransmittanceFactor=0, directTransmittanceFactor=0, hapkeParameterH1=1.0, hapkeParameterH2=1.0, specularIntensityFactor=1, useSameOpticalFactorMatrixForAllBands=0, hapkeParameterC4=1.0, hapkeParameterC1=1.0, hapkeParameterC3=1.0, hapkeParameterC2=1.0, useSameFactorForAllBands=1, hapkeParameterW=1.0, hapkeMultiplicativeFactorForLUT=None, opticalFactorMatrix=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_hapkeNodeMultiplicativeFactorForLUT")
        self.attrib = ['diffuseTransmittanceFactor', 'directTransmittanceFactor', 'hapkeParameterH1', 'hapkeParameterH2', 'specularIntensityFactor', 'useSameOpticalFactorMatrixForAllBands', 'hapkeParameterC4', 'hapkeParameterC1', 'hapkeParameterC3', 'hapkeParameterC2', 'useSameFactorForAllBands', 'hapkeParameterW']
        self.children = ['hapkeMultiplicativeFactorForLUT', 'opticalFactorMatrix']
        self.parent = None
        self._diffuseTransmittanceFactor = _cast(float, diffuseTransmittanceFactor)
        self._directTransmittanceFactor = _cast(float, directTransmittanceFactor)
        self._hapkeParameterH1 = _cast(float, hapkeParameterH1)
        self._hapkeParameterH2 = _cast(float, hapkeParameterH2)
        self._specularIntensityFactor = _cast(float, specularIntensityFactor)
        self._useSameOpticalFactorMatrixForAllBands = _cast(int, useSameOpticalFactorMatrixForAllBands)
        self._hapkeParameterC4 = _cast(float, hapkeParameterC4)
        self._hapkeParameterC1 = _cast(float, hapkeParameterC1)
        self._hapkeParameterC3 = _cast(float, hapkeParameterC3)
        self._hapkeParameterC2 = _cast(float, hapkeParameterC2)
        self._useSameFactorForAllBands = _cast(int, useSameFactorForAllBands)
        self._hapkeParameterW = _cast(float, hapkeParameterW)
        if hapkeMultiplicativeFactorForLUT is None:
            self._hapkeMultiplicativeFactorForLUT = []
        else:
            self._hapkeMultiplicativeFactorForLUT = hapkeMultiplicativeFactorForLUT
        self._opticalFactorMatrix = opticalFactorMatrix
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_hapkeNodeMultiplicativeFactorForLUT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_hapkeNodeMultiplicativeFactorForLUT.subclass:
            return create_hapkeNodeMultiplicativeFactorForLUT.subclass(*args_, **kwargs_)
        else:
            return create_hapkeNodeMultiplicativeFactorForLUT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hapkeMultiplicativeFactorForLUT(self): return self._hapkeMultiplicativeFactorForLUT
    def set_hapkeMultiplicativeFactorForLUT(self, value):
        if value is not None:
            checkclass(value, create_hapkeMultiplicativeFactorForLUT)
            for v in value:
                v.parent = self
        self._hapkeMultiplicativeFactorForLUT = value
    def add_hapkeMultiplicativeFactorForLUT(self, value):
        value.parent = self
        self._hapkeMultiplicativeFactorForLUT.append(value)
    def insert_hapkeMultiplicativeFactorForLUT_at(self, index, value):
        value.parent = self
        self.hapkeMultiplicativeFactorForLUT.insert(index, value)
    def replace_hapkeMultiplicativeFactorForLUT_at(self, index, value):
        value.parent = self
        self.hapkeMultiplicativeFactorForLUT[index] = value
    hapkeMultiplicativeFactorForLUT = property(get_hapkeMultiplicativeFactorForLUT, set_hapkeMultiplicativeFactorForLUT)
    def get_opticalFactorMatrix(self): return self._opticalFactorMatrix
    def set_opticalFactorMatrix(self, value):
        if value is not None:
            checkclass(value, create_opticalFactorMatrix)
            value.parent = self
        self._opticalFactorMatrix = value
    opticalFactorMatrix = property(get_opticalFactorMatrix, set_opticalFactorMatrix)
    def get_diffuseTransmittanceFactor(self): return self._diffuseTransmittanceFactor
    def set_diffuseTransmittanceFactor(self, value):
        self._diffuseTransmittanceFactor = value
        update_node(self,self.troot,"coeff_diff")
    diffuseTransmittanceFactor = property(get_diffuseTransmittanceFactor, set_diffuseTransmittanceFactor)
    def get_directTransmittanceFactor(self): return self._directTransmittanceFactor
    def set_directTransmittanceFactor(self, value):
        self._directTransmittanceFactor = value
        update_node(self,self.troot,"coeff_diff")
    directTransmittanceFactor = property(get_directTransmittanceFactor, set_directTransmittanceFactor)
    def get_hapkeParameterH1(self): return self._hapkeParameterH1
    def set_hapkeParameterH1(self, value):
        self._hapkeParameterH1 = value
        update_node(self,self.troot,"coeff_diff")
    hapkeParameterH1 = property(get_hapkeParameterH1, set_hapkeParameterH1)
    def get_hapkeParameterH2(self): return self._hapkeParameterH2
    def set_hapkeParameterH2(self, value):
        self._hapkeParameterH2 = value
        update_node(self,self.troot,"coeff_diff")
    hapkeParameterH2 = property(get_hapkeParameterH2, set_hapkeParameterH2)
    def get_specularIntensityFactor(self): return self._specularIntensityFactor
    def set_specularIntensityFactor(self, value):
        self._specularIntensityFactor = value
        update_node(self,self.troot,"coeff_diff")
    specularIntensityFactor = property(get_specularIntensityFactor, set_specularIntensityFactor)
    def get_useSameOpticalFactorMatrixForAllBands(self): return self._useSameOpticalFactorMatrixForAllBands
    def set_useSameOpticalFactorMatrixForAllBands(self, value):
        self._useSameOpticalFactorMatrixForAllBands = value
        update_node(self,self.troot,"coeff_diff")
    useSameOpticalFactorMatrixForAllBands = property(get_useSameOpticalFactorMatrixForAllBands, set_useSameOpticalFactorMatrixForAllBands)
    def get_hapkeParameterC4(self): return self._hapkeParameterC4
    def set_hapkeParameterC4(self, value):
        self._hapkeParameterC4 = value
        update_node(self,self.troot,"coeff_diff")
    hapkeParameterC4 = property(get_hapkeParameterC4, set_hapkeParameterC4)
    def get_hapkeParameterC1(self): return self._hapkeParameterC1
    def set_hapkeParameterC1(self, value):
        self._hapkeParameterC1 = value
        update_node(self,self.troot,"coeff_diff")
    hapkeParameterC1 = property(get_hapkeParameterC1, set_hapkeParameterC1)
    def get_hapkeParameterC3(self): return self._hapkeParameterC3
    def set_hapkeParameterC3(self, value):
        self._hapkeParameterC3 = value
        update_node(self,self.troot,"coeff_diff")
    hapkeParameterC3 = property(get_hapkeParameterC3, set_hapkeParameterC3)
    def get_hapkeParameterC2(self): return self._hapkeParameterC2
    def set_hapkeParameterC2(self, value):
        self._hapkeParameterC2 = value
        update_node(self,self.troot,"coeff_diff")
    hapkeParameterC2 = property(get_hapkeParameterC2, set_hapkeParameterC2)
    def get_useSameFactorForAllBands(self): return self._useSameFactorForAllBands
    def set_useSameFactorForAllBands(self, value):
        self._useSameFactorForAllBands = value
        update_node(self,self.troot,"coeff_diff")
    useSameFactorForAllBands = property(get_useSameFactorForAllBands, set_useSameFactorForAllBands)
    def get_hapkeParameterW(self): return self._hapkeParameterW
    def set_hapkeParameterW(self, value):
        self._hapkeParameterW = value
        update_node(self,self.troot,"coeff_diff")
    hapkeParameterW = property(get_hapkeParameterW, set_hapkeParameterW)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.hapkeMultiplicativeFactorForLUT or
            self.opticalFactorMatrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_hapkeNodeMultiplicativeFactorForLUT', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_hapkeNodeMultiplicativeFactorForLUT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_hapkeNodeMultiplicativeFactorForLUT')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_hapkeNodeMultiplicativeFactorForLUT', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_hapkeNodeMultiplicativeFactorForLUT'):
        if self.diffuseTransmittanceFactor is not None and 'diffuseTransmittanceFactor' not in already_processed:
            already_processed.add('diffuseTransmittanceFactor')
            outfile.write(' diffuseTransmittanceFactor="%s"' % self.gds_format_double(self.diffuseTransmittanceFactor, input_name='diffuseTransmittanceFactor'))
        if self.directTransmittanceFactor is not None and 'directTransmittanceFactor' not in already_processed:
            already_processed.add('directTransmittanceFactor')
            outfile.write(' directTransmittanceFactor="%s"' % self.gds_format_double(self.directTransmittanceFactor, input_name='directTransmittanceFactor'))
        if self.hapkeParameterH1 is not None and 'hapkeParameterH1' not in already_processed:
            already_processed.add('hapkeParameterH1')
            outfile.write(' hapkeParameterH1="%s"' % self.gds_format_double(self.hapkeParameterH1, input_name='hapkeParameterH1'))
        if self.hapkeParameterH2 is not None and 'hapkeParameterH2' not in already_processed:
            already_processed.add('hapkeParameterH2')
            outfile.write(' hapkeParameterH2="%s"' % self.gds_format_double(self.hapkeParameterH2, input_name='hapkeParameterH2'))
        if self.specularIntensityFactor is not None and 'specularIntensityFactor' not in already_processed:
            already_processed.add('specularIntensityFactor')
            outfile.write(' specularIntensityFactor="%s"' % self.gds_format_double(self.specularIntensityFactor, input_name='specularIntensityFactor'))
        if self.useSameOpticalFactorMatrixForAllBands is not None and 'useSameOpticalFactorMatrixForAllBands' not in already_processed:
            already_processed.add('useSameOpticalFactorMatrixForAllBands')
            outfile.write(' useSameOpticalFactorMatrixForAllBands="%s"' % self.gds_format_integer(self.useSameOpticalFactorMatrixForAllBands, input_name='useSameOpticalFactorMatrixForAllBands'))
        if self.hapkeParameterC4 is not None and 'hapkeParameterC4' not in already_processed:
            already_processed.add('hapkeParameterC4')
            outfile.write(' hapkeParameterC4="%s"' % self.gds_format_double(self.hapkeParameterC4, input_name='hapkeParameterC4'))
        if self.hapkeParameterC1 is not None and 'hapkeParameterC1' not in already_processed:
            already_processed.add('hapkeParameterC1')
            outfile.write(' hapkeParameterC1="%s"' % self.gds_format_double(self.hapkeParameterC1, input_name='hapkeParameterC1'))
        if self.hapkeParameterC3 is not None and 'hapkeParameterC3' not in already_processed:
            already_processed.add('hapkeParameterC3')
            outfile.write(' hapkeParameterC3="%s"' % self.gds_format_double(self.hapkeParameterC3, input_name='hapkeParameterC3'))
        if self.hapkeParameterC2 is not None and 'hapkeParameterC2' not in already_processed:
            already_processed.add('hapkeParameterC2')
            outfile.write(' hapkeParameterC2="%s"' % self.gds_format_double(self.hapkeParameterC2, input_name='hapkeParameterC2'))
        if self.useSameFactorForAllBands is not None and 'useSameFactorForAllBands' not in already_processed:
            already_processed.add('useSameFactorForAllBands')
            outfile.write(' useSameFactorForAllBands="%s"' % self.gds_format_integer(self.useSameFactorForAllBands, input_name='useSameFactorForAllBands'))
        if self.hapkeParameterW is not None and 'hapkeParameterW' not in already_processed:
            already_processed.add('hapkeParameterW')
            outfile.write(' hapkeParameterW="%s"' % self.gds_format_double(self.hapkeParameterW, input_name='hapkeParameterW'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_hapkeNodeMultiplicativeFactorForLUT', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for hapkeMultiplicativeFactorForLUT_ in self.hapkeMultiplicativeFactorForLUT:
            hapkeMultiplicativeFactorForLUT_.export(outfile, level, namespaceprefix_, name_='hapkeMultiplicativeFactorForLUT', pretty_print=pretty_print)
        if self.opticalFactorMatrix is not None:
            self.opticalFactorMatrix.export(outfile, level, namespaceprefix_, name_='opticalFactorMatrix', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_hapkeNodeMultiplicativeFactorForLUT', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.diffuseTransmittanceFactor is not None:
            element.set('diffuseTransmittanceFactor', self.gds_format_double(self.diffuseTransmittanceFactor))
        if self.directTransmittanceFactor is not None:
            element.set('directTransmittanceFactor', self.gds_format_double(self.directTransmittanceFactor))
        if self.hapkeParameterH1 is not None:
            element.set('hapkeParameterH1', self.gds_format_double(self.hapkeParameterH1))
        if self.hapkeParameterH2 is not None:
            element.set('hapkeParameterH2', self.gds_format_double(self.hapkeParameterH2))
        if self.specularIntensityFactor is not None:
            element.set('specularIntensityFactor', self.gds_format_double(self.specularIntensityFactor))
        if self.useSameOpticalFactorMatrixForAllBands is not None:
            element.set('useSameOpticalFactorMatrixForAllBands', self.gds_format_integer(self.useSameOpticalFactorMatrixForAllBands))
        if self.hapkeParameterC4 is not None:
            element.set('hapkeParameterC4', self.gds_format_double(self.hapkeParameterC4))
        if self.hapkeParameterC1 is not None:
            element.set('hapkeParameterC1', self.gds_format_double(self.hapkeParameterC1))
        if self.hapkeParameterC3 is not None:
            element.set('hapkeParameterC3', self.gds_format_double(self.hapkeParameterC3))
        if self.hapkeParameterC2 is not None:
            element.set('hapkeParameterC2', self.gds_format_double(self.hapkeParameterC2))
        if self.useSameFactorForAllBands is not None:
            element.set('useSameFactorForAllBands', self.gds_format_integer(self.useSameFactorForAllBands))
        if self.hapkeParameterW is not None:
            element.set('hapkeParameterW', self.gds_format_double(self.hapkeParameterW))
        for hapkeMultiplicativeFactorForLUT_ in self.hapkeMultiplicativeFactorForLUT:
            hapkeMultiplicativeFactorForLUT_.to_etree(element, name_='hapkeMultiplicativeFactorForLUT', mapping_=mapping_)
        if self.opticalFactorMatrix is not None:
            opticalFactorMatrix_ = self.opticalFactorMatrix
            opticalFactorMatrix_.to_etree(element, name_='opticalFactorMatrix', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_hapkeNodeMultiplicativeFactorForLUT'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.diffuseTransmittanceFactor is not None and 'diffuseTransmittanceFactor' not in already_processed:
            already_processed.add('diffuseTransmittanceFactor')
            showIndent(outfile, level)
            outfile.write('diffuseTransmittanceFactor=%e,\n' % (self.diffuseTransmittanceFactor,))
        if self.directTransmittanceFactor is not None and 'directTransmittanceFactor' not in already_processed:
            already_processed.add('directTransmittanceFactor')
            showIndent(outfile, level)
            outfile.write('directTransmittanceFactor=%e,\n' % (self.directTransmittanceFactor,))
        if self.hapkeParameterH1 is not None and 'hapkeParameterH1' not in already_processed:
            already_processed.add('hapkeParameterH1')
            showIndent(outfile, level)
            outfile.write('hapkeParameterH1=%e,\n' % (self.hapkeParameterH1,))
        if self.hapkeParameterH2 is not None and 'hapkeParameterH2' not in already_processed:
            already_processed.add('hapkeParameterH2')
            showIndent(outfile, level)
            outfile.write('hapkeParameterH2=%e,\n' % (self.hapkeParameterH2,))
        if self.specularIntensityFactor is not None and 'specularIntensityFactor' not in already_processed:
            already_processed.add('specularIntensityFactor')
            showIndent(outfile, level)
            outfile.write('specularIntensityFactor=%e,\n' % (self.specularIntensityFactor,))
        if self.useSameOpticalFactorMatrixForAllBands is not None and 'useSameOpticalFactorMatrixForAllBands' not in already_processed:
            already_processed.add('useSameOpticalFactorMatrixForAllBands')
            showIndent(outfile, level)
            outfile.write('useSameOpticalFactorMatrixForAllBands=%d,\n' % (self.useSameOpticalFactorMatrixForAllBands,))
        if self.hapkeParameterC4 is not None and 'hapkeParameterC4' not in already_processed:
            already_processed.add('hapkeParameterC4')
            showIndent(outfile, level)
            outfile.write('hapkeParameterC4=%e,\n' % (self.hapkeParameterC4,))
        if self.hapkeParameterC1 is not None and 'hapkeParameterC1' not in already_processed:
            already_processed.add('hapkeParameterC1')
            showIndent(outfile, level)
            outfile.write('hapkeParameterC1=%e,\n' % (self.hapkeParameterC1,))
        if self.hapkeParameterC3 is not None and 'hapkeParameterC3' not in already_processed:
            already_processed.add('hapkeParameterC3')
            showIndent(outfile, level)
            outfile.write('hapkeParameterC3=%e,\n' % (self.hapkeParameterC3,))
        if self.hapkeParameterC2 is not None and 'hapkeParameterC2' not in already_processed:
            already_processed.add('hapkeParameterC2')
            showIndent(outfile, level)
            outfile.write('hapkeParameterC2=%e,\n' % (self.hapkeParameterC2,))
        if self.useSameFactorForAllBands is not None and 'useSameFactorForAllBands' not in already_processed:
            already_processed.add('useSameFactorForAllBands')
            showIndent(outfile, level)
            outfile.write('useSameFactorForAllBands=%d,\n' % (self.useSameFactorForAllBands,))
        if self.hapkeParameterW is not None and 'hapkeParameterW' not in already_processed:
            already_processed.add('hapkeParameterW')
            showIndent(outfile, level)
            outfile.write('hapkeParameterW=%e,\n' % (self.hapkeParameterW,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('hapkeMultiplicativeFactorForLUT=[\n')
        level += 1
        for hapkeMultiplicativeFactorForLUT_ in self.hapkeMultiplicativeFactorForLUT:
            showIndent(outfile, level)
            outfile.write('model_._hapkeMultiplicativeFactorForLUT(\n')
            hapkeMultiplicativeFactorForLUT_.exportLiteral(outfile, level, name_='_hapkeMultiplicativeFactorForLUT')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.opticalFactorMatrix is not None:
            showIndent(outfile, level)
            outfile.write('opticalFactorMatrix=model_._opticalFactorMatrix(\n')
            self.opticalFactorMatrix.exportLiteral(outfile, level, name_='opticalFactorMatrix')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.hapkeMultiplicativeFactorForLUT = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('diffuseTransmittanceFactor', node)
        if value is not None and 'diffuseTransmittanceFactor' not in already_processed:
            already_processed.add('diffuseTransmittanceFactor')
            try:
                self.diffuseTransmittanceFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (diffuseTransmittanceFactor): %s' % exp)
        value = find_attr_value_('directTransmittanceFactor', node)
        if value is not None and 'directTransmittanceFactor' not in already_processed:
            already_processed.add('directTransmittanceFactor')
            try:
                self.directTransmittanceFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (directTransmittanceFactor): %s' % exp)
        value = find_attr_value_('hapkeParameterH1', node)
        if value is not None and 'hapkeParameterH1' not in already_processed:
            already_processed.add('hapkeParameterH1')
            try:
                self.hapkeParameterH1 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (hapkeParameterH1): %s' % exp)
        value = find_attr_value_('hapkeParameterH2', node)
        if value is not None and 'hapkeParameterH2' not in already_processed:
            already_processed.add('hapkeParameterH2')
            try:
                self.hapkeParameterH2 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (hapkeParameterH2): %s' % exp)
        value = find_attr_value_('specularIntensityFactor', node)
        if value is not None and 'specularIntensityFactor' not in already_processed:
            already_processed.add('specularIntensityFactor')
            try:
                self.specularIntensityFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (specularIntensityFactor): %s' % exp)
        value = find_attr_value_('useSameOpticalFactorMatrixForAllBands', node)
        if value is not None and 'useSameOpticalFactorMatrixForAllBands' not in already_processed:
            already_processed.add('useSameOpticalFactorMatrixForAllBands')
            try:
                self.useSameOpticalFactorMatrixForAllBands = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('hapkeParameterC4', node)
        if value is not None and 'hapkeParameterC4' not in already_processed:
            already_processed.add('hapkeParameterC4')
            try:
                self.hapkeParameterC4 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (hapkeParameterC4): %s' % exp)
        value = find_attr_value_('hapkeParameterC1', node)
        if value is not None and 'hapkeParameterC1' not in already_processed:
            already_processed.add('hapkeParameterC1')
            try:
                self.hapkeParameterC1 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (hapkeParameterC1): %s' % exp)
        value = find_attr_value_('hapkeParameterC3', node)
        if value is not None and 'hapkeParameterC3' not in already_processed:
            already_processed.add('hapkeParameterC3')
            try:
                self.hapkeParameterC3 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (hapkeParameterC3): %s' % exp)
        value = find_attr_value_('hapkeParameterC2', node)
        if value is not None and 'hapkeParameterC2' not in already_processed:
            already_processed.add('hapkeParameterC2')
            try:
                self.hapkeParameterC2 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (hapkeParameterC2): %s' % exp)
        value = find_attr_value_('useSameFactorForAllBands', node)
        if value is not None and 'useSameFactorForAllBands' not in already_processed:
            already_processed.add('useSameFactorForAllBands')
            try:
                self.useSameFactorForAllBands = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('hapkeParameterW', node)
        if value is not None and 'hapkeParameterW' not in already_processed:
            already_processed.add('hapkeParameterW')
            try:
                self.hapkeParameterW = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (hapkeParameterW): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'hapkeMultiplicativeFactorForLUT':
            obj_ = create_hapkeMultiplicativeFactorForLUT.factory()
            obj_.build(child_)
            self.add_hapkeMultiplicativeFactorForLUT(obj_)
            obj_.original_tagname_ = 'hapkeMultiplicativeFactorForLUT'
        elif nodeName_ == 'opticalFactorMatrix':
            obj_ = create_opticalFactorMatrix.factory()
            obj_.build(child_)
            self.set_opticalFactorMatrix(obj_)
            obj_.original_tagname_ = 'opticalFactorMatrix'
# end class create_hapkeNodeMultiplicativeFactorForLUT


class create_hapkeMultiplicativeFactorForLUT(GeneratedsSuper):
    """Diffuse transmittance Diffuse transmittance Direct transmittance
    Direct transmittance H1 H1 H2 H2 Necessary for building up LUT
    tables with variable specular intensity values. \nA
    multispectral LUT can be computed applying the sequencer to DART
    mutispectral simulation with one spectral band each. Necessary
    for building up LUT tables with variable specular intensity
    values. \nA multispectral LUT can be computed applying the
    sequencer to DART mutispectral simulation with one spectral band
    each. C4 C4 C1 C1 C3 C3 C2 C2 W W Apply a 3D factor matrix per
    cell on optical properties Apply a 3D factor matrix per cell on
    optical properties"""
    subclass = None
    superclass = None
    def __init__(self, diffuseTransmittanceFactor=0, directTransmittanceFactor=0, hapkeParameterH1=1.0, hapkeParameterH2=1.0, specularIntensityFactor=1, hapkeParameterC4=1.0, hapkeParameterC1=1.0, hapkeParameterC3=1.0, hapkeParameterC2=1.0, hapkeParameterW=1.0, useOpticalFactorMatrix=0, opticalFactorMatrix=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_hapkeMultiplicativeFactorForLUT")
        self.attrib = ['diffuseTransmittanceFactor', 'directTransmittanceFactor', 'hapkeParameterH1', 'hapkeParameterH2', 'specularIntensityFactor', 'hapkeParameterC4', 'hapkeParameterC1', 'hapkeParameterC3', 'hapkeParameterC2', 'hapkeParameterW', 'useOpticalFactorMatrix']
        self.children = ['opticalFactorMatrix']
        self.parent = None
        self._diffuseTransmittanceFactor = _cast(float, diffuseTransmittanceFactor)
        self._directTransmittanceFactor = _cast(float, directTransmittanceFactor)
        self._hapkeParameterH1 = _cast(float, hapkeParameterH1)
        self._hapkeParameterH2 = _cast(float, hapkeParameterH2)
        self._specularIntensityFactor = _cast(float, specularIntensityFactor)
        self._hapkeParameterC4 = _cast(float, hapkeParameterC4)
        self._hapkeParameterC1 = _cast(float, hapkeParameterC1)
        self._hapkeParameterC3 = _cast(float, hapkeParameterC3)
        self._hapkeParameterC2 = _cast(float, hapkeParameterC2)
        self._hapkeParameterW = _cast(float, hapkeParameterW)
        self._useOpticalFactorMatrix = _cast(int, useOpticalFactorMatrix)
        self._opticalFactorMatrix = opticalFactorMatrix
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_hapkeMultiplicativeFactorForLUT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_hapkeMultiplicativeFactorForLUT.subclass:
            return create_hapkeMultiplicativeFactorForLUT.subclass(*args_, **kwargs_)
        else:
            return create_hapkeMultiplicativeFactorForLUT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_opticalFactorMatrix(self): return self._opticalFactorMatrix
    def set_opticalFactorMatrix(self, value):
        if value is not None:
            checkclass(value, create_opticalFactorMatrix)
            value.parent = self
        self._opticalFactorMatrix = value
    opticalFactorMatrix = property(get_opticalFactorMatrix, set_opticalFactorMatrix)
    def get_diffuseTransmittanceFactor(self): return self._diffuseTransmittanceFactor
    def set_diffuseTransmittanceFactor(self, value):
        self._diffuseTransmittanceFactor = value
        update_node(self,self.troot,"coeff_diff")
    diffuseTransmittanceFactor = property(get_diffuseTransmittanceFactor, set_diffuseTransmittanceFactor)
    def get_directTransmittanceFactor(self): return self._directTransmittanceFactor
    def set_directTransmittanceFactor(self, value):
        self._directTransmittanceFactor = value
        update_node(self,self.troot,"coeff_diff")
    directTransmittanceFactor = property(get_directTransmittanceFactor, set_directTransmittanceFactor)
    def get_hapkeParameterH1(self): return self._hapkeParameterH1
    def set_hapkeParameterH1(self, value):
        self._hapkeParameterH1 = value
        update_node(self,self.troot,"coeff_diff")
    hapkeParameterH1 = property(get_hapkeParameterH1, set_hapkeParameterH1)
    def get_hapkeParameterH2(self): return self._hapkeParameterH2
    def set_hapkeParameterH2(self, value):
        self._hapkeParameterH2 = value
        update_node(self,self.troot,"coeff_diff")
    hapkeParameterH2 = property(get_hapkeParameterH2, set_hapkeParameterH2)
    def get_specularIntensityFactor(self): return self._specularIntensityFactor
    def set_specularIntensityFactor(self, value):
        self._specularIntensityFactor = value
        update_node(self,self.troot,"coeff_diff")
    specularIntensityFactor = property(get_specularIntensityFactor, set_specularIntensityFactor)
    def get_hapkeParameterC4(self): return self._hapkeParameterC4
    def set_hapkeParameterC4(self, value):
        self._hapkeParameterC4 = value
        update_node(self,self.troot,"coeff_diff")
    hapkeParameterC4 = property(get_hapkeParameterC4, set_hapkeParameterC4)
    def get_hapkeParameterC1(self): return self._hapkeParameterC1
    def set_hapkeParameterC1(self, value):
        self._hapkeParameterC1 = value
        update_node(self,self.troot,"coeff_diff")
    hapkeParameterC1 = property(get_hapkeParameterC1, set_hapkeParameterC1)
    def get_hapkeParameterC3(self): return self._hapkeParameterC3
    def set_hapkeParameterC3(self, value):
        self._hapkeParameterC3 = value
        update_node(self,self.troot,"coeff_diff")
    hapkeParameterC3 = property(get_hapkeParameterC3, set_hapkeParameterC3)
    def get_hapkeParameterC2(self): return self._hapkeParameterC2
    def set_hapkeParameterC2(self, value):
        self._hapkeParameterC2 = value
        update_node(self,self.troot,"coeff_diff")
    hapkeParameterC2 = property(get_hapkeParameterC2, set_hapkeParameterC2)
    def get_hapkeParameterW(self): return self._hapkeParameterW
    def set_hapkeParameterW(self, value):
        self._hapkeParameterW = value
        update_node(self,self.troot,"coeff_diff")
    hapkeParameterW = property(get_hapkeParameterW, set_hapkeParameterW)
    def get_useOpticalFactorMatrix(self): return self._useOpticalFactorMatrix
    def set_useOpticalFactorMatrix(self, value):
        self._useOpticalFactorMatrix = value
        update_node(self,self.troot,"coeff_diff")
    useOpticalFactorMatrix = property(get_useOpticalFactorMatrix, set_useOpticalFactorMatrix)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.opticalFactorMatrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_hapkeMultiplicativeFactorForLUT', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_hapkeMultiplicativeFactorForLUT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_hapkeMultiplicativeFactorForLUT')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_hapkeMultiplicativeFactorForLUT', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_hapkeMultiplicativeFactorForLUT'):
        if self.diffuseTransmittanceFactor is not None and 'diffuseTransmittanceFactor' not in already_processed:
            already_processed.add('diffuseTransmittanceFactor')
            outfile.write(' diffuseTransmittanceFactor="%s"' % self.gds_format_double(self.diffuseTransmittanceFactor, input_name='diffuseTransmittanceFactor'))
        if self.directTransmittanceFactor is not None and 'directTransmittanceFactor' not in already_processed:
            already_processed.add('directTransmittanceFactor')
            outfile.write(' directTransmittanceFactor="%s"' % self.gds_format_double(self.directTransmittanceFactor, input_name='directTransmittanceFactor'))
        if self.hapkeParameterH1 is not None and 'hapkeParameterH1' not in already_processed:
            already_processed.add('hapkeParameterH1')
            outfile.write(' hapkeParameterH1="%s"' % self.gds_format_double(self.hapkeParameterH1, input_name='hapkeParameterH1'))
        if self.hapkeParameterH2 is not None and 'hapkeParameterH2' not in already_processed:
            already_processed.add('hapkeParameterH2')
            outfile.write(' hapkeParameterH2="%s"' % self.gds_format_double(self.hapkeParameterH2, input_name='hapkeParameterH2'))
        if self.specularIntensityFactor is not None and 'specularIntensityFactor' not in already_processed:
            already_processed.add('specularIntensityFactor')
            outfile.write(' specularIntensityFactor="%s"' % self.gds_format_double(self.specularIntensityFactor, input_name='specularIntensityFactor'))
        if self.hapkeParameterC4 is not None and 'hapkeParameterC4' not in already_processed:
            already_processed.add('hapkeParameterC4')
            outfile.write(' hapkeParameterC4="%s"' % self.gds_format_double(self.hapkeParameterC4, input_name='hapkeParameterC4'))
        if self.hapkeParameterC1 is not None and 'hapkeParameterC1' not in already_processed:
            already_processed.add('hapkeParameterC1')
            outfile.write(' hapkeParameterC1="%s"' % self.gds_format_double(self.hapkeParameterC1, input_name='hapkeParameterC1'))
        if self.hapkeParameterC3 is not None and 'hapkeParameterC3' not in already_processed:
            already_processed.add('hapkeParameterC3')
            outfile.write(' hapkeParameterC3="%s"' % self.gds_format_double(self.hapkeParameterC3, input_name='hapkeParameterC3'))
        if self.hapkeParameterC2 is not None and 'hapkeParameterC2' not in already_processed:
            already_processed.add('hapkeParameterC2')
            outfile.write(' hapkeParameterC2="%s"' % self.gds_format_double(self.hapkeParameterC2, input_name='hapkeParameterC2'))
        if self.hapkeParameterW is not None and 'hapkeParameterW' not in already_processed:
            already_processed.add('hapkeParameterW')
            outfile.write(' hapkeParameterW="%s"' % self.gds_format_double(self.hapkeParameterW, input_name='hapkeParameterW'))
        if self.useOpticalFactorMatrix is not None and 'useOpticalFactorMatrix' not in already_processed:
            already_processed.add('useOpticalFactorMatrix')
            outfile.write(' useOpticalFactorMatrix="%s"' % self.gds_format_integer(self.useOpticalFactorMatrix, input_name='useOpticalFactorMatrix'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_hapkeMultiplicativeFactorForLUT', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.opticalFactorMatrix is not None:
            self.opticalFactorMatrix.export(outfile, level, namespaceprefix_, name_='opticalFactorMatrix', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_hapkeMultiplicativeFactorForLUT', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.diffuseTransmittanceFactor is not None:
            element.set('diffuseTransmittanceFactor', self.gds_format_double(self.diffuseTransmittanceFactor))
        if self.directTransmittanceFactor is not None:
            element.set('directTransmittanceFactor', self.gds_format_double(self.directTransmittanceFactor))
        if self.hapkeParameterH1 is not None:
            element.set('hapkeParameterH1', self.gds_format_double(self.hapkeParameterH1))
        if self.hapkeParameterH2 is not None:
            element.set('hapkeParameterH2', self.gds_format_double(self.hapkeParameterH2))
        if self.specularIntensityFactor is not None:
            element.set('specularIntensityFactor', self.gds_format_double(self.specularIntensityFactor))
        if self.hapkeParameterC4 is not None:
            element.set('hapkeParameterC4', self.gds_format_double(self.hapkeParameterC4))
        if self.hapkeParameterC1 is not None:
            element.set('hapkeParameterC1', self.gds_format_double(self.hapkeParameterC1))
        if self.hapkeParameterC3 is not None:
            element.set('hapkeParameterC3', self.gds_format_double(self.hapkeParameterC3))
        if self.hapkeParameterC2 is not None:
            element.set('hapkeParameterC2', self.gds_format_double(self.hapkeParameterC2))
        if self.hapkeParameterW is not None:
            element.set('hapkeParameterW', self.gds_format_double(self.hapkeParameterW))
        if self.useOpticalFactorMatrix is not None:
            element.set('useOpticalFactorMatrix', self.gds_format_integer(self.useOpticalFactorMatrix))
        if self.opticalFactorMatrix is not None:
            opticalFactorMatrix_ = self.opticalFactorMatrix
            opticalFactorMatrix_.to_etree(element, name_='opticalFactorMatrix', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_hapkeMultiplicativeFactorForLUT'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.diffuseTransmittanceFactor is not None and 'diffuseTransmittanceFactor' not in already_processed:
            already_processed.add('diffuseTransmittanceFactor')
            showIndent(outfile, level)
            outfile.write('diffuseTransmittanceFactor=%e,\n' % (self.diffuseTransmittanceFactor,))
        if self.directTransmittanceFactor is not None and 'directTransmittanceFactor' not in already_processed:
            already_processed.add('directTransmittanceFactor')
            showIndent(outfile, level)
            outfile.write('directTransmittanceFactor=%e,\n' % (self.directTransmittanceFactor,))
        if self.hapkeParameterH1 is not None and 'hapkeParameterH1' not in already_processed:
            already_processed.add('hapkeParameterH1')
            showIndent(outfile, level)
            outfile.write('hapkeParameterH1=%e,\n' % (self.hapkeParameterH1,))
        if self.hapkeParameterH2 is not None and 'hapkeParameterH2' not in already_processed:
            already_processed.add('hapkeParameterH2')
            showIndent(outfile, level)
            outfile.write('hapkeParameterH2=%e,\n' % (self.hapkeParameterH2,))
        if self.specularIntensityFactor is not None and 'specularIntensityFactor' not in already_processed:
            already_processed.add('specularIntensityFactor')
            showIndent(outfile, level)
            outfile.write('specularIntensityFactor=%e,\n' % (self.specularIntensityFactor,))
        if self.hapkeParameterC4 is not None and 'hapkeParameterC4' not in already_processed:
            already_processed.add('hapkeParameterC4')
            showIndent(outfile, level)
            outfile.write('hapkeParameterC4=%e,\n' % (self.hapkeParameterC4,))
        if self.hapkeParameterC1 is not None and 'hapkeParameterC1' not in already_processed:
            already_processed.add('hapkeParameterC1')
            showIndent(outfile, level)
            outfile.write('hapkeParameterC1=%e,\n' % (self.hapkeParameterC1,))
        if self.hapkeParameterC3 is not None and 'hapkeParameterC3' not in already_processed:
            already_processed.add('hapkeParameterC3')
            showIndent(outfile, level)
            outfile.write('hapkeParameterC3=%e,\n' % (self.hapkeParameterC3,))
        if self.hapkeParameterC2 is not None and 'hapkeParameterC2' not in already_processed:
            already_processed.add('hapkeParameterC2')
            showIndent(outfile, level)
            outfile.write('hapkeParameterC2=%e,\n' % (self.hapkeParameterC2,))
        if self.hapkeParameterW is not None and 'hapkeParameterW' not in already_processed:
            already_processed.add('hapkeParameterW')
            showIndent(outfile, level)
            outfile.write('hapkeParameterW=%e,\n' % (self.hapkeParameterW,))
        if self.useOpticalFactorMatrix is not None and 'useOpticalFactorMatrix' not in already_processed:
            already_processed.add('useOpticalFactorMatrix')
            showIndent(outfile, level)
            outfile.write('useOpticalFactorMatrix=%d,\n' % (self.useOpticalFactorMatrix,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.opticalFactorMatrix is not None:
            showIndent(outfile, level)
            outfile.write('opticalFactorMatrix=model_._opticalFactorMatrix(\n')
            self.opticalFactorMatrix.exportLiteral(outfile, level, name_='opticalFactorMatrix')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('diffuseTransmittanceFactor', node)
        if value is not None and 'diffuseTransmittanceFactor' not in already_processed:
            already_processed.add('diffuseTransmittanceFactor')
            try:
                self.diffuseTransmittanceFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (diffuseTransmittanceFactor): %s' % exp)
        value = find_attr_value_('directTransmittanceFactor', node)
        if value is not None and 'directTransmittanceFactor' not in already_processed:
            already_processed.add('directTransmittanceFactor')
            try:
                self.directTransmittanceFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (directTransmittanceFactor): %s' % exp)
        value = find_attr_value_('hapkeParameterH1', node)
        if value is not None and 'hapkeParameterH1' not in already_processed:
            already_processed.add('hapkeParameterH1')
            try:
                self.hapkeParameterH1 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (hapkeParameterH1): %s' % exp)
        value = find_attr_value_('hapkeParameterH2', node)
        if value is not None and 'hapkeParameterH2' not in already_processed:
            already_processed.add('hapkeParameterH2')
            try:
                self.hapkeParameterH2 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (hapkeParameterH2): %s' % exp)
        value = find_attr_value_('specularIntensityFactor', node)
        if value is not None and 'specularIntensityFactor' not in already_processed:
            already_processed.add('specularIntensityFactor')
            try:
                self.specularIntensityFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (specularIntensityFactor): %s' % exp)
        value = find_attr_value_('hapkeParameterC4', node)
        if value is not None and 'hapkeParameterC4' not in already_processed:
            already_processed.add('hapkeParameterC4')
            try:
                self.hapkeParameterC4 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (hapkeParameterC4): %s' % exp)
        value = find_attr_value_('hapkeParameterC1', node)
        if value is not None and 'hapkeParameterC1' not in already_processed:
            already_processed.add('hapkeParameterC1')
            try:
                self.hapkeParameterC1 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (hapkeParameterC1): %s' % exp)
        value = find_attr_value_('hapkeParameterC3', node)
        if value is not None and 'hapkeParameterC3' not in already_processed:
            already_processed.add('hapkeParameterC3')
            try:
                self.hapkeParameterC3 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (hapkeParameterC3): %s' % exp)
        value = find_attr_value_('hapkeParameterC2', node)
        if value is not None and 'hapkeParameterC2' not in already_processed:
            already_processed.add('hapkeParameterC2')
            try:
                self.hapkeParameterC2 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (hapkeParameterC2): %s' % exp)
        value = find_attr_value_('hapkeParameterW', node)
        if value is not None and 'hapkeParameterW' not in already_processed:
            already_processed.add('hapkeParameterW')
            try:
                self.hapkeParameterW = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (hapkeParameterW): %s' % exp)
        value = find_attr_value_('useOpticalFactorMatrix', node)
        if value is not None and 'useOpticalFactorMatrix' not in already_processed:
            already_processed.add('useOpticalFactorMatrix')
            try:
                self.useOpticalFactorMatrix = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'opticalFactorMatrix':
            obj_ = create_opticalFactorMatrix.factory()
            obj_.build(child_)
            self.set_opticalFactorMatrix(obj_)
            obj_.original_tagname_ = 'opticalFactorMatrix'
# end class create_hapkeMultiplicativeFactorForLUT


class create_RPVMultiFunctions(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RPVMulti=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_RPVMultiFunctions")
        self.attrib = ['']
        self.children = ['RPVMulti']
        self.parent = None
        if RPVMulti is None:
            self._RPVMulti = []
        else:
            self._RPVMulti = RPVMulti
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_RPVMultiFunctions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_RPVMultiFunctions.subclass:
            return create_RPVMultiFunctions.subclass(*args_, **kwargs_)
        else:
            return create_RPVMultiFunctions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RPVMulti(self): return self._RPVMulti
    def set_RPVMulti(self, value):
        if value is not None:
            checkclass(value, create_RPVMulti)
            for v in value:
                v.parent = self
        self._RPVMulti = value
    def add_RPVMulti(self, value):
        value.parent = self
        self._RPVMulti.append(value)
    def insert_RPVMulti_at(self, index, value):
        value.parent = self
        self.RPVMulti.insert(index, value)
    def replace_RPVMulti_at(self, index, value):
        value.parent = self
        self.RPVMulti[index] = value
    RPVMulti = property(get_RPVMulti, set_RPVMulti)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.RPVMulti
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_RPVMultiFunctions', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_RPVMultiFunctions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_RPVMultiFunctions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_RPVMultiFunctions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_RPVMultiFunctions'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_RPVMultiFunctions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RPVMulti_ in self.RPVMulti:
            RPVMulti_.export(outfile, level, namespaceprefix_, name_='RPVMulti', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_RPVMultiFunctions', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for RPVMulti_ in self.RPVMulti:
            RPVMulti_.to_etree(element, name_='RPVMulti', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_RPVMultiFunctions'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('RPVMulti=[\n')
        level += 1
        for RPVMulti_ in self.RPVMulti:
            showIndent(outfile, level)
            outfile.write('model_._RPVMulti(\n')
            RPVMulti_.exportLiteral(outfile, level, name_='_RPVMulti')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.RPVMulti = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RPVMulti':
            obj_ = create_RPVMulti.factory()
            obj_.build(child_)
            self.add_RPVMulti(obj_)
            obj_.original_tagname_ = 'RPVMulti'
# end class create_RPVMultiFunctions


class create_RPVMulti(GeneratedsSuper):
    """Name of the spectral data base (text file) used to compute the
    spectral phase function(s) Name of the spectral data base (text
    file) used to compute the spectral phase function(s)
    Transmittance model Transmittance model Reflectance database
    Reflectance database useMultiplicativeFactorForLUT
    useMultiplicativeFactorForLUT Transmittance database
    Transmittance database proportion of photons intercepted along
    an incident direction that are scattered within a solid angle
    along a given direction proportion of photons intercepted along
    an incident direction that are scattered within a solid angle
    along a given direction Use specular Use specular"""
    subclass = None
    superclass = None
    def __init__(self, ModelName='basic', transmittanceModelName='reflect_equal_1_trans_equal_0_0', databaseName='RPV.db', useMultiplicativeFactorForLUT=1, transmittanceDatabaseName='Lambertian_vegetation.db', ident='RPV_Phase_Function_1', useSpecular=0, SpecularData=None, RPVNodeMultiplicativeFactorForLUT=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_RPVMulti")
        self.attrib = ['ModelName', 'transmittanceModelName', 'databaseName', 'useMultiplicativeFactorForLUT', 'transmittanceDatabaseName', 'ident', 'useSpecular']
        self.children = ['SpecularData', 'RPVNodeMultiplicativeFactorForLUT']
        self.parent = None
        self._ModelName = _cast(None, ModelName)
        self._transmittanceModelName = _cast(None, transmittanceModelName)
        self._databaseName = _cast(None, databaseName)
        self._useMultiplicativeFactorForLUT = _cast(int, useMultiplicativeFactorForLUT)
        self._transmittanceDatabaseName = _cast(None, transmittanceDatabaseName)
        self._ident = _cast(None, ident)
        self._useSpecular = _cast(int, useSpecular)
        self._SpecularData = SpecularData
        self._RPVNodeMultiplicativeFactorForLUT = RPVNodeMultiplicativeFactorForLUT
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_RPVMulti)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_RPVMulti.subclass:
            return create_RPVMulti.subclass(*args_, **kwargs_)
        else:
            return create_RPVMulti(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SpecularData(self): return self._SpecularData
    def set_SpecularData(self, value):
        if value is not None:
            checkclass(value, create_SpecularData)
            value.parent = self
        self._SpecularData = value
    SpecularData = property(get_SpecularData, set_SpecularData)
    def get_RPVNodeMultiplicativeFactorForLUT(self): return self._RPVNodeMultiplicativeFactorForLUT
    def set_RPVNodeMultiplicativeFactorForLUT(self, value):
        if value is not None:
            checkclass(value, create_RPVNodeMultiplicativeFactorForLUT)
            value.parent = self
        self._RPVNodeMultiplicativeFactorForLUT = value
    RPVNodeMultiplicativeFactorForLUT = property(get_RPVNodeMultiplicativeFactorForLUT, set_RPVNodeMultiplicativeFactorForLUT)
    def get_ModelName(self): return self._ModelName
    def set_ModelName(self, value):
        self._ModelName = value
        update_node(self,self.troot,"coeff_diff")
    ModelName = property(get_ModelName, set_ModelName)
    def get_transmittanceModelName(self): return self._transmittanceModelName
    def set_transmittanceModelName(self, value):
        self._transmittanceModelName = value
        update_node(self,self.troot,"coeff_diff")
    transmittanceModelName = property(get_transmittanceModelName, set_transmittanceModelName)
    def get_databaseName(self): return self._databaseName
    def set_databaseName(self, value):
        self._databaseName = value
        update_node(self,self.troot,"coeff_diff")
    databaseName = property(get_databaseName, set_databaseName)
    def get_useMultiplicativeFactorForLUT(self): return self._useMultiplicativeFactorForLUT
    def set_useMultiplicativeFactorForLUT(self, value):
        self._useMultiplicativeFactorForLUT = value
        update_node(self,self.troot,"coeff_diff")
    useMultiplicativeFactorForLUT = property(get_useMultiplicativeFactorForLUT, set_useMultiplicativeFactorForLUT)
    def get_transmittanceDatabaseName(self): return self._transmittanceDatabaseName
    def set_transmittanceDatabaseName(self, value):
        self._transmittanceDatabaseName = value
        update_node(self,self.troot,"coeff_diff")
    transmittanceDatabaseName = property(get_transmittanceDatabaseName, set_transmittanceDatabaseName)
    def get_ident(self): return self._ident
    def set_ident(self, value):
        self._ident = value
        update_node(self,self.troot,"coeff_diff")
    ident = property(get_ident, set_ident)
    def get_useSpecular(self): return self._useSpecular
    def set_useSpecular(self, value):
        self._useSpecular = value
        update_node(self,self.troot,"coeff_diff")
    useSpecular = property(get_useSpecular, set_useSpecular)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.SpecularData is not None or
            self.RPVNodeMultiplicativeFactorForLUT is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_RPVMulti', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_RPVMulti')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_RPVMulti')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_RPVMulti', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_RPVMulti'):
        if self.ModelName is not None and 'ModelName' not in already_processed:
            already_processed.add('ModelName')
            outfile.write(' ModelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ModelName), input_name='ModelName')), ))
        if self.transmittanceModelName is not None and 'transmittanceModelName' not in already_processed:
            already_processed.add('transmittanceModelName')
            outfile.write(' transmittanceModelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transmittanceModelName), input_name='transmittanceModelName')), ))
        if self.databaseName is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            outfile.write(' databaseName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.databaseName), input_name='databaseName')), ))
        if self.useMultiplicativeFactorForLUT is not None and 'useMultiplicativeFactorForLUT' not in already_processed:
            already_processed.add('useMultiplicativeFactorForLUT')
            outfile.write(' useMultiplicativeFactorForLUT="%s"' % self.gds_format_integer(self.useMultiplicativeFactorForLUT, input_name='useMultiplicativeFactorForLUT'))
        if self.transmittanceDatabaseName is not None and 'transmittanceDatabaseName' not in already_processed:
            already_processed.add('transmittanceDatabaseName')
            outfile.write(' transmittanceDatabaseName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transmittanceDatabaseName), input_name='transmittanceDatabaseName')), ))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            outfile.write(' ident=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ident), input_name='ident')), ))
        if self.useSpecular is not None and 'useSpecular' not in already_processed:
            already_processed.add('useSpecular')
            outfile.write(' useSpecular="%s"' % self.gds_format_integer(self.useSpecular, input_name='useSpecular'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_RPVMulti', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SpecularData is not None:
            self.SpecularData.export(outfile, level, namespaceprefix_, name_='SpecularData', pretty_print=pretty_print)
        if self.RPVNodeMultiplicativeFactorForLUT is not None:
            self.RPVNodeMultiplicativeFactorForLUT.export(outfile, level, namespaceprefix_, name_='RPVNodeMultiplicativeFactorForLUT', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_RPVMulti', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ModelName is not None:
            element.set('ModelName', self.gds_format_string(self.ModelName))
        if self.transmittanceModelName is not None:
            element.set('transmittanceModelName', self.gds_format_string(self.transmittanceModelName))
        if self.databaseName is not None:
            element.set('databaseName', self.gds_format_string(self.databaseName))
        if self.useMultiplicativeFactorForLUT is not None:
            element.set('useMultiplicativeFactorForLUT', self.gds_format_integer(self.useMultiplicativeFactorForLUT))
        if self.transmittanceDatabaseName is not None:
            element.set('transmittanceDatabaseName', self.gds_format_string(self.transmittanceDatabaseName))
        if self.ident is not None:
            element.set('ident', self.gds_format_string(self.ident))
        if self.useSpecular is not None:
            element.set('useSpecular', self.gds_format_integer(self.useSpecular))
        if self.SpecularData is not None:
            SpecularData_ = self.SpecularData
            SpecularData_.to_etree(element, name_='SpecularData', mapping_=mapping_)
        if self.RPVNodeMultiplicativeFactorForLUT is not None:
            RPVNodeMultiplicativeFactorForLUT_ = self.RPVNodeMultiplicativeFactorForLUT
            RPVNodeMultiplicativeFactorForLUT_.to_etree(element, name_='RPVNodeMultiplicativeFactorForLUT', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_RPVMulti'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ModelName is not None and 'ModelName' not in already_processed:
            already_processed.add('ModelName')
            showIndent(outfile, level)
            outfile.write('ModelName="%s",\n' % (self.ModelName,))
        if self.transmittanceModelName is not None and 'transmittanceModelName' not in already_processed:
            already_processed.add('transmittanceModelName')
            showIndent(outfile, level)
            outfile.write('transmittanceModelName="%s",\n' % (self.transmittanceModelName,))
        if self.databaseName is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            showIndent(outfile, level)
            outfile.write('databaseName="%s",\n' % (self.databaseName,))
        if self.useMultiplicativeFactorForLUT is not None and 'useMultiplicativeFactorForLUT' not in already_processed:
            already_processed.add('useMultiplicativeFactorForLUT')
            showIndent(outfile, level)
            outfile.write('useMultiplicativeFactorForLUT=%d,\n' % (self.useMultiplicativeFactorForLUT,))
        if self.transmittanceDatabaseName is not None and 'transmittanceDatabaseName' not in already_processed:
            already_processed.add('transmittanceDatabaseName')
            showIndent(outfile, level)
            outfile.write('transmittanceDatabaseName="%s",\n' % (self.transmittanceDatabaseName,))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            showIndent(outfile, level)
            outfile.write('ident="%s",\n' % (self.ident,))
        if self.useSpecular is not None and 'useSpecular' not in already_processed:
            already_processed.add('useSpecular')
            showIndent(outfile, level)
            outfile.write('useSpecular=%d,\n' % (self.useSpecular,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SpecularData is not None:
            showIndent(outfile, level)
            outfile.write('SpecularData=model_._SpecularData(\n')
            self.SpecularData.exportLiteral(outfile, level, name_='SpecularData')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RPVNodeMultiplicativeFactorForLUT is not None:
            showIndent(outfile, level)
            outfile.write('RPVNodeMultiplicativeFactorForLUT=model_._RPVNodeMultiplicativeFactorForLUT(\n')
            self.RPVNodeMultiplicativeFactorForLUT.exportLiteral(outfile, level, name_='RPVNodeMultiplicativeFactorForLUT')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ModelName', node)
        if value is not None and 'ModelName' not in already_processed:
            already_processed.add('ModelName')
            self.ModelName = value
        value = find_attr_value_('transmittanceModelName', node)
        if value is not None and 'transmittanceModelName' not in already_processed:
            already_processed.add('transmittanceModelName')
            self.transmittanceModelName = value
        value = find_attr_value_('databaseName', node)
        if value is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            self.databaseName = value
        value = find_attr_value_('useMultiplicativeFactorForLUT', node)
        if value is not None and 'useMultiplicativeFactorForLUT' not in already_processed:
            already_processed.add('useMultiplicativeFactorForLUT')
            try:
                self.useMultiplicativeFactorForLUT = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('transmittanceDatabaseName', node)
        if value is not None and 'transmittanceDatabaseName' not in already_processed:
            already_processed.add('transmittanceDatabaseName')
            self.transmittanceDatabaseName = value
        value = find_attr_value_('ident', node)
        if value is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            self.ident = value
        value = find_attr_value_('useSpecular', node)
        if value is not None and 'useSpecular' not in already_processed:
            already_processed.add('useSpecular')
            try:
                self.useSpecular = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SpecularData':
            obj_ = create_SpecularData.factory()
            obj_.build(child_)
            self.set_SpecularData(obj_)
            obj_.original_tagname_ = 'SpecularData'
        elif nodeName_ == 'RPVNodeMultiplicativeFactorForLUT':
            obj_ = create_RPVNodeMultiplicativeFactorForLUT.factory()
            obj_.build(child_)
            self.set_RPVNodeMultiplicativeFactorForLUT(obj_)
            obj_.original_tagname_ = 'RPVNodeMultiplicativeFactorForLUT'
# end class create_RPVMulti


class create_RPVNodeMultiplicativeFactorForLUT(GeneratedsSuper):
    """g g Diffuse transmittance Diffuse transmittance Direct transmittance
    Direct transmittance k k Apply the same 3D factor matrix per
    cell on optical properties to all the spectral bands Apply the
    same 3D factor matrix per cell on optical properties to all the
    spectral bands h h When selected, the parameters values of every
    spectral band will be equal to these parameters. When selected,
    the parameters values of every spectral band will be equal to
    these parameters. Rho_0 Rho_0 Necessary for building up LUT
    tables with variable specular intensity values. \nA
    multispectral LUT can be computed applying the sequencer to DART
    mutispectral simulation with one spectral band each. Necessary
    for building up LUT tables with variable specular intensity
    values. \nA multispectral LUT can be computed applying the
    sequencer to DART mutispectral simulation with one spectral band
    each."""
    subclass = None
    superclass = None
    def __init__(self, g_RPVMultiplicativeFactor=0.1, diffuseTransmittanceFactor=1, directTransmittanceFactor=1, k_RPVMultiplicativeFactor=0.95, useSameOpticalFactorMatrixForAllBands=0, h_RPVMultiplicativeFactor=0.7, useSameFactorForAllBands=1, rhoZero_RPVMultiplicativeFactor=0.70, specularIntensityFactor=1, RPVMultiplicativeFactorForLUT=None, opticalFactorMatrix=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_RPVNodeMultiplicativeFactorForLUT")
        self.attrib = ['g_RPVMultiplicativeFactor', 'diffuseTransmittanceFactor', 'directTransmittanceFactor', 'k_RPVMultiplicativeFactor', 'useSameOpticalFactorMatrixForAllBands', 'h_RPVMultiplicativeFactor', 'useSameFactorForAllBands', 'rhoZero_RPVMultiplicativeFactor', 'specularIntensityFactor']
        self.children = ['RPVMultiplicativeFactorForLUT', 'opticalFactorMatrix']
        self.parent = None
        self._g_RPVMultiplicativeFactor = _cast(float, g_RPVMultiplicativeFactor)
        self._diffuseTransmittanceFactor = _cast(float, diffuseTransmittanceFactor)
        self._directTransmittanceFactor = _cast(float, directTransmittanceFactor)
        self._k_RPVMultiplicativeFactor = _cast(float, k_RPVMultiplicativeFactor)
        self._useSameOpticalFactorMatrixForAllBands = _cast(int, useSameOpticalFactorMatrixForAllBands)
        self._h_RPVMultiplicativeFactor = _cast(float, h_RPVMultiplicativeFactor)
        self._useSameFactorForAllBands = _cast(int, useSameFactorForAllBands)
        self._rhoZero_RPVMultiplicativeFactor = _cast(float, rhoZero_RPVMultiplicativeFactor)
        self._specularIntensityFactor = _cast(float, specularIntensityFactor)
        if RPVMultiplicativeFactorForLUT is None:
            self._RPVMultiplicativeFactorForLUT = []
        else:
            self._RPVMultiplicativeFactorForLUT = RPVMultiplicativeFactorForLUT
        self._opticalFactorMatrix = opticalFactorMatrix
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_RPVNodeMultiplicativeFactorForLUT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_RPVNodeMultiplicativeFactorForLUT.subclass:
            return create_RPVNodeMultiplicativeFactorForLUT.subclass(*args_, **kwargs_)
        else:
            return create_RPVNodeMultiplicativeFactorForLUT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RPVMultiplicativeFactorForLUT(self): return self._RPVMultiplicativeFactorForLUT
    def set_RPVMultiplicativeFactorForLUT(self, value):
        if value is not None:
            checkclass(value, create_RPVMultiplicativeFactorForLUT)
            for v in value:
                v.parent = self
        self._RPVMultiplicativeFactorForLUT = value
    def add_RPVMultiplicativeFactorForLUT(self, value):
        value.parent = self
        self._RPVMultiplicativeFactorForLUT.append(value)
    def insert_RPVMultiplicativeFactorForLUT_at(self, index, value):
        value.parent = self
        self.RPVMultiplicativeFactorForLUT.insert(index, value)
    def replace_RPVMultiplicativeFactorForLUT_at(self, index, value):
        value.parent = self
        self.RPVMultiplicativeFactorForLUT[index] = value
    RPVMultiplicativeFactorForLUT = property(get_RPVMultiplicativeFactorForLUT, set_RPVMultiplicativeFactorForLUT)
    def get_opticalFactorMatrix(self): return self._opticalFactorMatrix
    def set_opticalFactorMatrix(self, value):
        if value is not None:
            checkclass(value, create_opticalFactorMatrix)
            value.parent = self
        self._opticalFactorMatrix = value
    opticalFactorMatrix = property(get_opticalFactorMatrix, set_opticalFactorMatrix)
    def get_g_RPVMultiplicativeFactor(self): return self._g_RPVMultiplicativeFactor
    def set_g_RPVMultiplicativeFactor(self, value):
        self._g_RPVMultiplicativeFactor = value
        update_node(self,self.troot,"coeff_diff")
    g_RPVMultiplicativeFactor = property(get_g_RPVMultiplicativeFactor, set_g_RPVMultiplicativeFactor)
    def get_diffuseTransmittanceFactor(self): return self._diffuseTransmittanceFactor
    def set_diffuseTransmittanceFactor(self, value):
        self._diffuseTransmittanceFactor = value
        update_node(self,self.troot,"coeff_diff")
    diffuseTransmittanceFactor = property(get_diffuseTransmittanceFactor, set_diffuseTransmittanceFactor)
    def get_directTransmittanceFactor(self): return self._directTransmittanceFactor
    def set_directTransmittanceFactor(self, value):
        self._directTransmittanceFactor = value
        update_node(self,self.troot,"coeff_diff")
    directTransmittanceFactor = property(get_directTransmittanceFactor, set_directTransmittanceFactor)
    def get_k_RPVMultiplicativeFactor(self): return self._k_RPVMultiplicativeFactor
    def set_k_RPVMultiplicativeFactor(self, value):
        self._k_RPVMultiplicativeFactor = value
        update_node(self,self.troot,"coeff_diff")
    k_RPVMultiplicativeFactor = property(get_k_RPVMultiplicativeFactor, set_k_RPVMultiplicativeFactor)
    def get_useSameOpticalFactorMatrixForAllBands(self): return self._useSameOpticalFactorMatrixForAllBands
    def set_useSameOpticalFactorMatrixForAllBands(self, value):
        self._useSameOpticalFactorMatrixForAllBands = value
        update_node(self,self.troot,"coeff_diff")
    useSameOpticalFactorMatrixForAllBands = property(get_useSameOpticalFactorMatrixForAllBands, set_useSameOpticalFactorMatrixForAllBands)
    def get_h_RPVMultiplicativeFactor(self): return self._h_RPVMultiplicativeFactor
    def set_h_RPVMultiplicativeFactor(self, value):
        self._h_RPVMultiplicativeFactor = value
        update_node(self,self.troot,"coeff_diff")
    h_RPVMultiplicativeFactor = property(get_h_RPVMultiplicativeFactor, set_h_RPVMultiplicativeFactor)
    def get_useSameFactorForAllBands(self): return self._useSameFactorForAllBands
    def set_useSameFactorForAllBands(self, value):
        self._useSameFactorForAllBands = value
        update_node(self,self.troot,"coeff_diff")
    useSameFactorForAllBands = property(get_useSameFactorForAllBands, set_useSameFactorForAllBands)
    def get_rhoZero_RPVMultiplicativeFactor(self): return self._rhoZero_RPVMultiplicativeFactor
    def set_rhoZero_RPVMultiplicativeFactor(self, value):
        self._rhoZero_RPVMultiplicativeFactor = value
        update_node(self,self.troot,"coeff_diff")
    rhoZero_RPVMultiplicativeFactor = property(get_rhoZero_RPVMultiplicativeFactor, set_rhoZero_RPVMultiplicativeFactor)
    def get_specularIntensityFactor(self): return self._specularIntensityFactor
    def set_specularIntensityFactor(self, value):
        self._specularIntensityFactor = value
        update_node(self,self.troot,"coeff_diff")
    specularIntensityFactor = property(get_specularIntensityFactor, set_specularIntensityFactor)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.RPVMultiplicativeFactorForLUT or
            self.opticalFactorMatrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_RPVNodeMultiplicativeFactorForLUT', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_RPVNodeMultiplicativeFactorForLUT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_RPVNodeMultiplicativeFactorForLUT')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_RPVNodeMultiplicativeFactorForLUT', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_RPVNodeMultiplicativeFactorForLUT'):
        if self.g_RPVMultiplicativeFactor is not None and 'g_RPVMultiplicativeFactor' not in already_processed:
            already_processed.add('g_RPVMultiplicativeFactor')
            outfile.write(' g_RPVMultiplicativeFactor="%s"' % self.gds_format_double(self.g_RPVMultiplicativeFactor, input_name='g_RPVMultiplicativeFactor'))
        if self.diffuseTransmittanceFactor is not None and 'diffuseTransmittanceFactor' not in already_processed:
            already_processed.add('diffuseTransmittanceFactor')
            outfile.write(' diffuseTransmittanceFactor="%s"' % self.gds_format_double(self.diffuseTransmittanceFactor, input_name='diffuseTransmittanceFactor'))
        if self.directTransmittanceFactor is not None and 'directTransmittanceFactor' not in already_processed:
            already_processed.add('directTransmittanceFactor')
            outfile.write(' directTransmittanceFactor="%s"' % self.gds_format_double(self.directTransmittanceFactor, input_name='directTransmittanceFactor'))
        if self.k_RPVMultiplicativeFactor is not None and 'k_RPVMultiplicativeFactor' not in already_processed:
            already_processed.add('k_RPVMultiplicativeFactor')
            outfile.write(' k_RPVMultiplicativeFactor="%s"' % self.gds_format_double(self.k_RPVMultiplicativeFactor, input_name='k_RPVMultiplicativeFactor'))
        if self.useSameOpticalFactorMatrixForAllBands is not None and 'useSameOpticalFactorMatrixForAllBands' not in already_processed:
            already_processed.add('useSameOpticalFactorMatrixForAllBands')
            outfile.write(' useSameOpticalFactorMatrixForAllBands="%s"' % self.gds_format_integer(self.useSameOpticalFactorMatrixForAllBands, input_name='useSameOpticalFactorMatrixForAllBands'))
        if self.h_RPVMultiplicativeFactor is not None and 'h_RPVMultiplicativeFactor' not in already_processed:
            already_processed.add('h_RPVMultiplicativeFactor')
            outfile.write(' h_RPVMultiplicativeFactor="%s"' % self.gds_format_double(self.h_RPVMultiplicativeFactor, input_name='h_RPVMultiplicativeFactor'))
        if self.useSameFactorForAllBands is not None and 'useSameFactorForAllBands' not in already_processed:
            already_processed.add('useSameFactorForAllBands')
            outfile.write(' useSameFactorForAllBands="%s"' % self.gds_format_integer(self.useSameFactorForAllBands, input_name='useSameFactorForAllBands'))
        if self.rhoZero_RPVMultiplicativeFactor is not None and 'rhoZero_RPVMultiplicativeFactor' not in already_processed:
            already_processed.add('rhoZero_RPVMultiplicativeFactor')
            outfile.write(' rhoZero_RPVMultiplicativeFactor="%s"' % self.gds_format_double(self.rhoZero_RPVMultiplicativeFactor, input_name='rhoZero_RPVMultiplicativeFactor'))
        if self.specularIntensityFactor is not None and 'specularIntensityFactor' not in already_processed:
            already_processed.add('specularIntensityFactor')
            outfile.write(' specularIntensityFactor="%s"' % self.gds_format_double(self.specularIntensityFactor, input_name='specularIntensityFactor'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_RPVNodeMultiplicativeFactorForLUT', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RPVMultiplicativeFactorForLUT_ in self.RPVMultiplicativeFactorForLUT:
            RPVMultiplicativeFactorForLUT_.export(outfile, level, namespaceprefix_, name_='RPVMultiplicativeFactorForLUT', pretty_print=pretty_print)
        if self.opticalFactorMatrix is not None:
            self.opticalFactorMatrix.export(outfile, level, namespaceprefix_, name_='opticalFactorMatrix', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_RPVNodeMultiplicativeFactorForLUT', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.g_RPVMultiplicativeFactor is not None:
            element.set('g_RPVMultiplicativeFactor', self.gds_format_double(self.g_RPVMultiplicativeFactor))
        if self.diffuseTransmittanceFactor is not None:
            element.set('diffuseTransmittanceFactor', self.gds_format_double(self.diffuseTransmittanceFactor))
        if self.directTransmittanceFactor is not None:
            element.set('directTransmittanceFactor', self.gds_format_double(self.directTransmittanceFactor))
        if self.k_RPVMultiplicativeFactor is not None:
            element.set('k_RPVMultiplicativeFactor', self.gds_format_double(self.k_RPVMultiplicativeFactor))
        if self.useSameOpticalFactorMatrixForAllBands is not None:
            element.set('useSameOpticalFactorMatrixForAllBands', self.gds_format_integer(self.useSameOpticalFactorMatrixForAllBands))
        if self.h_RPVMultiplicativeFactor is not None:
            element.set('h_RPVMultiplicativeFactor', self.gds_format_double(self.h_RPVMultiplicativeFactor))
        if self.useSameFactorForAllBands is not None:
            element.set('useSameFactorForAllBands', self.gds_format_integer(self.useSameFactorForAllBands))
        if self.rhoZero_RPVMultiplicativeFactor is not None:
            element.set('rhoZero_RPVMultiplicativeFactor', self.gds_format_double(self.rhoZero_RPVMultiplicativeFactor))
        if self.specularIntensityFactor is not None:
            element.set('specularIntensityFactor', self.gds_format_double(self.specularIntensityFactor))
        for RPVMultiplicativeFactorForLUT_ in self.RPVMultiplicativeFactorForLUT:
            RPVMultiplicativeFactorForLUT_.to_etree(element, name_='RPVMultiplicativeFactorForLUT', mapping_=mapping_)
        if self.opticalFactorMatrix is not None:
            opticalFactorMatrix_ = self.opticalFactorMatrix
            opticalFactorMatrix_.to_etree(element, name_='opticalFactorMatrix', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_RPVNodeMultiplicativeFactorForLUT'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.g_RPVMultiplicativeFactor is not None and 'g_RPVMultiplicativeFactor' not in already_processed:
            already_processed.add('g_RPVMultiplicativeFactor')
            showIndent(outfile, level)
            outfile.write('g_RPVMultiplicativeFactor=%e,\n' % (self.g_RPVMultiplicativeFactor,))
        if self.diffuseTransmittanceFactor is not None and 'diffuseTransmittanceFactor' not in already_processed:
            already_processed.add('diffuseTransmittanceFactor')
            showIndent(outfile, level)
            outfile.write('diffuseTransmittanceFactor=%e,\n' % (self.diffuseTransmittanceFactor,))
        if self.directTransmittanceFactor is not None and 'directTransmittanceFactor' not in already_processed:
            already_processed.add('directTransmittanceFactor')
            showIndent(outfile, level)
            outfile.write('directTransmittanceFactor=%e,\n' % (self.directTransmittanceFactor,))
        if self.k_RPVMultiplicativeFactor is not None and 'k_RPVMultiplicativeFactor' not in already_processed:
            already_processed.add('k_RPVMultiplicativeFactor')
            showIndent(outfile, level)
            outfile.write('k_RPVMultiplicativeFactor=%e,\n' % (self.k_RPVMultiplicativeFactor,))
        if self.useSameOpticalFactorMatrixForAllBands is not None and 'useSameOpticalFactorMatrixForAllBands' not in already_processed:
            already_processed.add('useSameOpticalFactorMatrixForAllBands')
            showIndent(outfile, level)
            outfile.write('useSameOpticalFactorMatrixForAllBands=%d,\n' % (self.useSameOpticalFactorMatrixForAllBands,))
        if self.h_RPVMultiplicativeFactor is not None and 'h_RPVMultiplicativeFactor' not in already_processed:
            already_processed.add('h_RPVMultiplicativeFactor')
            showIndent(outfile, level)
            outfile.write('h_RPVMultiplicativeFactor=%e,\n' % (self.h_RPVMultiplicativeFactor,))
        if self.useSameFactorForAllBands is not None and 'useSameFactorForAllBands' not in already_processed:
            already_processed.add('useSameFactorForAllBands')
            showIndent(outfile, level)
            outfile.write('useSameFactorForAllBands=%d,\n' % (self.useSameFactorForAllBands,))
        if self.rhoZero_RPVMultiplicativeFactor is not None and 'rhoZero_RPVMultiplicativeFactor' not in already_processed:
            already_processed.add('rhoZero_RPVMultiplicativeFactor')
            showIndent(outfile, level)
            outfile.write('rhoZero_RPVMultiplicativeFactor=%e,\n' % (self.rhoZero_RPVMultiplicativeFactor,))
        if self.specularIntensityFactor is not None and 'specularIntensityFactor' not in already_processed:
            already_processed.add('specularIntensityFactor')
            showIndent(outfile, level)
            outfile.write('specularIntensityFactor=%e,\n' % (self.specularIntensityFactor,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('RPVMultiplicativeFactorForLUT=[\n')
        level += 1
        for RPVMultiplicativeFactorForLUT_ in self.RPVMultiplicativeFactorForLUT:
            showIndent(outfile, level)
            outfile.write('model_._RPVMultiplicativeFactorForLUT(\n')
            RPVMultiplicativeFactorForLUT_.exportLiteral(outfile, level, name_='_RPVMultiplicativeFactorForLUT')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.opticalFactorMatrix is not None:
            showIndent(outfile, level)
            outfile.write('opticalFactorMatrix=model_._opticalFactorMatrix(\n')
            self.opticalFactorMatrix.exportLiteral(outfile, level, name_='opticalFactorMatrix')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.RPVMultiplicativeFactorForLUT = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('g_RPVMultiplicativeFactor', node)
        if value is not None and 'g_RPVMultiplicativeFactor' not in already_processed:
            already_processed.add('g_RPVMultiplicativeFactor')
            try:
                self.g_RPVMultiplicativeFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (g_RPVMultiplicativeFactor): %s' % exp)
        value = find_attr_value_('diffuseTransmittanceFactor', node)
        if value is not None and 'diffuseTransmittanceFactor' not in already_processed:
            already_processed.add('diffuseTransmittanceFactor')
            try:
                self.diffuseTransmittanceFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (diffuseTransmittanceFactor): %s' % exp)
        value = find_attr_value_('directTransmittanceFactor', node)
        if value is not None and 'directTransmittanceFactor' not in already_processed:
            already_processed.add('directTransmittanceFactor')
            try:
                self.directTransmittanceFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (directTransmittanceFactor): %s' % exp)
        value = find_attr_value_('k_RPVMultiplicativeFactor', node)
        if value is not None and 'k_RPVMultiplicativeFactor' not in already_processed:
            already_processed.add('k_RPVMultiplicativeFactor')
            try:
                self.k_RPVMultiplicativeFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (k_RPVMultiplicativeFactor): %s' % exp)
        value = find_attr_value_('useSameOpticalFactorMatrixForAllBands', node)
        if value is not None and 'useSameOpticalFactorMatrixForAllBands' not in already_processed:
            already_processed.add('useSameOpticalFactorMatrixForAllBands')
            try:
                self.useSameOpticalFactorMatrixForAllBands = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('h_RPVMultiplicativeFactor', node)
        if value is not None and 'h_RPVMultiplicativeFactor' not in already_processed:
            already_processed.add('h_RPVMultiplicativeFactor')
            try:
                self.h_RPVMultiplicativeFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (h_RPVMultiplicativeFactor): %s' % exp)
        value = find_attr_value_('useSameFactorForAllBands', node)
        if value is not None and 'useSameFactorForAllBands' not in already_processed:
            already_processed.add('useSameFactorForAllBands')
            try:
                self.useSameFactorForAllBands = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('rhoZero_RPVMultiplicativeFactor', node)
        if value is not None and 'rhoZero_RPVMultiplicativeFactor' not in already_processed:
            already_processed.add('rhoZero_RPVMultiplicativeFactor')
            try:
                self.rhoZero_RPVMultiplicativeFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (rhoZero_RPVMultiplicativeFactor): %s' % exp)
        value = find_attr_value_('specularIntensityFactor', node)
        if value is not None and 'specularIntensityFactor' not in already_processed:
            already_processed.add('specularIntensityFactor')
            try:
                self.specularIntensityFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (specularIntensityFactor): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RPVMultiplicativeFactorForLUT':
            obj_ = create_RPVMultiplicativeFactorForLUT.factory()
            obj_.build(child_)
            self.add_RPVMultiplicativeFactorForLUT(obj_)
            obj_.original_tagname_ = 'RPVMultiplicativeFactorForLUT'
        elif nodeName_ == 'opticalFactorMatrix':
            obj_ = create_opticalFactorMatrix.factory()
            obj_.build(child_)
            self.set_opticalFactorMatrix(obj_)
            obj_.original_tagname_ = 'opticalFactorMatrix'
# end class create_RPVNodeMultiplicativeFactorForLUT


class create_RPVMultiplicativeFactorForLUT(GeneratedsSuper):
    """g g Diffuse transmittance Diffuse transmittance Direct transmittance
    Direct transmittance k k h h Rho_0 Rho_0 Necessary for building
    up LUT tables with variable specular intensity values. \nA
    multispectral LUT can be computed applying the sequencer to DART
    mutispectral simulation with one spectral band each. Necessary
    for building up LUT tables with variable specular intensity
    values. \nA multispectral LUT can be computed applying the
    sequencer to DART mutispectral simulation with one spectral band
    each. Apply a 3D factor matrix per cell on optical properties
    Apply a 3D factor matrix per cell on optical properties"""
    subclass = None
    superclass = None
    def __init__(self, g_RPVMultiplicativeFactor=0.1, diffuseTransmittanceFactor=1, directTransmittanceFactor=1, k_RPVMultiplicativeFactor=0.95, h_RPVMultiplicativeFactor=0.7, rhoZero_RPVMultiplicativeFactor=0.70, specularIntensityFactor=1, useOpticalFactorMatrix=0, opticalFactorMatrix=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_RPVMultiplicativeFactorForLUT")
        self.attrib = ['g_RPVMultiplicativeFactor', 'diffuseTransmittanceFactor', 'directTransmittanceFactor', 'k_RPVMultiplicativeFactor', 'h_RPVMultiplicativeFactor', 'rhoZero_RPVMultiplicativeFactor', 'specularIntensityFactor', 'useOpticalFactorMatrix']
        self.children = ['opticalFactorMatrix']
        self.parent = None
        self._g_RPVMultiplicativeFactor = _cast(float, g_RPVMultiplicativeFactor)
        self._diffuseTransmittanceFactor = _cast(float, diffuseTransmittanceFactor)
        self._directTransmittanceFactor = _cast(float, directTransmittanceFactor)
        self._k_RPVMultiplicativeFactor = _cast(float, k_RPVMultiplicativeFactor)
        self._h_RPVMultiplicativeFactor = _cast(float, h_RPVMultiplicativeFactor)
        self._rhoZero_RPVMultiplicativeFactor = _cast(float, rhoZero_RPVMultiplicativeFactor)
        self._specularIntensityFactor = _cast(float, specularIntensityFactor)
        self._useOpticalFactorMatrix = _cast(int, useOpticalFactorMatrix)
        self._opticalFactorMatrix = opticalFactorMatrix
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_RPVMultiplicativeFactorForLUT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_RPVMultiplicativeFactorForLUT.subclass:
            return create_RPVMultiplicativeFactorForLUT.subclass(*args_, **kwargs_)
        else:
            return create_RPVMultiplicativeFactorForLUT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_opticalFactorMatrix(self): return self._opticalFactorMatrix
    def set_opticalFactorMatrix(self, value):
        if value is not None:
            checkclass(value, create_opticalFactorMatrix)
            value.parent = self
        self._opticalFactorMatrix = value
    opticalFactorMatrix = property(get_opticalFactorMatrix, set_opticalFactorMatrix)
    def get_g_RPVMultiplicativeFactor(self): return self._g_RPVMultiplicativeFactor
    def set_g_RPVMultiplicativeFactor(self, value):
        self._g_RPVMultiplicativeFactor = value
        update_node(self,self.troot,"coeff_diff")
    g_RPVMultiplicativeFactor = property(get_g_RPVMultiplicativeFactor, set_g_RPVMultiplicativeFactor)
    def get_diffuseTransmittanceFactor(self): return self._diffuseTransmittanceFactor
    def set_diffuseTransmittanceFactor(self, value):
        self._diffuseTransmittanceFactor = value
        update_node(self,self.troot,"coeff_diff")
    diffuseTransmittanceFactor = property(get_diffuseTransmittanceFactor, set_diffuseTransmittanceFactor)
    def get_directTransmittanceFactor(self): return self._directTransmittanceFactor
    def set_directTransmittanceFactor(self, value):
        self._directTransmittanceFactor = value
        update_node(self,self.troot,"coeff_diff")
    directTransmittanceFactor = property(get_directTransmittanceFactor, set_directTransmittanceFactor)
    def get_k_RPVMultiplicativeFactor(self): return self._k_RPVMultiplicativeFactor
    def set_k_RPVMultiplicativeFactor(self, value):
        self._k_RPVMultiplicativeFactor = value
        update_node(self,self.troot,"coeff_diff")
    k_RPVMultiplicativeFactor = property(get_k_RPVMultiplicativeFactor, set_k_RPVMultiplicativeFactor)
    def get_h_RPVMultiplicativeFactor(self): return self._h_RPVMultiplicativeFactor
    def set_h_RPVMultiplicativeFactor(self, value):
        self._h_RPVMultiplicativeFactor = value
        update_node(self,self.troot,"coeff_diff")
    h_RPVMultiplicativeFactor = property(get_h_RPVMultiplicativeFactor, set_h_RPVMultiplicativeFactor)
    def get_rhoZero_RPVMultiplicativeFactor(self): return self._rhoZero_RPVMultiplicativeFactor
    def set_rhoZero_RPVMultiplicativeFactor(self, value):
        self._rhoZero_RPVMultiplicativeFactor = value
        update_node(self,self.troot,"coeff_diff")
    rhoZero_RPVMultiplicativeFactor = property(get_rhoZero_RPVMultiplicativeFactor, set_rhoZero_RPVMultiplicativeFactor)
    def get_specularIntensityFactor(self): return self._specularIntensityFactor
    def set_specularIntensityFactor(self, value):
        self._specularIntensityFactor = value
        update_node(self,self.troot,"coeff_diff")
    specularIntensityFactor = property(get_specularIntensityFactor, set_specularIntensityFactor)
    def get_useOpticalFactorMatrix(self): return self._useOpticalFactorMatrix
    def set_useOpticalFactorMatrix(self, value):
        self._useOpticalFactorMatrix = value
        update_node(self,self.troot,"coeff_diff")
    useOpticalFactorMatrix = property(get_useOpticalFactorMatrix, set_useOpticalFactorMatrix)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.opticalFactorMatrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_RPVMultiplicativeFactorForLUT', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_RPVMultiplicativeFactorForLUT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_RPVMultiplicativeFactorForLUT')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_RPVMultiplicativeFactorForLUT', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_RPVMultiplicativeFactorForLUT'):
        if self.g_RPVMultiplicativeFactor is not None and 'g_RPVMultiplicativeFactor' not in already_processed:
            already_processed.add('g_RPVMultiplicativeFactor')
            outfile.write(' g_RPVMultiplicativeFactor="%s"' % self.gds_format_double(self.g_RPVMultiplicativeFactor, input_name='g_RPVMultiplicativeFactor'))
        if self.diffuseTransmittanceFactor is not None and 'diffuseTransmittanceFactor' not in already_processed:
            already_processed.add('diffuseTransmittanceFactor')
            outfile.write(' diffuseTransmittanceFactor="%s"' % self.gds_format_double(self.diffuseTransmittanceFactor, input_name='diffuseTransmittanceFactor'))
        if self.directTransmittanceFactor is not None and 'directTransmittanceFactor' not in already_processed:
            already_processed.add('directTransmittanceFactor')
            outfile.write(' directTransmittanceFactor="%s"' % self.gds_format_double(self.directTransmittanceFactor, input_name='directTransmittanceFactor'))
        if self.k_RPVMultiplicativeFactor is not None and 'k_RPVMultiplicativeFactor' not in already_processed:
            already_processed.add('k_RPVMultiplicativeFactor')
            outfile.write(' k_RPVMultiplicativeFactor="%s"' % self.gds_format_double(self.k_RPVMultiplicativeFactor, input_name='k_RPVMultiplicativeFactor'))
        if self.h_RPVMultiplicativeFactor is not None and 'h_RPVMultiplicativeFactor' not in already_processed:
            already_processed.add('h_RPVMultiplicativeFactor')
            outfile.write(' h_RPVMultiplicativeFactor="%s"' % self.gds_format_double(self.h_RPVMultiplicativeFactor, input_name='h_RPVMultiplicativeFactor'))
        if self.rhoZero_RPVMultiplicativeFactor is not None and 'rhoZero_RPVMultiplicativeFactor' not in already_processed:
            already_processed.add('rhoZero_RPVMultiplicativeFactor')
            outfile.write(' rhoZero_RPVMultiplicativeFactor="%s"' % self.gds_format_double(self.rhoZero_RPVMultiplicativeFactor, input_name='rhoZero_RPVMultiplicativeFactor'))
        if self.specularIntensityFactor is not None and 'specularIntensityFactor' not in already_processed:
            already_processed.add('specularIntensityFactor')
            outfile.write(' specularIntensityFactor="%s"' % self.gds_format_double(self.specularIntensityFactor, input_name='specularIntensityFactor'))
        if self.useOpticalFactorMatrix is not None and 'useOpticalFactorMatrix' not in already_processed:
            already_processed.add('useOpticalFactorMatrix')
            outfile.write(' useOpticalFactorMatrix="%s"' % self.gds_format_integer(self.useOpticalFactorMatrix, input_name='useOpticalFactorMatrix'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_RPVMultiplicativeFactorForLUT', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.opticalFactorMatrix is not None:
            self.opticalFactorMatrix.export(outfile, level, namespaceprefix_, name_='opticalFactorMatrix', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_RPVMultiplicativeFactorForLUT', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.g_RPVMultiplicativeFactor is not None:
            element.set('g_RPVMultiplicativeFactor', self.gds_format_double(self.g_RPVMultiplicativeFactor))
        if self.diffuseTransmittanceFactor is not None:
            element.set('diffuseTransmittanceFactor', self.gds_format_double(self.diffuseTransmittanceFactor))
        if self.directTransmittanceFactor is not None:
            element.set('directTransmittanceFactor', self.gds_format_double(self.directTransmittanceFactor))
        if self.k_RPVMultiplicativeFactor is not None:
            element.set('k_RPVMultiplicativeFactor', self.gds_format_double(self.k_RPVMultiplicativeFactor))
        if self.h_RPVMultiplicativeFactor is not None:
            element.set('h_RPVMultiplicativeFactor', self.gds_format_double(self.h_RPVMultiplicativeFactor))
        if self.rhoZero_RPVMultiplicativeFactor is not None:
            element.set('rhoZero_RPVMultiplicativeFactor', self.gds_format_double(self.rhoZero_RPVMultiplicativeFactor))
        if self.specularIntensityFactor is not None:
            element.set('specularIntensityFactor', self.gds_format_double(self.specularIntensityFactor))
        if self.useOpticalFactorMatrix is not None:
            element.set('useOpticalFactorMatrix', self.gds_format_integer(self.useOpticalFactorMatrix))
        if self.opticalFactorMatrix is not None:
            opticalFactorMatrix_ = self.opticalFactorMatrix
            opticalFactorMatrix_.to_etree(element, name_='opticalFactorMatrix', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_RPVMultiplicativeFactorForLUT'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.g_RPVMultiplicativeFactor is not None and 'g_RPVMultiplicativeFactor' not in already_processed:
            already_processed.add('g_RPVMultiplicativeFactor')
            showIndent(outfile, level)
            outfile.write('g_RPVMultiplicativeFactor=%e,\n' % (self.g_RPVMultiplicativeFactor,))
        if self.diffuseTransmittanceFactor is not None and 'diffuseTransmittanceFactor' not in already_processed:
            already_processed.add('diffuseTransmittanceFactor')
            showIndent(outfile, level)
            outfile.write('diffuseTransmittanceFactor=%e,\n' % (self.diffuseTransmittanceFactor,))
        if self.directTransmittanceFactor is not None and 'directTransmittanceFactor' not in already_processed:
            already_processed.add('directTransmittanceFactor')
            showIndent(outfile, level)
            outfile.write('directTransmittanceFactor=%e,\n' % (self.directTransmittanceFactor,))
        if self.k_RPVMultiplicativeFactor is not None and 'k_RPVMultiplicativeFactor' not in already_processed:
            already_processed.add('k_RPVMultiplicativeFactor')
            showIndent(outfile, level)
            outfile.write('k_RPVMultiplicativeFactor=%e,\n' % (self.k_RPVMultiplicativeFactor,))
        if self.h_RPVMultiplicativeFactor is not None and 'h_RPVMultiplicativeFactor' not in already_processed:
            already_processed.add('h_RPVMultiplicativeFactor')
            showIndent(outfile, level)
            outfile.write('h_RPVMultiplicativeFactor=%e,\n' % (self.h_RPVMultiplicativeFactor,))
        if self.rhoZero_RPVMultiplicativeFactor is not None and 'rhoZero_RPVMultiplicativeFactor' not in already_processed:
            already_processed.add('rhoZero_RPVMultiplicativeFactor')
            showIndent(outfile, level)
            outfile.write('rhoZero_RPVMultiplicativeFactor=%e,\n' % (self.rhoZero_RPVMultiplicativeFactor,))
        if self.specularIntensityFactor is not None and 'specularIntensityFactor' not in already_processed:
            already_processed.add('specularIntensityFactor')
            showIndent(outfile, level)
            outfile.write('specularIntensityFactor=%e,\n' % (self.specularIntensityFactor,))
        if self.useOpticalFactorMatrix is not None and 'useOpticalFactorMatrix' not in already_processed:
            already_processed.add('useOpticalFactorMatrix')
            showIndent(outfile, level)
            outfile.write('useOpticalFactorMatrix=%d,\n' % (self.useOpticalFactorMatrix,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.opticalFactorMatrix is not None:
            showIndent(outfile, level)
            outfile.write('opticalFactorMatrix=model_._opticalFactorMatrix(\n')
            self.opticalFactorMatrix.exportLiteral(outfile, level, name_='opticalFactorMatrix')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('g_RPVMultiplicativeFactor', node)
        if value is not None and 'g_RPVMultiplicativeFactor' not in already_processed:
            already_processed.add('g_RPVMultiplicativeFactor')
            try:
                self.g_RPVMultiplicativeFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (g_RPVMultiplicativeFactor): %s' % exp)
        value = find_attr_value_('diffuseTransmittanceFactor', node)
        if value is not None and 'diffuseTransmittanceFactor' not in already_processed:
            already_processed.add('diffuseTransmittanceFactor')
            try:
                self.diffuseTransmittanceFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (diffuseTransmittanceFactor): %s' % exp)
        value = find_attr_value_('directTransmittanceFactor', node)
        if value is not None and 'directTransmittanceFactor' not in already_processed:
            already_processed.add('directTransmittanceFactor')
            try:
                self.directTransmittanceFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (directTransmittanceFactor): %s' % exp)
        value = find_attr_value_('k_RPVMultiplicativeFactor', node)
        if value is not None and 'k_RPVMultiplicativeFactor' not in already_processed:
            already_processed.add('k_RPVMultiplicativeFactor')
            try:
                self.k_RPVMultiplicativeFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (k_RPVMultiplicativeFactor): %s' % exp)
        value = find_attr_value_('h_RPVMultiplicativeFactor', node)
        if value is not None and 'h_RPVMultiplicativeFactor' not in already_processed:
            already_processed.add('h_RPVMultiplicativeFactor')
            try:
                self.h_RPVMultiplicativeFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (h_RPVMultiplicativeFactor): %s' % exp)
        value = find_attr_value_('rhoZero_RPVMultiplicativeFactor', node)
        if value is not None and 'rhoZero_RPVMultiplicativeFactor' not in already_processed:
            already_processed.add('rhoZero_RPVMultiplicativeFactor')
            try:
                self.rhoZero_RPVMultiplicativeFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (rhoZero_RPVMultiplicativeFactor): %s' % exp)
        value = find_attr_value_('specularIntensityFactor', node)
        if value is not None and 'specularIntensityFactor' not in already_processed:
            already_processed.add('specularIntensityFactor')
            try:
                self.specularIntensityFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (specularIntensityFactor): %s' % exp)
        value = find_attr_value_('useOpticalFactorMatrix', node)
        if value is not None and 'useOpticalFactorMatrix' not in already_processed:
            already_processed.add('useOpticalFactorMatrix')
            try:
                self.useOpticalFactorMatrix = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'opticalFactorMatrix':
            obj_ = create_opticalFactorMatrix.factory()
            obj_.build(child_)
            self.set_opticalFactorMatrix(obj_)
            obj_.original_tagname_ = 'opticalFactorMatrix'
# end class create_RPVMultiplicativeFactorForLUT


class create_UnderstoryMultiFunctions(GeneratedsSuper):
    """Integration step on theta for the computation of phase functions (1
    - 90).\nThe algorithm takes the nearest value from : 1, 2, 3, 5,
    6, 9, 10, 15, 18, 30, 45, 90 Integration step on theta for the
    computation of phase functions (1 - 90).\nThe algorithm takes
    the nearest value from : 1, 2, 3, 5, 6, 9, 10, 15, 18, 30, 45,
    90 Integration step on phi for the computation of phase
    functions (1 - 360).\nThe algorithm takes the nearest value from
    : 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 18, 20, 24, 30, 36, 40,
    45, 60, 72, 90, 120, 180, 360 Integration step on phi for the
    computation of phase functions (1 - 360).\nThe algorithm takes
    the nearest value from : 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 18,
    20, 24, 30, 36, 40, 45, 60, 72, 90, 120, 180, 360 Write computed
    LAD into the file : output/lib_phase/LAD.txt Write computed LAD
    into the file : output/lib_phase/LAD.txt"""
    subclass = None
    superclass = None
    def __init__(self, integrationStepOnTheta=1, integrationStepOnPhi=10, outputLADFile=0, UnderstoryMulti=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_UnderstoryMultiFunctions")
        self.attrib = ['integrationStepOnTheta', 'integrationStepOnPhi', 'outputLADFile']
        self.children = ['UnderstoryMulti']
        self.parent = None
        self._integrationStepOnTheta = _cast(int, integrationStepOnTheta)
        self._integrationStepOnPhi = _cast(int, integrationStepOnPhi)
        self._outputLADFile = _cast(int, outputLADFile)
        if UnderstoryMulti is None:
            self._UnderstoryMulti = []
        else:
            self._UnderstoryMulti = UnderstoryMulti
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_UnderstoryMultiFunctions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_UnderstoryMultiFunctions.subclass:
            return create_UnderstoryMultiFunctions.subclass(*args_, **kwargs_)
        else:
            return create_UnderstoryMultiFunctions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UnderstoryMulti(self): return self._UnderstoryMulti
    def set_UnderstoryMulti(self, value):
        if value is not None:
            checkclass(value, create_UnderstoryMulti)
            for v in value:
                v.parent = self
        self._UnderstoryMulti = value
    def add_UnderstoryMulti(self, value):
        value.parent = self
        self._UnderstoryMulti.append(value)
    def insert_UnderstoryMulti_at(self, index, value):
        value.parent = self
        self.UnderstoryMulti.insert(index, value)
    def replace_UnderstoryMulti_at(self, index, value):
        value.parent = self
        self.UnderstoryMulti[index] = value
    UnderstoryMulti = property(get_UnderstoryMulti, set_UnderstoryMulti)
    def get_integrationStepOnTheta(self): return self._integrationStepOnTheta
    def set_integrationStepOnTheta(self, value):
        self._integrationStepOnTheta = value
        update_node(self,self.troot,"coeff_diff")
    integrationStepOnTheta = property(get_integrationStepOnTheta, set_integrationStepOnTheta)
    def get_integrationStepOnPhi(self): return self._integrationStepOnPhi
    def set_integrationStepOnPhi(self, value):
        self._integrationStepOnPhi = value
        update_node(self,self.troot,"coeff_diff")
    integrationStepOnPhi = property(get_integrationStepOnPhi, set_integrationStepOnPhi)
    def get_outputLADFile(self): return self._outputLADFile
    def set_outputLADFile(self, value):
        self._outputLADFile = value
        update_node(self,self.troot,"coeff_diff")
    outputLADFile = property(get_outputLADFile, set_outputLADFile)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.UnderstoryMulti
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_UnderstoryMultiFunctions', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_UnderstoryMultiFunctions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_UnderstoryMultiFunctions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_UnderstoryMultiFunctions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_UnderstoryMultiFunctions'):
        if self.integrationStepOnTheta is not None and 'integrationStepOnTheta' not in already_processed:
            already_processed.add('integrationStepOnTheta')
            outfile.write(' integrationStepOnTheta="%s"' % self.gds_format_integer(self.integrationStepOnTheta, input_name='integrationStepOnTheta'))
        if self.integrationStepOnPhi is not None and 'integrationStepOnPhi' not in already_processed:
            already_processed.add('integrationStepOnPhi')
            outfile.write(' integrationStepOnPhi="%s"' % self.gds_format_integer(self.integrationStepOnPhi, input_name='integrationStepOnPhi'))
        if self.outputLADFile is not None and 'outputLADFile' not in already_processed:
            already_processed.add('outputLADFile')
            outfile.write(' outputLADFile="%s"' % self.gds_format_integer(self.outputLADFile, input_name='outputLADFile'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_UnderstoryMultiFunctions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for UnderstoryMulti_ in self.UnderstoryMulti:
            UnderstoryMulti_.export(outfile, level, namespaceprefix_, name_='UnderstoryMulti', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_UnderstoryMultiFunctions', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.integrationStepOnTheta is not None:
            element.set('integrationStepOnTheta', self.gds_format_integer(self.integrationStepOnTheta))
        if self.integrationStepOnPhi is not None:
            element.set('integrationStepOnPhi', self.gds_format_integer(self.integrationStepOnPhi))
        if self.outputLADFile is not None:
            element.set('outputLADFile', self.gds_format_integer(self.outputLADFile))
        for UnderstoryMulti_ in self.UnderstoryMulti:
            UnderstoryMulti_.to_etree(element, name_='UnderstoryMulti', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_UnderstoryMultiFunctions'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.integrationStepOnTheta is not None and 'integrationStepOnTheta' not in already_processed:
            already_processed.add('integrationStepOnTheta')
            showIndent(outfile, level)
            outfile.write('integrationStepOnTheta=%d,\n' % (self.integrationStepOnTheta,))
        if self.integrationStepOnPhi is not None and 'integrationStepOnPhi' not in already_processed:
            already_processed.add('integrationStepOnPhi')
            showIndent(outfile, level)
            outfile.write('integrationStepOnPhi=%d,\n' % (self.integrationStepOnPhi,))
        if self.outputLADFile is not None and 'outputLADFile' not in already_processed:
            already_processed.add('outputLADFile')
            showIndent(outfile, level)
            outfile.write('outputLADFile=%d,\n' % (self.outputLADFile,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('UnderstoryMulti=[\n')
        level += 1
        for UnderstoryMulti_ in self.UnderstoryMulti:
            showIndent(outfile, level)
            outfile.write('model_._UnderstoryMulti(\n')
            UnderstoryMulti_.exportLiteral(outfile, level, name_='_UnderstoryMulti')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.UnderstoryMulti = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('integrationStepOnTheta', node)
        if value is not None and 'integrationStepOnTheta' not in already_processed:
            already_processed.add('integrationStepOnTheta')
            try:
                self.integrationStepOnTheta = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('integrationStepOnPhi', node)
        if value is not None and 'integrationStepOnPhi' not in already_processed:
            already_processed.add('integrationStepOnPhi')
            try:
                self.integrationStepOnPhi = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('outputLADFile', node)
        if value is not None and 'outputLADFile' not in already_processed:
            already_processed.add('outputLADFile')
            try:
                self.outputLADFile = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UnderstoryMulti':
            obj_ = create_UnderstoryMulti.factory()
            obj_.build(child_)
            self.add_UnderstoryMulti(obj_)
            obj_.original_tagname_ = 'UnderstoryMulti'
# end class create_UnderstoryMultiFunctions


class create_UnderstoryMulti(GeneratedsSuper):
    """Name of the spectral data base (text file) used to compute the
    spectral phase function(s) Name of the spectral data base (text
    file) used to compute the spectral phase function(s) 0 for no
    hot spot) 0 for no hot spot) Leaf Angle Distribution\nNot used
    for "Triangle" to "Turbid" transformation.\nIn that case, there
    are several LADs and these LADs are ellipsoidal Leaf Angle
    Distribution\nNot used for "Triangle" to "Turbid"
    transformation.\nIn that case, there are several LADs and these
    LADs are ellipsoidal Use specular Use specular proportion of
    photons intercepted along an incident direction that are
    scattered within a solid angle along a given direction
    proportion of photons intercepted along an incident direction
    that are scattered within a solid angle along a given direction
    Reflectance database Reflectance database
    useMultiplicativeFactorForLUT useMultiplicativeFactorForLUT
    Apply a 3D factor matrix per cell on optical properties Apply a
    3D factor matrix per cell on optical properties"""
    subclass = None
    superclass = None
    def __init__(self, ModelName='leaf_deciduous', dimFoliar=0.01, lad=1, useSpecular=0, ident='Turbid_Leaf_Deciduous_Phase_Function', databaseName='Vegetation.db', useMultiplicativeFactorForLUT=1, useOpticalFactorMatrix=0, SpecularData=None, Ellipsoidal=None, Elliptical=None, UserDefined=None, Manual=None, BoundedUniform=None, DirectionalClumpingIndexProperties=None, ProspectExternalModule=None, understoryNodeMultiplicativeFactorForLUT=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_UnderstoryMulti")
        self.attrib = ['ModelName', 'dimFoliar', 'lad', 'useSpecular', 'ident', 'databaseName', 'useMultiplicativeFactorForLUT', 'useOpticalFactorMatrix']
        self.children = ['SpecularData', 'Ellipsoidal', 'Elliptical', 'UserDefined', 'Manual', 'BoundedUniform', 'DirectionalClumpingIndexProperties', 'ProspectExternalModule', 'understoryNodeMultiplicativeFactorForLUT']
        self.parent = None
        self._ModelName = _cast(None, ModelName)
        self._dimFoliar = _cast(float, dimFoliar)
        self._lad = _cast(int, lad)
        self._useSpecular = _cast(int, useSpecular)
        self._ident = _cast(None, ident)
        self._databaseName = _cast(None, databaseName)
        self._useMultiplicativeFactorForLUT = _cast(int, useMultiplicativeFactorForLUT)
        self._useOpticalFactorMatrix = _cast(int, useOpticalFactorMatrix)
        self._SpecularData = SpecularData
        self._Ellipsoidal = Ellipsoidal
        self._Elliptical = Elliptical
        self._UserDefined = UserDefined
        self._Manual = Manual
        self._BoundedUniform = BoundedUniform
        self._DirectionalClumpingIndexProperties = DirectionalClumpingIndexProperties
        self._ProspectExternalModule = ProspectExternalModule
        self._understoryNodeMultiplicativeFactorForLUT = understoryNodeMultiplicativeFactorForLUT
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_UnderstoryMulti)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_UnderstoryMulti.subclass:
            return create_UnderstoryMulti.subclass(*args_, **kwargs_)
        else:
            return create_UnderstoryMulti(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SpecularData(self): return self._SpecularData
    def set_SpecularData(self, value):
        if value is not None:
            checkclass(value, create_SpecularData)
            value.parent = self
        self._SpecularData = value
    SpecularData = property(get_SpecularData, set_SpecularData)
    def get_Ellipsoidal(self): return self._Ellipsoidal
    def set_Ellipsoidal(self, value):
        if value is not None:
            checkclass(value, create_Ellipsoidal)
            value.parent = self
        self._Ellipsoidal = value
    Ellipsoidal = property(get_Ellipsoidal, set_Ellipsoidal)
    def get_Elliptical(self): return self._Elliptical
    def set_Elliptical(self, value):
        if value is not None:
            checkclass(value, create_Elliptical)
            value.parent = self
        self._Elliptical = value
    Elliptical = property(get_Elliptical, set_Elliptical)
    def get_UserDefined(self): return self._UserDefined
    def set_UserDefined(self, value):
        if value is not None:
            checkclass(value, create_UserDefined)
            value.parent = self
        self._UserDefined = value
    UserDefined = property(get_UserDefined, set_UserDefined)
    def get_Manual(self): return self._Manual
    def set_Manual(self, value):
        if value is not None:
            checkclass(value, create_Manual)
            value.parent = self
        self._Manual = value
    Manual = property(get_Manual, set_Manual)
    def get_BoundedUniform(self): return self._BoundedUniform
    def set_BoundedUniform(self, value):
        if value is not None:
            checkclass(value, create_BoundedUniform)
            value.parent = self
        self._BoundedUniform = value
    BoundedUniform = property(get_BoundedUniform, set_BoundedUniform)
    def get_DirectionalClumpingIndexProperties(self): return self._DirectionalClumpingIndexProperties
    def set_DirectionalClumpingIndexProperties(self, value):
        if value is not None:
            checkclass(value, create_DirectionalClumpingIndexProperties)
            value.parent = self
        self._DirectionalClumpingIndexProperties = value
    DirectionalClumpingIndexProperties = property(get_DirectionalClumpingIndexProperties, set_DirectionalClumpingIndexProperties)
    def get_ProspectExternalModule(self): return self._ProspectExternalModule
    def set_ProspectExternalModule(self, value):
        if value is not None:
            checkclass(value, create_ProspectExternalModule)
            value.parent = self
        self._ProspectExternalModule = value
    ProspectExternalModule = property(get_ProspectExternalModule, set_ProspectExternalModule)
    def get_understoryNodeMultiplicativeFactorForLUT(self): return self._understoryNodeMultiplicativeFactorForLUT
    def set_understoryNodeMultiplicativeFactorForLUT(self, value):
        if value is not None:
            checkclass(value, create_understoryNodeMultiplicativeFactorForLUT)
            value.parent = self
        self._understoryNodeMultiplicativeFactorForLUT = value
    understoryNodeMultiplicativeFactorForLUT = property(get_understoryNodeMultiplicativeFactorForLUT, set_understoryNodeMultiplicativeFactorForLUT)
    def get_ModelName(self): return self._ModelName
    def set_ModelName(self, value):
        self._ModelName = value
        update_node(self,self.troot,"coeff_diff")
    ModelName = property(get_ModelName, set_ModelName)
    def get_dimFoliar(self): return self._dimFoliar
    def set_dimFoliar(self, value):
        self._dimFoliar = value
        update_node(self,self.troot,"coeff_diff")
    dimFoliar = property(get_dimFoliar, set_dimFoliar)
    def get_lad(self): return self._lad
    def set_lad(self, value):
        self._lad = value
        update_node(self,self.troot,"coeff_diff")
    lad = property(get_lad, set_lad)
    def get_useSpecular(self): return self._useSpecular
    def set_useSpecular(self, value):
        self._useSpecular = value
        update_node(self,self.troot,"coeff_diff")
    useSpecular = property(get_useSpecular, set_useSpecular)
    def get_ident(self): return self._ident
    def set_ident(self, value):
        self._ident = value
        update_node(self,self.troot,"coeff_diff")
    ident = property(get_ident, set_ident)
    def get_databaseName(self): return self._databaseName
    def set_databaseName(self, value):
        self._databaseName = value
        update_node(self,self.troot,"coeff_diff")
    databaseName = property(get_databaseName, set_databaseName)
    def get_useMultiplicativeFactorForLUT(self): return self._useMultiplicativeFactorForLUT
    def set_useMultiplicativeFactorForLUT(self, value):
        self._useMultiplicativeFactorForLUT = value
        update_node(self,self.troot,"coeff_diff")
    useMultiplicativeFactorForLUT = property(get_useMultiplicativeFactorForLUT, set_useMultiplicativeFactorForLUT)
    def get_useOpticalFactorMatrix(self): return self._useOpticalFactorMatrix
    def set_useOpticalFactorMatrix(self, value):
        self._useOpticalFactorMatrix = value
        update_node(self,self.troot,"coeff_diff")
    useOpticalFactorMatrix = property(get_useOpticalFactorMatrix, set_useOpticalFactorMatrix)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.SpecularData is not None or
            self.Ellipsoidal is not None or
            self.Elliptical is not None or
            self.UserDefined is not None or
            self.Manual is not None or
            self.BoundedUniform is not None or
            self.DirectionalClumpingIndexProperties is not None or
            self.ProspectExternalModule is not None or
            self.understoryNodeMultiplicativeFactorForLUT is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_UnderstoryMulti', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_UnderstoryMulti')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_UnderstoryMulti')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_UnderstoryMulti', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_UnderstoryMulti'):
        if self.ModelName is not None and 'ModelName' not in already_processed:
            already_processed.add('ModelName')
            outfile.write(' ModelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ModelName), input_name='ModelName')), ))
        if self.dimFoliar is not None and 'dimFoliar' not in already_processed:
            already_processed.add('dimFoliar')
            outfile.write(' dimFoliar="%s"' % self.gds_format_double(self.dimFoliar, input_name='dimFoliar'))
        if self.lad is not None and 'lad' not in already_processed:
            already_processed.add('lad')
            outfile.write(' lad="%s"' % self.gds_format_integer(self.lad, input_name='lad'))
        if self.useSpecular is not None and 'useSpecular' not in already_processed:
            already_processed.add('useSpecular')
            outfile.write(' useSpecular="%s"' % self.gds_format_integer(self.useSpecular, input_name='useSpecular'))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            outfile.write(' ident=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ident), input_name='ident')), ))
        if self.databaseName is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            outfile.write(' databaseName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.databaseName), input_name='databaseName')), ))
        if self.useMultiplicativeFactorForLUT is not None and 'useMultiplicativeFactorForLUT' not in already_processed:
            already_processed.add('useMultiplicativeFactorForLUT')
            outfile.write(' useMultiplicativeFactorForLUT="%s"' % self.gds_format_integer(self.useMultiplicativeFactorForLUT, input_name='useMultiplicativeFactorForLUT'))
        if self.useOpticalFactorMatrix is not None and 'useOpticalFactorMatrix' not in already_processed:
            already_processed.add('useOpticalFactorMatrix')
            outfile.write(' useOpticalFactorMatrix="%s"' % self.gds_format_integer(self.useOpticalFactorMatrix, input_name='useOpticalFactorMatrix'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_UnderstoryMulti', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SpecularData is not None:
            self.SpecularData.export(outfile, level, namespaceprefix_, name_='SpecularData', pretty_print=pretty_print)
        if self.Ellipsoidal is not None:
            self.Ellipsoidal.export(outfile, level, namespaceprefix_, name_='Ellipsoidal', pretty_print=pretty_print)
        if self.Elliptical is not None:
            self.Elliptical.export(outfile, level, namespaceprefix_, name_='Elliptical', pretty_print=pretty_print)
        if self.UserDefined is not None:
            self.UserDefined.export(outfile, level, namespaceprefix_, name_='UserDefined', pretty_print=pretty_print)
        if self.Manual is not None:
            self.Manual.export(outfile, level, namespaceprefix_, name_='Manual', pretty_print=pretty_print)
        if self.BoundedUniform is not None:
            self.BoundedUniform.export(outfile, level, namespaceprefix_, name_='BoundedUniform', pretty_print=pretty_print)
        if self.DirectionalClumpingIndexProperties is not None:
            self.DirectionalClumpingIndexProperties.export(outfile, level, namespaceprefix_, name_='DirectionalClumpingIndexProperties', pretty_print=pretty_print)
        if self.ProspectExternalModule is not None:
            self.ProspectExternalModule.export(outfile, level, namespaceprefix_, name_='ProspectExternalModule', pretty_print=pretty_print)
        if self.understoryNodeMultiplicativeFactorForLUT is not None:
            self.understoryNodeMultiplicativeFactorForLUT.export(outfile, level, namespaceprefix_, name_='understoryNodeMultiplicativeFactorForLUT', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_UnderstoryMulti', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ModelName is not None:
            element.set('ModelName', self.gds_format_string(self.ModelName))
        if self.dimFoliar is not None:
            element.set('dimFoliar', self.gds_format_double(self.dimFoliar))
        if self.lad is not None:
            element.set('lad', self.gds_format_integer(self.lad))
        if self.useSpecular is not None:
            element.set('useSpecular', self.gds_format_integer(self.useSpecular))
        if self.ident is not None:
            element.set('ident', self.gds_format_string(self.ident))
        if self.databaseName is not None:
            element.set('databaseName', self.gds_format_string(self.databaseName))
        if self.useMultiplicativeFactorForLUT is not None:
            element.set('useMultiplicativeFactorForLUT', self.gds_format_integer(self.useMultiplicativeFactorForLUT))
        if self.useOpticalFactorMatrix is not None:
            element.set('useOpticalFactorMatrix', self.gds_format_integer(self.useOpticalFactorMatrix))
        if self.SpecularData is not None:
            SpecularData_ = self.SpecularData
            SpecularData_.to_etree(element, name_='SpecularData', mapping_=mapping_)
        if self.Ellipsoidal is not None:
            Ellipsoidal_ = self.Ellipsoidal
            Ellipsoidal_.to_etree(element, name_='Ellipsoidal', mapping_=mapping_)
        if self.Elliptical is not None:
            Elliptical_ = self.Elliptical
            Elliptical_.to_etree(element, name_='Elliptical', mapping_=mapping_)
        if self.UserDefined is not None:
            UserDefined_ = self.UserDefined
            UserDefined_.to_etree(element, name_='UserDefined', mapping_=mapping_)
        if self.Manual is not None:
            Manual_ = self.Manual
            Manual_.to_etree(element, name_='Manual', mapping_=mapping_)
        if self.BoundedUniform is not None:
            BoundedUniform_ = self.BoundedUniform
            BoundedUniform_.to_etree(element, name_='BoundedUniform', mapping_=mapping_)
        if self.DirectionalClumpingIndexProperties is not None:
            DirectionalClumpingIndexProperties_ = self.DirectionalClumpingIndexProperties
            DirectionalClumpingIndexProperties_.to_etree(element, name_='DirectionalClumpingIndexProperties', mapping_=mapping_)
        if self.ProspectExternalModule is not None:
            ProspectExternalModule_ = self.ProspectExternalModule
            ProspectExternalModule_.to_etree(element, name_='ProspectExternalModule', mapping_=mapping_)
        if self.understoryNodeMultiplicativeFactorForLUT is not None:
            understoryNodeMultiplicativeFactorForLUT_ = self.understoryNodeMultiplicativeFactorForLUT
            understoryNodeMultiplicativeFactorForLUT_.to_etree(element, name_='understoryNodeMultiplicativeFactorForLUT', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_UnderstoryMulti'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ModelName is not None and 'ModelName' not in already_processed:
            already_processed.add('ModelName')
            showIndent(outfile, level)
            outfile.write('ModelName="%s",\n' % (self.ModelName,))
        if self.dimFoliar is not None and 'dimFoliar' not in already_processed:
            already_processed.add('dimFoliar')
            showIndent(outfile, level)
            outfile.write('dimFoliar=%e,\n' % (self.dimFoliar,))
        if self.lad is not None and 'lad' not in already_processed:
            already_processed.add('lad')
            showIndent(outfile, level)
            outfile.write('lad=%d,\n' % (self.lad,))
        if self.useSpecular is not None and 'useSpecular' not in already_processed:
            already_processed.add('useSpecular')
            showIndent(outfile, level)
            outfile.write('useSpecular=%d,\n' % (self.useSpecular,))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            showIndent(outfile, level)
            outfile.write('ident="%s",\n' % (self.ident,))
        if self.databaseName is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            showIndent(outfile, level)
            outfile.write('databaseName="%s",\n' % (self.databaseName,))
        if self.useMultiplicativeFactorForLUT is not None and 'useMultiplicativeFactorForLUT' not in already_processed:
            already_processed.add('useMultiplicativeFactorForLUT')
            showIndent(outfile, level)
            outfile.write('useMultiplicativeFactorForLUT=%d,\n' % (self.useMultiplicativeFactorForLUT,))
        if self.useOpticalFactorMatrix is not None and 'useOpticalFactorMatrix' not in already_processed:
            already_processed.add('useOpticalFactorMatrix')
            showIndent(outfile, level)
            outfile.write('useOpticalFactorMatrix=%d,\n' % (self.useOpticalFactorMatrix,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SpecularData is not None:
            showIndent(outfile, level)
            outfile.write('SpecularData=model_._SpecularData(\n')
            self.SpecularData.exportLiteral(outfile, level, name_='SpecularData')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Ellipsoidal is not None:
            showIndent(outfile, level)
            outfile.write('Ellipsoidal=model_._Ellipsoidal(\n')
            self.Ellipsoidal.exportLiteral(outfile, level, name_='Ellipsoidal')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Elliptical is not None:
            showIndent(outfile, level)
            outfile.write('Elliptical=model_._Elliptical(\n')
            self.Elliptical.exportLiteral(outfile, level, name_='Elliptical')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.UserDefined is not None:
            showIndent(outfile, level)
            outfile.write('UserDefined=model_._UserDefined(\n')
            self.UserDefined.exportLiteral(outfile, level, name_='UserDefined')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Manual is not None:
            showIndent(outfile, level)
            outfile.write('Manual=model_._Manual(\n')
            self.Manual.exportLiteral(outfile, level, name_='Manual')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BoundedUniform is not None:
            showIndent(outfile, level)
            outfile.write('BoundedUniform=model_._BoundedUniform(\n')
            self.BoundedUniform.exportLiteral(outfile, level, name_='BoundedUniform')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DirectionalClumpingIndexProperties is not None:
            showIndent(outfile, level)
            outfile.write('DirectionalClumpingIndexProperties=model_._DirectionalClumpingIndexProperties(\n')
            self.DirectionalClumpingIndexProperties.exportLiteral(outfile, level, name_='DirectionalClumpingIndexProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ProspectExternalModule is not None:
            showIndent(outfile, level)
            outfile.write('ProspectExternalModule=model_._ProspectExternalModule(\n')
            self.ProspectExternalModule.exportLiteral(outfile, level, name_='ProspectExternalModule')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.understoryNodeMultiplicativeFactorForLUT is not None:
            showIndent(outfile, level)
            outfile.write('understoryNodeMultiplicativeFactorForLUT=model_._understoryNodeMultiplicativeFactorForLUT(\n')
            self.understoryNodeMultiplicativeFactorForLUT.exportLiteral(outfile, level, name_='understoryNodeMultiplicativeFactorForLUT')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ModelName', node)
        if value is not None and 'ModelName' not in already_processed:
            already_processed.add('ModelName')
            self.ModelName = value
        value = find_attr_value_('dimFoliar', node)
        if value is not None and 'dimFoliar' not in already_processed:
            already_processed.add('dimFoliar')
            try:
                self.dimFoliar = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (dimFoliar): %s' % exp)
        value = find_attr_value_('lad', node)
        if value is not None and 'lad' not in already_processed:
            already_processed.add('lad')
            try:
                self.lad = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('useSpecular', node)
        if value is not None and 'useSpecular' not in already_processed:
            already_processed.add('useSpecular')
            try:
                self.useSpecular = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ident', node)
        if value is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            self.ident = value
        value = find_attr_value_('databaseName', node)
        if value is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            self.databaseName = value
        value = find_attr_value_('useMultiplicativeFactorForLUT', node)
        if value is not None and 'useMultiplicativeFactorForLUT' not in already_processed:
            already_processed.add('useMultiplicativeFactorForLUT')
            try:
                self.useMultiplicativeFactorForLUT = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('useOpticalFactorMatrix', node)
        if value is not None and 'useOpticalFactorMatrix' not in already_processed:
            already_processed.add('useOpticalFactorMatrix')
            try:
                self.useOpticalFactorMatrix = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SpecularData':
            obj_ = create_SpecularData.factory()
            obj_.build(child_)
            self.set_SpecularData(obj_)
            obj_.original_tagname_ = 'SpecularData'
        elif nodeName_ == 'Ellipsoidal':
            obj_ = create_Ellipsoidal.factory()
            obj_.build(child_)
            self.set_Ellipsoidal(obj_)
            obj_.original_tagname_ = 'Ellipsoidal'
        elif nodeName_ == 'Elliptical':
            obj_ = create_Elliptical.factory()
            obj_.build(child_)
            self.set_Elliptical(obj_)
            obj_.original_tagname_ = 'Elliptical'
        elif nodeName_ == 'UserDefined':
            obj_ = create_UserDefined.factory()
            obj_.build(child_)
            self.set_UserDefined(obj_)
            obj_.original_tagname_ = 'UserDefined'
        elif nodeName_ == 'Manual':
            obj_ = create_Manual.factory()
            obj_.build(child_)
            self.set_Manual(obj_)
            obj_.original_tagname_ = 'Manual'
        elif nodeName_ == 'BoundedUniform':
            obj_ = create_BoundedUniform.factory()
            obj_.build(child_)
            self.set_BoundedUniform(obj_)
            obj_.original_tagname_ = 'BoundedUniform'
        elif nodeName_ == 'DirectionalClumpingIndexProperties':
            obj_ = create_DirectionalClumpingIndexProperties.factory()
            obj_.build(child_)
            self.set_DirectionalClumpingIndexProperties(obj_)
            obj_.original_tagname_ = 'DirectionalClumpingIndexProperties'
        elif nodeName_ == 'ProspectExternalModule':
            obj_ = create_ProspectExternalModule.factory()
            obj_.build(child_)
            self.set_ProspectExternalModule(obj_)
            obj_.original_tagname_ = 'ProspectExternalModule'
        elif nodeName_ == 'understoryNodeMultiplicativeFactorForLUT':
            obj_ = create_understoryNodeMultiplicativeFactorForLUT.factory()
            obj_.build(child_)
            self.set_understoryNodeMultiplicativeFactorForLUT(obj_)
            obj_.original_tagname_ = 'understoryNodeMultiplicativeFactorForLUT'
# end class create_UnderstoryMulti


class create_Ellipsoidal(GeneratedsSuper):
    """Average leaf angle for the ellipsoidal leaf angle distribution
    Average leaf angle for the ellipsoidal leaf angle distribution"""
    subclass = None
    superclass = None
    def __init__(self, ala=0.000):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_Ellipsoidal")
        self.attrib = ['ala']
        self.children = []
        self.parent = None
        self._ala = _cast(float, ala)
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Ellipsoidal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Ellipsoidal.subclass:
            return create_Ellipsoidal.subclass(*args_, **kwargs_)
        else:
            return create_Ellipsoidal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ala(self): return self._ala
    def set_ala(self, value):
        self._ala = value
        update_node(self,self.troot,"coeff_diff")
    ala = property(get_ala, set_ala)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Ellipsoidal', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Ellipsoidal')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Ellipsoidal')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Ellipsoidal', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Ellipsoidal'):
        if self.ala is not None and 'ala' not in already_processed:
            already_processed.add('ala')
            outfile.write(' ala="%s"' % self.gds_format_double(self.ala, input_name='ala'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Ellipsoidal', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_Ellipsoidal', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ala is not None:
            element.set('ala', self.gds_format_double(self.ala))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Ellipsoidal'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ala is not None and 'ala' not in already_processed:
            already_processed.add('ala')
            showIndent(outfile, level)
            outfile.write('ala=%e,\n' % (self.ala,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ala', node)
        if value is not None and 'ala' not in already_processed:
            already_processed.add('ala')
            try:
                self.ala = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (ala): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_Ellipsoidal


class create_Elliptical(GeneratedsSuper):
    """Excentricity of the elliptical leaf angle distribution Excentricity
    of the elliptical leaf angle distribution Angle of the principal
    axis of the ellipse (elliptical LAD) Angle of the principal axis
    of the ellipse (elliptical LAD)"""
    subclass = None
    superclass = None
    def __init__(self, epsilon=0.000, thetam=0.000):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_Elliptical")
        self.attrib = ['epsilon', 'thetam']
        self.children = []
        self.parent = None
        self._epsilon = _cast(float, epsilon)
        self._thetam = _cast(float, thetam)
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Elliptical)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Elliptical.subclass:
            return create_Elliptical.subclass(*args_, **kwargs_)
        else:
            return create_Elliptical(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_epsilon(self): return self._epsilon
    def set_epsilon(self, value):
        self._epsilon = value
        update_node(self,self.troot,"coeff_diff")
    epsilon = property(get_epsilon, set_epsilon)
    def get_thetam(self): return self._thetam
    def set_thetam(self, value):
        self._thetam = value
        update_node(self,self.troot,"coeff_diff")
    thetam = property(get_thetam, set_thetam)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Elliptical', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Elliptical')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Elliptical')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Elliptical', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Elliptical'):
        if self.epsilon is not None and 'epsilon' not in already_processed:
            already_processed.add('epsilon')
            outfile.write(' epsilon="%s"' % self.gds_format_double(self.epsilon, input_name='epsilon'))
        if self.thetam is not None and 'thetam' not in already_processed:
            already_processed.add('thetam')
            outfile.write(' thetam="%s"' % self.gds_format_double(self.thetam, input_name='thetam'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Elliptical', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_Elliptical', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.epsilon is not None:
            element.set('epsilon', self.gds_format_double(self.epsilon))
        if self.thetam is not None:
            element.set('thetam', self.gds_format_double(self.thetam))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Elliptical'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.epsilon is not None and 'epsilon' not in already_processed:
            already_processed.add('epsilon')
            showIndent(outfile, level)
            outfile.write('epsilon=%e,\n' % (self.epsilon,))
        if self.thetam is not None and 'thetam' not in already_processed:
            already_processed.add('thetam')
            showIndent(outfile, level)
            outfile.write('thetam=%e,\n' % (self.thetam,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('epsilon', node)
        if value is not None and 'epsilon' not in already_processed:
            already_processed.add('epsilon')
            try:
                self.epsilon = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (epsilon): %s' % exp)
        value = find_attr_value_('thetam', node)
        if value is not None and 'thetam' not in already_processed:
            already_processed.add('thetam')
            try:
                self.thetam = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (thetam): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_Elliptical


class create_UserDefined(GeneratedsSuper):
    """Name of the spectral data base (text file) used to compute the
    spectral phase function(s). Name of the spectral data base (text
    file) used to compute the spectral phase function(s)."""
    subclass = None
    superclass = None
    def __init__(self, fileName='LADFile.txt'):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_UserDefined")
        self.attrib = ['fileName']
        self.children = []
        self.parent = None
        self._fileName = _cast(None, fileName)
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_UserDefined)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_UserDefined.subclass:
            return create_UserDefined.subclass(*args_, **kwargs_)
        else:
            return create_UserDefined(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fileName(self): return self._fileName
    def set_fileName(self, value):
        self._fileName = value
        update_node(self,self.troot,"coeff_diff")
    fileName = property(get_fileName, set_fileName)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_UserDefined', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_UserDefined')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_UserDefined')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_UserDefined', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_UserDefined'):
        if self.fileName is not None and 'fileName' not in already_processed:
            already_processed.add('fileName')
            outfile.write(' fileName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fileName), input_name='fileName')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_UserDefined', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_UserDefined', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.fileName is not None:
            element.set('fileName', self.gds_format_string(self.fileName))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_UserDefined'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.fileName is not None and 'fileName' not in already_processed:
            already_processed.add('fileName')
            showIndent(outfile, level)
            outfile.write('fileName="%s",\n' % (self.fileName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fileName', node)
        if value is not None and 'fileName' not in already_processed:
            already_processed.add('fileName')
            self.fileName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_UserDefined


class create_Manual(GeneratedsSuper):
    """A cos ^m [PI/2 Theta-b0 /b2-b0] A cos ^m [PI/2 Theta-b0 /b2-b0]
    Maximum angle of leaf distribution Maximum angle of leaf
    distribution Mean angle of leaf distribution Mean angle of leaf
    distribution Minimum angle of leaf distribution Minimum angle of
    leaf distribution"""
    subclass = None
    superclass = None
    def __init__(self, LAD_m=1, LAD_b2=90, LAD_b0=45, LAD_b1=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_Manual")
        self.attrib = ['LAD_m', 'LAD_b2', 'LAD_b0', 'LAD_b1']
        self.children = []
        self.parent = None
        self._LAD_m = _cast(float, LAD_m)
        self._LAD_b2 = _cast(float, LAD_b2)
        self._LAD_b0 = _cast(float, LAD_b0)
        self._LAD_b1 = _cast(float, LAD_b1)
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Manual)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Manual.subclass:
            return create_Manual.subclass(*args_, **kwargs_)
        else:
            return create_Manual(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LAD_m(self): return self._LAD_m
    def set_LAD_m(self, value):
        self._LAD_m = value
        update_node(self,self.troot,"coeff_diff")
    LAD_m = property(get_LAD_m, set_LAD_m)
    def get_LAD_b2(self): return self._LAD_b2
    def set_LAD_b2(self, value):
        self._LAD_b2 = value
        update_node(self,self.troot,"coeff_diff")
    LAD_b2 = property(get_LAD_b2, set_LAD_b2)
    def get_LAD_b0(self): return self._LAD_b0
    def set_LAD_b0(self, value):
        self._LAD_b0 = value
        update_node(self,self.troot,"coeff_diff")
    LAD_b0 = property(get_LAD_b0, set_LAD_b0)
    def get_LAD_b1(self): return self._LAD_b1
    def set_LAD_b1(self, value):
        self._LAD_b1 = value
        update_node(self,self.troot,"coeff_diff")
    LAD_b1 = property(get_LAD_b1, set_LAD_b1)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Manual', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Manual')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Manual')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Manual', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Manual'):
        if self.LAD_m is not None and 'LAD_m' not in already_processed:
            already_processed.add('LAD_m')
            outfile.write(' LAD_m="%s"' % self.gds_format_double(self.LAD_m, input_name='LAD_m'))
        if self.LAD_b2 is not None and 'LAD_b2' not in already_processed:
            already_processed.add('LAD_b2')
            outfile.write(' LAD_b2="%s"' % self.gds_format_double(self.LAD_b2, input_name='LAD_b2'))
        if self.LAD_b0 is not None and 'LAD_b0' not in already_processed:
            already_processed.add('LAD_b0')
            outfile.write(' LAD_b0="%s"' % self.gds_format_double(self.LAD_b0, input_name='LAD_b0'))
        if self.LAD_b1 is not None and 'LAD_b1' not in already_processed:
            already_processed.add('LAD_b1')
            outfile.write(' LAD_b1="%s"' % self.gds_format_double(self.LAD_b1, input_name='LAD_b1'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Manual', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_Manual', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.LAD_m is not None:
            element.set('LAD_m', self.gds_format_double(self.LAD_m))
        if self.LAD_b2 is not None:
            element.set('LAD_b2', self.gds_format_double(self.LAD_b2))
        if self.LAD_b0 is not None:
            element.set('LAD_b0', self.gds_format_double(self.LAD_b0))
        if self.LAD_b1 is not None:
            element.set('LAD_b1', self.gds_format_double(self.LAD_b1))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Manual'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.LAD_m is not None and 'LAD_m' not in already_processed:
            already_processed.add('LAD_m')
            showIndent(outfile, level)
            outfile.write('LAD_m=%e,\n' % (self.LAD_m,))
        if self.LAD_b2 is not None and 'LAD_b2' not in already_processed:
            already_processed.add('LAD_b2')
            showIndent(outfile, level)
            outfile.write('LAD_b2=%e,\n' % (self.LAD_b2,))
        if self.LAD_b0 is not None and 'LAD_b0' not in already_processed:
            already_processed.add('LAD_b0')
            showIndent(outfile, level)
            outfile.write('LAD_b0=%e,\n' % (self.LAD_b0,))
        if self.LAD_b1 is not None and 'LAD_b1' not in already_processed:
            already_processed.add('LAD_b1')
            showIndent(outfile, level)
            outfile.write('LAD_b1=%e,\n' % (self.LAD_b1,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('LAD_m', node)
        if value is not None and 'LAD_m' not in already_processed:
            already_processed.add('LAD_m')
            try:
                self.LAD_m = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (LAD_m): %s' % exp)
        value = find_attr_value_('LAD_b2', node)
        if value is not None and 'LAD_b2' not in already_processed:
            already_processed.add('LAD_b2')
            try:
                self.LAD_b2 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (LAD_b2): %s' % exp)
        value = find_attr_value_('LAD_b0', node)
        if value is not None and 'LAD_b0' not in already_processed:
            already_processed.add('LAD_b0')
            try:
                self.LAD_b0 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (LAD_b0): %s' % exp)
        value = find_attr_value_('LAD_b1', node)
        if value is not None and 'LAD_b1' not in already_processed:
            already_processed.add('LAD_b1')
            try:
                self.LAD_b1 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (LAD_b1): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_Manual


class create_BoundedUniform(GeneratedsSuper):
    """Number of angluar segmentation for leaf angle distribution Number of
    angluar segmentation for leaf angle distribution Umpteenth
    angluar segment of computed leaf angle distribution Umpteenth
    angluar segment of computed leaf angle distribution"""
    subclass = None
    superclass = None
    def __init__(self, nbAla=1, nthAla=1):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_BoundedUniform")
        self.attrib = ['nbAla', 'nthAla']
        self.children = []
        self.parent = None
        self._nbAla = _cast(int, nbAla)
        self._nthAla = _cast(int, nthAla)
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_BoundedUniform)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_BoundedUniform.subclass:
            return create_BoundedUniform.subclass(*args_, **kwargs_)
        else:
            return create_BoundedUniform(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nbAla(self): return self._nbAla
    def set_nbAla(self, value):
        self._nbAla = value
        update_node(self,self.troot,"coeff_diff")
    nbAla = property(get_nbAla, set_nbAla)
    def get_nthAla(self): return self._nthAla
    def set_nthAla(self, value):
        self._nthAla = value
        update_node(self,self.troot,"coeff_diff")
    nthAla = property(get_nthAla, set_nthAla)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_BoundedUniform', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_BoundedUniform')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_BoundedUniform')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_BoundedUniform', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_BoundedUniform'):
        if self.nbAla is not None and 'nbAla' not in already_processed:
            already_processed.add('nbAla')
            outfile.write(' nbAla="%s"' % self.gds_format_integer(self.nbAla, input_name='nbAla'))
        if self.nthAla is not None and 'nthAla' not in already_processed:
            already_processed.add('nthAla')
            outfile.write(' nthAla="%s"' % self.gds_format_integer(self.nthAla, input_name='nthAla'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_BoundedUniform', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_BoundedUniform', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.nbAla is not None:
            element.set('nbAla', self.gds_format_integer(self.nbAla))
        if self.nthAla is not None:
            element.set('nthAla', self.gds_format_integer(self.nthAla))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_BoundedUniform'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nbAla is not None and 'nbAla' not in already_processed:
            already_processed.add('nbAla')
            showIndent(outfile, level)
            outfile.write('nbAla=%d,\n' % (self.nbAla,))
        if self.nthAla is not None and 'nthAla' not in already_processed:
            already_processed.add('nthAla')
            showIndent(outfile, level)
            outfile.write('nthAla=%d,\n' % (self.nthAla,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nbAla', node)
        if value is not None and 'nbAla' not in already_processed:
            already_processed.add('nbAla')
            try:
                self.nbAla = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('nthAla', node)
        if value is not None and 'nthAla' not in already_processed:
            already_processed.add('nthAla')
            try:
                self.nthAla = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_BoundedUniform


class create_DirectionalClumpingIndexProperties(GeneratedsSuper):
    """See tool tip of Omega Min See tool tip of Omega Min See tool tip of
    Omega Min See tool tip of Omega Min See tool tip of Omega Min
    See tool tip of Omega Min G(teta)_with_clumping
    G(teta)_with_clumping"""
    subclass = None
    superclass = None
    def __init__(self, omegaMax=0, clumpinga=0, clumpingb=0, omegaMin=1):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_DirectionalClumpingIndexProperties")
        self.attrib = ['omegaMax', 'clumpinga', 'clumpingb', 'omegaMin']
        self.children = []
        self.parent = None
        self._omegaMax = _cast(float, omegaMax)
        self._clumpinga = _cast(float, clumpinga)
        self._clumpingb = _cast(float, clumpingb)
        self._omegaMin = _cast(float, omegaMin)
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_DirectionalClumpingIndexProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_DirectionalClumpingIndexProperties.subclass:
            return create_DirectionalClumpingIndexProperties.subclass(*args_, **kwargs_)
        else:
            return create_DirectionalClumpingIndexProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_omegaMax(self): return self._omegaMax
    def set_omegaMax(self, value):
        self._omegaMax = value
        update_node(self,self.troot,"coeff_diff")
    omegaMax = property(get_omegaMax, set_omegaMax)
    def get_clumpinga(self): return self._clumpinga
    def set_clumpinga(self, value):
        self._clumpinga = value
        update_node(self,self.troot,"coeff_diff")
    clumpinga = property(get_clumpinga, set_clumpinga)
    def get_clumpingb(self): return self._clumpingb
    def set_clumpingb(self, value):
        self._clumpingb = value
        update_node(self,self.troot,"coeff_diff")
    clumpingb = property(get_clumpingb, set_clumpingb)
    def get_omegaMin(self): return self._omegaMin
    def set_omegaMin(self, value):
        self._omegaMin = value
        update_node(self,self.troot,"coeff_diff")
    omegaMin = property(get_omegaMin, set_omegaMin)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_DirectionalClumpingIndexProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_DirectionalClumpingIndexProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_DirectionalClumpingIndexProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_DirectionalClumpingIndexProperties', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_DirectionalClumpingIndexProperties'):
        if self.omegaMax is not None and 'omegaMax' not in already_processed:
            already_processed.add('omegaMax')
            outfile.write(' omegaMax="%s"' % self.gds_format_double(self.omegaMax, input_name='omegaMax'))
        if self.clumpinga is not None and 'clumpinga' not in already_processed:
            already_processed.add('clumpinga')
            outfile.write(' clumpinga="%s"' % self.gds_format_double(self.clumpinga, input_name='clumpinga'))
        if self.clumpingb is not None and 'clumpingb' not in already_processed:
            already_processed.add('clumpingb')
            outfile.write(' clumpingb="%s"' % self.gds_format_double(self.clumpingb, input_name='clumpingb'))
        if self.omegaMin is not None and 'omegaMin' not in already_processed:
            already_processed.add('omegaMin')
            outfile.write(' omegaMin="%s"' % self.gds_format_double(self.omegaMin, input_name='omegaMin'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_DirectionalClumpingIndexProperties', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_DirectionalClumpingIndexProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.omegaMax is not None:
            element.set('omegaMax', self.gds_format_double(self.omegaMax))
        if self.clumpinga is not None:
            element.set('clumpinga', self.gds_format_double(self.clumpinga))
        if self.clumpingb is not None:
            element.set('clumpingb', self.gds_format_double(self.clumpingb))
        if self.omegaMin is not None:
            element.set('omegaMin', self.gds_format_double(self.omegaMin))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_DirectionalClumpingIndexProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.omegaMax is not None and 'omegaMax' not in already_processed:
            already_processed.add('omegaMax')
            showIndent(outfile, level)
            outfile.write('omegaMax=%e,\n' % (self.omegaMax,))
        if self.clumpinga is not None and 'clumpinga' not in already_processed:
            already_processed.add('clumpinga')
            showIndent(outfile, level)
            outfile.write('clumpinga=%e,\n' % (self.clumpinga,))
        if self.clumpingb is not None and 'clumpingb' not in already_processed:
            already_processed.add('clumpingb')
            showIndent(outfile, level)
            outfile.write('clumpingb=%e,\n' % (self.clumpingb,))
        if self.omegaMin is not None and 'omegaMin' not in already_processed:
            already_processed.add('omegaMin')
            showIndent(outfile, level)
            outfile.write('omegaMin=%e,\n' % (self.omegaMin,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('omegaMax', node)
        if value is not None and 'omegaMax' not in already_processed:
            already_processed.add('omegaMax')
            try:
                self.omegaMax = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (omegaMax): %s' % exp)
        value = find_attr_value_('clumpinga', node)
        if value is not None and 'clumpinga' not in already_processed:
            already_processed.add('clumpinga')
            try:
                self.clumpinga = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (clumpinga): %s' % exp)
        value = find_attr_value_('clumpingb', node)
        if value is not None and 'clumpingb' not in already_processed:
            already_processed.add('clumpingb')
            try:
                self.clumpingb = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (clumpingb): %s' % exp)
        value = find_attr_value_('omegaMin', node)
        if value is not None and 'omegaMin' not in already_processed:
            already_processed.add('omegaMin')
            try:
                self.omegaMin = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (omegaMin): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_DirectionalClumpingIndexProperties


class create_understoryNodeMultiplicativeFactorForLUT(GeneratedsSuper):
    """When selected, the parameters values of every spectral band will be
    equal to these parameters. When selected, the parameters values
    of every spectral band will be equal to these parameters.
    Necessary for building up LUT tables with variable adaxial leaf
    reflectance values. \nA multispectral LUT can be computed
    applying the sequencer to DART mutispectral simulation with one
    spectral band each. Necessary for building up LUT tables with
    variable adaxial leaf reflectance values. \nA multispectral LUT
    can be computed applying the sequencer to DART mutispectral
    simulation with one spectral band each. Apply the same 3D factor
    matrix per cell on optical properties to all the spectral bands
    Apply the same 3D factor matrix per cell on optical properties
    to all the spectral bands Necessary for building up LUT tables
    with variable abaxial leaf reflectance values. \nA multispectral
    LUT can be computed applying the sequencer to DART mutispectral
    simulation with one spectral band each. Necessary for building
    up LUT tables with variable abaxial leaf reflectance values. \nA
    multispectral LUT can be computed applying the sequencer to DART
    mutispectral simulation with one spectral band each. Necessary
    for building up LUT tables with variable leaf transmittance
    values. \nA multispectral LUT can be computed applying the
    sequencer to DART mutispectral simulation with one spectral band
    each. Necessary for building up LUT tables with variable leaf
    transmittance values. \nA multispectral LUT can be computed
    applying the sequencer to DART mutispectral simulation with one
    spectral band each."""
    subclass = None
    superclass = None
    def __init__(self, useSameFactorForAllBands=1, adaxialReflectanceFactor=1, useSameOpticalFactorMatrixForAllBands=0, abaxialReflectanceFactor=1, LeafTransmittanceFactor=1, understoryMultiplicativeFactorForLUT=None, opticalFactorMatrix=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_understoryNodeMultiplicativeFactorForLUT")
        self.attrib = ['useSameFactorForAllBands', 'adaxialReflectanceFactor', 'useSameOpticalFactorMatrixForAllBands', 'abaxialReflectanceFactor', 'LeafTransmittanceFactor']
        self.children = ['understoryMultiplicativeFactorForLUT', 'opticalFactorMatrix']
        self.parent = None
        self._useSameFactorForAllBands = _cast(int, useSameFactorForAllBands)
        self._adaxialReflectanceFactor = _cast(float, adaxialReflectanceFactor)
        self._useSameOpticalFactorMatrixForAllBands = _cast(int, useSameOpticalFactorMatrixForAllBands)
        self._abaxialReflectanceFactor = _cast(float, abaxialReflectanceFactor)
        self._LeafTransmittanceFactor = _cast(float, LeafTransmittanceFactor)
        if understoryMultiplicativeFactorForLUT is None:
            self._understoryMultiplicativeFactorForLUT = []
        else:
            self._understoryMultiplicativeFactorForLUT = understoryMultiplicativeFactorForLUT
        self._opticalFactorMatrix = opticalFactorMatrix
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_understoryNodeMultiplicativeFactorForLUT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_understoryNodeMultiplicativeFactorForLUT.subclass:
            return create_understoryNodeMultiplicativeFactorForLUT.subclass(*args_, **kwargs_)
        else:
            return create_understoryNodeMultiplicativeFactorForLUT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_understoryMultiplicativeFactorForLUT(self): return self._understoryMultiplicativeFactorForLUT
    def set_understoryMultiplicativeFactorForLUT(self, value):
        if value is not None:
            checkclass(value, create_understoryMultiplicativeFactorForLUT)
            for v in value:
                v.parent = self
        self._understoryMultiplicativeFactorForLUT = value
    def add_understoryMultiplicativeFactorForLUT(self, value):
        value.parent = self
        self._understoryMultiplicativeFactorForLUT.append(value)
    def insert_understoryMultiplicativeFactorForLUT_at(self, index, value):
        value.parent = self
        self.understoryMultiplicativeFactorForLUT.insert(index, value)
    def replace_understoryMultiplicativeFactorForLUT_at(self, index, value):
        value.parent = self
        self.understoryMultiplicativeFactorForLUT[index] = value
    understoryMultiplicativeFactorForLUT = property(get_understoryMultiplicativeFactorForLUT, set_understoryMultiplicativeFactorForLUT)
    def get_opticalFactorMatrix(self): return self._opticalFactorMatrix
    def set_opticalFactorMatrix(self, value):
        if value is not None:
            checkclass(value, create_opticalFactorMatrix)
            value.parent = self
        self._opticalFactorMatrix = value
    opticalFactorMatrix = property(get_opticalFactorMatrix, set_opticalFactorMatrix)
    def get_useSameFactorForAllBands(self): return self._useSameFactorForAllBands
    def set_useSameFactorForAllBands(self, value):
        self._useSameFactorForAllBands = value
        update_node(self,self.troot,"coeff_diff")
    useSameFactorForAllBands = property(get_useSameFactorForAllBands, set_useSameFactorForAllBands)
    def get_adaxialReflectanceFactor(self): return self._adaxialReflectanceFactor
    def set_adaxialReflectanceFactor(self, value):
        self._adaxialReflectanceFactor = value
        update_node(self,self.troot,"coeff_diff")
    adaxialReflectanceFactor = property(get_adaxialReflectanceFactor, set_adaxialReflectanceFactor)
    def get_useSameOpticalFactorMatrixForAllBands(self): return self._useSameOpticalFactorMatrixForAllBands
    def set_useSameOpticalFactorMatrixForAllBands(self, value):
        self._useSameOpticalFactorMatrixForAllBands = value
        update_node(self,self.troot,"coeff_diff")
    useSameOpticalFactorMatrixForAllBands = property(get_useSameOpticalFactorMatrixForAllBands, set_useSameOpticalFactorMatrixForAllBands)
    def get_abaxialReflectanceFactor(self): return self._abaxialReflectanceFactor
    def set_abaxialReflectanceFactor(self, value):
        self._abaxialReflectanceFactor = value
        update_node(self,self.troot,"coeff_diff")
    abaxialReflectanceFactor = property(get_abaxialReflectanceFactor, set_abaxialReflectanceFactor)
    def get_LeafTransmittanceFactor(self): return self._LeafTransmittanceFactor
    def set_LeafTransmittanceFactor(self, value):
        self._LeafTransmittanceFactor = value
        update_node(self,self.troot,"coeff_diff")
    LeafTransmittanceFactor = property(get_LeafTransmittanceFactor, set_LeafTransmittanceFactor)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.understoryMultiplicativeFactorForLUT or
            self.opticalFactorMatrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_understoryNodeMultiplicativeFactorForLUT', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_understoryNodeMultiplicativeFactorForLUT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_understoryNodeMultiplicativeFactorForLUT')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_understoryNodeMultiplicativeFactorForLUT', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_understoryNodeMultiplicativeFactorForLUT'):
        if self.useSameFactorForAllBands is not None and 'useSameFactorForAllBands' not in already_processed:
            already_processed.add('useSameFactorForAllBands')
            outfile.write(' useSameFactorForAllBands="%s"' % self.gds_format_integer(self.useSameFactorForAllBands, input_name='useSameFactorForAllBands'))
        if self.adaxialReflectanceFactor is not None and 'adaxialReflectanceFactor' not in already_processed:
            already_processed.add('adaxialReflectanceFactor')
            outfile.write(' adaxialReflectanceFactor="%s"' % self.gds_format_double(self.adaxialReflectanceFactor, input_name='adaxialReflectanceFactor'))
        if self.useSameOpticalFactorMatrixForAllBands is not None and 'useSameOpticalFactorMatrixForAllBands' not in already_processed:
            already_processed.add('useSameOpticalFactorMatrixForAllBands')
            outfile.write(' useSameOpticalFactorMatrixForAllBands="%s"' % self.gds_format_integer(self.useSameOpticalFactorMatrixForAllBands, input_name='useSameOpticalFactorMatrixForAllBands'))
        if self.abaxialReflectanceFactor is not None and 'abaxialReflectanceFactor' not in already_processed:
            already_processed.add('abaxialReflectanceFactor')
            outfile.write(' abaxialReflectanceFactor="%s"' % self.gds_format_double(self.abaxialReflectanceFactor, input_name='abaxialReflectanceFactor'))
        if self.LeafTransmittanceFactor is not None and 'LeafTransmittanceFactor' not in already_processed:
            already_processed.add('LeafTransmittanceFactor')
            outfile.write(' LeafTransmittanceFactor="%s"' % self.gds_format_double(self.LeafTransmittanceFactor, input_name='LeafTransmittanceFactor'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_understoryNodeMultiplicativeFactorForLUT', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for understoryMultiplicativeFactorForLUT_ in self.understoryMultiplicativeFactorForLUT:
            understoryMultiplicativeFactorForLUT_.export(outfile, level, namespaceprefix_, name_='understoryMultiplicativeFactorForLUT', pretty_print=pretty_print)
        if self.opticalFactorMatrix is not None:
            self.opticalFactorMatrix.export(outfile, level, namespaceprefix_, name_='opticalFactorMatrix', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_understoryNodeMultiplicativeFactorForLUT', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.useSameFactorForAllBands is not None:
            element.set('useSameFactorForAllBands', self.gds_format_integer(self.useSameFactorForAllBands))
        if self.adaxialReflectanceFactor is not None:
            element.set('adaxialReflectanceFactor', self.gds_format_double(self.adaxialReflectanceFactor))
        if self.useSameOpticalFactorMatrixForAllBands is not None:
            element.set('useSameOpticalFactorMatrixForAllBands', self.gds_format_integer(self.useSameOpticalFactorMatrixForAllBands))
        if self.abaxialReflectanceFactor is not None:
            element.set('abaxialReflectanceFactor', self.gds_format_double(self.abaxialReflectanceFactor))
        if self.LeafTransmittanceFactor is not None:
            element.set('LeafTransmittanceFactor', self.gds_format_double(self.LeafTransmittanceFactor))
        for understoryMultiplicativeFactorForLUT_ in self.understoryMultiplicativeFactorForLUT:
            understoryMultiplicativeFactorForLUT_.to_etree(element, name_='understoryMultiplicativeFactorForLUT', mapping_=mapping_)
        if self.opticalFactorMatrix is not None:
            opticalFactorMatrix_ = self.opticalFactorMatrix
            opticalFactorMatrix_.to_etree(element, name_='opticalFactorMatrix', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_understoryNodeMultiplicativeFactorForLUT'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.useSameFactorForAllBands is not None and 'useSameFactorForAllBands' not in already_processed:
            already_processed.add('useSameFactorForAllBands')
            showIndent(outfile, level)
            outfile.write('useSameFactorForAllBands=%d,\n' % (self.useSameFactorForAllBands,))
        if self.adaxialReflectanceFactor is not None and 'adaxialReflectanceFactor' not in already_processed:
            already_processed.add('adaxialReflectanceFactor')
            showIndent(outfile, level)
            outfile.write('adaxialReflectanceFactor=%e,\n' % (self.adaxialReflectanceFactor,))
        if self.useSameOpticalFactorMatrixForAllBands is not None and 'useSameOpticalFactorMatrixForAllBands' not in already_processed:
            already_processed.add('useSameOpticalFactorMatrixForAllBands')
            showIndent(outfile, level)
            outfile.write('useSameOpticalFactorMatrixForAllBands=%d,\n' % (self.useSameOpticalFactorMatrixForAllBands,))
        if self.abaxialReflectanceFactor is not None and 'abaxialReflectanceFactor' not in already_processed:
            already_processed.add('abaxialReflectanceFactor')
            showIndent(outfile, level)
            outfile.write('abaxialReflectanceFactor=%e,\n' % (self.abaxialReflectanceFactor,))
        if self.LeafTransmittanceFactor is not None and 'LeafTransmittanceFactor' not in already_processed:
            already_processed.add('LeafTransmittanceFactor')
            showIndent(outfile, level)
            outfile.write('LeafTransmittanceFactor=%e,\n' % (self.LeafTransmittanceFactor,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('understoryMultiplicativeFactorForLUT=[\n')
        level += 1
        for understoryMultiplicativeFactorForLUT_ in self.understoryMultiplicativeFactorForLUT:
            showIndent(outfile, level)
            outfile.write('model_._understoryMultiplicativeFactorForLUT(\n')
            understoryMultiplicativeFactorForLUT_.exportLiteral(outfile, level, name_='_understoryMultiplicativeFactorForLUT')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.opticalFactorMatrix is not None:
            showIndent(outfile, level)
            outfile.write('opticalFactorMatrix=model_._opticalFactorMatrix(\n')
            self.opticalFactorMatrix.exportLiteral(outfile, level, name_='opticalFactorMatrix')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.understoryMultiplicativeFactorForLUT = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('useSameFactorForAllBands', node)
        if value is not None and 'useSameFactorForAllBands' not in already_processed:
            already_processed.add('useSameFactorForAllBands')
            try:
                self.useSameFactorForAllBands = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('adaxialReflectanceFactor', node)
        if value is not None and 'adaxialReflectanceFactor' not in already_processed:
            already_processed.add('adaxialReflectanceFactor')
            try:
                self.adaxialReflectanceFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (adaxialReflectanceFactor): %s' % exp)
        value = find_attr_value_('useSameOpticalFactorMatrixForAllBands', node)
        if value is not None and 'useSameOpticalFactorMatrixForAllBands' not in already_processed:
            already_processed.add('useSameOpticalFactorMatrixForAllBands')
            try:
                self.useSameOpticalFactorMatrixForAllBands = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('abaxialReflectanceFactor', node)
        if value is not None and 'abaxialReflectanceFactor' not in already_processed:
            already_processed.add('abaxialReflectanceFactor')
            try:
                self.abaxialReflectanceFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (abaxialReflectanceFactor): %s' % exp)
        value = find_attr_value_('LeafTransmittanceFactor', node)
        if value is not None and 'LeafTransmittanceFactor' not in already_processed:
            already_processed.add('LeafTransmittanceFactor')
            try:
                self.LeafTransmittanceFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (LeafTransmittanceFactor): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'understoryMultiplicativeFactorForLUT':
            obj_ = create_understoryMultiplicativeFactorForLUT.factory()
            obj_.build(child_)
            self.add_understoryMultiplicativeFactorForLUT(obj_)
            obj_.original_tagname_ = 'understoryMultiplicativeFactorForLUT'
        elif nodeName_ == 'opticalFactorMatrix':
            obj_ = create_opticalFactorMatrix.factory()
            obj_.build(child_)
            self.set_opticalFactorMatrix(obj_)
            obj_.original_tagname_ = 'opticalFactorMatrix'
# end class create_understoryNodeMultiplicativeFactorForLUT


class create_understoryMultiplicativeFactorForLUT(GeneratedsSuper):
    """Necessary for building up LUT tables with variable abaxial leaf
    reflectance values. \nA multispectral LUT can be computed
    applying the sequencer to DART mutispectral simulation with one
    spectral band each. Necessary for building up LUT tables with
    variable abaxial leaf reflectance values. \nA multispectral LUT
    can be computed applying the sequencer to DART mutispectral
    simulation with one spectral band each. Necessary for building
    up LUT tables with variable adaxial leaf reflectance values. \nA
    multispectral LUT can be computed applying the sequencer to DART
    mutispectral simulation with one spectral band each. Necessary
    for building up LUT tables with variable adaxial leaf
    reflectance values. \nA multispectral LUT can be computed
    applying the sequencer to DART mutispectral simulation with one
    spectral band each. Necessary for building up LUT tables with
    variable leaf transmittance values. \nA multispectral LUT can be
    computed applying the sequencer to DART mutispectral simulation
    with one spectral band each. Necessary for building up LUT
    tables with variable leaf transmittance values. \nA
    multispectral LUT can be computed applying the sequencer to DART
    mutispectral simulation with one spectral band each. Apply a 3D
    factor matrix per cell on optical properties Apply a 3D factor
    matrix per cell on optical properties"""
    subclass = None
    superclass = None
    def __init__(self, abaxialReflectanceFactor=1, adaxialReflectanceFactor=1, LeafTransmittanceFactor=1, useOpticalFactorMatrix=0, opticalFactorMatrix=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_understoryMultiplicativeFactorForLUT")
        self.attrib = ['abaxialReflectanceFactor', 'adaxialReflectanceFactor', 'LeafTransmittanceFactor', 'useOpticalFactorMatrix']
        self.children = ['opticalFactorMatrix']
        self.parent = None
        self._abaxialReflectanceFactor = _cast(float, abaxialReflectanceFactor)
        self._adaxialReflectanceFactor = _cast(float, adaxialReflectanceFactor)
        self._LeafTransmittanceFactor = _cast(float, LeafTransmittanceFactor)
        self._useOpticalFactorMatrix = _cast(int, useOpticalFactorMatrix)
        self._opticalFactorMatrix = opticalFactorMatrix
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_understoryMultiplicativeFactorForLUT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_understoryMultiplicativeFactorForLUT.subclass:
            return create_understoryMultiplicativeFactorForLUT.subclass(*args_, **kwargs_)
        else:
            return create_understoryMultiplicativeFactorForLUT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_opticalFactorMatrix(self): return self._opticalFactorMatrix
    def set_opticalFactorMatrix(self, value):
        if value is not None:
            checkclass(value, create_opticalFactorMatrix)
            value.parent = self
        self._opticalFactorMatrix = value
    opticalFactorMatrix = property(get_opticalFactorMatrix, set_opticalFactorMatrix)
    def get_abaxialReflectanceFactor(self): return self._abaxialReflectanceFactor
    def set_abaxialReflectanceFactor(self, value):
        self._abaxialReflectanceFactor = value
        update_node(self,self.troot,"coeff_diff")
    abaxialReflectanceFactor = property(get_abaxialReflectanceFactor, set_abaxialReflectanceFactor)
    def get_adaxialReflectanceFactor(self): return self._adaxialReflectanceFactor
    def set_adaxialReflectanceFactor(self, value):
        self._adaxialReflectanceFactor = value
        update_node(self,self.troot,"coeff_diff")
    adaxialReflectanceFactor = property(get_adaxialReflectanceFactor, set_adaxialReflectanceFactor)
    def get_LeafTransmittanceFactor(self): return self._LeafTransmittanceFactor
    def set_LeafTransmittanceFactor(self, value):
        self._LeafTransmittanceFactor = value
        update_node(self,self.troot,"coeff_diff")
    LeafTransmittanceFactor = property(get_LeafTransmittanceFactor, set_LeafTransmittanceFactor)
    def get_useOpticalFactorMatrix(self): return self._useOpticalFactorMatrix
    def set_useOpticalFactorMatrix(self, value):
        self._useOpticalFactorMatrix = value
        update_node(self,self.troot,"coeff_diff")
    useOpticalFactorMatrix = property(get_useOpticalFactorMatrix, set_useOpticalFactorMatrix)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.opticalFactorMatrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_understoryMultiplicativeFactorForLUT', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_understoryMultiplicativeFactorForLUT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_understoryMultiplicativeFactorForLUT')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_understoryMultiplicativeFactorForLUT', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_understoryMultiplicativeFactorForLUT'):
        if self.abaxialReflectanceFactor is not None and 'abaxialReflectanceFactor' not in already_processed:
            already_processed.add('abaxialReflectanceFactor')
            outfile.write(' abaxialReflectanceFactor="%s"' % self.gds_format_double(self.abaxialReflectanceFactor, input_name='abaxialReflectanceFactor'))
        if self.adaxialReflectanceFactor is not None and 'adaxialReflectanceFactor' not in already_processed:
            already_processed.add('adaxialReflectanceFactor')
            outfile.write(' adaxialReflectanceFactor="%s"' % self.gds_format_double(self.adaxialReflectanceFactor, input_name='adaxialReflectanceFactor'))
        if self.LeafTransmittanceFactor is not None and 'LeafTransmittanceFactor' not in already_processed:
            already_processed.add('LeafTransmittanceFactor')
            outfile.write(' LeafTransmittanceFactor="%s"' % self.gds_format_double(self.LeafTransmittanceFactor, input_name='LeafTransmittanceFactor'))
        if self.useOpticalFactorMatrix is not None and 'useOpticalFactorMatrix' not in already_processed:
            already_processed.add('useOpticalFactorMatrix')
            outfile.write(' useOpticalFactorMatrix="%s"' % self.gds_format_integer(self.useOpticalFactorMatrix, input_name='useOpticalFactorMatrix'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_understoryMultiplicativeFactorForLUT', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.opticalFactorMatrix is not None:
            self.opticalFactorMatrix.export(outfile, level, namespaceprefix_, name_='opticalFactorMatrix', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_understoryMultiplicativeFactorForLUT', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.abaxialReflectanceFactor is not None:
            element.set('abaxialReflectanceFactor', self.gds_format_double(self.abaxialReflectanceFactor))
        if self.adaxialReflectanceFactor is not None:
            element.set('adaxialReflectanceFactor', self.gds_format_double(self.adaxialReflectanceFactor))
        if self.LeafTransmittanceFactor is not None:
            element.set('LeafTransmittanceFactor', self.gds_format_double(self.LeafTransmittanceFactor))
        if self.useOpticalFactorMatrix is not None:
            element.set('useOpticalFactorMatrix', self.gds_format_integer(self.useOpticalFactorMatrix))
        if self.opticalFactorMatrix is not None:
            opticalFactorMatrix_ = self.opticalFactorMatrix
            opticalFactorMatrix_.to_etree(element, name_='opticalFactorMatrix', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_understoryMultiplicativeFactorForLUT'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.abaxialReflectanceFactor is not None and 'abaxialReflectanceFactor' not in already_processed:
            already_processed.add('abaxialReflectanceFactor')
            showIndent(outfile, level)
            outfile.write('abaxialReflectanceFactor=%e,\n' % (self.abaxialReflectanceFactor,))
        if self.adaxialReflectanceFactor is not None and 'adaxialReflectanceFactor' not in already_processed:
            already_processed.add('adaxialReflectanceFactor')
            showIndent(outfile, level)
            outfile.write('adaxialReflectanceFactor=%e,\n' % (self.adaxialReflectanceFactor,))
        if self.LeafTransmittanceFactor is not None and 'LeafTransmittanceFactor' not in already_processed:
            already_processed.add('LeafTransmittanceFactor')
            showIndent(outfile, level)
            outfile.write('LeafTransmittanceFactor=%e,\n' % (self.LeafTransmittanceFactor,))
        if self.useOpticalFactorMatrix is not None and 'useOpticalFactorMatrix' not in already_processed:
            already_processed.add('useOpticalFactorMatrix')
            showIndent(outfile, level)
            outfile.write('useOpticalFactorMatrix=%d,\n' % (self.useOpticalFactorMatrix,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.opticalFactorMatrix is not None:
            showIndent(outfile, level)
            outfile.write('opticalFactorMatrix=model_._opticalFactorMatrix(\n')
            self.opticalFactorMatrix.exportLiteral(outfile, level, name_='opticalFactorMatrix')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('abaxialReflectanceFactor', node)
        if value is not None and 'abaxialReflectanceFactor' not in already_processed:
            already_processed.add('abaxialReflectanceFactor')
            try:
                self.abaxialReflectanceFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (abaxialReflectanceFactor): %s' % exp)
        value = find_attr_value_('adaxialReflectanceFactor', node)
        if value is not None and 'adaxialReflectanceFactor' not in already_processed:
            already_processed.add('adaxialReflectanceFactor')
            try:
                self.adaxialReflectanceFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (adaxialReflectanceFactor): %s' % exp)
        value = find_attr_value_('LeafTransmittanceFactor', node)
        if value is not None and 'LeafTransmittanceFactor' not in already_processed:
            already_processed.add('LeafTransmittanceFactor')
            try:
                self.LeafTransmittanceFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (LeafTransmittanceFactor): %s' % exp)
        value = find_attr_value_('useOpticalFactorMatrix', node)
        if value is not None and 'useOpticalFactorMatrix' not in already_processed:
            already_processed.add('useOpticalFactorMatrix')
            try:
                self.useOpticalFactorMatrix = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'opticalFactorMatrix':
            obj_ = create_opticalFactorMatrix.factory()
            obj_.build(child_)
            self.set_opticalFactorMatrix(obj_)
            obj_.original_tagname_ = 'opticalFactorMatrix'
# end class create_understoryMultiplicativeFactorForLUT


class create_AirMultiFunctions(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AirFunction=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_AirMultiFunctions")
        self.attrib = ['']
        self.children = ['AirFunction']
        self.parent = None
        if AirFunction is None:
            self._AirFunction = []
        else:
            self._AirFunction = AirFunction
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_AirMultiFunctions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_AirMultiFunctions.subclass:
            return create_AirMultiFunctions.subclass(*args_, **kwargs_)
        else:
            return create_AirMultiFunctions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AirFunction(self): return self._AirFunction
    def set_AirFunction(self, value):
        if value is not None:
            checkclass(value, create_AirFunction)
            for v in value:
                v.parent = self
        self._AirFunction = value
    def add_AirFunction(self, value):
        value.parent = self
        self._AirFunction.append(value)
    def insert_AirFunction_at(self, index, value):
        value.parent = self
        self.AirFunction.insert(index, value)
    def replace_AirFunction_at(self, index, value):
        value.parent = self
        self.AirFunction[index] = value
    AirFunction = property(get_AirFunction, set_AirFunction)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.AirFunction
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_AirMultiFunctions', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_AirMultiFunctions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_AirMultiFunctions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_AirMultiFunctions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_AirMultiFunctions'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_AirMultiFunctions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AirFunction_ in self.AirFunction:
            AirFunction_.export(outfile, level, namespaceprefix_, name_='AirFunction', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_AirMultiFunctions', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for AirFunction_ in self.AirFunction:
            AirFunction_.to_etree(element, name_='AirFunction', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_AirMultiFunctions'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('AirFunction=[\n')
        level += 1
        for AirFunction_ in self.AirFunction:
            showIndent(outfile, level)
            outfile.write('model_._AirFunction(\n')
            AirFunction_.exportLiteral(outfile, level, name_='_AirFunction')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.AirFunction = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AirFunction':
            obj_ = create_AirFunction.factory()
            obj_.build(child_)
            self.add_AirFunction(obj_)
            obj_.original_tagname_ = 'AirFunction'
# end class create_AirMultiFunctions


class create_AirFunction(GeneratedsSuper):
    """proportion of photons intercepted along an incident direction that
    are scattered within a solid angle along a given direction
    proportion of photons intercepted along an incident direction
    that are scattered within a solid angle along a given direction
    Name of the spectral data base (text file) used to compute the
    spectral phase function(s) Name of the spectral data base (text
    file) used to compute the spectral phase function(s) Reflectance
    database Reflectance database Multiplicative factor for database
    Multiplicative factor for database"""
    subclass = None
    superclass = None
    def __init__(self, ident='Molecule', ModelName='rayleigh_gas', databaseName='Fluid.db', useMultiplicativeFactorForLUT=1, AirFunctionNodeMultiplicativeFactorForLut=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_AirFunction")
        self.attrib = ['ident', 'ModelName', 'databaseName', 'useMultiplicativeFactorForLUT']
        self.children = ['AirFunctionNodeMultiplicativeFactorForLut']
        self.parent = None
        self._ident = _cast(None, ident)
        self._ModelName = _cast(None, ModelName)
        self._databaseName = _cast(None, databaseName)
        self._useMultiplicativeFactorForLUT = _cast(int, useMultiplicativeFactorForLUT)
        self._AirFunctionNodeMultiplicativeFactorForLut = AirFunctionNodeMultiplicativeFactorForLut
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_AirFunction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_AirFunction.subclass:
            return create_AirFunction.subclass(*args_, **kwargs_)
        else:
            return create_AirFunction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AirFunctionNodeMultiplicativeFactorForLut(self): return self._AirFunctionNodeMultiplicativeFactorForLut
    def set_AirFunctionNodeMultiplicativeFactorForLut(self, value):
        if value is not None:
            checkclass(value, create_AirFunctionNodeMultiplicativeFactorForLut)
            value.parent = self
        self._AirFunctionNodeMultiplicativeFactorForLut = value
    AirFunctionNodeMultiplicativeFactorForLut = property(get_AirFunctionNodeMultiplicativeFactorForLut, set_AirFunctionNodeMultiplicativeFactorForLut)
    def get_ident(self): return self._ident
    def set_ident(self, value):
        self._ident = value
        update_node(self,self.troot,"coeff_diff")
    ident = property(get_ident, set_ident)
    def get_ModelName(self): return self._ModelName
    def set_ModelName(self, value):
        self._ModelName = value
        update_node(self,self.troot,"coeff_diff")
    ModelName = property(get_ModelName, set_ModelName)
    def get_databaseName(self): return self._databaseName
    def set_databaseName(self, value):
        self._databaseName = value
        update_node(self,self.troot,"coeff_diff")
    databaseName = property(get_databaseName, set_databaseName)
    def get_useMultiplicativeFactorForLUT(self): return self._useMultiplicativeFactorForLUT
    def set_useMultiplicativeFactorForLUT(self, value):
        self._useMultiplicativeFactorForLUT = value
        update_node(self,self.troot,"coeff_diff")
    useMultiplicativeFactorForLUT = property(get_useMultiplicativeFactorForLUT, set_useMultiplicativeFactorForLUT)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.AirFunctionNodeMultiplicativeFactorForLut is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_AirFunction', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_AirFunction')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_AirFunction')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_AirFunction', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_AirFunction'):
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            outfile.write(' ident=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ident), input_name='ident')), ))
        if self.ModelName is not None and 'ModelName' not in already_processed:
            already_processed.add('ModelName')
            outfile.write(' ModelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ModelName), input_name='ModelName')), ))
        if self.databaseName is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            outfile.write(' databaseName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.databaseName), input_name='databaseName')), ))
        if self.useMultiplicativeFactorForLUT is not None and 'useMultiplicativeFactorForLUT' not in already_processed:
            already_processed.add('useMultiplicativeFactorForLUT')
            outfile.write(' useMultiplicativeFactorForLUT="%s"' % self.gds_format_integer(self.useMultiplicativeFactorForLUT, input_name='useMultiplicativeFactorForLUT'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_AirFunction', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AirFunctionNodeMultiplicativeFactorForLut is not None:
            self.AirFunctionNodeMultiplicativeFactorForLut.export(outfile, level, namespaceprefix_, name_='AirFunctionNodeMultiplicativeFactorForLut', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_AirFunction', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ident is not None:
            element.set('ident', self.gds_format_string(self.ident))
        if self.ModelName is not None:
            element.set('ModelName', self.gds_format_string(self.ModelName))
        if self.databaseName is not None:
            element.set('databaseName', self.gds_format_string(self.databaseName))
        if self.useMultiplicativeFactorForLUT is not None:
            element.set('useMultiplicativeFactorForLUT', self.gds_format_integer(self.useMultiplicativeFactorForLUT))
        if self.AirFunctionNodeMultiplicativeFactorForLut is not None:
            AirFunctionNodeMultiplicativeFactorForLut_ = self.AirFunctionNodeMultiplicativeFactorForLut
            AirFunctionNodeMultiplicativeFactorForLut_.to_etree(element, name_='AirFunctionNodeMultiplicativeFactorForLut', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_AirFunction'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            showIndent(outfile, level)
            outfile.write('ident="%s",\n' % (self.ident,))
        if self.ModelName is not None and 'ModelName' not in already_processed:
            already_processed.add('ModelName')
            showIndent(outfile, level)
            outfile.write('ModelName="%s",\n' % (self.ModelName,))
        if self.databaseName is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            showIndent(outfile, level)
            outfile.write('databaseName="%s",\n' % (self.databaseName,))
        if self.useMultiplicativeFactorForLUT is not None and 'useMultiplicativeFactorForLUT' not in already_processed:
            already_processed.add('useMultiplicativeFactorForLUT')
            showIndent(outfile, level)
            outfile.write('useMultiplicativeFactorForLUT=%d,\n' % (self.useMultiplicativeFactorForLUT,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AirFunctionNodeMultiplicativeFactorForLut is not None:
            showIndent(outfile, level)
            outfile.write('AirFunctionNodeMultiplicativeFactorForLut=model_._AirFunctionNodeMultiplicativeFactorForLut(\n')
            self.AirFunctionNodeMultiplicativeFactorForLut.exportLiteral(outfile, level, name_='AirFunctionNodeMultiplicativeFactorForLut')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ident', node)
        if value is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            self.ident = value
        value = find_attr_value_('ModelName', node)
        if value is not None and 'ModelName' not in already_processed:
            already_processed.add('ModelName')
            self.ModelName = value
        value = find_attr_value_('databaseName', node)
        if value is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            self.databaseName = value
        value = find_attr_value_('useMultiplicativeFactorForLUT', node)
        if value is not None and 'useMultiplicativeFactorForLUT' not in already_processed:
            already_processed.add('useMultiplicativeFactorForLUT')
            try:
                self.useMultiplicativeFactorForLUT = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AirFunctionNodeMultiplicativeFactorForLut':
            obj_ = create_AirFunctionNodeMultiplicativeFactorForLut.factory()
            obj_.build(child_)
            self.set_AirFunctionNodeMultiplicativeFactorForLut(obj_)
            obj_.original_tagname_ = 'AirFunctionNodeMultiplicativeFactorForLut'
# end class create_AirFunction


class create_AirFunctionNodeMultiplicativeFactorForLut(GeneratedsSuper):
    """Mutiplicative factor per spectral bands Mutiplicative factor per
    spectral bands Multiplicative factor for coefficient A if model
    is Henley Greenstein \nMultiplicative factor for coefficient A
    if model is Rayleigh Multiplicative factor for coefficient A if
    model is Henley Greenstein \nMultiplicative factor for
    coefficient A if model is Rayleigh Multiplicative factor for
    coefficient G1 if model is Henley Greenstein \nMultiplicative
    factor for coefficient C if model is Rayleigh Multiplicative
    factor for coefficient G1 if model is Henley Greenstein
    \nMultiplicative factor for coefficient C if model is Rayleigh
    Multiplicative factor for coefficient G2 if model is Henley
    Greenstein \nThis field is ignored if model is RayLeigh
    Multiplicative factor for coefficient G2 if model is Henley
    Greenstein \nThis field is ignored if model is RayLeigh Use same
    multiplicator for every band Use same multiplicator for every
    band Apply the same 3D factor matrix per cell on optical
    properties to all the spectral bands Apply the same 3D factor
    matrix per cell on optical properties to all the spectral bands
    Multiplicative factor for Sigma Multiplicative factor for Sigma
    Multiplicative factor for Albedo Multiplicative factor for
    Albedo"""
    subclass = None
    superclass = None
    def __init__(self, multiplicativeFactor1=1.0, multiplicativeFactor2=1.0, multiplicativeFactor3=1.0, useSameFactorForAllBands=1, useSameOpticalFactorMatrixForAllBands=0, sigma=1.0, albedo=1.0, AirFunctionMultiplicativeFactorForLut=None, opticalFactorMatrix=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_AirFunctionNodeMultiplicativeFactorForLut")
        self.attrib = ['multiplicativeFactor1', 'multiplicativeFactor2', 'multiplicativeFactor3', 'useSameFactorForAllBands', 'useSameOpticalFactorMatrixForAllBands', 'sigma', 'albedo']
        self.children = ['AirFunctionMultiplicativeFactorForLut', 'opticalFactorMatrix']
        self.parent = None
        self._multiplicativeFactor1 = _cast(float, multiplicativeFactor1)
        self._multiplicativeFactor2 = _cast(float, multiplicativeFactor2)
        self._multiplicativeFactor3 = _cast(float, multiplicativeFactor3)
        self._useSameFactorForAllBands = _cast(int, useSameFactorForAllBands)
        self._useSameOpticalFactorMatrixForAllBands = _cast(int, useSameOpticalFactorMatrixForAllBands)
        self._sigma = _cast(float, sigma)
        self._albedo = _cast(float, albedo)
        if AirFunctionMultiplicativeFactorForLut is None:
            self._AirFunctionMultiplicativeFactorForLut = []
        else:
            self._AirFunctionMultiplicativeFactorForLut = AirFunctionMultiplicativeFactorForLut
        self._opticalFactorMatrix = opticalFactorMatrix
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_AirFunctionNodeMultiplicativeFactorForLut)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_AirFunctionNodeMultiplicativeFactorForLut.subclass:
            return create_AirFunctionNodeMultiplicativeFactorForLut.subclass(*args_, **kwargs_)
        else:
            return create_AirFunctionNodeMultiplicativeFactorForLut(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AirFunctionMultiplicativeFactorForLut(self): return self._AirFunctionMultiplicativeFactorForLut
    def set_AirFunctionMultiplicativeFactorForLut(self, value):
        if value is not None:
            checkclass(value, create_AirFunctionMultiplicativeFactorForLut)
            for v in value:
                v.parent = self
        self._AirFunctionMultiplicativeFactorForLut = value
    def add_AirFunctionMultiplicativeFactorForLut(self, value):
        value.parent = self
        self._AirFunctionMultiplicativeFactorForLut.append(value)
    def insert_AirFunctionMultiplicativeFactorForLut_at(self, index, value):
        value.parent = self
        self.AirFunctionMultiplicativeFactorForLut.insert(index, value)
    def replace_AirFunctionMultiplicativeFactorForLut_at(self, index, value):
        value.parent = self
        self.AirFunctionMultiplicativeFactorForLut[index] = value
    AirFunctionMultiplicativeFactorForLut = property(get_AirFunctionMultiplicativeFactorForLut, set_AirFunctionMultiplicativeFactorForLut)
    def get_opticalFactorMatrix(self): return self._opticalFactorMatrix
    def set_opticalFactorMatrix(self, value):
        if value is not None:
            checkclass(value, create_opticalFactorMatrix)
            value.parent = self
        self._opticalFactorMatrix = value
    opticalFactorMatrix = property(get_opticalFactorMatrix, set_opticalFactorMatrix)
    def get_multiplicativeFactor1(self): return self._multiplicativeFactor1
    def set_multiplicativeFactor1(self, value):
        self._multiplicativeFactor1 = value
        update_node(self,self.troot,"coeff_diff")
    multiplicativeFactor1 = property(get_multiplicativeFactor1, set_multiplicativeFactor1)
    def get_multiplicativeFactor2(self): return self._multiplicativeFactor2
    def set_multiplicativeFactor2(self, value):
        self._multiplicativeFactor2 = value
        update_node(self,self.troot,"coeff_diff")
    multiplicativeFactor2 = property(get_multiplicativeFactor2, set_multiplicativeFactor2)
    def get_multiplicativeFactor3(self): return self._multiplicativeFactor3
    def set_multiplicativeFactor3(self, value):
        self._multiplicativeFactor3 = value
        update_node(self,self.troot,"coeff_diff")
    multiplicativeFactor3 = property(get_multiplicativeFactor3, set_multiplicativeFactor3)
    def get_useSameFactorForAllBands(self): return self._useSameFactorForAllBands
    def set_useSameFactorForAllBands(self, value):
        self._useSameFactorForAllBands = value
        update_node(self,self.troot,"coeff_diff")
    useSameFactorForAllBands = property(get_useSameFactorForAllBands, set_useSameFactorForAllBands)
    def get_useSameOpticalFactorMatrixForAllBands(self): return self._useSameOpticalFactorMatrixForAllBands
    def set_useSameOpticalFactorMatrixForAllBands(self, value):
        self._useSameOpticalFactorMatrixForAllBands = value
        update_node(self,self.troot,"coeff_diff")
    useSameOpticalFactorMatrixForAllBands = property(get_useSameOpticalFactorMatrixForAllBands, set_useSameOpticalFactorMatrixForAllBands)
    def get_sigma(self): return self._sigma
    def set_sigma(self, value):
        self._sigma = value
        update_node(self,self.troot,"coeff_diff")
    sigma = property(get_sigma, set_sigma)
    def get_albedo(self): return self._albedo
    def set_albedo(self, value):
        self._albedo = value
        update_node(self,self.troot,"coeff_diff")
    albedo = property(get_albedo, set_albedo)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.AirFunctionMultiplicativeFactorForLut or
            self.opticalFactorMatrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_AirFunctionNodeMultiplicativeFactorForLut', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_AirFunctionNodeMultiplicativeFactorForLut')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_AirFunctionNodeMultiplicativeFactorForLut')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_AirFunctionNodeMultiplicativeFactorForLut', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_AirFunctionNodeMultiplicativeFactorForLut'):
        if self.multiplicativeFactor1 is not None and 'multiplicativeFactor1' not in already_processed:
            already_processed.add('multiplicativeFactor1')
            outfile.write(' multiplicativeFactor1="%s"' % self.gds_format_double(self.multiplicativeFactor1, input_name='multiplicativeFactor1'))
        if self.multiplicativeFactor2 is not None and 'multiplicativeFactor2' not in already_processed:
            already_processed.add('multiplicativeFactor2')
            outfile.write(' multiplicativeFactor2="%s"' % self.gds_format_double(self.multiplicativeFactor2, input_name='multiplicativeFactor2'))
        if self.multiplicativeFactor3 is not None and 'multiplicativeFactor3' not in already_processed:
            already_processed.add('multiplicativeFactor3')
            outfile.write(' multiplicativeFactor3="%s"' % self.gds_format_double(self.multiplicativeFactor3, input_name='multiplicativeFactor3'))
        if self.useSameFactorForAllBands is not None and 'useSameFactorForAllBands' not in already_processed:
            already_processed.add('useSameFactorForAllBands')
            outfile.write(' useSameFactorForAllBands="%s"' % self.gds_format_integer(self.useSameFactorForAllBands, input_name='useSameFactorForAllBands'))
        if self.useSameOpticalFactorMatrixForAllBands is not None and 'useSameOpticalFactorMatrixForAllBands' not in already_processed:
            already_processed.add('useSameOpticalFactorMatrixForAllBands')
            outfile.write(' useSameOpticalFactorMatrixForAllBands="%s"' % self.gds_format_integer(self.useSameOpticalFactorMatrixForAllBands, input_name='useSameOpticalFactorMatrixForAllBands'))
        if self.sigma is not None and 'sigma' not in already_processed:
            already_processed.add('sigma')
            outfile.write(' sigma="%s"' % self.gds_format_double(self.sigma, input_name='sigma'))
        if self.albedo is not None and 'albedo' not in already_processed:
            already_processed.add('albedo')
            outfile.write(' albedo="%s"' % self.gds_format_double(self.albedo, input_name='albedo'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_AirFunctionNodeMultiplicativeFactorForLut', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AirFunctionMultiplicativeFactorForLut_ in self.AirFunctionMultiplicativeFactorForLut:
            AirFunctionMultiplicativeFactorForLut_.export(outfile, level, namespaceprefix_, name_='AirFunctionMultiplicativeFactorForLut', pretty_print=pretty_print)
        if self.opticalFactorMatrix is not None:
            self.opticalFactorMatrix.export(outfile, level, namespaceprefix_, name_='opticalFactorMatrix', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_AirFunctionNodeMultiplicativeFactorForLut', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.multiplicativeFactor1 is not None:
            element.set('multiplicativeFactor1', self.gds_format_double(self.multiplicativeFactor1))
        if self.multiplicativeFactor2 is not None:
            element.set('multiplicativeFactor2', self.gds_format_double(self.multiplicativeFactor2))
        if self.multiplicativeFactor3 is not None:
            element.set('multiplicativeFactor3', self.gds_format_double(self.multiplicativeFactor3))
        if self.useSameFactorForAllBands is not None:
            element.set('useSameFactorForAllBands', self.gds_format_integer(self.useSameFactorForAllBands))
        if self.useSameOpticalFactorMatrixForAllBands is not None:
            element.set('useSameOpticalFactorMatrixForAllBands', self.gds_format_integer(self.useSameOpticalFactorMatrixForAllBands))
        if self.sigma is not None:
            element.set('sigma', self.gds_format_double(self.sigma))
        if self.albedo is not None:
            element.set('albedo', self.gds_format_double(self.albedo))
        for AirFunctionMultiplicativeFactorForLut_ in self.AirFunctionMultiplicativeFactorForLut:
            AirFunctionMultiplicativeFactorForLut_.to_etree(element, name_='AirFunctionMultiplicativeFactorForLut', mapping_=mapping_)
        if self.opticalFactorMatrix is not None:
            opticalFactorMatrix_ = self.opticalFactorMatrix
            opticalFactorMatrix_.to_etree(element, name_='opticalFactorMatrix', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_AirFunctionNodeMultiplicativeFactorForLut'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.multiplicativeFactor1 is not None and 'multiplicativeFactor1' not in already_processed:
            already_processed.add('multiplicativeFactor1')
            showIndent(outfile, level)
            outfile.write('multiplicativeFactor1=%e,\n' % (self.multiplicativeFactor1,))
        if self.multiplicativeFactor2 is not None and 'multiplicativeFactor2' not in already_processed:
            already_processed.add('multiplicativeFactor2')
            showIndent(outfile, level)
            outfile.write('multiplicativeFactor2=%e,\n' % (self.multiplicativeFactor2,))
        if self.multiplicativeFactor3 is not None and 'multiplicativeFactor3' not in already_processed:
            already_processed.add('multiplicativeFactor3')
            showIndent(outfile, level)
            outfile.write('multiplicativeFactor3=%e,\n' % (self.multiplicativeFactor3,))
        if self.useSameFactorForAllBands is not None and 'useSameFactorForAllBands' not in already_processed:
            already_processed.add('useSameFactorForAllBands')
            showIndent(outfile, level)
            outfile.write('useSameFactorForAllBands=%d,\n' % (self.useSameFactorForAllBands,))
        if self.useSameOpticalFactorMatrixForAllBands is not None and 'useSameOpticalFactorMatrixForAllBands' not in already_processed:
            already_processed.add('useSameOpticalFactorMatrixForAllBands')
            showIndent(outfile, level)
            outfile.write('useSameOpticalFactorMatrixForAllBands=%d,\n' % (self.useSameOpticalFactorMatrixForAllBands,))
        if self.sigma is not None and 'sigma' not in already_processed:
            already_processed.add('sigma')
            showIndent(outfile, level)
            outfile.write('sigma=%e,\n' % (self.sigma,))
        if self.albedo is not None and 'albedo' not in already_processed:
            already_processed.add('albedo')
            showIndent(outfile, level)
            outfile.write('albedo=%e,\n' % (self.albedo,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('AirFunctionMultiplicativeFactorForLut=[\n')
        level += 1
        for AirFunctionMultiplicativeFactorForLut_ in self.AirFunctionMultiplicativeFactorForLut:
            showIndent(outfile, level)
            outfile.write('model_._AirFunctionMultiplicativeFactorForLut(\n')
            AirFunctionMultiplicativeFactorForLut_.exportLiteral(outfile, level, name_='_AirFunctionMultiplicativeFactorForLut')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.opticalFactorMatrix is not None:
            showIndent(outfile, level)
            outfile.write('opticalFactorMatrix=model_._opticalFactorMatrix(\n')
            self.opticalFactorMatrix.exportLiteral(outfile, level, name_='opticalFactorMatrix')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.AirFunctionMultiplicativeFactorForLut = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('multiplicativeFactor1', node)
        if value is not None and 'multiplicativeFactor1' not in already_processed:
            already_processed.add('multiplicativeFactor1')
            try:
                self.multiplicativeFactor1 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (multiplicativeFactor1): %s' % exp)
        value = find_attr_value_('multiplicativeFactor2', node)
        if value is not None and 'multiplicativeFactor2' not in already_processed:
            already_processed.add('multiplicativeFactor2')
            try:
                self.multiplicativeFactor2 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (multiplicativeFactor2): %s' % exp)
        value = find_attr_value_('multiplicativeFactor3', node)
        if value is not None and 'multiplicativeFactor3' not in already_processed:
            already_processed.add('multiplicativeFactor3')
            try:
                self.multiplicativeFactor3 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (multiplicativeFactor3): %s' % exp)
        value = find_attr_value_('useSameFactorForAllBands', node)
        if value is not None and 'useSameFactorForAllBands' not in already_processed:
            already_processed.add('useSameFactorForAllBands')
            try:
                self.useSameFactorForAllBands = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('useSameOpticalFactorMatrixForAllBands', node)
        if value is not None and 'useSameOpticalFactorMatrixForAllBands' not in already_processed:
            already_processed.add('useSameOpticalFactorMatrixForAllBands')
            try:
                self.useSameOpticalFactorMatrixForAllBands = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('sigma', node)
        if value is not None and 'sigma' not in already_processed:
            already_processed.add('sigma')
            try:
                self.sigma = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sigma): %s' % exp)
        value = find_attr_value_('albedo', node)
        if value is not None and 'albedo' not in already_processed:
            already_processed.add('albedo')
            try:
                self.albedo = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (albedo): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AirFunctionMultiplicativeFactorForLut':
            obj_ = create_AirFunctionMultiplicativeFactorForLut.factory()
            obj_.build(child_)
            self.add_AirFunctionMultiplicativeFactorForLut(obj_)
            obj_.original_tagname_ = 'AirFunctionMultiplicativeFactorForLut'
        elif nodeName_ == 'opticalFactorMatrix':
            obj_ = create_opticalFactorMatrix.factory()
            obj_.build(child_)
            self.set_opticalFactorMatrix(obj_)
            obj_.original_tagname_ = 'opticalFactorMatrix'
# end class create_AirFunctionNodeMultiplicativeFactorForLut


class create_AirFunctionMultiplicativeFactorForLut(GeneratedsSuper):
    """Spectral band Spectral band Multiplicative factor for coefficient A
    if model is Henley Greenstein \nMultiplicative factor for
    coefficient A if model is Rayleigh Multiplicative factor for
    coefficient A if model is Henley Greenstein \nMultiplicative
    factor for coefficient A if model is Rayleigh Multiplicative
    factor for coefficient G1 if model is Henley Greenstein
    \nMultiplicative factor for coefficient C if model is Rayleigh
    Multiplicative factor for coefficient G1 if model is Henley
    Greenstein \nMultiplicative factor for coefficient C if model is
    Rayleigh Multiplicative factor for coefficient G2 if model is
    Henley Greenstein \nThis field is ignored if model is RayLeigh
    Multiplicative factor for coefficient G2 if model is Henley
    Greenstein \nThis field is ignored if model is RayLeigh
    Multiplicative factor for Sigma Multiplicative factor for Sigma
    Multiplicative factor for Albedo Multiplicative factor for
    Albedo Apply a 3D factor matrix per cell on optical properties
    Apply a 3D factor matrix per cell on optical properties"""
    subclass = None
    superclass = None
    def __init__(self, multiplicativeFactor1=1.0, multiplicativeFactor2=1.0, multiplicativeFactor3=1.0, sigma=1.0, albedo=1.0, useOpticalFactorMatrix=0, opticalFactorMatrix=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_AirFunctionMultiplicativeFactorForLut")
        self.attrib = ['multiplicativeFactor1', 'multiplicativeFactor2', 'multiplicativeFactor3', 'sigma', 'albedo', 'useOpticalFactorMatrix']
        self.children = ['opticalFactorMatrix']
        self.parent = None
        self._multiplicativeFactor1 = _cast(float, multiplicativeFactor1)
        self._multiplicativeFactor2 = _cast(float, multiplicativeFactor2)
        self._multiplicativeFactor3 = _cast(float, multiplicativeFactor3)
        self._sigma = _cast(float, sigma)
        self._albedo = _cast(float, albedo)
        self._useOpticalFactorMatrix = _cast(int, useOpticalFactorMatrix)
        self._opticalFactorMatrix = opticalFactorMatrix
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_AirFunctionMultiplicativeFactorForLut)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_AirFunctionMultiplicativeFactorForLut.subclass:
            return create_AirFunctionMultiplicativeFactorForLut.subclass(*args_, **kwargs_)
        else:
            return create_AirFunctionMultiplicativeFactorForLut(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_opticalFactorMatrix(self): return self._opticalFactorMatrix
    def set_opticalFactorMatrix(self, value):
        if value is not None:
            checkclass(value, create_opticalFactorMatrix)
            value.parent = self
        self._opticalFactorMatrix = value
    opticalFactorMatrix = property(get_opticalFactorMatrix, set_opticalFactorMatrix)
    def get_multiplicativeFactor1(self): return self._multiplicativeFactor1
    def set_multiplicativeFactor1(self, value):
        self._multiplicativeFactor1 = value
        update_node(self,self.troot,"coeff_diff")
    multiplicativeFactor1 = property(get_multiplicativeFactor1, set_multiplicativeFactor1)
    def get_multiplicativeFactor2(self): return self._multiplicativeFactor2
    def set_multiplicativeFactor2(self, value):
        self._multiplicativeFactor2 = value
        update_node(self,self.troot,"coeff_diff")
    multiplicativeFactor2 = property(get_multiplicativeFactor2, set_multiplicativeFactor2)
    def get_multiplicativeFactor3(self): return self._multiplicativeFactor3
    def set_multiplicativeFactor3(self, value):
        self._multiplicativeFactor3 = value
        update_node(self,self.troot,"coeff_diff")
    multiplicativeFactor3 = property(get_multiplicativeFactor3, set_multiplicativeFactor3)
    def get_sigma(self): return self._sigma
    def set_sigma(self, value):
        self._sigma = value
        update_node(self,self.troot,"coeff_diff")
    sigma = property(get_sigma, set_sigma)
    def get_albedo(self): return self._albedo
    def set_albedo(self, value):
        self._albedo = value
        update_node(self,self.troot,"coeff_diff")
    albedo = property(get_albedo, set_albedo)
    def get_useOpticalFactorMatrix(self): return self._useOpticalFactorMatrix
    def set_useOpticalFactorMatrix(self, value):
        self._useOpticalFactorMatrix = value
        update_node(self,self.troot,"coeff_diff")
    useOpticalFactorMatrix = property(get_useOpticalFactorMatrix, set_useOpticalFactorMatrix)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.opticalFactorMatrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_AirFunctionMultiplicativeFactorForLut', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_AirFunctionMultiplicativeFactorForLut')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_AirFunctionMultiplicativeFactorForLut')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_AirFunctionMultiplicativeFactorForLut', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_AirFunctionMultiplicativeFactorForLut'):
        if self.multiplicativeFactor1 is not None and 'multiplicativeFactor1' not in already_processed:
            already_processed.add('multiplicativeFactor1')
            outfile.write(' multiplicativeFactor1="%s"' % self.gds_format_double(self.multiplicativeFactor1, input_name='multiplicativeFactor1'))
        if self.multiplicativeFactor2 is not None and 'multiplicativeFactor2' not in already_processed:
            already_processed.add('multiplicativeFactor2')
            outfile.write(' multiplicativeFactor2="%s"' % self.gds_format_double(self.multiplicativeFactor2, input_name='multiplicativeFactor2'))
        if self.multiplicativeFactor3 is not None and 'multiplicativeFactor3' not in already_processed:
            already_processed.add('multiplicativeFactor3')
            outfile.write(' multiplicativeFactor3="%s"' % self.gds_format_double(self.multiplicativeFactor3, input_name='multiplicativeFactor3'))
        if self.sigma is not None and 'sigma' not in already_processed:
            already_processed.add('sigma')
            outfile.write(' sigma="%s"' % self.gds_format_double(self.sigma, input_name='sigma'))
        if self.albedo is not None and 'albedo' not in already_processed:
            already_processed.add('albedo')
            outfile.write(' albedo="%s"' % self.gds_format_double(self.albedo, input_name='albedo'))
        if self.useOpticalFactorMatrix is not None and 'useOpticalFactorMatrix' not in already_processed:
            already_processed.add('useOpticalFactorMatrix')
            outfile.write(' useOpticalFactorMatrix="%s"' % self.gds_format_integer(self.useOpticalFactorMatrix, input_name='useOpticalFactorMatrix'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_AirFunctionMultiplicativeFactorForLut', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.opticalFactorMatrix is not None:
            self.opticalFactorMatrix.export(outfile, level, namespaceprefix_, name_='opticalFactorMatrix', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_AirFunctionMultiplicativeFactorForLut', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.multiplicativeFactor1 is not None:
            element.set('multiplicativeFactor1', self.gds_format_double(self.multiplicativeFactor1))
        if self.multiplicativeFactor2 is not None:
            element.set('multiplicativeFactor2', self.gds_format_double(self.multiplicativeFactor2))
        if self.multiplicativeFactor3 is not None:
            element.set('multiplicativeFactor3', self.gds_format_double(self.multiplicativeFactor3))
        if self.sigma is not None:
            element.set('sigma', self.gds_format_double(self.sigma))
        if self.albedo is not None:
            element.set('albedo', self.gds_format_double(self.albedo))
        if self.useOpticalFactorMatrix is not None:
            element.set('useOpticalFactorMatrix', self.gds_format_integer(self.useOpticalFactorMatrix))
        if self.opticalFactorMatrix is not None:
            opticalFactorMatrix_ = self.opticalFactorMatrix
            opticalFactorMatrix_.to_etree(element, name_='opticalFactorMatrix', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_AirFunctionMultiplicativeFactorForLut'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.multiplicativeFactor1 is not None and 'multiplicativeFactor1' not in already_processed:
            already_processed.add('multiplicativeFactor1')
            showIndent(outfile, level)
            outfile.write('multiplicativeFactor1=%e,\n' % (self.multiplicativeFactor1,))
        if self.multiplicativeFactor2 is not None and 'multiplicativeFactor2' not in already_processed:
            already_processed.add('multiplicativeFactor2')
            showIndent(outfile, level)
            outfile.write('multiplicativeFactor2=%e,\n' % (self.multiplicativeFactor2,))
        if self.multiplicativeFactor3 is not None and 'multiplicativeFactor3' not in already_processed:
            already_processed.add('multiplicativeFactor3')
            showIndent(outfile, level)
            outfile.write('multiplicativeFactor3=%e,\n' % (self.multiplicativeFactor3,))
        if self.sigma is not None and 'sigma' not in already_processed:
            already_processed.add('sigma')
            showIndent(outfile, level)
            outfile.write('sigma=%e,\n' % (self.sigma,))
        if self.albedo is not None and 'albedo' not in already_processed:
            already_processed.add('albedo')
            showIndent(outfile, level)
            outfile.write('albedo=%e,\n' % (self.albedo,))
        if self.useOpticalFactorMatrix is not None and 'useOpticalFactorMatrix' not in already_processed:
            already_processed.add('useOpticalFactorMatrix')
            showIndent(outfile, level)
            outfile.write('useOpticalFactorMatrix=%d,\n' % (self.useOpticalFactorMatrix,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.opticalFactorMatrix is not None:
            showIndent(outfile, level)
            outfile.write('opticalFactorMatrix=model_._opticalFactorMatrix(\n')
            self.opticalFactorMatrix.exportLiteral(outfile, level, name_='opticalFactorMatrix')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('multiplicativeFactor1', node)
        if value is not None and 'multiplicativeFactor1' not in already_processed:
            already_processed.add('multiplicativeFactor1')
            try:
                self.multiplicativeFactor1 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (multiplicativeFactor1): %s' % exp)
        value = find_attr_value_('multiplicativeFactor2', node)
        if value is not None and 'multiplicativeFactor2' not in already_processed:
            already_processed.add('multiplicativeFactor2')
            try:
                self.multiplicativeFactor2 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (multiplicativeFactor2): %s' % exp)
        value = find_attr_value_('multiplicativeFactor3', node)
        if value is not None and 'multiplicativeFactor3' not in already_processed:
            already_processed.add('multiplicativeFactor3')
            try:
                self.multiplicativeFactor3 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (multiplicativeFactor3): %s' % exp)
        value = find_attr_value_('sigma', node)
        if value is not None and 'sigma' not in already_processed:
            already_processed.add('sigma')
            try:
                self.sigma = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sigma): %s' % exp)
        value = find_attr_value_('albedo', node)
        if value is not None and 'albedo' not in already_processed:
            already_processed.add('albedo')
            try:
                self.albedo = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (albedo): %s' % exp)
        value = find_attr_value_('useOpticalFactorMatrix', node)
        if value is not None and 'useOpticalFactorMatrix' not in already_processed:
            already_processed.add('useOpticalFactorMatrix')
            try:
                self.useOpticalFactorMatrix = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'opticalFactorMatrix':
            obj_ = create_opticalFactorMatrix.factory()
            obj_.build(child_)
            self.set_opticalFactorMatrix(obj_)
            obj_.original_tagname_ = 'opticalFactorMatrix'
# end class create_AirFunctionMultiplicativeFactorForLut


class create_Temperatures(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ThermalFunction=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_Temperatures")
        self.attrib = ['']
        self.children = ['ThermalFunction']
        self.parent = None
        if ThermalFunction is None:
            self._ThermalFunction = []
        else:
            self._ThermalFunction = ThermalFunction
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Temperatures)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Temperatures.subclass:
            return create_Temperatures.subclass(*args_, **kwargs_)
        else:
            return create_Temperatures(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ThermalFunction(self): return self._ThermalFunction
    def set_ThermalFunction(self, value):
        if value is not None:
            checkclass(value, create_ThermalFunction)
            for v in value:
                v.parent = self
        self._ThermalFunction = value
    def add_ThermalFunction(self, value):
        value.parent = self
        self._ThermalFunction.append(value)
    def insert_ThermalFunction_at(self, index, value):
        value.parent = self
        self.ThermalFunction.insert(index, value)
    def replace_ThermalFunction_at(self, index, value):
        value.parent = self
        self.ThermalFunction[index] = value
    ThermalFunction = property(get_ThermalFunction, set_ThermalFunction)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.ThermalFunction
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Temperatures', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Temperatures')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Temperatures')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Temperatures', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Temperatures'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Temperatures', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ThermalFunction_ in self.ThermalFunction:
            ThermalFunction_.export(outfile, level, namespaceprefix_, name_='ThermalFunction', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Temperatures', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for ThermalFunction_ in self.ThermalFunction:
            ThermalFunction_.to_etree(element, name_='ThermalFunction', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Temperatures'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ThermalFunction=[\n')
        level += 1
        for ThermalFunction_ in self.ThermalFunction:
            showIndent(outfile, level)
            outfile.write('model_._ThermalFunction(\n')
            ThermalFunction_.exportLiteral(outfile, level, name_='_ThermalFunction')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.ThermalFunction = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ThermalFunction':
            obj_ = create_ThermalFunction.factory()
            obj_.build(child_)
            self.add_ThermalFunction(obj_)
            obj_.original_tagname_ = 'ThermalFunction'
# end class create_Temperatures


class create_ThermalFunction(GeneratedsSuper):
    """Mean temperature Mean temperature Thermal Function ID Thermal
    Function ID delta temperature : object temperature defined by a
    function of temperature will be between [meanT - deltaT/2 ;
    meanT + deltaT/2] delta temperature : object temperature defined
    by a function of temperature will be between [meanT - deltaT/2 ;
    meanT + deltaT/2] Apply a 3D factor matrix per cell on optical
    properties Apply a 3D factor matrix per cell on optical
    properties Elements of the scene using a thermal function with
    this option enabled will ignore the temperature provided by the
    3D Matrix option. Elements of the scene using a thermal function
    with this option enabled will ignore the temperature provided by
    the 3D Matrix option. If checked, a single temperature will be
    applied to both side of the surfaces, namely the
    maximum.\nOtherwise, each side may have a different temperature
    depending on their individual illumination. If checked, a single
    temperature will be applied to both side of the surfaces, namely
    the maximum.\nOtherwise, each side may have a different
    temperature depending on their individual illumination."""
    subclass = None
    superclass = None
    def __init__(self, meanT=300.0, idTemperature='ThermalFunction290_310', deltaT=20.0, useOpticalFactorMatrix=0, override3DMatrix=0, singleTemperatureSurface=1, opticalFactorMatrix=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("coeff_diff","_ThermalFunction")
        self.attrib = ['meanT', 'idTemperature', 'deltaT', 'useOpticalFactorMatrix', 'override3DMatrix', 'singleTemperatureSurface']
        self.children = ['opticalFactorMatrix']
        self.parent = None
        self._meanT = _cast(float, meanT)
        self._idTemperature = _cast(None, idTemperature)
        self._deltaT = _cast(float, deltaT)
        self._useOpticalFactorMatrix = _cast(int, useOpticalFactorMatrix)
        self._override3DMatrix = _cast(int, override3DMatrix)
        self._singleTemperatureSurface = _cast(int, singleTemperatureSurface)
        self._opticalFactorMatrix = opticalFactorMatrix
        update_node(self,self.troot,"coeff_diff")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ThermalFunction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ThermalFunction.subclass:
            return create_ThermalFunction.subclass(*args_, **kwargs_)
        else:
            return create_ThermalFunction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_opticalFactorMatrix(self): return self._opticalFactorMatrix
    def set_opticalFactorMatrix(self, value):
        if value is not None:
            checkclass(value, create_opticalFactorMatrix)
            value.parent = self
        self._opticalFactorMatrix = value
    opticalFactorMatrix = property(get_opticalFactorMatrix, set_opticalFactorMatrix)
    def get_meanT(self): return self._meanT
    def set_meanT(self, value):
        self._meanT = value
        update_node(self,self.troot,"coeff_diff")
    meanT = property(get_meanT, set_meanT)
    def get_idTemperature(self): return self._idTemperature
    def set_idTemperature(self, value):
        self._idTemperature = value
        update_node(self,self.troot,"coeff_diff")
    idTemperature = property(get_idTemperature, set_idTemperature)
    def get_deltaT(self): return self._deltaT
    def set_deltaT(self, value):
        self._deltaT = value
        update_node(self,self.troot,"coeff_diff")
    deltaT = property(get_deltaT, set_deltaT)
    def get_useOpticalFactorMatrix(self): return self._useOpticalFactorMatrix
    def set_useOpticalFactorMatrix(self, value):
        self._useOpticalFactorMatrix = value
        update_node(self,self.troot,"coeff_diff")
    useOpticalFactorMatrix = property(get_useOpticalFactorMatrix, set_useOpticalFactorMatrix)
    def get_override3DMatrix(self): return self._override3DMatrix
    def set_override3DMatrix(self, value):
        self._override3DMatrix = value
        update_node(self,self.troot,"coeff_diff")
    override3DMatrix = property(get_override3DMatrix, set_override3DMatrix)
    def get_singleTemperatureSurface(self): return self._singleTemperatureSurface
    def set_singleTemperatureSurface(self, value):
        self._singleTemperatureSurface = value
        update_node(self,self.troot,"coeff_diff")
    singleTemperatureSurface = property(get_singleTemperatureSurface, set_singleTemperatureSurface)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.opticalFactorMatrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ThermalFunction', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ThermalFunction')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ThermalFunction')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ThermalFunction', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ThermalFunction'):
        if self.meanT is not None and 'meanT' not in already_processed:
            already_processed.add('meanT')
            outfile.write(' meanT="%s"' % self.gds_format_double(self.meanT, input_name='meanT'))
        if self.idTemperature is not None and 'idTemperature' not in already_processed:
            already_processed.add('idTemperature')
            outfile.write(' idTemperature=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idTemperature), input_name='idTemperature')), ))
        if self.deltaT is not None and 'deltaT' not in already_processed:
            already_processed.add('deltaT')
            outfile.write(' deltaT="%s"' % self.gds_format_double(self.deltaT, input_name='deltaT'))
        if self.useOpticalFactorMatrix is not None and 'useOpticalFactorMatrix' not in already_processed:
            already_processed.add('useOpticalFactorMatrix')
            outfile.write(' useOpticalFactorMatrix="%s"' % self.gds_format_integer(self.useOpticalFactorMatrix, input_name='useOpticalFactorMatrix'))
        if self.override3DMatrix is not None and 'override3DMatrix' not in already_processed:
            already_processed.add('override3DMatrix')
            outfile.write(' override3DMatrix="%s"' % self.gds_format_integer(self.override3DMatrix, input_name='override3DMatrix'))
        if self.singleTemperatureSurface is not None and 'singleTemperatureSurface' not in already_processed:
            already_processed.add('singleTemperatureSurface')
            outfile.write(' singleTemperatureSurface="%s"' % self.gds_format_integer(self.singleTemperatureSurface, input_name='singleTemperatureSurface'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ThermalFunction', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.opticalFactorMatrix is not None:
            self.opticalFactorMatrix.export(outfile, level, namespaceprefix_, name_='opticalFactorMatrix', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_ThermalFunction', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.meanT is not None:
            element.set('meanT', self.gds_format_double(self.meanT))
        if self.idTemperature is not None:
            element.set('idTemperature', self.gds_format_string(self.idTemperature))
        if self.deltaT is not None:
            element.set('deltaT', self.gds_format_double(self.deltaT))
        if self.useOpticalFactorMatrix is not None:
            element.set('useOpticalFactorMatrix', self.gds_format_integer(self.useOpticalFactorMatrix))
        if self.override3DMatrix is not None:
            element.set('override3DMatrix', self.gds_format_integer(self.override3DMatrix))
        if self.singleTemperatureSurface is not None:
            element.set('singleTemperatureSurface', self.gds_format_integer(self.singleTemperatureSurface))
        if self.opticalFactorMatrix is not None:
            opticalFactorMatrix_ = self.opticalFactorMatrix
            opticalFactorMatrix_.to_etree(element, name_='opticalFactorMatrix', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ThermalFunction'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.meanT is not None and 'meanT' not in already_processed:
            already_processed.add('meanT')
            showIndent(outfile, level)
            outfile.write('meanT=%e,\n' % (self.meanT,))
        if self.idTemperature is not None and 'idTemperature' not in already_processed:
            already_processed.add('idTemperature')
            showIndent(outfile, level)
            outfile.write('idTemperature="%s",\n' % (self.idTemperature,))
        if self.deltaT is not None and 'deltaT' not in already_processed:
            already_processed.add('deltaT')
            showIndent(outfile, level)
            outfile.write('deltaT=%e,\n' % (self.deltaT,))
        if self.useOpticalFactorMatrix is not None and 'useOpticalFactorMatrix' not in already_processed:
            already_processed.add('useOpticalFactorMatrix')
            showIndent(outfile, level)
            outfile.write('useOpticalFactorMatrix=%d,\n' % (self.useOpticalFactorMatrix,))
        if self.override3DMatrix is not None and 'override3DMatrix' not in already_processed:
            already_processed.add('override3DMatrix')
            showIndent(outfile, level)
            outfile.write('override3DMatrix=%d,\n' % (self.override3DMatrix,))
        if self.singleTemperatureSurface is not None and 'singleTemperatureSurface' not in already_processed:
            already_processed.add('singleTemperatureSurface')
            showIndent(outfile, level)
            outfile.write('singleTemperatureSurface=%d,\n' % (self.singleTemperatureSurface,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.opticalFactorMatrix is not None:
            showIndent(outfile, level)
            outfile.write('opticalFactorMatrix=model_._opticalFactorMatrix(\n')
            self.opticalFactorMatrix.exportLiteral(outfile, level, name_='opticalFactorMatrix')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('meanT', node)
        if value is not None and 'meanT' not in already_processed:
            already_processed.add('meanT')
            try:
                self.meanT = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (meanT): %s' % exp)
        value = find_attr_value_('idTemperature', node)
        if value is not None and 'idTemperature' not in already_processed:
            already_processed.add('idTemperature')
            self.idTemperature = value
        value = find_attr_value_('deltaT', node)
        if value is not None and 'deltaT' not in already_processed:
            already_processed.add('deltaT')
            try:
                self.deltaT = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (deltaT): %s' % exp)
        value = find_attr_value_('useOpticalFactorMatrix', node)
        if value is not None and 'useOpticalFactorMatrix' not in already_processed:
            already_processed.add('useOpticalFactorMatrix')
            try:
                self.useOpticalFactorMatrix = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('override3DMatrix', node)
        if value is not None and 'override3DMatrix' not in already_processed:
            already_processed.add('override3DMatrix')
            try:
                self.override3DMatrix = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('singleTemperatureSurface', node)
        if value is not None and 'singleTemperatureSurface' not in already_processed:
            already_processed.add('singleTemperatureSurface')
            try:
                self.singleTemperatureSurface = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'opticalFactorMatrix':
            obj_ = create_opticalFactorMatrix.factory()
            obj_.build(child_)
            self.set_opticalFactorMatrix(obj_)
            obj_.original_tagname_ = 'opticalFactorMatrix'
# end class create_ThermalFunction


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <createParser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from coeff_diff import *\n\n')
        sys.stdout.write('import coeff_diff as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "createDartFile",
    "create_AirFunction",
    "create_AirFunctionMultiplicativeFactorForLut",
    "create_AirFunctionNodeMultiplicativeFactorForLut",
    "create_AirMultiFunctions",
    "create_BioClimaticWeighting",
    "create_BoundedUniform",
    "create_Coeff_diff",
    "create_DirectionalClumpingIndexProperties",
    "create_Ellipsoidal",
    "create_Elliptical",
    "create_FluorescenceProductsProperties",
    "create_FluorescenceYields",
    "create_HapkeExternalModule",
    "create_HapkeExternalModules",
    "create_HapkeSpecularMulti",
    "create_HapkeSpecularMultiFunctions",
    "create_LambertianMulti",
    "create_LambertianMultiFunctions",
    "create_Manual",
    "create_OpticalPropertyLink",
    "create_ProspectExternParameters",
    "create_ProspectExternalModule",
    "create_RPVMulti",
    "create_RPVMultiFunctions",
    "create_RPVMultiplicativeFactorForLUT",
    "create_RPVNodeMultiplicativeFactorForLUT",
    "create_SpecularData",
    "create_Temperatures",
    "create_ThermalFunction",
    "create_UnderstoryMulti",
    "create_UnderstoryMultiFunctions",
    "create_UserDefined",
    "create_WindProfileEta",
    "create_Yields",
    "create_hapkeMultiplicativeFactorForLUT",
    "create_hapkeNodeMultiplicativeFactorForLUT",
    "create_lambertianMultiplicativeFactorForLUT",
    "create_lambertianNodeMultiplicativeFactorForLUT",
    "create_opticalFactorMatrix",
    "create_understoryMultiplicativeFactorForLUT",
    "create_understoryNodeMultiplicativeFactorForLUT"
]
