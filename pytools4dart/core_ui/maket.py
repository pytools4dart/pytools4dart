#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Jan 30 01:18:09 2019 by generateDS.py version 2.29.25.
# Python 2.7.3 (default, Oct 26 2016, 21:01:49)  [GCC 4.6.3]
#
# Command line options:
#   ('-m', '')
#   ('-f', '')
#   ('--always-export-default', '')
#   ('--export', 'write literal etree')
#   ('-u', 'core_ui.user_methods')
#   ('-p', 'create')
#   ('--post-attrib-setter', "update_node(self,self.troot,'maket')")
#   ('--pre-ctor', "self.troot=get_gs_troot('maket','{classname}')")
#   ('--post-ctor', "update_node(self,self.troot,'maket')")
#   ('--imports', 'from pytools4dart.core_ui.utils import get_gs_troot, update_node, get_path')
#   ('-o', '/media/DATA/Florian/IRSTEA/Scripts/pytools4dartMTD/pytools4dart/core_ui/maket.py')
#
# Command line arguments:
#   /media/DATA/Florian/IRSTEA/Scripts/pytools4dartMTD/pytools4dart/xsdschemas/maket.xsd
#
# Command line:
#   /media/DATA/Florian/IRSTEA/Scripts/pytools4dartMTD/venv/bin/generateDS.py -m -f --always-export-default --export="write literal etree" -u "core_ui.user_methods" -p "create" --post-attrib-setter="update_node(self,self.troot,'maket')" --pre-ctor="self.troot=get_gs_troot('maket','{classname}')" --post-ctor="update_node(self,self.troot,'maket')" --imports="from pytools4dart.core_ui.utils import get_gs_troot, update_node, get_path" -o "/media/DATA/Florian/IRSTEA/Scripts/pytools4dartMTD/pytools4dart/core_ui/maket.py" /media/DATA/Florian/IRSTEA/Scripts/pytools4dartMTD/pytools4dart/xsdschemas/maket.xsd
#
# Current working directory (os.getcwd()):
#   pytools4dart
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_
from pytools4dart.core_ui.utils import get_gs_troot, update_node, get_path


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#

def checkclass(value, cl):
    if isinstance(value, list):
        for v in value:
            if not isinstance(v, cl):
                raise ValueError("invalid class")
    else:
        if not isinstance(value, cl):
            raise ValueError("invalid class")

def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class createDartFile(GeneratedsSuper):
    """Version of the plots.xml file. Depends of the version on DART
    itself. Version of the plots.xml file. Depends of the version on
    DART itself."""
    member_data_items_ = [
        MemberSpec_('version', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('build_', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('Maket', '_Maket', 0, 0, {u'maxOccurs': u'1', u'type': u'_Maket', u'name': u'Maket', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, version='5.7.4', build_='0', Maket=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('maket','DartFile')
        self.attrib = ['version', 'build_']
        self.children = ['Maket']
        self.parent = None
        self._version = _cast(None, version)
        self._build_ = _cast(None, build_)
        self._Maket = Maket
        update_node(self,self.troot,'maket')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, createDartFile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if createDartFile.subclass:
            return createDartFile.subclass(*args_, **kwargs_)
        else:
            return createDartFile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Maket(self): return self._Maket
    def set_Maket(self, value):
        if value is not None:
            checkclass(value, create_Maket)
            value.parent = self
        self._Maket = value
    Maket = property(get_Maket, set_Maket)
    def get_version(self): return self._version
    def set_version(self, value):
        self._version = value
        update_node(self,self.troot,'maket')
    version = property(get_version, set_version)
    def get_build(self): return self._build_
    def set_build(self, value):
        self._build_ = value
        update_node(self,self.troot,'maket')
    build_ = property(get_build, set_build)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Maket is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='DartFile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DartFile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DartFile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='DartFile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DartFile'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
        if self.build_ is not None and 'build_' not in already_processed:
            already_processed.add('build_')
            outfile.write(' build=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.build_), input_name='build')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='DartFile', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Maket is not None:
            self.Maket.export(outfile, level, namespaceprefix_, name_='Maket', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='DartFile', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.version is not None:
            element.set('version', self.gds_format_string(self.version))
        if self.build_ is not None:
            element.set('build', self.gds_format_string(self.build_))
        if self.Maket is not None:
            Maket_ = self.Maket
            Maket_.to_etree(element, name_='Maket', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='DartFile'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.build_ is not None and 'build_' not in already_processed:
            already_processed.add('build_')
            showIndent(outfile, level)
            outfile.write('build_="%s",\n' % (self.build_,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Maket is not None:
            showIndent(outfile, level)
            outfile.write('Maket=model_._Maket(\n')
            self.Maket.exportLiteral(outfile, level, name_='Maket')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('build', node)
        if value is not None and 'build' not in already_processed:
            already_processed.add('build')
            self.build_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Maket':
            obj_ = create_Maket.factory()
            obj_.build(child_)
            self.set_Maket(obj_)
            obj_.original_tagname_ = 'Maket'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class createDartFile


class create_Maket(GeneratedsSuper):
    """The actual DART scene can a sub-rectangular part of the total
    specified scene. Then, crowns of neighbor trees can appear in
    the simulated scene The actual DART scene can a sub-rectangular
    part of the total specified scene. Then, crowns of neighbor
    trees can appear in the simulated scene juxtaposition of a
    unique pattern\nContninuous scene: Altitudes of juxtaposed
    patterns are equal or are shifted with values equal to altitude
    difference the scene edges. This option ensures the continuity
    of topography. It allows one to simulate infinite slopes.
    juxtaposition of a unique pattern\nContninuous scene: Altitudes
    of juxtaposed patterns are equal or are shifted with values
    equal to altitude difference the scene edges. This option
    ensures the continuity of topography. It allows one to simulate
    infinite slopes. Use a random seed for random operations. Use a
    random seed for random operations."""
    member_data_items_ = [
        MemberSpec_('dartZone', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('exactlyPeriodicScene', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('useRandomGenerationSeed', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('Scene', '_Scene', 0, 0, {u'maxOccurs': u'1', u'type': u'_Scene', u'name': u'Scene', u'minOccurs': u'1'}, None),
        MemberSpec_('RandomGenerationParameters', '_RandomGenerationParameters', 0, 0, {u'maxOccurs': u'1', u'type': u'_RandomGenerationParameters', u'name': u'RandomGenerationParameters', u'minOccurs': u'1'}, None),
        MemberSpec_('Soil', '_Soil', 0, 0, {u'maxOccurs': u'1', u'type': u'_Soil', u'name': u'Soil', u'minOccurs': u'1'}, None),
        MemberSpec_('LatLon', '_LatLon', 0, 0, {u'maxOccurs': u'1', u'type': u'_LatLon', u'name': u'LatLon', u'minOccurs': u'1'}, None),
        MemberSpec_('InfiniteSlopeProperties', '_InfiniteSlopeProperties', 0, 0, {u'maxOccurs': u'1', u'type': u'_InfiniteSlopeProperties', u'name': u'InfiniteSlopeProperties', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, dartZone=0, exactlyPeriodicScene=1, useRandomGenerationSeed=1, Scene=None, RandomGenerationParameters=None, Soil=None, LatLon=None, InfiniteSlopeProperties=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('maket','_Maket')
        self.attrib = ['dartZone', 'exactlyPeriodicScene', 'useRandomGenerationSeed']
        self.children = ['Scene', 'RandomGenerationParameters', 'Soil', 'LatLon', 'InfiniteSlopeProperties']
        self.parent = None
        self._dartZone = _cast(int, dartZone)
        self._exactlyPeriodicScene = _cast(int, exactlyPeriodicScene)
        self._useRandomGenerationSeed = _cast(int, useRandomGenerationSeed)
        self._Scene = Scene
        self._RandomGenerationParameters = RandomGenerationParameters
        self._Soil = Soil
        self._LatLon = LatLon
        self._InfiniteSlopeProperties = InfiniteSlopeProperties
        update_node(self,self.troot,'maket')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Maket)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Maket.subclass:
            return create_Maket.subclass(*args_, **kwargs_)
        else:
            return create_Maket(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Scene(self): return self._Scene
    def set_Scene(self, value):
        if value is not None:
            checkclass(value, create_Scene)
            value.parent = self
        self._Scene = value
    Scene = property(get_Scene, set_Scene)
    def get_RandomGenerationParameters(self): return self._RandomGenerationParameters
    def set_RandomGenerationParameters(self, value):
        if value is not None:
            checkclass(value, create_RandomGenerationParameters)
            value.parent = self
        self._RandomGenerationParameters = value
    RandomGenerationParameters = property(get_RandomGenerationParameters, set_RandomGenerationParameters)
    def get_Soil(self): return self._Soil
    def set_Soil(self, value):
        if value is not None:
            checkclass(value, create_Soil)
            value.parent = self
        self._Soil = value
    Soil = property(get_Soil, set_Soil)
    def get_LatLon(self): return self._LatLon
    def set_LatLon(self, value):
        if value is not None:
            checkclass(value, create_LatLon)
            value.parent = self
        self._LatLon = value
    LatLon = property(get_LatLon, set_LatLon)
    def get_InfiniteSlopeProperties(self): return self._InfiniteSlopeProperties
    def set_InfiniteSlopeProperties(self, value):
        if value is not None:
            checkclass(value, create_InfiniteSlopeProperties)
            value.parent = self
        self._InfiniteSlopeProperties = value
    InfiniteSlopeProperties = property(get_InfiniteSlopeProperties, set_InfiniteSlopeProperties)
    def get_dartZone(self): return self._dartZone
    def set_dartZone(self, value):
        self._dartZone = value
        update_node(self,self.troot,'maket')
    dartZone = property(get_dartZone, set_dartZone)
    def get_exactlyPeriodicScene(self): return self._exactlyPeriodicScene
    def set_exactlyPeriodicScene(self, value):
        self._exactlyPeriodicScene = value
        update_node(self,self.troot,'maket')
    exactlyPeriodicScene = property(get_exactlyPeriodicScene, set_exactlyPeriodicScene)
    def get_useRandomGenerationSeed(self): return self._useRandomGenerationSeed
    def set_useRandomGenerationSeed(self, value):
        self._useRandomGenerationSeed = value
        update_node(self,self.troot,'maket')
    useRandomGenerationSeed = property(get_useRandomGenerationSeed, set_useRandomGenerationSeed)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Scene is not None or
            self.RandomGenerationParameters is not None or
            self.Soil is not None or
            self.LatLon is not None or
            self.InfiniteSlopeProperties is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Maket', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Maket')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Maket')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Maket', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Maket'):
        if self.dartZone is not None and 'dartZone' not in already_processed:
            already_processed.add('dartZone')
            outfile.write(' dartZone="%s"' % self.gds_format_integer(self.dartZone, input_name='dartZone'))
        if self.exactlyPeriodicScene is not None and 'exactlyPeriodicScene' not in already_processed:
            already_processed.add('exactlyPeriodicScene')
            outfile.write(' exactlyPeriodicScene="%s"' % self.gds_format_integer(self.exactlyPeriodicScene, input_name='exactlyPeriodicScene'))
        if self.useRandomGenerationSeed is not None and 'useRandomGenerationSeed' not in already_processed:
            already_processed.add('useRandomGenerationSeed')
            outfile.write(' useRandomGenerationSeed="%s"' % self.gds_format_integer(self.useRandomGenerationSeed, input_name='useRandomGenerationSeed'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Maket', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Scene is not None:
            self.Scene.export(outfile, level, namespaceprefix_, name_='Scene', pretty_print=pretty_print)
        if self.RandomGenerationParameters is not None:
            self.RandomGenerationParameters.export(outfile, level, namespaceprefix_, name_='RandomGenerationParameters', pretty_print=pretty_print)
        if self.Soil is not None:
            self.Soil.export(outfile, level, namespaceprefix_, name_='Soil', pretty_print=pretty_print)
        if self.LatLon is not None:
            self.LatLon.export(outfile, level, namespaceprefix_, name_='LatLon', pretty_print=pretty_print)
        if self.InfiniteSlopeProperties is not None:
            self.InfiniteSlopeProperties.export(outfile, level, namespaceprefix_, name_='InfiniteSlopeProperties', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Maket', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.dartZone is not None:
            element.set('dartZone', self.gds_format_integer(self.dartZone))
        if self.exactlyPeriodicScene is not None:
            element.set('exactlyPeriodicScene', self.gds_format_integer(self.exactlyPeriodicScene))
        if self.useRandomGenerationSeed is not None:
            element.set('useRandomGenerationSeed', self.gds_format_integer(self.useRandomGenerationSeed))
        if self.Scene is not None:
            Scene_ = self.Scene
            Scene_.to_etree(element, name_='Scene', mapping_=mapping_)
        if self.RandomGenerationParameters is not None:
            RandomGenerationParameters_ = self.RandomGenerationParameters
            RandomGenerationParameters_.to_etree(element, name_='RandomGenerationParameters', mapping_=mapping_)
        if self.Soil is not None:
            Soil_ = self.Soil
            Soil_.to_etree(element, name_='Soil', mapping_=mapping_)
        if self.LatLon is not None:
            LatLon_ = self.LatLon
            LatLon_.to_etree(element, name_='LatLon', mapping_=mapping_)
        if self.InfiniteSlopeProperties is not None:
            InfiniteSlopeProperties_ = self.InfiniteSlopeProperties
            InfiniteSlopeProperties_.to_etree(element, name_='InfiniteSlopeProperties', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Maket'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.dartZone is not None and 'dartZone' not in already_processed:
            already_processed.add('dartZone')
            showIndent(outfile, level)
            outfile.write('dartZone=%d,\n' % (self.dartZone,))
        if self.exactlyPeriodicScene is not None and 'exactlyPeriodicScene' not in already_processed:
            already_processed.add('exactlyPeriodicScene')
            showIndent(outfile, level)
            outfile.write('exactlyPeriodicScene=%d,\n' % (self.exactlyPeriodicScene,))
        if self.useRandomGenerationSeed is not None and 'useRandomGenerationSeed' not in already_processed:
            already_processed.add('useRandomGenerationSeed')
            showIndent(outfile, level)
            outfile.write('useRandomGenerationSeed=%d,\n' % (self.useRandomGenerationSeed,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Scene is not None:
            showIndent(outfile, level)
            outfile.write('Scene=model_._Scene(\n')
            self.Scene.exportLiteral(outfile, level, name_='Scene')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RandomGenerationParameters is not None:
            showIndent(outfile, level)
            outfile.write('RandomGenerationParameters=model_._RandomGenerationParameters(\n')
            self.RandomGenerationParameters.exportLiteral(outfile, level, name_='RandomGenerationParameters')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Soil is not None:
            showIndent(outfile, level)
            outfile.write('Soil=model_._Soil(\n')
            self.Soil.exportLiteral(outfile, level, name_='Soil')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LatLon is not None:
            showIndent(outfile, level)
            outfile.write('LatLon=model_._LatLon(\n')
            self.LatLon.exportLiteral(outfile, level, name_='LatLon')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InfiniteSlopeProperties is not None:
            showIndent(outfile, level)
            outfile.write('InfiniteSlopeProperties=model_._InfiniteSlopeProperties(\n')
            self.InfiniteSlopeProperties.exportLiteral(outfile, level, name_='InfiniteSlopeProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dartZone', node)
        if value is not None and 'dartZone' not in already_processed:
            already_processed.add('dartZone')
            try:
                self.dartZone = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('exactlyPeriodicScene', node)
        if value is not None and 'exactlyPeriodicScene' not in already_processed:
            already_processed.add('exactlyPeriodicScene')
            try:
                self.exactlyPeriodicScene = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('useRandomGenerationSeed', node)
        if value is not None and 'useRandomGenerationSeed' not in already_processed:
            already_processed.add('useRandomGenerationSeed')
            try:
                self.useRandomGenerationSeed = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Scene':
            obj_ = create_Scene.factory()
            obj_.build(child_)
            self.set_Scene(obj_)
            obj_.original_tagname_ = 'Scene'
        elif nodeName_ == 'RandomGenerationParameters':
            obj_ = create_RandomGenerationParameters.factory()
            obj_.build(child_)
            self.set_RandomGenerationParameters(obj_)
            obj_.original_tagname_ = 'RandomGenerationParameters'
        elif nodeName_ == 'Soil':
            obj_ = create_Soil.factory()
            obj_.build(child_)
            self.set_Soil(obj_)
            obj_.original_tagname_ = 'Soil'
        elif nodeName_ == 'LatLon':
            obj_ = create_LatLon.factory()
            obj_.build(child_)
            self.set_LatLon(obj_)
            obj_.original_tagname_ = 'LatLon'
        elif nodeName_ == 'InfiniteSlopeProperties':
            obj_ = create_InfiniteSlopeProperties.factory()
            obj_.build(child_)
            self.set_InfiniteSlopeProperties(obj_)
            obj_.original_tagname_ = 'InfiniteSlopeProperties'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_Maket


class create_Scene(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('CellDimensions', '_CellDimensions', 0, 0, {u'maxOccurs': u'1', u'type': u'_CellDimensions', u'name': u'CellDimensions', u'minOccurs': u'1'}, None),
        MemberSpec_('SceneDimensions', '_SceneDimensions', 0, 0, {u'maxOccurs': u'1', u'type': u'_SceneDimensions', u'name': u'SceneDimensions', u'minOccurs': u'1'}, None),
        MemberSpec_('DartZoneProperties', '_DartZoneProperties', 0, 0, {u'maxOccurs': u'1', u'type': u'_DartZoneProperties', u'name': u'DartZoneProperties', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, CellDimensions=None, SceneDimensions=None, DartZoneProperties=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('maket','_Scene')
        self.attrib = ['']
        self.children = ['CellDimensions', 'SceneDimensions', 'DartZoneProperties']
        self.parent = None
        self._CellDimensions = CellDimensions
        self._SceneDimensions = SceneDimensions
        self._DartZoneProperties = DartZoneProperties
        update_node(self,self.troot,'maket')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Scene)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Scene.subclass:
            return create_Scene.subclass(*args_, **kwargs_)
        else:
            return create_Scene(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CellDimensions(self): return self._CellDimensions
    def set_CellDimensions(self, value):
        if value is not None:
            checkclass(value, create_CellDimensions)
            value.parent = self
        self._CellDimensions = value
    CellDimensions = property(get_CellDimensions, set_CellDimensions)
    def get_SceneDimensions(self): return self._SceneDimensions
    def set_SceneDimensions(self, value):
        if value is not None:
            checkclass(value, create_SceneDimensions)
            value.parent = self
        self._SceneDimensions = value
    SceneDimensions = property(get_SceneDimensions, set_SceneDimensions)
    def get_DartZoneProperties(self): return self._DartZoneProperties
    def set_DartZoneProperties(self, value):
        if value is not None:
            checkclass(value, create_DartZoneProperties)
            value.parent = self
        self._DartZoneProperties = value
    DartZoneProperties = property(get_DartZoneProperties, set_DartZoneProperties)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.CellDimensions is not None or
            self.SceneDimensions is not None or
            self.DartZoneProperties is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Scene', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Scene')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Scene')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Scene', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Scene'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Scene', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CellDimensions is not None:
            self.CellDimensions.export(outfile, level, namespaceprefix_, name_='CellDimensions', pretty_print=pretty_print)
        if self.SceneDimensions is not None:
            self.SceneDimensions.export(outfile, level, namespaceprefix_, name_='SceneDimensions', pretty_print=pretty_print)
        if self.DartZoneProperties is not None:
            self.DartZoneProperties.export(outfile, level, namespaceprefix_, name_='DartZoneProperties', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Scene', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.CellDimensions is not None:
            CellDimensions_ = self.CellDimensions
            CellDimensions_.to_etree(element, name_='CellDimensions', mapping_=mapping_)
        if self.SceneDimensions is not None:
            SceneDimensions_ = self.SceneDimensions
            SceneDimensions_.to_etree(element, name_='SceneDimensions', mapping_=mapping_)
        if self.DartZoneProperties is not None:
            DartZoneProperties_ = self.DartZoneProperties
            DartZoneProperties_.to_etree(element, name_='DartZoneProperties', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Scene'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CellDimensions is not None:
            showIndent(outfile, level)
            outfile.write('CellDimensions=model_._CellDimensions(\n')
            self.CellDimensions.exportLiteral(outfile, level, name_='CellDimensions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SceneDimensions is not None:
            showIndent(outfile, level)
            outfile.write('SceneDimensions=model_._SceneDimensions(\n')
            self.SceneDimensions.exportLiteral(outfile, level, name_='SceneDimensions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DartZoneProperties is not None:
            showIndent(outfile, level)
            outfile.write('DartZoneProperties=model_._DartZoneProperties(\n')
            self.DartZoneProperties.exportLiteral(outfile, level, name_='DartZoneProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CellDimensions':
            obj_ = create_CellDimensions.factory()
            obj_.build(child_)
            self.set_CellDimensions(obj_)
            obj_.original_tagname_ = 'CellDimensions'
        elif nodeName_ == 'SceneDimensions':
            obj_ = create_SceneDimensions.factory()
            obj_.build(child_)
            self.set_SceneDimensions(obj_)
            obj_.original_tagname_ = 'SceneDimensions'
        elif nodeName_ == 'DartZoneProperties':
            obj_ = create_DartZoneProperties.factory()
            obj_.build(child_)
            self.set_DartZoneProperties(obj_)
            obj_.original_tagname_ = 'DartZoneProperties'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_Scene


class create_CellDimensions(GeneratedsSuper):
    """Cell dimension along the x and y directions Cell dimension along the
    x and y directions Cell dimension along the z direction Cell
    dimension along the z direction"""
    member_data_items_ = [
        MemberSpec_('x', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('z', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, x=1, z=1):
        self.original_tagname_ = None
        self.troot=get_gs_troot('maket','_CellDimensions')
        self.attrib = ['x', 'z']
        self.children = []
        self.parent = None
        self._x = _cast(float, x)
        self._z = _cast(float, z)
        update_node(self,self.troot,'maket')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_CellDimensions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_CellDimensions.subclass:
            return create_CellDimensions.subclass(*args_, **kwargs_)
        else:
            return create_CellDimensions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_x(self): return self._x
    def set_x(self, value):
        self._x = value
        update_node(self,self.troot,'maket')
    x = property(get_x, set_x)
    def get_z(self): return self._z
    def set_z(self, value):
        self._z = value
        update_node(self,self.troot,'maket')
    z = property(get_z, set_z)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_CellDimensions', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_CellDimensions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_CellDimensions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_CellDimensions', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_CellDimensions'):
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name='x'))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z="%s"' % self.gds_format_double(self.z, input_name='z'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_CellDimensions', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_CellDimensions', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.x is not None:
            element.set('x', self.gds_format_double(self.x))
        if self.z is not None:
            element.set('z', self.gds_format_double(self.z))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_CellDimensions'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            showIndent(outfile, level)
            outfile.write('x=%e,\n' % (self.x,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            showIndent(outfile, level)
            outfile.write('z=%e,\n' % (self.z,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            try:
                self.x = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            try:
                self.z = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (z): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_CellDimensions


class create_SceneDimensions(GeneratedsSuper):
    """Scene dimension along the y direction Scene dimension along the y
    direction Scene dimension along the x direction Scene dimension
    along the x direction"""
    member_data_items_ = [
        MemberSpec_('y', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('x', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, y=40.00, x=40.00):
        self.original_tagname_ = None
        self.troot=get_gs_troot('maket','_SceneDimensions')
        self.attrib = ['y', 'x']
        self.children = []
        self.parent = None
        self._y = _cast(float, y)
        self._x = _cast(float, x)
        update_node(self,self.troot,'maket')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_SceneDimensions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_SceneDimensions.subclass:
            return create_SceneDimensions.subclass(*args_, **kwargs_)
        else:
            return create_SceneDimensions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_y(self): return self._y
    def set_y(self, value):
        self._y = value
        update_node(self,self.troot,'maket')
    y = property(get_y, set_y)
    def get_x(self): return self._x
    def set_x(self, value):
        self._x = value
        update_node(self,self.troot,'maket')
    x = property(get_x, set_x)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_SceneDimensions', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_SceneDimensions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_SceneDimensions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_SceneDimensions', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_SceneDimensions'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y="%s"' % self.gds_format_double(self.y, input_name='y'))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name='x'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_SceneDimensions', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_SceneDimensions', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.y is not None:
            element.set('y', self.gds_format_double(self.y))
        if self.x is not None:
            element.set('x', self.gds_format_double(self.x))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_SceneDimensions'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            showIndent(outfile, level)
            outfile.write('y=%e,\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            showIndent(outfile, level)
            outfile.write('x=%e,\n' % (self.x,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            try:
                self.y = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (y): %s' % exp)
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            try:
                self.x = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_SceneDimensions


class create_DartZoneProperties(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('Point2D', '_Point2D', 1, 0, {u'maxOccurs': u'2', u'type': u'_Point2D', u'name': u'Point2D', u'minOccurs': u'2'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Point2D=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('maket','_DartZoneProperties')
        self.attrib = ['']
        self.children = ['Point2D']
        self.parent = None
        if Point2D is None:
            self._Point2D = []
        else:
            self._Point2D = Point2D
        update_node(self,self.troot,'maket')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_DartZoneProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_DartZoneProperties.subclass:
            return create_DartZoneProperties.subclass(*args_, **kwargs_)
        else:
            return create_DartZoneProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Point2D(self): return self._Point2D
    def set_Point2D(self, value):
        if value is not None:
            checkclass(value, create_Point2D)
            for v in value:
                v.parent = self
        self._Point2D = value
    def add_Point2D(self, value):
        if (value is not None) and (len(self._Point2D) == 2):
            raise ValueError('Maximum length already reached.')
        value.parent = self
        self._Point2D.append(value)
    def insert_Point2D_at(self, index, value):
        if (value is not None) and (len(self._Point2D) == 2):
            raise ValueError('Maximum length already reached.')
        value.parent = self
        self.Point2D.insert(index, value)
    def replace_Point2D_at(self, index, value):
        value.parent = self
        self.Point2D[index] = value
    Point2D = property(get_Point2D, set_Point2D)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Point2D
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_DartZoneProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_DartZoneProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_DartZoneProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_DartZoneProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_DartZoneProperties'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_DartZoneProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Point2D_ in self.Point2D:
            Point2D_.export(outfile, level, namespaceprefix_, name_='Point2D', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_DartZoneProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for Point2D_ in self.Point2D:
            Point2D_.to_etree(element, name_='Point2D', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_DartZoneProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Point2D=[\n')
        level += 1
        for Point2D_ in self.Point2D:
            showIndent(outfile, level)
            outfile.write('model_._Point2D(\n')
            Point2D_.exportLiteral(outfile, level, name_='_Point2D')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.Point2D = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Point2D':
            obj_ = create_Point2D.factory()
            obj_.build(child_)
            self.add_Point2D(obj_)
            obj_.original_tagname_ = 'Point2D'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_DartZoneProperties


class create_Point2D(GeneratedsSuper):
    """y coordinate of the upper left or lower right corner of the
    rectangular sub zone y coordinate of the upper left or lower
    right corner of the rectangular sub zone x coordinate of the
    upper left or lower right corner of the rectangular sub zone x
    coordinate of the upper left or lower right corner of the
    rectangular sub zone"""
    member_data_items_ = [
        MemberSpec_('y', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('x', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, y=1, x=1):
        self.original_tagname_ = None
        self.troot=get_gs_troot('maket','_Point2D')
        self.attrib = ['y', 'x']
        self.children = []
        self.parent = None
        self._y = _cast(float, y)
        self._x = _cast(float, x)
        update_node(self,self.troot,'maket')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Point2D)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Point2D.subclass:
            return create_Point2D.subclass(*args_, **kwargs_)
        else:
            return create_Point2D(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_y(self): return self._y
    def set_y(self, value):
        self._y = value
        update_node(self,self.troot,'maket')
    y = property(get_y, set_y)
    def get_x(self): return self._x
    def set_x(self, value):
        self._x = value
        update_node(self,self.troot,'maket')
    x = property(get_x, set_x)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Point2D', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Point2D')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Point2D')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Point2D', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Point2D'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y="%s"' % self.gds_format_double(self.y, input_name='y'))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name='x'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Point2D', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_Point2D', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.y is not None:
            element.set('y', self.gds_format_double(self.y))
        if self.x is not None:
            element.set('x', self.gds_format_double(self.x))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Point2D'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            showIndent(outfile, level)
            outfile.write('y=%e,\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            showIndent(outfile, level)
            outfile.write('x=%e,\n' % (self.x,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            try:
                self.y = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (y): %s' % exp)
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            try:
                self.x = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_Point2D


class create_RandomGenerationParameters(GeneratedsSuper):
    """Random generation parameters Random generation parameters Seed for
    random operations. Seed for random operations."""
    member_data_items_ = [
        MemberSpec_('generationSeed', 'xsd:int', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, generationSeed=733426921):
        self.original_tagname_ = None
        self.troot=get_gs_troot('maket','_RandomGenerationParameters')
        self.attrib = ['generationSeed']
        self.children = []
        self.parent = None
        self._generationSeed = _cast(int, generationSeed)
        update_node(self,self.troot,'maket')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_RandomGenerationParameters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_RandomGenerationParameters.subclass:
            return create_RandomGenerationParameters.subclass(*args_, **kwargs_)
        else:
            return create_RandomGenerationParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_generationSeed(self): return self._generationSeed
    def set_generationSeed(self, value):
        self._generationSeed = value
        update_node(self,self.troot,'maket')
    generationSeed = property(get_generationSeed, set_generationSeed)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_RandomGenerationParameters', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_RandomGenerationParameters')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_RandomGenerationParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_RandomGenerationParameters', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_RandomGenerationParameters'):
        if self.generationSeed is not None and 'generationSeed' not in already_processed:
            already_processed.add('generationSeed')
            outfile.write(' generationSeed="%s"' % self.gds_format_integer(self.generationSeed, input_name='generationSeed'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_RandomGenerationParameters', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_RandomGenerationParameters', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.generationSeed is not None:
            element.set('generationSeed', self.gds_format_integer(self.generationSeed))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_RandomGenerationParameters'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.generationSeed is not None and 'generationSeed' not in already_processed:
            already_processed.add('generationSeed')
            showIndent(outfile, level)
            outfile.write('generationSeed=%d,\n' % (self.generationSeed,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('generationSeed', node)
        if value is not None and 'generationSeed' not in already_processed:
            already_processed.add('generationSeed')
            try:
                self.generationSeed = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_RandomGenerationParameters


class create_Soil(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('OpticalPropertyLink', '_OpticalPropertyLink', 0, 0, {u'maxOccurs': u'1', u'type': u'_OpticalPropertyLink', u'name': u'OpticalPropertyLink', u'minOccurs': u'1'}, None),
        MemberSpec_('ThermalPropertyLink', '_ThermalPropertyLink', 0, 0, {u'maxOccurs': u'1', u'type': u'_ThermalPropertyLink', u'name': u'ThermalPropertyLink', u'minOccurs': u'1'}, None),
        MemberSpec_('Topography', '_Topography', 0, 0, {u'maxOccurs': u'1', u'type': u'_Topography', u'name': u'Topography', u'minOccurs': u'1'}, None),
        MemberSpec_('DEM_properties', '_DEM_properties', 0, 0, {u'maxOccurs': u'1', u'type': u'_DEM_properties', u'name': u'DEM_properties', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, OpticalPropertyLink=None, ThermalPropertyLink=None, Topography=None, DEM_properties=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('maket','_Soil')
        self.attrib = ['']
        self.children = ['OpticalPropertyLink', 'ThermalPropertyLink', 'Topography', 'DEM_properties']
        self.parent = None
        self._OpticalPropertyLink = OpticalPropertyLink
        self._ThermalPropertyLink = ThermalPropertyLink
        self._Topography = Topography
        self._DEM_properties = DEM_properties
        update_node(self,self.troot,'maket')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Soil)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Soil.subclass:
            return create_Soil.subclass(*args_, **kwargs_)
        else:
            return create_Soil(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OpticalPropertyLink(self): return self._OpticalPropertyLink
    def set_OpticalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_OpticalPropertyLink)
            value.parent = self
        self._OpticalPropertyLink = value
    OpticalPropertyLink = property(get_OpticalPropertyLink, set_OpticalPropertyLink)
    def get_ThermalPropertyLink(self): return self._ThermalPropertyLink
    def set_ThermalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_ThermalPropertyLink)
            value.parent = self
        self._ThermalPropertyLink = value
    ThermalPropertyLink = property(get_ThermalPropertyLink, set_ThermalPropertyLink)
    def get_Topography(self): return self._Topography
    def set_Topography(self, value):
        if value is not None:
            checkclass(value, create_Topography)
            value.parent = self
        self._Topography = value
    Topography = property(get_Topography, set_Topography)
    def get_DEM_properties(self): return self._DEM_properties
    def set_DEM_properties(self, value):
        if value is not None:
            checkclass(value, create_DEM_properties)
            value.parent = self
        self._DEM_properties = value
    DEM_properties = property(get_DEM_properties, set_DEM_properties)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.OpticalPropertyLink is not None or
            self.ThermalPropertyLink is not None or
            self.Topography is not None or
            self.DEM_properties is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Soil', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Soil')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Soil')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Soil', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Soil'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Soil', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OpticalPropertyLink is not None:
            self.OpticalPropertyLink.export(outfile, level, namespaceprefix_, name_='OpticalPropertyLink', pretty_print=pretty_print)
        if self.ThermalPropertyLink is not None:
            self.ThermalPropertyLink.export(outfile, level, namespaceprefix_, name_='ThermalPropertyLink', pretty_print=pretty_print)
        if self.Topography is not None:
            self.Topography.export(outfile, level, namespaceprefix_, name_='Topography', pretty_print=pretty_print)
        if self.DEM_properties is not None:
            self.DEM_properties.export(outfile, level, namespaceprefix_, name_='DEM_properties', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Soil', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.OpticalPropertyLink is not None:
            OpticalPropertyLink_ = self.OpticalPropertyLink
            OpticalPropertyLink_.to_etree(element, name_='OpticalPropertyLink', mapping_=mapping_)
        if self.ThermalPropertyLink is not None:
            ThermalPropertyLink_ = self.ThermalPropertyLink
            ThermalPropertyLink_.to_etree(element, name_='ThermalPropertyLink', mapping_=mapping_)
        if self.Topography is not None:
            Topography_ = self.Topography
            Topography_.to_etree(element, name_='Topography', mapping_=mapping_)
        if self.DEM_properties is not None:
            DEM_properties_ = self.DEM_properties
            DEM_properties_.to_etree(element, name_='DEM_properties', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Soil'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.OpticalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('OpticalPropertyLink=model_._OpticalPropertyLink(\n')
            self.OpticalPropertyLink.exportLiteral(outfile, level, name_='OpticalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ThermalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('ThermalPropertyLink=model_._ThermalPropertyLink(\n')
            self.ThermalPropertyLink.exportLiteral(outfile, level, name_='ThermalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Topography is not None:
            showIndent(outfile, level)
            outfile.write('Topography=model_._Topography(\n')
            self.Topography.exportLiteral(outfile, level, name_='Topography')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DEM_properties is not None:
            showIndent(outfile, level)
            outfile.write('DEM_properties=model_._DEM_properties(\n')
            self.DEM_properties.exportLiteral(outfile, level, name_='DEM_properties')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OpticalPropertyLink':
            obj_ = create_OpticalPropertyLink.factory()
            obj_.build(child_)
            self.set_OpticalPropertyLink(obj_)
            obj_.original_tagname_ = 'OpticalPropertyLink'
        elif nodeName_ == 'ThermalPropertyLink':
            obj_ = create_ThermalPropertyLink.factory()
            obj_.build(child_)
            self.set_ThermalPropertyLink(obj_)
            obj_.original_tagname_ = 'ThermalPropertyLink'
        elif nodeName_ == 'Topography':
            obj_ = create_Topography.factory()
            obj_.build(child_)
            self.set_Topography(obj_)
            obj_.original_tagname_ = 'Topography'
        elif nodeName_ == 'DEM_properties':
            obj_ = create_DEM_properties.factory()
            obj_.build(child_)
            self.set_DEM_properties(obj_)
            obj_.original_tagname_ = 'DEM_properties'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_Soil


class create_OpticalPropertyLink(GeneratedsSuper):
    """Index of the DART phase function of the ground of the plot. Index of
    the DART phase function of the ground of the plot. proportion of
    photons intercepted along an incident direction that are
    scattered within a solid angle along a given direction
    proportion of photons intercepted along an incident direction
    that are scattered within a solid angle along a given direction
    Type of phase function (lambertian, etc.) Type of phase function
    (lambertian, etc.)"""
    member_data_items_ = [
        MemberSpec_('indexFctPhase', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('ident', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('type_', 'xsd:int', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, indexFctPhase=0, ident='Lambertian_Phase_Function_1', type_=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('maket','_OpticalPropertyLink')
        self.attrib = ['indexFctPhase', 'ident', 'type_']
        self.children = []
        self.parent = None
        self._indexFctPhase = _cast(int, indexFctPhase)
        self._ident = _cast(None, ident)
        self._type_ = _cast(int, type_)
        update_node(self,self.troot,'maket')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_OpticalPropertyLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_OpticalPropertyLink.subclass:
            return create_OpticalPropertyLink.subclass(*args_, **kwargs_)
        else:
            return create_OpticalPropertyLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexFctPhase(self): return self._indexFctPhase
    def set_indexFctPhase(self, value):
        self._indexFctPhase = value
        update_node(self,self.troot,'maket')
    indexFctPhase = property(get_indexFctPhase, set_indexFctPhase)
    def get_ident(self): return self._ident
    def set_ident(self, value):
        self._ident = value
        update_node(self,self.troot,'maket')
    ident = property(get_ident, set_ident)
    def get_type(self): return self._type_
    def set_type(self, value):
        self._type_ = value
        update_node(self,self.troot,'maket')
    type_ = property(get_type, set_type)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_OpticalPropertyLink', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_OpticalPropertyLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_OpticalPropertyLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_OpticalPropertyLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_OpticalPropertyLink'):
        if self.indexFctPhase is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            outfile.write(' indexFctPhase="%s"' % self.gds_format_integer(self.indexFctPhase, input_name='indexFctPhase'))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            outfile.write(' ident=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ident), input_name='ident')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type="%s"' % self.gds_format_integer(self.type_, input_name='type'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_OpticalPropertyLink', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_OpticalPropertyLink', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.indexFctPhase is not None:
            element.set('indexFctPhase', self.gds_format_integer(self.indexFctPhase))
        if self.ident is not None:
            element.set('ident', self.gds_format_string(self.ident))
        if self.type_ is not None:
            element.set('type', self.gds_format_integer(self.type_))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_OpticalPropertyLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.indexFctPhase is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            showIndent(outfile, level)
            outfile.write('indexFctPhase=%d,\n' % (self.indexFctPhase,))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            showIndent(outfile, level)
            outfile.write('ident="%s",\n' % (self.ident,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_=%d,\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('indexFctPhase', node)
        if value is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            try:
                self.indexFctPhase = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ident', node)
        if value is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            self.ident = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            try:
                self.type_ = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_OpticalPropertyLink


class create_ThermalPropertyLink(GeneratedsSuper):
    """indexTemperature indexTemperature Thermal Function ID Thermal
    Function ID"""
    member_data_items_ = [
        MemberSpec_('indexTemperature', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('idTemperature', 'xsd:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, indexTemperature=0, idTemperature='ThermalFunction290_310'):
        self.original_tagname_ = None
        self.troot=get_gs_troot('maket','_ThermalPropertyLink')
        self.attrib = ['indexTemperature', 'idTemperature']
        self.children = []
        self.parent = None
        self._indexTemperature = _cast(int, indexTemperature)
        self._idTemperature = _cast(None, idTemperature)
        update_node(self,self.troot,'maket')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ThermalPropertyLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ThermalPropertyLink.subclass:
            return create_ThermalPropertyLink.subclass(*args_, **kwargs_)
        else:
            return create_ThermalPropertyLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexTemperature(self): return self._indexTemperature
    def set_indexTemperature(self, value):
        self._indexTemperature = value
        update_node(self,self.troot,'maket')
    indexTemperature = property(get_indexTemperature, set_indexTemperature)
    def get_idTemperature(self): return self._idTemperature
    def set_idTemperature(self, value):
        self._idTemperature = value
        update_node(self,self.troot,'maket')
    idTemperature = property(get_idTemperature, set_idTemperature)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ThermalPropertyLink', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ThermalPropertyLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ThermalPropertyLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ThermalPropertyLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ThermalPropertyLink'):
        if self.indexTemperature is not None and 'indexTemperature' not in already_processed:
            already_processed.add('indexTemperature')
            outfile.write(' indexTemperature="%s"' % self.gds_format_integer(self.indexTemperature, input_name='indexTemperature'))
        if self.idTemperature is not None and 'idTemperature' not in already_processed:
            already_processed.add('idTemperature')
            outfile.write(' idTemperature=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idTemperature), input_name='idTemperature')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ThermalPropertyLink', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_ThermalPropertyLink', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.indexTemperature is not None:
            element.set('indexTemperature', self.gds_format_integer(self.indexTemperature))
        if self.idTemperature is not None:
            element.set('idTemperature', self.gds_format_string(self.idTemperature))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ThermalPropertyLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.indexTemperature is not None and 'indexTemperature' not in already_processed:
            already_processed.add('indexTemperature')
            showIndent(outfile, level)
            outfile.write('indexTemperature=%d,\n' % (self.indexTemperature,))
        if self.idTemperature is not None and 'idTemperature' not in already_processed:
            already_processed.add('idTemperature')
            showIndent(outfile, level)
            outfile.write('idTemperature="%s",\n' % (self.idTemperature,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('indexTemperature', node)
        if value is not None and 'indexTemperature' not in already_processed:
            already_processed.add('indexTemperature')
            try:
                self.indexTemperature = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('idTemperature', node)
        if value is not None and 'idTemperature' not in already_processed:
            already_processed.add('idTemperature')
            self.idTemperature = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_ThermalPropertyLink


class create_Topography(GeneratedsSuper):
    """Presence or not of a Digital Elevation Model Presence or not of a
    Digital Elevation Model"""
    member_data_items_ = [
        MemberSpec_('presenceOfTopography', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('TopographyProperties', '_TopographyProperties', 0, 0, {u'maxOccurs': u'1', u'type': u'_TopographyProperties', u'name': u'TopographyProperties', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, presenceOfTopography=0, TopographyProperties=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('maket','_Topography')
        self.attrib = ['presenceOfTopography']
        self.children = ['TopographyProperties']
        self.parent = None
        self._presenceOfTopography = _cast(int, presenceOfTopography)
        self._TopographyProperties = TopographyProperties
        update_node(self,self.troot,'maket')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Topography)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Topography.subclass:
            return create_Topography.subclass(*args_, **kwargs_)
        else:
            return create_Topography(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TopographyProperties(self): return self._TopographyProperties
    def set_TopographyProperties(self, value):
        if value is not None:
            checkclass(value, create_TopographyProperties)
            value.parent = self
        self._TopographyProperties = value
    TopographyProperties = property(get_TopographyProperties, set_TopographyProperties)
    def get_presenceOfTopography(self): return self._presenceOfTopography
    def set_presenceOfTopography(self, value):
        self._presenceOfTopography = value
        update_node(self,self.troot,'maket')
    presenceOfTopography = property(get_presenceOfTopography, set_presenceOfTopography)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.TopographyProperties is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Topography', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Topography')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Topography')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Topography', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Topography'):
        if self.presenceOfTopography is not None and 'presenceOfTopography' not in already_processed:
            already_processed.add('presenceOfTopography')
            outfile.write(' presenceOfTopography="%s"' % self.gds_format_integer(self.presenceOfTopography, input_name='presenceOfTopography'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Topography', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TopographyProperties is not None:
            self.TopographyProperties.export(outfile, level, namespaceprefix_, name_='TopographyProperties', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Topography', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.presenceOfTopography is not None:
            element.set('presenceOfTopography', self.gds_format_integer(self.presenceOfTopography))
        if self.TopographyProperties is not None:
            TopographyProperties_ = self.TopographyProperties
            TopographyProperties_.to_etree(element, name_='TopographyProperties', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Topography'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.presenceOfTopography is not None and 'presenceOfTopography' not in already_processed:
            already_processed.add('presenceOfTopography')
            showIndent(outfile, level)
            outfile.write('presenceOfTopography=%d,\n' % (self.presenceOfTopography,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TopographyProperties is not None:
            showIndent(outfile, level)
            outfile.write('TopographyProperties=model_._TopographyProperties(\n')
            self.TopographyProperties.exportLiteral(outfile, level, name_='TopographyProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('presenceOfTopography', node)
        if value is not None and 'presenceOfTopography' not in already_processed:
            already_processed.add('presenceOfTopography')
            try:
                self.presenceOfTopography = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TopographyProperties':
            obj_ = create_TopographyProperties.factory()
            obj_.build(child_)
            self.set_TopographyProperties(obj_)
            obj_.original_tagname_ = 'TopographyProperties'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_Topography


class create_TopographyProperties(GeneratedsSuper):
    """Name of the DEM (Digital Elevation Map). This is a raster map coded
    in float numbers (4 bytes /pixel) Name of the DEM (Digital
    Elevation Map). This is a raster map coded in float numbers (4
    bytes /pixel)"""
    member_data_items_ = [
        MemberSpec_('fileName', 'xsd:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, fileName='DEM.mp#'):
        self.original_tagname_ = None
        self.troot=get_gs_troot('maket','_TopographyProperties')
        self.attrib = ['fileName']
        self.children = []
        self.parent = None
        self._fileName = _cast(None, fileName)
        update_node(self,self.troot,'maket')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_TopographyProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_TopographyProperties.subclass:
            return create_TopographyProperties.subclass(*args_, **kwargs_)
        else:
            return create_TopographyProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fileName(self): return self._fileName
    def set_fileName(self, value):
        self._fileName = value
        update_node(self,self.troot,'maket')
    fileName = property(get_fileName, set_fileName)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_TopographyProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_TopographyProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_TopographyProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_TopographyProperties', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_TopographyProperties'):
        if self.fileName is not None and 'fileName' not in already_processed:
            already_processed.add('fileName')
            outfile.write(' fileName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fileName), input_name='fileName')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_TopographyProperties', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_TopographyProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.fileName is not None:
            element.set('fileName', self.gds_format_string(self.fileName))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_TopographyProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.fileName is not None and 'fileName' not in already_processed:
            already_processed.add('fileName')
            showIndent(outfile, level)
            outfile.write('fileName="%s",\n' % (self.fileName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fileName', node)
        if value is not None and 'fileName' not in already_processed:
            already_processed.add('fileName')
            self.fileName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_TopographyProperties


class create_DEM_properties(GeneratedsSuper):
    """Create or Convert DEM Create or Convert DEM"""
    member_data_items_ = [
        MemberSpec_('createTopography', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('DEMGenerator', '_DEMGenerator', 0, 0, {u'maxOccurs': u'1', u'type': u'_DEMGenerator', u'name': u'DEMGenerator', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, createTopography=0, DEMGenerator=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('maket','_DEM_properties')
        self.attrib = ['createTopography']
        self.children = ['DEMGenerator']
        self.parent = None
        self._createTopography = _cast(int, createTopography)
        self._DEMGenerator = DEMGenerator
        update_node(self,self.troot,'maket')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_DEM_properties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_DEM_properties.subclass:
            return create_DEM_properties.subclass(*args_, **kwargs_)
        else:
            return create_DEM_properties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DEMGenerator(self): return self._DEMGenerator
    def set_DEMGenerator(self, value):
        if value is not None:
            checkclass(value, create_DEMGenerator)
            value.parent = self
        self._DEMGenerator = value
    DEMGenerator = property(get_DEMGenerator, set_DEMGenerator)
    def get_createTopography(self): return self._createTopography
    def set_createTopography(self, value):
        self._createTopography = value
        update_node(self,self.troot,'maket')
    createTopography = property(get_createTopography, set_createTopography)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.DEMGenerator is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_DEM_properties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_DEM_properties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_DEM_properties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_DEM_properties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_DEM_properties'):
        if self.createTopography is not None and 'createTopography' not in already_processed:
            already_processed.add('createTopography')
            outfile.write(' createTopography="%s"' % self.gds_format_integer(self.createTopography, input_name='createTopography'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_DEM_properties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DEMGenerator is not None:
            self.DEMGenerator.export(outfile, level, namespaceprefix_, name_='DEMGenerator', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_DEM_properties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.createTopography is not None:
            element.set('createTopography', self.gds_format_integer(self.createTopography))
        if self.DEMGenerator is not None:
            DEMGenerator_ = self.DEMGenerator
            DEMGenerator_.to_etree(element, name_='DEMGenerator', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_DEM_properties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.createTopography is not None and 'createTopography' not in already_processed:
            already_processed.add('createTopography')
            showIndent(outfile, level)
            outfile.write('createTopography=%d,\n' % (self.createTopography,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DEMGenerator is not None:
            showIndent(outfile, level)
            outfile.write('DEMGenerator=model_._DEMGenerator(\n')
            self.DEMGenerator.exportLiteral(outfile, level, name_='DEMGenerator')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('createTopography', node)
        if value is not None and 'createTopography' not in already_processed:
            already_processed.add('createTopography')
            try:
                self.createTopography = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DEMGenerator':
            obj_ = create_DEMGenerator.factory()
            obj_.build(child_)
            self.set_DEMGenerator(obj_)
            obj_.original_tagname_ = 'DEMGenerator'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_DEM_properties


class create_DEMGenerator(GeneratedsSuper):
    """caseDEM caseDEM outputFileName outputFileName"""
    member_data_items_ = [
        MemberSpec_('caseDEM', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('outputFileName', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('DEM_1', '_DEM_1', 0, 0, {u'maxOccurs': u'1', u'type': u'_DEM_1', u'name': u'DEM_1', u'minOccurs': u'1'}, None),
        MemberSpec_('DEM_2', '_DEM_2', 0, 0, {u'maxOccurs': u'1', u'type': u'_DEM_2', u'name': u'DEM_2', u'minOccurs': u'1'}, None),
        MemberSpec_('DEM_3', '_DEM_3', 0, 0, {u'maxOccurs': u'1', u'type': u'_DEM_3', u'name': u'DEM_3', u'minOccurs': u'1'}, None),
        MemberSpec_('DEM_4', '_DEM_4', 0, 0, {u'maxOccurs': u'1', u'type': u'_DEM_4', u'name': u'DEM_4', u'minOccurs': u'1'}, None),
        MemberSpec_('DEM_5', '_DEM_5', 0, 0, {u'maxOccurs': u'1', u'type': u'_DEM_5', u'name': u'DEM_5', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, caseDEM=1, outputFileName='DEM.mp#', DEM_1=None, DEM_2=None, DEM_3=None, DEM_4=None, DEM_5=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('maket','_DEMGenerator')
        self.attrib = ['caseDEM', 'outputFileName']
        self.children = ['DEM_1', 'DEM_2', 'DEM_3', 'DEM_4', 'DEM_5']
        self.parent = None
        self._caseDEM = _cast(int, caseDEM)
        self._outputFileName = _cast(None, outputFileName)
        self._DEM_1 = DEM_1
        self._DEM_2 = DEM_2
        self._DEM_3 = DEM_3
        self._DEM_4 = DEM_4
        self._DEM_5 = DEM_5
        update_node(self,self.troot,'maket')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_DEMGenerator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_DEMGenerator.subclass:
            return create_DEMGenerator.subclass(*args_, **kwargs_)
        else:
            return create_DEMGenerator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DEM_1(self): return self._DEM_1
    def set_DEM_1(self, value):
        if value is not None:
            checkclass(value, create_DEM_1)
            value.parent = self
        self._DEM_1 = value
    DEM_1 = property(get_DEM_1, set_DEM_1)
    def get_DEM_2(self): return self._DEM_2
    def set_DEM_2(self, value):
        if value is not None:
            checkclass(value, create_DEM_2)
            value.parent = self
        self._DEM_2 = value
    DEM_2 = property(get_DEM_2, set_DEM_2)
    def get_DEM_3(self): return self._DEM_3
    def set_DEM_3(self, value):
        if value is not None:
            checkclass(value, create_DEM_3)
            value.parent = self
        self._DEM_3 = value
    DEM_3 = property(get_DEM_3, set_DEM_3)
    def get_DEM_4(self): return self._DEM_4
    def set_DEM_4(self, value):
        if value is not None:
            checkclass(value, create_DEM_4)
            value.parent = self
        self._DEM_4 = value
    DEM_4 = property(get_DEM_4, set_DEM_4)
    def get_DEM_5(self): return self._DEM_5
    def set_DEM_5(self, value):
        if value is not None:
            checkclass(value, create_DEM_5)
            value.parent = self
        self._DEM_5 = value
    DEM_5 = property(get_DEM_5, set_DEM_5)
    def get_caseDEM(self): return self._caseDEM
    def set_caseDEM(self, value):
        self._caseDEM = value
        update_node(self,self.troot,'maket')
    caseDEM = property(get_caseDEM, set_caseDEM)
    def get_outputFileName(self): return self._outputFileName
    def set_outputFileName(self, value):
        self._outputFileName = value
        update_node(self,self.troot,'maket')
    outputFileName = property(get_outputFileName, set_outputFileName)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.DEM_1 is not None or
            self.DEM_2 is not None or
            self.DEM_3 is not None or
            self.DEM_4 is not None or
            self.DEM_5 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_DEMGenerator', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_DEMGenerator')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_DEMGenerator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_DEMGenerator', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_DEMGenerator'):
        if self.caseDEM is not None and 'caseDEM' not in already_processed:
            already_processed.add('caseDEM')
            outfile.write(' caseDEM="%s"' % self.gds_format_integer(self.caseDEM, input_name='caseDEM'))
        if self.outputFileName is not None and 'outputFileName' not in already_processed:
            already_processed.add('outputFileName')
            outfile.write(' outputFileName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.outputFileName), input_name='outputFileName')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_DEMGenerator', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DEM_1 is not None:
            self.DEM_1.export(outfile, level, namespaceprefix_, name_='DEM_1', pretty_print=pretty_print)
        if self.DEM_2 is not None:
            self.DEM_2.export(outfile, level, namespaceprefix_, name_='DEM_2', pretty_print=pretty_print)
        if self.DEM_3 is not None:
            self.DEM_3.export(outfile, level, namespaceprefix_, name_='DEM_3', pretty_print=pretty_print)
        if self.DEM_4 is not None:
            self.DEM_4.export(outfile, level, namespaceprefix_, name_='DEM_4', pretty_print=pretty_print)
        if self.DEM_5 is not None:
            self.DEM_5.export(outfile, level, namespaceprefix_, name_='DEM_5', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_DEMGenerator', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.caseDEM is not None:
            element.set('caseDEM', self.gds_format_integer(self.caseDEM))
        if self.outputFileName is not None:
            element.set('outputFileName', self.gds_format_string(self.outputFileName))
        if self.DEM_1 is not None:
            DEM_1_ = self.DEM_1
            DEM_1_.to_etree(element, name_='DEM_1', mapping_=mapping_)
        if self.DEM_2 is not None:
            DEM_2_ = self.DEM_2
            DEM_2_.to_etree(element, name_='DEM_2', mapping_=mapping_)
        if self.DEM_3 is not None:
            DEM_3_ = self.DEM_3
            DEM_3_.to_etree(element, name_='DEM_3', mapping_=mapping_)
        if self.DEM_4 is not None:
            DEM_4_ = self.DEM_4
            DEM_4_.to_etree(element, name_='DEM_4', mapping_=mapping_)
        if self.DEM_5 is not None:
            DEM_5_ = self.DEM_5
            DEM_5_.to_etree(element, name_='DEM_5', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_DEMGenerator'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.caseDEM is not None and 'caseDEM' not in already_processed:
            already_processed.add('caseDEM')
            showIndent(outfile, level)
            outfile.write('caseDEM=%d,\n' % (self.caseDEM,))
        if self.outputFileName is not None and 'outputFileName' not in already_processed:
            already_processed.add('outputFileName')
            showIndent(outfile, level)
            outfile.write('outputFileName="%s",\n' % (self.outputFileName,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DEM_1 is not None:
            showIndent(outfile, level)
            outfile.write('DEM_1=model_._DEM_1(\n')
            self.DEM_1.exportLiteral(outfile, level, name_='DEM_1')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DEM_2 is not None:
            showIndent(outfile, level)
            outfile.write('DEM_2=model_._DEM_2(\n')
            self.DEM_2.exportLiteral(outfile, level, name_='DEM_2')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DEM_3 is not None:
            showIndent(outfile, level)
            outfile.write('DEM_3=model_._DEM_3(\n')
            self.DEM_3.exportLiteral(outfile, level, name_='DEM_3')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DEM_4 is not None:
            showIndent(outfile, level)
            outfile.write('DEM_4=model_._DEM_4(\n')
            self.DEM_4.exportLiteral(outfile, level, name_='DEM_4')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DEM_5 is not None:
            showIndent(outfile, level)
            outfile.write('DEM_5=model_._DEM_5(\n')
            self.DEM_5.exportLiteral(outfile, level, name_='DEM_5')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('caseDEM', node)
        if value is not None and 'caseDEM' not in already_processed:
            already_processed.add('caseDEM')
            try:
                self.caseDEM = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('outputFileName', node)
        if value is not None and 'outputFileName' not in already_processed:
            already_processed.add('outputFileName')
            self.outputFileName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DEM_1':
            obj_ = create_DEM_1.factory()
            obj_.build(child_)
            self.set_DEM_1(obj_)
            obj_.original_tagname_ = 'DEM_1'
        elif nodeName_ == 'DEM_2':
            obj_ = create_DEM_2.factory()
            obj_.build(child_)
            self.set_DEM_2(obj_)
            obj_.original_tagname_ = 'DEM_2'
        elif nodeName_ == 'DEM_3':
            obj_ = create_DEM_3.factory()
            obj_.build(child_)
            self.set_DEM_3(obj_)
            obj_.original_tagname_ = 'DEM_3'
        elif nodeName_ == 'DEM_4':
            obj_ = create_DEM_4.factory()
            obj_.build(child_)
            self.set_DEM_4(obj_)
            obj_.original_tagname_ = 'DEM_4'
        elif nodeName_ == 'DEM_5':
            obj_ = create_DEM_5.factory()
            obj_.build(child_)
            self.set_DEM_5(obj_)
            obj_.original_tagname_ = 'DEM_5'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_DEMGenerator


class create_DEM_1(GeneratedsSuper):
    """Theorical DEM curve shape Theorical DEM curve shape"""
    member_data_items_ = [
        MemberSpec_('curveShape', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('DEMproperties_0', '_DEMproperties_0', 0, 0, {u'maxOccurs': u'1', u'type': u'_DEMproperties_0', u'name': u'DEMproperties_0', u'minOccurs': u'1'}, None),
        MemberSpec_('DEMproperties_1', '_DEMproperties_1', 0, 0, {u'maxOccurs': u'1', u'type': u'_DEMproperties_1', u'name': u'DEMproperties_1', u'minOccurs': u'1'}, None),
        MemberSpec_('DEMproperties_3', '_DEMproperties_3', 0, 0, {u'maxOccurs': u'1', u'type': u'_DEMproperties_3', u'name': u'DEMproperties_3', u'minOccurs': u'1'}, None),
        MemberSpec_('DEMproperties_5', '_DEMproperties_5', 0, 0, {u'maxOccurs': u'1', u'type': u'_DEMproperties_5', u'name': u'DEMproperties_5', u'minOccurs': u'1'}, None),
        MemberSpec_('DEMproperties_6', '_DEMproperties_6', 0, 0, {u'maxOccurs': u'1', u'type': u'_DEMproperties_6', u'name': u'DEMproperties_6', u'minOccurs': u'1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, curveShape=0, DEMproperties_0=None, DEMproperties_1=None, DEMproperties_3=None, DEMproperties_5=None, DEMproperties_6=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('maket','_DEM_1')
        self.attrib = ['curveShape']
        self.children = ['DEMproperties_0', 'DEMproperties_1', 'DEMproperties_3', 'DEMproperties_5', 'DEMproperties_6']
        self.parent = None
        self._curveShape = _cast(int, curveShape)
        self._DEMproperties_0 = DEMproperties_0
        self._DEMproperties_1 = DEMproperties_1
        self._DEMproperties_3 = DEMproperties_3
        self._DEMproperties_5 = DEMproperties_5
        self._DEMproperties_6 = DEMproperties_6
        update_node(self,self.troot,'maket')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_DEM_1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_DEM_1.subclass:
            return create_DEM_1.subclass(*args_, **kwargs_)
        else:
            return create_DEM_1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DEMproperties_0(self): return self._DEMproperties_0
    def set_DEMproperties_0(self, value):
        if value is not None:
            checkclass(value, create_DEMproperties_0)
            value.parent = self
        self._DEMproperties_0 = value
    DEMproperties_0 = property(get_DEMproperties_0, set_DEMproperties_0)
    def get_DEMproperties_1(self): return self._DEMproperties_1
    def set_DEMproperties_1(self, value):
        if value is not None:
            checkclass(value, create_DEMproperties_1)
            value.parent = self
        self._DEMproperties_1 = value
    DEMproperties_1 = property(get_DEMproperties_1, set_DEMproperties_1)
    def get_DEMproperties_3(self): return self._DEMproperties_3
    def set_DEMproperties_3(self, value):
        if value is not None:
            checkclass(value, create_DEMproperties_3)
            value.parent = self
        self._DEMproperties_3 = value
    DEMproperties_3 = property(get_DEMproperties_3, set_DEMproperties_3)
    def get_DEMproperties_5(self): return self._DEMproperties_5
    def set_DEMproperties_5(self, value):
        if value is not None:
            checkclass(value, create_DEMproperties_5)
            value.parent = self
        self._DEMproperties_5 = value
    DEMproperties_5 = property(get_DEMproperties_5, set_DEMproperties_5)
    def get_DEMproperties_6(self): return self._DEMproperties_6
    def set_DEMproperties_6(self, value):
        if value is not None:
            checkclass(value, create_DEMproperties_6)
            value.parent = self
        self._DEMproperties_6 = value
    DEMproperties_6 = property(get_DEMproperties_6, set_DEMproperties_6)
    def get_curveShape(self): return self._curveShape
    def set_curveShape(self, value):
        self._curveShape = value
        update_node(self,self.troot,'maket')
    curveShape = property(get_curveShape, set_curveShape)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.DEMproperties_0 is not None or
            self.DEMproperties_1 is not None or
            self.DEMproperties_3 is not None or
            self.DEMproperties_5 is not None or
            self.DEMproperties_6 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_DEM_1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_DEM_1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_DEM_1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_DEM_1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_DEM_1'):
        if self.curveShape is not None and 'curveShape' not in already_processed:
            already_processed.add('curveShape')
            outfile.write(' curveShape="%s"' % self.gds_format_integer(self.curveShape, input_name='curveShape'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_DEM_1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DEMproperties_0 is not None:
            self.DEMproperties_0.export(outfile, level, namespaceprefix_, name_='DEMproperties_0', pretty_print=pretty_print)
        if self.DEMproperties_1 is not None:
            self.DEMproperties_1.export(outfile, level, namespaceprefix_, name_='DEMproperties_1', pretty_print=pretty_print)
        if self.DEMproperties_3 is not None:
            self.DEMproperties_3.export(outfile, level, namespaceprefix_, name_='DEMproperties_3', pretty_print=pretty_print)
        if self.DEMproperties_5 is not None:
            self.DEMproperties_5.export(outfile, level, namespaceprefix_, name_='DEMproperties_5', pretty_print=pretty_print)
        if self.DEMproperties_6 is not None:
            self.DEMproperties_6.export(outfile, level, namespaceprefix_, name_='DEMproperties_6', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_DEM_1', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.curveShape is not None:
            element.set('curveShape', self.gds_format_integer(self.curveShape))
        if self.DEMproperties_0 is not None:
            DEMproperties_0_ = self.DEMproperties_0
            DEMproperties_0_.to_etree(element, name_='DEMproperties_0', mapping_=mapping_)
        if self.DEMproperties_1 is not None:
            DEMproperties_1_ = self.DEMproperties_1
            DEMproperties_1_.to_etree(element, name_='DEMproperties_1', mapping_=mapping_)
        if self.DEMproperties_3 is not None:
            DEMproperties_3_ = self.DEMproperties_3
            DEMproperties_3_.to_etree(element, name_='DEMproperties_3', mapping_=mapping_)
        if self.DEMproperties_5 is not None:
            DEMproperties_5_ = self.DEMproperties_5
            DEMproperties_5_.to_etree(element, name_='DEMproperties_5', mapping_=mapping_)
        if self.DEMproperties_6 is not None:
            DEMproperties_6_ = self.DEMproperties_6
            DEMproperties_6_.to_etree(element, name_='DEMproperties_6', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_DEM_1'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.curveShape is not None and 'curveShape' not in already_processed:
            already_processed.add('curveShape')
            showIndent(outfile, level)
            outfile.write('curveShape=%d,\n' % (self.curveShape,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DEMproperties_0 is not None:
            showIndent(outfile, level)
            outfile.write('DEMproperties_0=model_._DEMproperties_0(\n')
            self.DEMproperties_0.exportLiteral(outfile, level, name_='DEMproperties_0')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DEMproperties_1 is not None:
            showIndent(outfile, level)
            outfile.write('DEMproperties_1=model_._DEMproperties_1(\n')
            self.DEMproperties_1.exportLiteral(outfile, level, name_='DEMproperties_1')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DEMproperties_3 is not None:
            showIndent(outfile, level)
            outfile.write('DEMproperties_3=model_._DEMproperties_3(\n')
            self.DEMproperties_3.exportLiteral(outfile, level, name_='DEMproperties_3')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DEMproperties_5 is not None:
            showIndent(outfile, level)
            outfile.write('DEMproperties_5=model_._DEMproperties_5(\n')
            self.DEMproperties_5.exportLiteral(outfile, level, name_='DEMproperties_5')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DEMproperties_6 is not None:
            showIndent(outfile, level)
            outfile.write('DEMproperties_6=model_._DEMproperties_6(\n')
            self.DEMproperties_6.exportLiteral(outfile, level, name_='DEMproperties_6')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('curveShape', node)
        if value is not None and 'curveShape' not in already_processed:
            already_processed.add('curveShape')
            try:
                self.curveShape = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DEMproperties_0':
            obj_ = create_DEMproperties_0.factory()
            obj_.build(child_)
            self.set_DEMproperties_0(obj_)
            obj_.original_tagname_ = 'DEMproperties_0'
        elif nodeName_ == 'DEMproperties_1':
            obj_ = create_DEMproperties_1.factory()
            obj_.build(child_)
            self.set_DEMproperties_1(obj_)
            obj_.original_tagname_ = 'DEMproperties_1'
        elif nodeName_ == 'DEMproperties_3':
            obj_ = create_DEMproperties_3.factory()
            obj_.build(child_)
            self.set_DEMproperties_3(obj_)
            obj_.original_tagname_ = 'DEMproperties_3'
        elif nodeName_ == 'DEMproperties_5':
            obj_ = create_DEMproperties_5.factory()
            obj_.build(child_)
            self.set_DEMproperties_5(obj_)
            obj_.original_tagname_ = 'DEMproperties_5'
        elif nodeName_ == 'DEMproperties_6':
            obj_ = create_DEMproperties_6.factory()
            obj_.build(child_)
            self.set_DEMproperties_6(obj_)
            obj_.original_tagname_ = 'DEMproperties_6'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_DEM_1


class create_DEMproperties_0(GeneratedsSuper):
    """heightDEM heightDEM"""
    member_data_items_ = [
        MemberSpec_('heightDEM', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, heightDEM=3.5):
        self.original_tagname_ = None
        self.troot=get_gs_troot('maket','_DEMproperties_0')
        self.attrib = ['heightDEM']
        self.children = []
        self.parent = None
        self._heightDEM = _cast(float, heightDEM)
        update_node(self,self.troot,'maket')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_DEMproperties_0)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_DEMproperties_0.subclass:
            return create_DEMproperties_0.subclass(*args_, **kwargs_)
        else:
            return create_DEMproperties_0(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_heightDEM(self): return self._heightDEM
    def set_heightDEM(self, value):
        self._heightDEM = value
        update_node(self,self.troot,'maket')
    heightDEM = property(get_heightDEM, set_heightDEM)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_DEMproperties_0', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_DEMproperties_0')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_DEMproperties_0')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_DEMproperties_0', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_DEMproperties_0'):
        if self.heightDEM is not None and 'heightDEM' not in already_processed:
            already_processed.add('heightDEM')
            outfile.write(' heightDEM="%s"' % self.gds_format_double(self.heightDEM, input_name='heightDEM'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_DEMproperties_0', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_DEMproperties_0', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.heightDEM is not None:
            element.set('heightDEM', self.gds_format_double(self.heightDEM))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_DEMproperties_0'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.heightDEM is not None and 'heightDEM' not in already_processed:
            already_processed.add('heightDEM')
            showIndent(outfile, level)
            outfile.write('heightDEM=%e,\n' % (self.heightDEM,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('heightDEM', node)
        if value is not None and 'heightDEM' not in already_processed:
            already_processed.add('heightDEM')
            try:
                self.heightDEM = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (heightDEM): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_DEMproperties_0


class create_DEMproperties_1(GeneratedsSuper):
    """Width of the valley Width of the valley Azimuth angle of the slopes
    Azimuth angle of the slopes Distance of valley from origin
    Distance of valley from origin Height of the first plateau
    Height of the first plateau Height of the second plateau Height
    of the second plateau Zenith angle of the second slope Zenith
    angle of the second slope Zenith angle of the first slope Zenith
    angle of the first slope"""
    member_data_items_ = [
        MemberSpec_('distance2', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('az_slope', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('distance1', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('heightPlateau1', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('heightPlateau2', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('z_slope_2', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('z_slope_1', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, distance2=5, az_slope=0, distance1=10, heightPlateau1=10, heightPlateau2=7, z_slope_2=33, z_slope_1=33):
        self.original_tagname_ = None
        self.troot=get_gs_troot('maket','_DEMproperties_1')
        self.attrib = ['distance2', 'az_slope', 'distance1', 'heightPlateau1', 'heightPlateau2', 'z_slope_2', 'z_slope_1']
        self.children = []
        self.parent = None
        self._distance2 = _cast(float, distance2)
        self._az_slope = _cast(float, az_slope)
        self._distance1 = _cast(float, distance1)
        self._heightPlateau1 = _cast(float, heightPlateau1)
        self._heightPlateau2 = _cast(float, heightPlateau2)
        self._z_slope_2 = _cast(float, z_slope_2)
        self._z_slope_1 = _cast(float, z_slope_1)
        update_node(self,self.troot,'maket')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_DEMproperties_1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_DEMproperties_1.subclass:
            return create_DEMproperties_1.subclass(*args_, **kwargs_)
        else:
            return create_DEMproperties_1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_distance2(self): return self._distance2
    def set_distance2(self, value):
        self._distance2 = value
        update_node(self,self.troot,'maket')
    distance2 = property(get_distance2, set_distance2)
    def get_az_slope(self): return self._az_slope
    def set_az_slope(self, value):
        self._az_slope = value
        update_node(self,self.troot,'maket')
    az_slope = property(get_az_slope, set_az_slope)
    def get_distance1(self): return self._distance1
    def set_distance1(self, value):
        self._distance1 = value
        update_node(self,self.troot,'maket')
    distance1 = property(get_distance1, set_distance1)
    def get_heightPlateau1(self): return self._heightPlateau1
    def set_heightPlateau1(self, value):
        self._heightPlateau1 = value
        update_node(self,self.troot,'maket')
    heightPlateau1 = property(get_heightPlateau1, set_heightPlateau1)
    def get_heightPlateau2(self): return self._heightPlateau2
    def set_heightPlateau2(self, value):
        self._heightPlateau2 = value
        update_node(self,self.troot,'maket')
    heightPlateau2 = property(get_heightPlateau2, set_heightPlateau2)
    def get_z_slope_2(self): return self._z_slope_2
    def set_z_slope_2(self, value):
        self._z_slope_2 = value
        update_node(self,self.troot,'maket')
    z_slope_2 = property(get_z_slope_2, set_z_slope_2)
    def get_z_slope_1(self): return self._z_slope_1
    def set_z_slope_1(self, value):
        self._z_slope_1 = value
        update_node(self,self.troot,'maket')
    z_slope_1 = property(get_z_slope_1, set_z_slope_1)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_DEMproperties_1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_DEMproperties_1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_DEMproperties_1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_DEMproperties_1', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_DEMproperties_1'):
        if self.distance2 is not None and 'distance2' not in already_processed:
            already_processed.add('distance2')
            outfile.write(' distance2="%s"' % self.gds_format_double(self.distance2, input_name='distance2'))
        if self.az_slope is not None and 'az_slope' not in already_processed:
            already_processed.add('az_slope')
            outfile.write(' az_slope="%s"' % self.gds_format_double(self.az_slope, input_name='az_slope'))
        if self.distance1 is not None and 'distance1' not in already_processed:
            already_processed.add('distance1')
            outfile.write(' distance1="%s"' % self.gds_format_double(self.distance1, input_name='distance1'))
        if self.heightPlateau1 is not None and 'heightPlateau1' not in already_processed:
            already_processed.add('heightPlateau1')
            outfile.write(' heightPlateau1="%s"' % self.gds_format_double(self.heightPlateau1, input_name='heightPlateau1'))
        if self.heightPlateau2 is not None and 'heightPlateau2' not in already_processed:
            already_processed.add('heightPlateau2')
            outfile.write(' heightPlateau2="%s"' % self.gds_format_double(self.heightPlateau2, input_name='heightPlateau2'))
        if self.z_slope_2 is not None and 'z_slope_2' not in already_processed:
            already_processed.add('z_slope_2')
            outfile.write(' z_slope_2="%s"' % self.gds_format_double(self.z_slope_2, input_name='z_slope_2'))
        if self.z_slope_1 is not None and 'z_slope_1' not in already_processed:
            already_processed.add('z_slope_1')
            outfile.write(' z_slope_1="%s"' % self.gds_format_double(self.z_slope_1, input_name='z_slope_1'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_DEMproperties_1', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_DEMproperties_1', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.distance2 is not None:
            element.set('distance2', self.gds_format_double(self.distance2))
        if self.az_slope is not None:
            element.set('az_slope', self.gds_format_double(self.az_slope))
        if self.distance1 is not None:
            element.set('distance1', self.gds_format_double(self.distance1))
        if self.heightPlateau1 is not None:
            element.set('heightPlateau1', self.gds_format_double(self.heightPlateau1))
        if self.heightPlateau2 is not None:
            element.set('heightPlateau2', self.gds_format_double(self.heightPlateau2))
        if self.z_slope_2 is not None:
            element.set('z_slope_2', self.gds_format_double(self.z_slope_2))
        if self.z_slope_1 is not None:
            element.set('z_slope_1', self.gds_format_double(self.z_slope_1))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_DEMproperties_1'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.distance2 is not None and 'distance2' not in already_processed:
            already_processed.add('distance2')
            showIndent(outfile, level)
            outfile.write('distance2=%e,\n' % (self.distance2,))
        if self.az_slope is not None and 'az_slope' not in already_processed:
            already_processed.add('az_slope')
            showIndent(outfile, level)
            outfile.write('az_slope=%e,\n' % (self.az_slope,))
        if self.distance1 is not None and 'distance1' not in already_processed:
            already_processed.add('distance1')
            showIndent(outfile, level)
            outfile.write('distance1=%e,\n' % (self.distance1,))
        if self.heightPlateau1 is not None and 'heightPlateau1' not in already_processed:
            already_processed.add('heightPlateau1')
            showIndent(outfile, level)
            outfile.write('heightPlateau1=%e,\n' % (self.heightPlateau1,))
        if self.heightPlateau2 is not None and 'heightPlateau2' not in already_processed:
            already_processed.add('heightPlateau2')
            showIndent(outfile, level)
            outfile.write('heightPlateau2=%e,\n' % (self.heightPlateau2,))
        if self.z_slope_2 is not None and 'z_slope_2' not in already_processed:
            already_processed.add('z_slope_2')
            showIndent(outfile, level)
            outfile.write('z_slope_2=%e,\n' % (self.z_slope_2,))
        if self.z_slope_1 is not None and 'z_slope_1' not in already_processed:
            already_processed.add('z_slope_1')
            showIndent(outfile, level)
            outfile.write('z_slope_1=%e,\n' % (self.z_slope_1,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('distance2', node)
        if value is not None and 'distance2' not in already_processed:
            already_processed.add('distance2')
            try:
                self.distance2 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (distance2): %s' % exp)
        value = find_attr_value_('az_slope', node)
        if value is not None and 'az_slope' not in already_processed:
            already_processed.add('az_slope')
            try:
                self.az_slope = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (az_slope): %s' % exp)
        value = find_attr_value_('distance1', node)
        if value is not None and 'distance1' not in already_processed:
            already_processed.add('distance1')
            try:
                self.distance1 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (distance1): %s' % exp)
        value = find_attr_value_('heightPlateau1', node)
        if value is not None and 'heightPlateau1' not in already_processed:
            already_processed.add('heightPlateau1')
            try:
                self.heightPlateau1 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (heightPlateau1): %s' % exp)
        value = find_attr_value_('heightPlateau2', node)
        if value is not None and 'heightPlateau2' not in already_processed:
            already_processed.add('heightPlateau2')
            try:
                self.heightPlateau2 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (heightPlateau2): %s' % exp)
        value = find_attr_value_('z_slope_2', node)
        if value is not None and 'z_slope_2' not in already_processed:
            already_processed.add('z_slope_2')
            try:
                self.z_slope_2 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (z_slope_2): %s' % exp)
        value = find_attr_value_('z_slope_1', node)
        if value is not None and 'z_slope_1' not in already_processed:
            already_processed.add('z_slope_1')
            try:
                self.z_slope_1 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (z_slope_1): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_DEMproperties_1


class create_DEMproperties_3(GeneratedsSuper):
    """maximum height of the gaussian bell maximum height of the gaussian
    bell Adjusting the shape of the gaussian bell along y axis
    Adjusting the shape of the gaussian bell along y axis Adjusting
    the shape of the gaussian bell along x axis Adjusting the shape
    of the gaussian bell along x axis Deplacement along the X of the
    origin of the gaussian bell (MNT is repeated if it extends
    beyond the scene) Deplacement along the X of the origin of the
    gaussian bell (MNT is repeated if it extends beyond the scene)
    Deplacement along the Y of the origin of the gaussian bell (MNT
    is repeated if it extends beyond the scene) Deplacement along
    the Y of the origin of the gaussian bell (MNT is repeated if it
    extends beyond the scene)"""
    member_data_items_ = [
        MemberSpec_('amplitudeDEM', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('sigmaY', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('sigmaX', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('deplacementX', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('deplacementY', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, amplitudeDEM=3.5, sigmaY=10.0, sigmaX=10.0, deplacementX=0.0, deplacementY=0.0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('maket','_DEMproperties_3')
        self.attrib = ['amplitudeDEM', 'sigmaY', 'sigmaX', 'deplacementX', 'deplacementY']
        self.children = []
        self.parent = None
        self._amplitudeDEM = _cast(float, amplitudeDEM)
        self._sigmaY = _cast(float, sigmaY)
        self._sigmaX = _cast(float, sigmaX)
        self._deplacementX = _cast(float, deplacementX)
        self._deplacementY = _cast(float, deplacementY)
        update_node(self,self.troot,'maket')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_DEMproperties_3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_DEMproperties_3.subclass:
            return create_DEMproperties_3.subclass(*args_, **kwargs_)
        else:
            return create_DEMproperties_3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_amplitudeDEM(self): return self._amplitudeDEM
    def set_amplitudeDEM(self, value):
        self._amplitudeDEM = value
        update_node(self,self.troot,'maket')
    amplitudeDEM = property(get_amplitudeDEM, set_amplitudeDEM)
    def get_sigmaY(self): return self._sigmaY
    def set_sigmaY(self, value):
        self._sigmaY = value
        update_node(self,self.troot,'maket')
    sigmaY = property(get_sigmaY, set_sigmaY)
    def get_sigmaX(self): return self._sigmaX
    def set_sigmaX(self, value):
        self._sigmaX = value
        update_node(self,self.troot,'maket')
    sigmaX = property(get_sigmaX, set_sigmaX)
    def get_deplacementX(self): return self._deplacementX
    def set_deplacementX(self, value):
        self._deplacementX = value
        update_node(self,self.troot,'maket')
    deplacementX = property(get_deplacementX, set_deplacementX)
    def get_deplacementY(self): return self._deplacementY
    def set_deplacementY(self, value):
        self._deplacementY = value
        update_node(self,self.troot,'maket')
    deplacementY = property(get_deplacementY, set_deplacementY)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_DEMproperties_3', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_DEMproperties_3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_DEMproperties_3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_DEMproperties_3', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_DEMproperties_3'):
        if self.amplitudeDEM is not None and 'amplitudeDEM' not in already_processed:
            already_processed.add('amplitudeDEM')
            outfile.write(' amplitudeDEM="%s"' % self.gds_format_double(self.amplitudeDEM, input_name='amplitudeDEM'))
        if self.sigmaY is not None and 'sigmaY' not in already_processed:
            already_processed.add('sigmaY')
            outfile.write(' sigmaY="%s"' % self.gds_format_double(self.sigmaY, input_name='sigmaY'))
        if self.sigmaX is not None and 'sigmaX' not in already_processed:
            already_processed.add('sigmaX')
            outfile.write(' sigmaX="%s"' % self.gds_format_double(self.sigmaX, input_name='sigmaX'))
        if self.deplacementX is not None and 'deplacementX' not in already_processed:
            already_processed.add('deplacementX')
            outfile.write(' deplacementX="%s"' % self.gds_format_double(self.deplacementX, input_name='deplacementX'))
        if self.deplacementY is not None and 'deplacementY' not in already_processed:
            already_processed.add('deplacementY')
            outfile.write(' deplacementY="%s"' % self.gds_format_double(self.deplacementY, input_name='deplacementY'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_DEMproperties_3', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_DEMproperties_3', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.amplitudeDEM is not None:
            element.set('amplitudeDEM', self.gds_format_double(self.amplitudeDEM))
        if self.sigmaY is not None:
            element.set('sigmaY', self.gds_format_double(self.sigmaY))
        if self.sigmaX is not None:
            element.set('sigmaX', self.gds_format_double(self.sigmaX))
        if self.deplacementX is not None:
            element.set('deplacementX', self.gds_format_double(self.deplacementX))
        if self.deplacementY is not None:
            element.set('deplacementY', self.gds_format_double(self.deplacementY))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_DEMproperties_3'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.amplitudeDEM is not None and 'amplitudeDEM' not in already_processed:
            already_processed.add('amplitudeDEM')
            showIndent(outfile, level)
            outfile.write('amplitudeDEM=%e,\n' % (self.amplitudeDEM,))
        if self.sigmaY is not None and 'sigmaY' not in already_processed:
            already_processed.add('sigmaY')
            showIndent(outfile, level)
            outfile.write('sigmaY=%e,\n' % (self.sigmaY,))
        if self.sigmaX is not None and 'sigmaX' not in already_processed:
            already_processed.add('sigmaX')
            showIndent(outfile, level)
            outfile.write('sigmaX=%e,\n' % (self.sigmaX,))
        if self.deplacementX is not None and 'deplacementX' not in already_processed:
            already_processed.add('deplacementX')
            showIndent(outfile, level)
            outfile.write('deplacementX=%e,\n' % (self.deplacementX,))
        if self.deplacementY is not None and 'deplacementY' not in already_processed:
            already_processed.add('deplacementY')
            showIndent(outfile, level)
            outfile.write('deplacementY=%e,\n' % (self.deplacementY,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('amplitudeDEM', node)
        if value is not None and 'amplitudeDEM' not in already_processed:
            already_processed.add('amplitudeDEM')
            try:
                self.amplitudeDEM = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (amplitudeDEM): %s' % exp)
        value = find_attr_value_('sigmaY', node)
        if value is not None and 'sigmaY' not in already_processed:
            already_processed.add('sigmaY')
            try:
                self.sigmaY = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sigmaY): %s' % exp)
        value = find_attr_value_('sigmaX', node)
        if value is not None and 'sigmaX' not in already_processed:
            already_processed.add('sigmaX')
            try:
                self.sigmaX = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sigmaX): %s' % exp)
        value = find_attr_value_('deplacementX', node)
        if value is not None and 'deplacementX' not in already_processed:
            already_processed.add('deplacementX')
            try:
                self.deplacementX = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (deplacementX): %s' % exp)
        value = find_attr_value_('deplacementY', node)
        if value is not None and 'deplacementY' not in already_processed:
            already_processed.add('deplacementY')
            try:
                self.deplacementY = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (deplacementY): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_DEMproperties_3


class create_DEMproperties_5(GeneratedsSuper):
    """maximum height of the gaussian bell maximum height of the gaussian
    bell"""
    member_data_items_ = [
        MemberSpec_('amplitudeDEM', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, amplitudeDEM=3.5):
        self.original_tagname_ = None
        self.troot=get_gs_troot('maket','_DEMproperties_5')
        self.attrib = ['amplitudeDEM']
        self.children = []
        self.parent = None
        self._amplitudeDEM = _cast(float, amplitudeDEM)
        update_node(self,self.troot,'maket')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_DEMproperties_5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_DEMproperties_5.subclass:
            return create_DEMproperties_5.subclass(*args_, **kwargs_)
        else:
            return create_DEMproperties_5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_amplitudeDEM(self): return self._amplitudeDEM
    def set_amplitudeDEM(self, value):
        self._amplitudeDEM = value
        update_node(self,self.troot,'maket')
    amplitudeDEM = property(get_amplitudeDEM, set_amplitudeDEM)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_DEMproperties_5', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_DEMproperties_5')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_DEMproperties_5')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_DEMproperties_5', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_DEMproperties_5'):
        if self.amplitudeDEM is not None and 'amplitudeDEM' not in already_processed:
            already_processed.add('amplitudeDEM')
            outfile.write(' amplitudeDEM="%s"' % self.gds_format_double(self.amplitudeDEM, input_name='amplitudeDEM'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_DEMproperties_5', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_DEMproperties_5', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.amplitudeDEM is not None:
            element.set('amplitudeDEM', self.gds_format_double(self.amplitudeDEM))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_DEMproperties_5'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.amplitudeDEM is not None and 'amplitudeDEM' not in already_processed:
            already_processed.add('amplitudeDEM')
            showIndent(outfile, level)
            outfile.write('amplitudeDEM=%e,\n' % (self.amplitudeDEM,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('amplitudeDEM', node)
        if value is not None and 'amplitudeDEM' not in already_processed:
            already_processed.add('amplitudeDEM')
            try:
                self.amplitudeDEM = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (amplitudeDEM): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_DEMproperties_5


class create_DEMproperties_6(GeneratedsSuper):
    """Number of sine curve Number of sine curve maximum height of the
    gaussian bell maximum height of the gaussian bell"""
    member_data_items_ = [
        MemberSpec_('patternNumber', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('amplitudeDEM', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, patternNumber=1.0, amplitudeDEM=3.5):
        self.original_tagname_ = None
        self.troot=get_gs_troot('maket','_DEMproperties_6')
        self.attrib = ['patternNumber', 'amplitudeDEM']
        self.children = []
        self.parent = None
        self._patternNumber = _cast(float, patternNumber)
        self._amplitudeDEM = _cast(float, amplitudeDEM)
        update_node(self,self.troot,'maket')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_DEMproperties_6)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_DEMproperties_6.subclass:
            return create_DEMproperties_6.subclass(*args_, **kwargs_)
        else:
            return create_DEMproperties_6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_patternNumber(self): return self._patternNumber
    def set_patternNumber(self, value):
        self._patternNumber = value
        update_node(self,self.troot,'maket')
    patternNumber = property(get_patternNumber, set_patternNumber)
    def get_amplitudeDEM(self): return self._amplitudeDEM
    def set_amplitudeDEM(self, value):
        self._amplitudeDEM = value
        update_node(self,self.troot,'maket')
    amplitudeDEM = property(get_amplitudeDEM, set_amplitudeDEM)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_DEMproperties_6', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_DEMproperties_6')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_DEMproperties_6')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_DEMproperties_6', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_DEMproperties_6'):
        if self.patternNumber is not None and 'patternNumber' not in already_processed:
            already_processed.add('patternNumber')
            outfile.write(' patternNumber="%s"' % self.gds_format_double(self.patternNumber, input_name='patternNumber'))
        if self.amplitudeDEM is not None and 'amplitudeDEM' not in already_processed:
            already_processed.add('amplitudeDEM')
            outfile.write(' amplitudeDEM="%s"' % self.gds_format_double(self.amplitudeDEM, input_name='amplitudeDEM'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_DEMproperties_6', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_DEMproperties_6', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.patternNumber is not None:
            element.set('patternNumber', self.gds_format_double(self.patternNumber))
        if self.amplitudeDEM is not None:
            element.set('amplitudeDEM', self.gds_format_double(self.amplitudeDEM))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_DEMproperties_6'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.patternNumber is not None and 'patternNumber' not in already_processed:
            already_processed.add('patternNumber')
            showIndent(outfile, level)
            outfile.write('patternNumber=%e,\n' % (self.patternNumber,))
        if self.amplitudeDEM is not None and 'amplitudeDEM' not in already_processed:
            already_processed.add('amplitudeDEM')
            showIndent(outfile, level)
            outfile.write('amplitudeDEM=%e,\n' % (self.amplitudeDEM,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('patternNumber', node)
        if value is not None and 'patternNumber' not in already_processed:
            already_processed.add('patternNumber')
            try:
                self.patternNumber = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (patternNumber): %s' % exp)
        value = find_attr_value_('amplitudeDEM', node)
        if value is not None and 'amplitudeDEM' not in already_processed:
            already_processed.add('amplitudeDEM')
            try:
                self.amplitudeDEM = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (amplitudeDEM): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_DEMproperties_6


class create_DEM_2(GeneratedsSuper):
    """Y translated coordinate origin Y translated coordinate origin X
    translated coordinate origin X translated coordinate origin Name
    of the spectral data base (text file) used to compute the
    spectral phase function(s). Name of the spectral data base (text
    file) used to compute the spectral phase function(s)."""
    member_data_items_ = [
        MemberSpec_('originY', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('originX', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('fileName', 'xsd:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, originY=0.0, originX=0.0, fileName='DEM.mp#'):
        self.original_tagname_ = None
        self.troot=get_gs_troot('maket','_DEM_2')
        self.attrib = ['originY', 'originX', 'fileName']
        self.children = []
        self.parent = None
        self._originY = _cast(float, originY)
        self._originX = _cast(float, originX)
        self._fileName = _cast(None, fileName)
        update_node(self,self.troot,'maket')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_DEM_2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_DEM_2.subclass:
            return create_DEM_2.subclass(*args_, **kwargs_)
        else:
            return create_DEM_2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_originY(self): return self._originY
    def set_originY(self, value):
        self._originY = value
        update_node(self,self.troot,'maket')
    originY = property(get_originY, set_originY)
    def get_originX(self): return self._originX
    def set_originX(self, value):
        self._originX = value
        update_node(self,self.troot,'maket')
    originX = property(get_originX, set_originX)
    def get_fileName(self): return self._fileName
    def set_fileName(self, value):
        self._fileName = value
        update_node(self,self.troot,'maket')
    fileName = property(get_fileName, set_fileName)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_DEM_2', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_DEM_2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_DEM_2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_DEM_2', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_DEM_2'):
        if self.originY is not None and 'originY' not in already_processed:
            already_processed.add('originY')
            outfile.write(' originY="%s"' % self.gds_format_double(self.originY, input_name='originY'))
        if self.originX is not None and 'originX' not in already_processed:
            already_processed.add('originX')
            outfile.write(' originX="%s"' % self.gds_format_double(self.originX, input_name='originX'))
        if self.fileName is not None and 'fileName' not in already_processed:
            already_processed.add('fileName')
            outfile.write(' fileName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fileName), input_name='fileName')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_DEM_2', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_DEM_2', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.originY is not None:
            element.set('originY', self.gds_format_double(self.originY))
        if self.originX is not None:
            element.set('originX', self.gds_format_double(self.originX))
        if self.fileName is not None:
            element.set('fileName', self.gds_format_string(self.fileName))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_DEM_2'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.originY is not None and 'originY' not in already_processed:
            already_processed.add('originY')
            showIndent(outfile, level)
            outfile.write('originY=%e,\n' % (self.originY,))
        if self.originX is not None and 'originX' not in already_processed:
            already_processed.add('originX')
            showIndent(outfile, level)
            outfile.write('originX=%e,\n' % (self.originX,))
        if self.fileName is not None and 'fileName' not in already_processed:
            already_processed.add('fileName')
            showIndent(outfile, level)
            outfile.write('fileName="%s",\n' % (self.fileName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('originY', node)
        if value is not None and 'originY' not in already_processed:
            already_processed.add('originY')
            try:
                self.originY = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (originY): %s' % exp)
        value = find_attr_value_('originX', node)
        if value is not None and 'originX' not in already_processed:
            already_processed.add('originX')
            try:
                self.originX = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (originX): %s' % exp)
        value = find_attr_value_('fileName', node)
        if value is not None and 'fileName' not in already_processed:
            already_processed.add('fileName')
            self.fileName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_DEM_2


class create_DEM_3(GeneratedsSuper):
    """Y translated coordinate origin Y translated coordinate origin X
    translated coordinate origin X translated coordinate origin Name
    of the spectral data base (text file) used to compute the
    spectral phase function(s). Name of the spectral data base (text
    file) used to compute the spectral phase function(s)."""
    member_data_items_ = [
        MemberSpec_('originY', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('originX', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('fileName', 'xsd:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, originY=0.0, originX=0.0, fileName='hills.txt'):
        self.original_tagname_ = None
        self.troot=get_gs_troot('maket','_DEM_3')
        self.attrib = ['originY', 'originX', 'fileName']
        self.children = []
        self.parent = None
        self._originY = _cast(float, originY)
        self._originX = _cast(float, originX)
        self._fileName = _cast(None, fileName)
        update_node(self,self.troot,'maket')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_DEM_3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_DEM_3.subclass:
            return create_DEM_3.subclass(*args_, **kwargs_)
        else:
            return create_DEM_3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_originY(self): return self._originY
    def set_originY(self, value):
        self._originY = value
        update_node(self,self.troot,'maket')
    originY = property(get_originY, set_originY)
    def get_originX(self): return self._originX
    def set_originX(self, value):
        self._originX = value
        update_node(self,self.troot,'maket')
    originX = property(get_originX, set_originX)
    def get_fileName(self): return self._fileName
    def set_fileName(self, value):
        self._fileName = value
        update_node(self,self.troot,'maket')
    fileName = property(get_fileName, set_fileName)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_DEM_3', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_DEM_3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_DEM_3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_DEM_3', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_DEM_3'):
        if self.originY is not None and 'originY' not in already_processed:
            already_processed.add('originY')
            outfile.write(' originY="%s"' % self.gds_format_double(self.originY, input_name='originY'))
        if self.originX is not None and 'originX' not in already_processed:
            already_processed.add('originX')
            outfile.write(' originX="%s"' % self.gds_format_double(self.originX, input_name='originX'))
        if self.fileName is not None and 'fileName' not in already_processed:
            already_processed.add('fileName')
            outfile.write(' fileName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fileName), input_name='fileName')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_DEM_3', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_DEM_3', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.originY is not None:
            element.set('originY', self.gds_format_double(self.originY))
        if self.originX is not None:
            element.set('originX', self.gds_format_double(self.originX))
        if self.fileName is not None:
            element.set('fileName', self.gds_format_string(self.fileName))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_DEM_3'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.originY is not None and 'originY' not in already_processed:
            already_processed.add('originY')
            showIndent(outfile, level)
            outfile.write('originY=%e,\n' % (self.originY,))
        if self.originX is not None and 'originX' not in already_processed:
            already_processed.add('originX')
            showIndent(outfile, level)
            outfile.write('originX=%e,\n' % (self.originX,))
        if self.fileName is not None and 'fileName' not in already_processed:
            already_processed.add('fileName')
            showIndent(outfile, level)
            outfile.write('fileName="%s",\n' % (self.fileName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('originY', node)
        if value is not None and 'originY' not in already_processed:
            already_processed.add('originY')
            try:
                self.originY = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (originY): %s' % exp)
        value = find_attr_value_('originX', node)
        if value is not None and 'originX' not in already_processed:
            already_processed.add('originX')
            try:
                self.originX = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (originX): %s' % exp)
        value = find_attr_value_('fileName', node)
        if value is not None and 'fileName' not in already_processed:
            already_processed.add('fileName')
            self.fileName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_DEM_3


class create_DEM_4(GeneratedsSuper):
    """numberOfRotation numberOfRotation Name of the spectral data base
    (text file) used to compute the spectral phase function(s). Name
    of the spectral data base (text file) used to compute the
    spectral phase function(s)."""
    member_data_items_ = [
        MemberSpec_('numberOfRotation', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('fileName', 'xsd:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, numberOfRotation=1, fileName='DEM.mp#'):
        self.original_tagname_ = None
        self.troot=get_gs_troot('maket','_DEM_4')
        self.attrib = ['numberOfRotation', 'fileName']
        self.children = []
        self.parent = None
        self._numberOfRotation = _cast(int, numberOfRotation)
        self._fileName = _cast(None, fileName)
        update_node(self,self.troot,'maket')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_DEM_4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_DEM_4.subclass:
            return create_DEM_4.subclass(*args_, **kwargs_)
        else:
            return create_DEM_4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_numberOfRotation(self): return self._numberOfRotation
    def set_numberOfRotation(self, value):
        self._numberOfRotation = value
        update_node(self,self.troot,'maket')
    numberOfRotation = property(get_numberOfRotation, set_numberOfRotation)
    def get_fileName(self): return self._fileName
    def set_fileName(self, value):
        self._fileName = value
        update_node(self,self.troot,'maket')
    fileName = property(get_fileName, set_fileName)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_DEM_4', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_DEM_4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_DEM_4')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_DEM_4', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_DEM_4'):
        if self.numberOfRotation is not None and 'numberOfRotation' not in already_processed:
            already_processed.add('numberOfRotation')
            outfile.write(' numberOfRotation="%s"' % self.gds_format_integer(self.numberOfRotation, input_name='numberOfRotation'))
        if self.fileName is not None and 'fileName' not in already_processed:
            already_processed.add('fileName')
            outfile.write(' fileName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fileName), input_name='fileName')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_DEM_4', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_DEM_4', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.numberOfRotation is not None:
            element.set('numberOfRotation', self.gds_format_integer(self.numberOfRotation))
        if self.fileName is not None:
            element.set('fileName', self.gds_format_string(self.fileName))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_DEM_4'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numberOfRotation is not None and 'numberOfRotation' not in already_processed:
            already_processed.add('numberOfRotation')
            showIndent(outfile, level)
            outfile.write('numberOfRotation=%d,\n' % (self.numberOfRotation,))
        if self.fileName is not None and 'fileName' not in already_processed:
            already_processed.add('fileName')
            showIndent(outfile, level)
            outfile.write('fileName="%s",\n' % (self.fileName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfRotation', node)
        if value is not None and 'numberOfRotation' not in already_processed:
            already_processed.add('numberOfRotation')
            try:
                self.numberOfRotation = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('fileName', node)
        if value is not None and 'fileName' not in already_processed:
            already_processed.add('fileName')
            self.fileName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_DEM_4


class create_DEM_5(GeneratedsSuper):
    """The encoding format in which are store the values of the raster The
    encoding format in which are store the values of the raster Of
    which type are the value of the pixels in the raster file Of
    which type are the value of the pixels in the raster file Name
    of the spectral data base (text file) used to compute the
    spectral phase function(s). Name of the spectral data base (text
    file) used to compute the spectral phase function(s)."""
    member_data_items_ = [
        MemberSpec_('dataEncoding', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('dataFormat', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('fileName', 'xsd:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, dataEncoding=0, dataFormat=8, fileName='Raster.img'):
        self.original_tagname_ = None
        self.troot=get_gs_troot('maket','_DEM_5')
        self.attrib = ['dataEncoding', 'dataFormat', 'fileName']
        self.children = []
        self.parent = None
        self._dataEncoding = _cast(int, dataEncoding)
        self._dataFormat = _cast(int, dataFormat)
        self._fileName = _cast(None, fileName)
        update_node(self,self.troot,'maket')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_DEM_5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_DEM_5.subclass:
            return create_DEM_5.subclass(*args_, **kwargs_)
        else:
            return create_DEM_5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dataEncoding(self): return self._dataEncoding
    def set_dataEncoding(self, value):
        self._dataEncoding = value
        update_node(self,self.troot,'maket')
    dataEncoding = property(get_dataEncoding, set_dataEncoding)
    def get_dataFormat(self): return self._dataFormat
    def set_dataFormat(self, value):
        self._dataFormat = value
        update_node(self,self.troot,'maket')
    dataFormat = property(get_dataFormat, set_dataFormat)
    def get_fileName(self): return self._fileName
    def set_fileName(self, value):
        self._fileName = value
        update_node(self,self.troot,'maket')
    fileName = property(get_fileName, set_fileName)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_DEM_5', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_DEM_5')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_DEM_5')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_DEM_5', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_DEM_5'):
        if self.dataEncoding is not None and 'dataEncoding' not in already_processed:
            already_processed.add('dataEncoding')
            outfile.write(' dataEncoding="%s"' % self.gds_format_integer(self.dataEncoding, input_name='dataEncoding'))
        if self.dataFormat is not None and 'dataFormat' not in already_processed:
            already_processed.add('dataFormat')
            outfile.write(' dataFormat="%s"' % self.gds_format_integer(self.dataFormat, input_name='dataFormat'))
        if self.fileName is not None and 'fileName' not in already_processed:
            already_processed.add('fileName')
            outfile.write(' fileName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fileName), input_name='fileName')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_DEM_5', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_DEM_5', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.dataEncoding is not None:
            element.set('dataEncoding', self.gds_format_integer(self.dataEncoding))
        if self.dataFormat is not None:
            element.set('dataFormat', self.gds_format_integer(self.dataFormat))
        if self.fileName is not None:
            element.set('fileName', self.gds_format_string(self.fileName))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_DEM_5'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.dataEncoding is not None and 'dataEncoding' not in already_processed:
            already_processed.add('dataEncoding')
            showIndent(outfile, level)
            outfile.write('dataEncoding=%d,\n' % (self.dataEncoding,))
        if self.dataFormat is not None and 'dataFormat' not in already_processed:
            already_processed.add('dataFormat')
            showIndent(outfile, level)
            outfile.write('dataFormat=%d,\n' % (self.dataFormat,))
        if self.fileName is not None and 'fileName' not in already_processed:
            already_processed.add('fileName')
            showIndent(outfile, level)
            outfile.write('fileName="%s",\n' % (self.fileName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dataEncoding', node)
        if value is not None and 'dataEncoding' not in already_processed:
            already_processed.add('dataEncoding')
            try:
                self.dataEncoding = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('dataFormat', node)
        if value is not None and 'dataFormat' not in already_processed:
            already_processed.add('dataFormat')
            try:
                self.dataFormat = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('fileName', node)
        if value is not None and 'fileName' not in already_processed:
            already_processed.add('fileName')
            self.fileName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_DEM_5


class create_LatLon(GeneratedsSuper):
    """Latitude Latitude Altitude Altitude Longitude Longitude"""
    member_data_items_ = [
        MemberSpec_('latitude', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('altitude', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('longitude', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, latitude=0.0, altitude=0.0, longitude=0.0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('maket','_LatLon')
        self.attrib = ['latitude', 'altitude', 'longitude']
        self.children = []
        self.parent = None
        self._latitude = _cast(float, latitude)
        self._altitude = _cast(float, altitude)
        self._longitude = _cast(float, longitude)
        update_node(self,self.troot,'maket')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_LatLon)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_LatLon.subclass:
            return create_LatLon.subclass(*args_, **kwargs_)
        else:
            return create_LatLon(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_latitude(self): return self._latitude
    def set_latitude(self, value):
        self._latitude = value
        update_node(self,self.troot,'maket')
    latitude = property(get_latitude, set_latitude)
    def get_altitude(self): return self._altitude
    def set_altitude(self, value):
        self._altitude = value
        update_node(self,self.troot,'maket')
    altitude = property(get_altitude, set_altitude)
    def get_longitude(self): return self._longitude
    def set_longitude(self, value):
        self._longitude = value
        update_node(self,self.troot,'maket')
    longitude = property(get_longitude, set_longitude)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_LatLon', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_LatLon')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_LatLon')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_LatLon', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_LatLon'):
        if self.latitude is not None and 'latitude' not in already_processed:
            already_processed.add('latitude')
            outfile.write(' latitude="%s"' % self.gds_format_double(self.latitude, input_name='latitude'))
        if self.altitude is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            outfile.write(' altitude="%s"' % self.gds_format_double(self.altitude, input_name='altitude'))
        if self.longitude is not None and 'longitude' not in already_processed:
            already_processed.add('longitude')
            outfile.write(' longitude="%s"' % self.gds_format_double(self.longitude, input_name='longitude'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_LatLon', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_LatLon', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.latitude is not None:
            element.set('latitude', self.gds_format_double(self.latitude))
        if self.altitude is not None:
            element.set('altitude', self.gds_format_double(self.altitude))
        if self.longitude is not None:
            element.set('longitude', self.gds_format_double(self.longitude))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_LatLon'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.latitude is not None and 'latitude' not in already_processed:
            already_processed.add('latitude')
            showIndent(outfile, level)
            outfile.write('latitude=%e,\n' % (self.latitude,))
        if self.altitude is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            showIndent(outfile, level)
            outfile.write('altitude=%e,\n' % (self.altitude,))
        if self.longitude is not None and 'longitude' not in already_processed:
            already_processed.add('longitude')
            showIndent(outfile, level)
            outfile.write('longitude=%e,\n' % (self.longitude,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('latitude', node)
        if value is not None and 'latitude' not in already_processed:
            already_processed.add('latitude')
            try:
                self.latitude = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (latitude): %s' % exp)
        value = find_attr_value_('altitude', node)
        if value is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            try:
                self.altitude = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (altitude): %s' % exp)
        value = find_attr_value_('longitude', node)
        if value is not None and 'longitude' not in already_processed:
            already_processed.add('longitude')
            try:
                self.longitude = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (longitude): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_LatLon


class create_InfiniteSlopeProperties(GeneratedsSuper):
    """Define the % of the DEM that will be cropped along the Y axis to be
    replaced with a smooth transition between borders.\nWithout this
    smooth transition, abrupt cliffs will be generated to avoid
    holes in the scene. Define the % of the DEM that will be cropped
    along the Y axis to be replaced with a smooth transition between
    borders.\nWithout this smooth transition, abrupt cliffs will be
    generated to avoid holes in the scene. Define the % of the DEM
    that will be cropped along the X axis to be replaced with a
    smooth transition between borders.\nWithout this smooth
    transition, abrupt cliffs will be generated to avoid holes in
    the scene. Define the % of the DEM that will be cropped along
    the X axis to be replaced with a smooth transition between
    borders.\nWithout this smooth transition, abrupt cliffs will be
    generated to avoid holes in the scene."""
    member_data_items_ = [
        MemberSpec_('connectionPercentageY', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('connectionPercentageX', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, connectionPercentageY=5, connectionPercentageX=5):
        self.original_tagname_ = None
        self.troot=get_gs_troot('maket','_InfiniteSlopeProperties')
        self.attrib = ['connectionPercentageY', 'connectionPercentageX']
        self.children = []
        self.parent = None
        self._connectionPercentageY = _cast(float, connectionPercentageY)
        self._connectionPercentageX = _cast(float, connectionPercentageX)
        update_node(self,self.troot,'maket')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_InfiniteSlopeProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_InfiniteSlopeProperties.subclass:
            return create_InfiniteSlopeProperties.subclass(*args_, **kwargs_)
        else:
            return create_InfiniteSlopeProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_connectionPercentageY(self): return self._connectionPercentageY
    def set_connectionPercentageY(self, value):
        self._connectionPercentageY = value
        update_node(self,self.troot,'maket')
    connectionPercentageY = property(get_connectionPercentageY, set_connectionPercentageY)
    def get_connectionPercentageX(self): return self._connectionPercentageX
    def set_connectionPercentageX(self, value):
        self._connectionPercentageX = value
        update_node(self,self.troot,'maket')
    connectionPercentageX = property(get_connectionPercentageX, set_connectionPercentageX)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_InfiniteSlopeProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_InfiniteSlopeProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_InfiniteSlopeProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_InfiniteSlopeProperties', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_InfiniteSlopeProperties'):
        if self.connectionPercentageY is not None and 'connectionPercentageY' not in already_processed:
            already_processed.add('connectionPercentageY')
            outfile.write(' connectionPercentageY="%s"' % self.gds_format_double(self.connectionPercentageY, input_name='connectionPercentageY'))
        if self.connectionPercentageX is not None and 'connectionPercentageX' not in already_processed:
            already_processed.add('connectionPercentageX')
            outfile.write(' connectionPercentageX="%s"' % self.gds_format_double(self.connectionPercentageX, input_name='connectionPercentageX'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_InfiniteSlopeProperties', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_InfiniteSlopeProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.connectionPercentageY is not None:
            element.set('connectionPercentageY', self.gds_format_double(self.connectionPercentageY))
        if self.connectionPercentageX is not None:
            element.set('connectionPercentageX', self.gds_format_double(self.connectionPercentageX))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_InfiniteSlopeProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.connectionPercentageY is not None and 'connectionPercentageY' not in already_processed:
            already_processed.add('connectionPercentageY')
            showIndent(outfile, level)
            outfile.write('connectionPercentageY=%e,\n' % (self.connectionPercentageY,))
        if self.connectionPercentageX is not None and 'connectionPercentageX' not in already_processed:
            already_processed.add('connectionPercentageX')
            showIndent(outfile, level)
            outfile.write('connectionPercentageX=%e,\n' % (self.connectionPercentageX,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('connectionPercentageY', node)
        if value is not None and 'connectionPercentageY' not in already_processed:
            already_processed.add('connectionPercentageY')
            try:
                self.connectionPercentageY = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (connectionPercentageY): %s' % exp)
        value = find_attr_value_('connectionPercentageX', node)
        if value is not None and 'connectionPercentageX' not in already_processed:
            already_processed.add('connectionPercentageX')
            try:
                self.connectionPercentageX = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (connectionPercentageX): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
    # end class create_InfiniteSlopeProperties


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <createParser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from maket import *\n\n')
        sys.stdout.write('import maket as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "createDartFile",
    "create_CellDimensions",
    "create_DEMGenerator",
    "create_DEM_1",
    "create_DEM_2",
    "create_DEM_3",
    "create_DEM_4",
    "create_DEM_5",
    "create_DEM_properties",
    "create_DEMproperties_0",
    "create_DEMproperties_1",
    "create_DEMproperties_3",
    "create_DEMproperties_5",
    "create_DEMproperties_6",
    "create_DartZoneProperties",
    "create_InfiniteSlopeProperties",
    "create_LatLon",
    "create_Maket",
    "create_OpticalPropertyLink",
    "create_Point2D",
    "create_RandomGenerationParameters",
    "create_Scene",
    "create_SceneDimensions",
    "create_Soil",
    "create_ThermalPropertyLink",
    "create_Topography",
    "create_TopographyProperties"
]
