#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Nov 19 15:08:15 2019 by generateDS.py version 2.29.25.
# Python 3.6.7 | packaged by conda-forge | (default, Nov  6 2019, 16:19:42)  [GCC 7.3.0]
#
# Command line options:
#   ('-m', '')
#   ('-f', '')
#   ('--always-export-default', '')
#   ('--export', 'write literal etree')
#   ('-u', 'core_ui.user_methods')
#   ('-p', 'create')
#   ('--post-attrib-setter', "update_node(self,self.troot,'trees')")
#   ('--pre-ctor', "self.troot=get_gs_troot('trees','{classname}')")
#   ('--post-ctor', "update_node(self,self.troot,'trees')")
#   ('--imports', 'from pytools4dart.core_ui.utils import get_gs_troot, update_node, get_path, findpaths, subpaths, set_nodes')
#   ('-o', '/media/DATA/Florian/git/pytools4dart/pytools4dart/core_ui/trees.py')
#
# Command line arguments:
#   /media/DATA/Florian/git/pytools4dart/pytools4dart/xsdschemas/trees.xsd
#
# Command line:
#   /home/boissieu/anaconda3/envs/pytools4dart/bin/generateDS.py -m -f --always-export-default --export="write literal etree" -u "core_ui.user_methods" -p "create" --post-attrib-setter="update_node(self,self.troot,'trees')" --pre-ctor="self.troot=get_gs_troot('trees','{classname}')" --post-ctor="update_node(self,self.troot,'trees')" --imports="from pytools4dart.core_ui.utils import get_gs_troot, update_node, get_path, findpaths, subpaths, set_nodes" -o "/media/DATA/Florian/git/pytools4dart/pytools4dart/core_ui/trees.py" /media/DATA/Florian/git/pytools4dart/pytools4dart/xsdschemas/trees.xsd
#
# Current working directory (os.getcwd()):
#   pytools4dart
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_
from pytools4dart.core_ui.utils import get_gs_troot, update_node, get_path, findpaths, subpaths, set_nodes


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#

def checkclass(value, cl):
    if isinstance(value, list):
        for v in value:
            if not isinstance(v, cl):
                raise ValueError("invalid class")
    else:
        if not isinstance(value, cl):
            raise ValueError("invalid class")

def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class createDartFile(GeneratedsSuper):
    """Version of the plots.xml file. Depends of the version on DART
    itself. Version of the plots.xml file. Depends of the version on
    DART itself."""
    member_data_items_ = [
        MemberSpec_('version', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('build_', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('Trees', '_Trees', 0, 0, {'name': 'Trees', 'type': '_Trees', 'minOccurs': '1', 'maxOccurs': '1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, version='5.7.5', build_='0', Trees=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','DartFile')
        self.attrib = ['version', 'build_']
        self.children = ['Trees']
        self.parent = None
        self._version = _cast(None, version)
        self._build_ = _cast(None, build_)
        self._Trees = Trees
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, createDartFile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if createDartFile.subclass:
            return createDartFile.subclass(*args_, **kwargs_)
        else:
            return createDartFile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Trees(self): return self._Trees
    def set_Trees(self, value):
        if value is not None:
            checkclass(value, create_Trees)
            value.parent = self
        self._Trees = value
    Trees = property(get_Trees, set_Trees)
    def get_version(self): return self._version
    def set_version(self, value):
        self._version = value
        update_node(self,self.troot,'trees')
    version = property(get_version, set_version)
    def get_build(self): return self._build_
    def set_build(self, value):
        self._build_ = value
        update_node(self,self.troot,'trees')
    build_ = property(get_build, set_build)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Trees is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='DartFile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DartFile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DartFile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='DartFile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DartFile'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
        if self.build_ is not None and 'build_' not in already_processed:
            already_processed.add('build_')
            outfile.write(' build=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.build_), input_name='build')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='DartFile', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Trees is not None:
            self.Trees.export(outfile, level, namespaceprefix_, name_='Trees', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='DartFile', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.version is not None:
            element.set('version', self.gds_format_string(self.version))
        if self.build_ is not None:
            element.set('build', self.gds_format_string(self.build_))
        if self.Trees is not None:
            Trees_ = self.Trees
            Trees_.to_etree(element, name_='Trees', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='DartFile'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.build_ is not None and 'build_' not in already_processed:
            already_processed.add('build_')
            showIndent(outfile, level)
            outfile.write('build_="%s",\n' % (self.build_,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Trees is not None:
            showIndent(outfile, level)
            outfile.write('Trees=model_._Trees(\n')
            self.Trees.exportLiteral(outfile, level, name_='Trees')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('build', node)
        if value is not None and 'build' not in already_processed:
            already_processed.add('build')
            self.build_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Trees':
            obj_ = create_Trees.factory()
            obj_.build(child_)
            self.set_Trees(obj_)
            obj_.original_tagname_ = 'Trees'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class createDartFile


class create_Trees(GeneratedsSuper):
    """Trees Trees Type of tree spatial distribution - Random location
    around the nodes of a user specified grid and dimensions "mean +
    standard deviation" specified by the user. - Exact location
    (x,y) specified by a text file and dimensions "mean + standard
    deviation" specified by the user. - Exact location (x,y) and
    exact dimensions specified by a text file Type of tree spatial
    distribution - Random location around the nodes of a user
    specified grid and dimensions "mean + standard deviation"
    specified by the user. - Exact location (x,y) specified by a
    text file and dimensions "mean + standard deviation" specified
    by the user. - Exact location (x,y) and exact dimensions
    specified by a text file Ignore trees in mock-up creation Ignore
    trees in mock-up creation Presence of trees in the scene
    Presence of trees in the scene"""
    member_data_items_ = [
        MemberSpec_('sceneModelCharacteristic', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('hidden', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('isTrees', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('Trees_1', '_Trees_1', 0, 0, {'name': 'Trees_1', 'type': '_Trees_1', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('Trees_2', '_Trees_2', 0, 0, {'name': 'Trees_2', 'type': '_Trees_2', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('Trees_3', '_Trees_3', 0, 0, {'name': 'Trees_3', 'type': '_Trees_3', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('TreeGeneralOptions', '_TreeGeneralOptions', 0, 0, {'name': 'TreeGeneralOptions', 'type': '_TreeGeneralOptions', 'minOccurs': '1', 'maxOccurs': '1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, sceneModelCharacteristic=1, hidden=0, isTrees=0, Trees_1=None, Trees_2=None, Trees_3=None, TreeGeneralOptions=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_Trees')
        self.attrib = ['sceneModelCharacteristic', 'hidden', 'isTrees']
        self.children = ['Trees_1', 'Trees_2', 'Trees_3', 'TreeGeneralOptions']
        self.parent = None
        self._sceneModelCharacteristic = _cast(int, sceneModelCharacteristic)
        self._hidden = _cast(int, hidden)
        self._isTrees = _cast(int, isTrees)
        self._Trees_1 = Trees_1
        self._Trees_2 = Trees_2
        self._Trees_3 = Trees_3
        self._TreeGeneralOptions = TreeGeneralOptions
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Trees)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Trees.subclass:
            return create_Trees.subclass(*args_, **kwargs_)
        else:
            return create_Trees(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Trees_1(self): return self._Trees_1
    def set_Trees_1(self, value):
        if value is not None:
            checkclass(value, create_Trees_1)
            value.parent = self
        self._Trees_1 = value
    Trees_1 = property(get_Trees_1, set_Trees_1)
    def get_Trees_2(self): return self._Trees_2
    def set_Trees_2(self, value):
        if value is not None:
            checkclass(value, create_Trees_2)
            value.parent = self
        self._Trees_2 = value
    Trees_2 = property(get_Trees_2, set_Trees_2)
    def get_Trees_3(self): return self._Trees_3
    def set_Trees_3(self, value):
        if value is not None:
            checkclass(value, create_Trees_3)
            value.parent = self
        self._Trees_3 = value
    Trees_3 = property(get_Trees_3, set_Trees_3)
    def get_TreeGeneralOptions(self): return self._TreeGeneralOptions
    def set_TreeGeneralOptions(self, value):
        if value is not None:
            checkclass(value, create_TreeGeneralOptions)
            value.parent = self
        self._TreeGeneralOptions = value
    TreeGeneralOptions = property(get_TreeGeneralOptions, set_TreeGeneralOptions)
    def get_sceneModelCharacteristic(self): return self._sceneModelCharacteristic
    def set_sceneModelCharacteristic(self, value):
        self._sceneModelCharacteristic = value
        update_node(self,self.troot,'trees')
    sceneModelCharacteristic = property(get_sceneModelCharacteristic, set_sceneModelCharacteristic)
    def get_hidden(self): return self._hidden
    def set_hidden(self, value):
        self._hidden = value
        update_node(self,self.troot,'trees')
    hidden = property(get_hidden, set_hidden)
    def get_isTrees(self): return self._isTrees
    def set_isTrees(self, value):
        self._isTrees = value
        update_node(self,self.troot,'trees')
    isTrees = property(get_isTrees, set_isTrees)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Trees_1 is not None or
            self.Trees_2 is not None or
            self.Trees_3 is not None or
            self.TreeGeneralOptions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Trees', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Trees')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Trees')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Trees', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Trees'):
        if self.sceneModelCharacteristic is not None and 'sceneModelCharacteristic' not in already_processed:
            already_processed.add('sceneModelCharacteristic')
            outfile.write(' sceneModelCharacteristic="%s"' % self.gds_format_integer(self.sceneModelCharacteristic, input_name='sceneModelCharacteristic'))
        if self.hidden is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            outfile.write(' hidden="%s"' % self.gds_format_integer(self.hidden, input_name='hidden'))
        if self.isTrees is not None and 'isTrees' not in already_processed:
            already_processed.add('isTrees')
            outfile.write(' isTrees="%s"' % self.gds_format_integer(self.isTrees, input_name='isTrees'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Trees', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Trees_1 is not None:
            self.Trees_1.export(outfile, level, namespaceprefix_, name_='Trees_1', pretty_print=pretty_print)
        if self.Trees_2 is not None:
            self.Trees_2.export(outfile, level, namespaceprefix_, name_='Trees_2', pretty_print=pretty_print)
        if self.Trees_3 is not None:
            self.Trees_3.export(outfile, level, namespaceprefix_, name_='Trees_3', pretty_print=pretty_print)
        if self.TreeGeneralOptions is not None:
            self.TreeGeneralOptions.export(outfile, level, namespaceprefix_, name_='TreeGeneralOptions', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Trees', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.sceneModelCharacteristic is not None:
            element.set('sceneModelCharacteristic', self.gds_format_integer(self.sceneModelCharacteristic))
        if self.hidden is not None:
            element.set('hidden', self.gds_format_integer(self.hidden))
        if self.isTrees is not None:
            element.set('isTrees', self.gds_format_integer(self.isTrees))
        if self.Trees_1 is not None:
            Trees_1_ = self.Trees_1
            Trees_1_.to_etree(element, name_='Trees_1', mapping_=mapping_)
        if self.Trees_2 is not None:
            Trees_2_ = self.Trees_2
            Trees_2_.to_etree(element, name_='Trees_2', mapping_=mapping_)
        if self.Trees_3 is not None:
            Trees_3_ = self.Trees_3
            Trees_3_.to_etree(element, name_='Trees_3', mapping_=mapping_)
        if self.TreeGeneralOptions is not None:
            TreeGeneralOptions_ = self.TreeGeneralOptions
            TreeGeneralOptions_.to_etree(element, name_='TreeGeneralOptions', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Trees'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sceneModelCharacteristic is not None and 'sceneModelCharacteristic' not in already_processed:
            already_processed.add('sceneModelCharacteristic')
            showIndent(outfile, level)
            outfile.write('sceneModelCharacteristic=%d,\n' % (self.sceneModelCharacteristic,))
        if self.hidden is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            showIndent(outfile, level)
            outfile.write('hidden=%d,\n' % (self.hidden,))
        if self.isTrees is not None and 'isTrees' not in already_processed:
            already_processed.add('isTrees')
            showIndent(outfile, level)
            outfile.write('isTrees=%d,\n' % (self.isTrees,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Trees_1 is not None:
            showIndent(outfile, level)
            outfile.write('Trees_1=model_._Trees_1(\n')
            self.Trees_1.exportLiteral(outfile, level, name_='Trees_1')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Trees_2 is not None:
            showIndent(outfile, level)
            outfile.write('Trees_2=model_._Trees_2(\n')
            self.Trees_2.exportLiteral(outfile, level, name_='Trees_2')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Trees_3 is not None:
            showIndent(outfile, level)
            outfile.write('Trees_3=model_._Trees_3(\n')
            self.Trees_3.exportLiteral(outfile, level, name_='Trees_3')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TreeGeneralOptions is not None:
            showIndent(outfile, level)
            outfile.write('TreeGeneralOptions=model_._TreeGeneralOptions(\n')
            self.TreeGeneralOptions.exportLiteral(outfile, level, name_='TreeGeneralOptions')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sceneModelCharacteristic', node)
        if value is not None and 'sceneModelCharacteristic' not in already_processed:
            already_processed.add('sceneModelCharacteristic')
            try:
                self.sceneModelCharacteristic = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('hidden', node)
        if value is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            try:
                self.hidden = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isTrees', node)
        if value is not None and 'isTrees' not in already_processed:
            already_processed.add('isTrees')
            try:
                self.isTrees = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Trees_1':
            obj_ = create_Trees_1.factory()
            obj_.build(child_)
            self.set_Trees_1(obj_)
            obj_.original_tagname_ = 'Trees_1'
        elif nodeName_ == 'Trees_2':
            obj_ = create_Trees_2.factory()
            obj_.build(child_)
            self.set_Trees_2(obj_)
            obj_.original_tagname_ = 'Trees_2'
        elif nodeName_ == 'Trees_3':
            obj_ = create_Trees_3.factory()
            obj_.build(child_)
            self.set_Trees_3(obj_)
            obj_.original_tagname_ = 'Trees_3'
        elif nodeName_ == 'TreeGeneralOptions':
            obj_ = create_TreeGeneralOptions.factory()
            obj_.build(child_)
            self.set_TreeGeneralOptions(obj_)
            obj_.original_tagname_ = 'TreeGeneralOptions'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_Trees


class create_Trees_1(GeneratedsSuper):
    """Trees_1 Trees_1 1). Knowledge of the LAI of a sub-scene gives the uf
    values of the cells of the sub-scene, which in turn gives the uf
    values of the cells outside the sub-scene. 1). Knowledge of the
    LAI of a sub-scene gives the uf values of the cells of the sub-
    scene, which in turn gives the uf values of the cells outside
    the sub-scene. Text files that gives all necessary tree
    information Text files that gives all necessary tree information"""
    member_data_items_ = [
        MemberSpec_('laiZone', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('sceneParametersFileName', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('LaiZoneProperties', '_LaiZoneProperties', 0, 0, {'name': 'LaiZoneProperties', 'type': '_LaiZoneProperties', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('Specie', '_Specie', 1, 0, {'name': 'Specie', 'type': '_Specie', 'minOccurs': '1', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, laiZone=0, sceneParametersFileName='trees.txt', LaiZoneProperties=None, Specie=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_Trees_1')
        self.attrib = ['laiZone', 'sceneParametersFileName']
        self.children = ['LaiZoneProperties', 'Specie']
        self.parent = None
        self._laiZone = _cast(int, laiZone)
        self._sceneParametersFileName = _cast(None, sceneParametersFileName)
        self._LaiZoneProperties = LaiZoneProperties
        if Specie is None:
            self._Specie = []
        else:
            self._Specie = Specie
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Trees_1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Trees_1.subclass:
            return create_Trees_1.subclass(*args_, **kwargs_)
        else:
            return create_Trees_1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LaiZoneProperties(self): return self._LaiZoneProperties
    def set_LaiZoneProperties(self, value):
        if value is not None:
            checkclass(value, create_LaiZoneProperties)
            value.parent = self
        self._LaiZoneProperties = value
    LaiZoneProperties = property(get_LaiZoneProperties, set_LaiZoneProperties)
    def get_Specie(self): return self._Specie
    def set_Specie(self, value):
        if value is not None:
            checkclass(value, create_Specie)
            for v in value:
                v.parent = self
        self._Specie = value
    def add_Specie(self, value):
        value.parent = self
        self._Specie.append(value)
    def insert_Specie_at(self, index, value):
        value.parent = self
        self.Specie.insert(index, value)
    def replace_Specie_at(self, index, value):
        value.parent = self
        self.Specie[index] = value
    Specie = property(get_Specie, set_Specie)
    def get_laiZone(self): return self._laiZone
    def set_laiZone(self, value):
        self._laiZone = value
        update_node(self,self.troot,'trees')
    laiZone = property(get_laiZone, set_laiZone)
    def get_sceneParametersFileName(self): return self._sceneParametersFileName
    def set_sceneParametersFileName(self, value):
        self._sceneParametersFileName = value
        update_node(self,self.troot,'trees')
    sceneParametersFileName = property(get_sceneParametersFileName, set_sceneParametersFileName)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.LaiZoneProperties is not None or
            self.Specie
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Trees_1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Trees_1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Trees_1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Trees_1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Trees_1'):
        if self.laiZone is not None and 'laiZone' not in already_processed:
            already_processed.add('laiZone')
            outfile.write(' laiZone="%s"' % self.gds_format_integer(self.laiZone, input_name='laiZone'))
        if self.sceneParametersFileName is not None and 'sceneParametersFileName' not in already_processed:
            already_processed.add('sceneParametersFileName')
            outfile.write(' sceneParametersFileName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sceneParametersFileName), input_name='sceneParametersFileName')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Trees_1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LaiZoneProperties is not None:
            self.LaiZoneProperties.export(outfile, level, namespaceprefix_, name_='LaiZoneProperties', pretty_print=pretty_print)
        for Specie_ in self.Specie:
            Specie_.export(outfile, level, namespaceprefix_, name_='Specie', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Trees_1', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.laiZone is not None:
            element.set('laiZone', self.gds_format_integer(self.laiZone))
        if self.sceneParametersFileName is not None:
            element.set('sceneParametersFileName', self.gds_format_string(self.sceneParametersFileName))
        if self.LaiZoneProperties is not None:
            LaiZoneProperties_ = self.LaiZoneProperties
            LaiZoneProperties_.to_etree(element, name_='LaiZoneProperties', mapping_=mapping_)
        for Specie_ in self.Specie:
            Specie_.to_etree(element, name_='Specie', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Trees_1'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.laiZone is not None and 'laiZone' not in already_processed:
            already_processed.add('laiZone')
            showIndent(outfile, level)
            outfile.write('laiZone=%d,\n' % (self.laiZone,))
        if self.sceneParametersFileName is not None and 'sceneParametersFileName' not in already_processed:
            already_processed.add('sceneParametersFileName')
            showIndent(outfile, level)
            outfile.write('sceneParametersFileName="%s",\n' % (self.sceneParametersFileName,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LaiZoneProperties is not None:
            showIndent(outfile, level)
            outfile.write('LaiZoneProperties=model_._LaiZoneProperties(\n')
            self.LaiZoneProperties.exportLiteral(outfile, level, name_='LaiZoneProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Specie=[\n')
        level += 1
        for Specie_ in self.Specie:
            showIndent(outfile, level)
            outfile.write('model_._Specie(\n')
            Specie_.exportLiteral(outfile, level, name_='_Specie')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.Specie = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('laiZone', node)
        if value is not None and 'laiZone' not in already_processed:
            already_processed.add('laiZone')
            try:
                self.laiZone = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('sceneParametersFileName', node)
        if value is not None and 'sceneParametersFileName' not in already_processed:
            already_processed.add('sceneParametersFileName')
            self.sceneParametersFileName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LaiZoneProperties':
            obj_ = create_LaiZoneProperties.factory()
            obj_.build(child_)
            self.set_LaiZoneProperties(obj_)
            obj_.original_tagname_ = 'LaiZoneProperties'
        elif nodeName_ == 'Specie':
            obj_ = create_Specie.factory()
            obj_.build(child_)
            self.add_Specie(obj_)
            obj_.original_tagname_ = 'Specie'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_Trees_1


class create_LaiZoneProperties(GeneratedsSuper):
    """LaiZoneProperties LaiZoneProperties"""
    member_data_items_ = [
        MemberSpec_('Point2D', '_Point2D', 1, 0, {'name': 'Point2D', 'type': '_Point2D', 'minOccurs': '2', 'maxOccurs': '2'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Point2D=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_LaiZoneProperties')
        self.attrib = ['']
        self.children = ['Point2D']
        self.parent = None
        if Point2D is None:
            self._Point2D = []
        else:
            self._Point2D = Point2D
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_LaiZoneProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_LaiZoneProperties.subclass:
            return create_LaiZoneProperties.subclass(*args_, **kwargs_)
        else:
            return create_LaiZoneProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Point2D(self): return self._Point2D
    def set_Point2D(self, value):
        if value is not None:
            checkclass(value, create_Point2D)
            for v in value:
                v.parent = self
        self._Point2D = value
    def add_Point2D(self, value):
        if (value is not None) and (len(self._Point2D) == 2):
            raise ValueError('Maximum length already reached.')
        value.parent = self
        self._Point2D.append(value)
    def insert_Point2D_at(self, index, value):
        if (value is not None) and (len(self._Point2D) == 2):
            raise ValueError('Maximum length already reached.')
        value.parent = self
        self.Point2D.insert(index, value)
    def replace_Point2D_at(self, index, value):
        value.parent = self
        self.Point2D[index] = value
    Point2D = property(get_Point2D, set_Point2D)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Point2D
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_LaiZoneProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_LaiZoneProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_LaiZoneProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_LaiZoneProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_LaiZoneProperties'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_LaiZoneProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Point2D_ in self.Point2D:
            Point2D_.export(outfile, level, namespaceprefix_, name_='Point2D', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_LaiZoneProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for Point2D_ in self.Point2D:
            Point2D_.to_etree(element, name_='Point2D', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_LaiZoneProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Point2D=[\n')
        level += 1
        for Point2D_ in self.Point2D:
            showIndent(outfile, level)
            outfile.write('model_._Point2D(\n')
            Point2D_.exportLiteral(outfile, level, name_='_Point2D')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.Point2D = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Point2D':
            obj_ = create_Point2D.factory()
            obj_.build(child_)
            self.add_Point2D(obj_)
            obj_.original_tagname_ = 'Point2D'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_LaiZoneProperties


class create_Point2D(GeneratedsSuper):
    """Point2D Point2D y coordinate of a corner (upper left or lower right)
    of the rectangular sub-scene for which the LAI is given y
    coordinate of a corner (upper left or lower right) of the
    rectangular sub-scene for which the LAI is given x coordinate of
    a corner (upper left or lower right) of the rectangular sub-
    scene for which the LAI is given x coordinate of a corner (upper
    left or lower right) of the rectangular sub-scene for which the
    LAI is given"""
    member_data_items_ = [
        MemberSpec_('y', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('x', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, y=1.00, x=1.00):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_Point2D')
        self.attrib = ['y', 'x']
        self.children = []
        self.parent = None
        self._y = _cast(float, y)
        self._x = _cast(float, x)
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Point2D)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Point2D.subclass:
            return create_Point2D.subclass(*args_, **kwargs_)
        else:
            return create_Point2D(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_y(self): return self._y
    def set_y(self, value):
        self._y = value
        update_node(self,self.troot,'trees')
    y = property(get_y, set_y)
    def get_x(self): return self._x
    def set_x(self, value):
        self._x = value
        update_node(self,self.troot,'trees')
    x = property(get_x, set_x)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Point2D', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Point2D')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Point2D')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Point2D', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Point2D'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y="%s"' % self.gds_format_double(self.y, input_name='y'))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name='x'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Point2D', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_Point2D', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.y is not None:
            element.set('y', self.gds_format_double(self.y))
        if self.x is not None:
            element.set('x', self.gds_format_double(self.x))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Point2D'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            showIndent(outfile, level)
            outfile.write('y=%e,\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            showIndent(outfile, level)
            outfile.write('x=%e,\n' % (self.x,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            try:
                self.y = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (y): %s' % exp)
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            try:
                self.x = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_Point2D


class create_Specie(GeneratedsSuper):
    """Specie Specie Simulation of trees with branches and twigs Simulation
    of trees with branches and twigs LAI LAI"""
    member_data_items_ = [
        MemberSpec_('branchesAndTwigsSimulation', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('lai', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('OpticalPropertyLink', '_OpticalPropertyLink', 0, 0, {'name': 'OpticalPropertyLink', 'type': '_OpticalPropertyLink', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('ThermalPropertyLink', '_ThermalPropertyLink', 0, 0, {'name': 'ThermalPropertyLink', 'type': '_ThermalPropertyLink', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('CrownLevel', '_CrownLevel', 1, 0, {'name': 'CrownLevel', 'type': '_CrownLevel', 'minOccurs': '1', 'maxOccurs': 'unbounded'}, None),
        MemberSpec_('BranchesAndTwigs', '_BranchesAndTwigs', 0, 0, {'name': 'BranchesAndTwigs', 'type': '_BranchesAndTwigs', 'minOccurs': '1', 'maxOccurs': '1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, branchesAndTwigsSimulation=0, lai=4.00, OpticalPropertyLink=None, ThermalPropertyLink=None, CrownLevel=None, BranchesAndTwigs=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_Specie')
        self.attrib = ['branchesAndTwigsSimulation', 'lai']
        self.children = ['OpticalPropertyLink', 'ThermalPropertyLink', 'CrownLevel', 'BranchesAndTwigs']
        self.parent = None
        self._branchesAndTwigsSimulation = _cast(int, branchesAndTwigsSimulation)
        self._lai = _cast(float, lai)
        self._OpticalPropertyLink = OpticalPropertyLink
        self._ThermalPropertyLink = ThermalPropertyLink
        if CrownLevel is None:
            self._CrownLevel = []
        else:
            self._CrownLevel = CrownLevel
        self._BranchesAndTwigs = BranchesAndTwigs
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Specie)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Specie.subclass:
            return create_Specie.subclass(*args_, **kwargs_)
        else:
            return create_Specie(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OpticalPropertyLink(self): return self._OpticalPropertyLink
    def set_OpticalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_OpticalPropertyLink)
            value.parent = self
        self._OpticalPropertyLink = value
    OpticalPropertyLink = property(get_OpticalPropertyLink, set_OpticalPropertyLink)
    def get_ThermalPropertyLink(self): return self._ThermalPropertyLink
    def set_ThermalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_ThermalPropertyLink)
            value.parent = self
        self._ThermalPropertyLink = value
    ThermalPropertyLink = property(get_ThermalPropertyLink, set_ThermalPropertyLink)
    def get_CrownLevel(self): return self._CrownLevel
    def set_CrownLevel(self, value):
        if value is not None:
            checkclass(value, create_CrownLevel)
            for v in value:
                v.parent = self
        self._CrownLevel = value
    def add_CrownLevel(self, value):
        value.parent = self
        self._CrownLevel.append(value)
    def insert_CrownLevel_at(self, index, value):
        value.parent = self
        self.CrownLevel.insert(index, value)
    def replace_CrownLevel_at(self, index, value):
        value.parent = self
        self.CrownLevel[index] = value
    CrownLevel = property(get_CrownLevel, set_CrownLevel)
    def get_BranchesAndTwigs(self): return self._BranchesAndTwigs
    def set_BranchesAndTwigs(self, value):
        if value is not None:
            checkclass(value, create_BranchesAndTwigs)
            value.parent = self
        self._BranchesAndTwigs = value
    BranchesAndTwigs = property(get_BranchesAndTwigs, set_BranchesAndTwigs)
    def get_branchesAndTwigsSimulation(self): return self._branchesAndTwigsSimulation
    def set_branchesAndTwigsSimulation(self, value):
        self._branchesAndTwigsSimulation = value
        update_node(self,self.troot,'trees')
    branchesAndTwigsSimulation = property(get_branchesAndTwigsSimulation, set_branchesAndTwigsSimulation)
    def get_lai(self): return self._lai
    def set_lai(self, value):
        self._lai = value
        update_node(self,self.troot,'trees')
    lai = property(get_lai, set_lai)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.OpticalPropertyLink is not None or
            self.ThermalPropertyLink is not None or
            self.CrownLevel or
            self.BranchesAndTwigs is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Specie', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Specie')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Specie')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Specie', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Specie'):
        if self.branchesAndTwigsSimulation is not None and 'branchesAndTwigsSimulation' not in already_processed:
            already_processed.add('branchesAndTwigsSimulation')
            outfile.write(' branchesAndTwigsSimulation="%s"' % self.gds_format_integer(self.branchesAndTwigsSimulation, input_name='branchesAndTwigsSimulation'))
        if self.lai is not None and 'lai' not in already_processed:
            already_processed.add('lai')
            outfile.write(' lai="%s"' % self.gds_format_double(self.lai, input_name='lai'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Specie', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OpticalPropertyLink is not None:
            self.OpticalPropertyLink.export(outfile, level, namespaceprefix_, name_='OpticalPropertyLink', pretty_print=pretty_print)
        if self.ThermalPropertyLink is not None:
            self.ThermalPropertyLink.export(outfile, level, namespaceprefix_, name_='ThermalPropertyLink', pretty_print=pretty_print)
        for CrownLevel_ in self.CrownLevel:
            CrownLevel_.export(outfile, level, namespaceprefix_, name_='CrownLevel', pretty_print=pretty_print)
        if self.BranchesAndTwigs is not None:
            self.BranchesAndTwigs.export(outfile, level, namespaceprefix_, name_='BranchesAndTwigs', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Specie', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.branchesAndTwigsSimulation is not None:
            element.set('branchesAndTwigsSimulation', self.gds_format_integer(self.branchesAndTwigsSimulation))
        if self.lai is not None:
            element.set('lai', self.gds_format_double(self.lai))
        if self.OpticalPropertyLink is not None:
            OpticalPropertyLink_ = self.OpticalPropertyLink
            OpticalPropertyLink_.to_etree(element, name_='OpticalPropertyLink', mapping_=mapping_)
        if self.ThermalPropertyLink is not None:
            ThermalPropertyLink_ = self.ThermalPropertyLink
            ThermalPropertyLink_.to_etree(element, name_='ThermalPropertyLink', mapping_=mapping_)
        for CrownLevel_ in self.CrownLevel:
            CrownLevel_.to_etree(element, name_='CrownLevel', mapping_=mapping_)
        if self.BranchesAndTwigs is not None:
            BranchesAndTwigs_ = self.BranchesAndTwigs
            BranchesAndTwigs_.to_etree(element, name_='BranchesAndTwigs', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Specie'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.branchesAndTwigsSimulation is not None and 'branchesAndTwigsSimulation' not in already_processed:
            already_processed.add('branchesAndTwigsSimulation')
            showIndent(outfile, level)
            outfile.write('branchesAndTwigsSimulation=%d,\n' % (self.branchesAndTwigsSimulation,))
        if self.lai is not None and 'lai' not in already_processed:
            already_processed.add('lai')
            showIndent(outfile, level)
            outfile.write('lai=%e,\n' % (self.lai,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.OpticalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('OpticalPropertyLink=model_._OpticalPropertyLink(\n')
            self.OpticalPropertyLink.exportLiteral(outfile, level, name_='OpticalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ThermalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('ThermalPropertyLink=model_._ThermalPropertyLink(\n')
            self.ThermalPropertyLink.exportLiteral(outfile, level, name_='ThermalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('CrownLevel=[\n')
        level += 1
        for CrownLevel_ in self.CrownLevel:
            showIndent(outfile, level)
            outfile.write('model_._CrownLevel(\n')
            CrownLevel_.exportLiteral(outfile, level, name_='_CrownLevel')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.BranchesAndTwigs is not None:
            showIndent(outfile, level)
            outfile.write('BranchesAndTwigs=model_._BranchesAndTwigs(\n')
            self.BranchesAndTwigs.exportLiteral(outfile, level, name_='BranchesAndTwigs')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.CrownLevel = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('branchesAndTwigsSimulation', node)
        if value is not None and 'branchesAndTwigsSimulation' not in already_processed:
            already_processed.add('branchesAndTwigsSimulation')
            try:
                self.branchesAndTwigsSimulation = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('lai', node)
        if value is not None and 'lai' not in already_processed:
            already_processed.add('lai')
            try:
                self.lai = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (lai): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OpticalPropertyLink':
            obj_ = create_OpticalPropertyLink.factory()
            obj_.build(child_)
            self.set_OpticalPropertyLink(obj_)
            obj_.original_tagname_ = 'OpticalPropertyLink'
        elif nodeName_ == 'ThermalPropertyLink':
            obj_ = create_ThermalPropertyLink.factory()
            obj_.build(child_)
            self.set_ThermalPropertyLink(obj_)
            obj_.original_tagname_ = 'ThermalPropertyLink'
        elif nodeName_ == 'CrownLevel':
            obj_ = create_CrownLevel.factory()
            obj_.build(child_)
            self.add_CrownLevel(obj_)
            obj_.original_tagname_ = 'CrownLevel'
        elif nodeName_ == 'BranchesAndTwigs':
            obj_ = create_BranchesAndTwigs.factory()
            obj_.build(child_)
            self.set_BranchesAndTwigs(obj_)
            obj_.original_tagname_ = 'BranchesAndTwigs'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_Specie


class create_OpticalPropertyLink(GeneratedsSuper):
    """OpticalPropertyLink OpticalPropertyLink Index of the DART phase
    function of the ground of the plot. Index of the DART phase
    function of the ground of the plot. proportion of photons
    intercepted along an incident direction that are scattered
    within a solid angle along a given direction proportion of
    photons intercepted along an incident direction that are
    scattered within a solid angle along a given direction Type of
    phase function (lambertian, etc.) Type of phase function
    (lambertian, etc.)"""
    member_data_items_ = [
        MemberSpec_('indexFctPhase', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('ident', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('type_', 'xsd:int', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, indexFctPhase=0, ident='f0', type_=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_OpticalPropertyLink')
        self.attrib = ['indexFctPhase', 'ident', 'type_']
        self.children = []
        self.parent = None
        self._indexFctPhase = _cast(int, indexFctPhase)
        self._ident = _cast(None, ident)
        self._type_ = _cast(int, type_)
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_OpticalPropertyLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_OpticalPropertyLink.subclass:
            return create_OpticalPropertyLink.subclass(*args_, **kwargs_)
        else:
            return create_OpticalPropertyLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexFctPhase(self): return self._indexFctPhase
    def set_indexFctPhase(self, value):
        self._indexFctPhase = value
        update_node(self,self.troot,'trees')
    indexFctPhase = property(get_indexFctPhase, set_indexFctPhase)
    def get_ident(self): return self._ident
    def set_ident(self, value):
        self._ident = value
        update_node(self,self.troot,'trees')
    ident = property(get_ident, set_ident)
    def get_type(self): return self._type_
    def set_type(self, value):
        self._type_ = value
        update_node(self,self.troot,'trees')
    type_ = property(get_type, set_type)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_OpticalPropertyLink', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_OpticalPropertyLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_OpticalPropertyLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_OpticalPropertyLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_OpticalPropertyLink'):
        if self.indexFctPhase is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            outfile.write(' indexFctPhase="%s"' % self.gds_format_integer(self.indexFctPhase, input_name='indexFctPhase'))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            outfile.write(' ident=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ident), input_name='ident')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type="%s"' % self.gds_format_integer(self.type_, input_name='type'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_OpticalPropertyLink', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_OpticalPropertyLink', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.indexFctPhase is not None:
            element.set('indexFctPhase', self.gds_format_integer(self.indexFctPhase))
        if self.ident is not None:
            element.set('ident', self.gds_format_string(self.ident))
        if self.type_ is not None:
            element.set('type', self.gds_format_integer(self.type_))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_OpticalPropertyLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.indexFctPhase is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            showIndent(outfile, level)
            outfile.write('indexFctPhase=%d,\n' % (self.indexFctPhase,))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            showIndent(outfile, level)
            outfile.write('ident="%s",\n' % (self.ident,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_=%d,\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('indexFctPhase', node)
        if value is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            try:
                self.indexFctPhase = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ident', node)
        if value is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            self.ident = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            try:
                self.type_ = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_OpticalPropertyLink


class create_ThermalPropertyLink(GeneratedsSuper):
    """ThermalPropertyLink ThermalPropertyLink indexTemperature
    indexTemperature Thermal Function ID Thermal Function ID"""
    member_data_items_ = [
        MemberSpec_('indexTemperature', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('idTemperature', 'xsd:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, indexTemperature=0, idTemperature='ThermalFunction290_310'):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_ThermalPropertyLink')
        self.attrib = ['indexTemperature', 'idTemperature']
        self.children = []
        self.parent = None
        self._indexTemperature = _cast(int, indexTemperature)
        self._idTemperature = _cast(None, idTemperature)
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ThermalPropertyLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ThermalPropertyLink.subclass:
            return create_ThermalPropertyLink.subclass(*args_, **kwargs_)
        else:
            return create_ThermalPropertyLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexTemperature(self): return self._indexTemperature
    def set_indexTemperature(self, value):
        self._indexTemperature = value
        update_node(self,self.troot,'trees')
    indexTemperature = property(get_indexTemperature, set_indexTemperature)
    def get_idTemperature(self): return self._idTemperature
    def set_idTemperature(self, value):
        self._idTemperature = value
        update_node(self,self.troot,'trees')
    idTemperature = property(get_idTemperature, set_idTemperature)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ThermalPropertyLink', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ThermalPropertyLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ThermalPropertyLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ThermalPropertyLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ThermalPropertyLink'):
        if self.indexTemperature is not None and 'indexTemperature' not in already_processed:
            already_processed.add('indexTemperature')
            outfile.write(' indexTemperature="%s"' % self.gds_format_integer(self.indexTemperature, input_name='indexTemperature'))
        if self.idTemperature is not None and 'idTemperature' not in already_processed:
            already_processed.add('idTemperature')
            outfile.write(' idTemperature=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idTemperature), input_name='idTemperature')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ThermalPropertyLink', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_ThermalPropertyLink', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.indexTemperature is not None:
            element.set('indexTemperature', self.gds_format_integer(self.indexTemperature))
        if self.idTemperature is not None:
            element.set('idTemperature', self.gds_format_string(self.idTemperature))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ThermalPropertyLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.indexTemperature is not None and 'indexTemperature' not in already_processed:
            already_processed.add('indexTemperature')
            showIndent(outfile, level)
            outfile.write('indexTemperature=%d,\n' % (self.indexTemperature,))
        if self.idTemperature is not None and 'idTemperature' not in already_processed:
            already_processed.add('idTemperature')
            showIndent(outfile, level)
            outfile.write('idTemperature="%s",\n' % (self.idTemperature,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('indexTemperature', node)
        if value is not None and 'indexTemperature' not in already_processed:
            already_processed.add('indexTemperature')
            try:
                self.indexTemperature = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('idTemperature', node)
        if value is not None and 'idTemperature' not in already_processed:
            already_processed.add('idTemperature')
            self.idTemperature = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_ThermalPropertyLink


class create_CrownLevel(GeneratedsSuper):
    """CrownLevel CrownLevel The profile of uf is defined by relative
    values. If vegetation biomass is defined by the lAI parameter,
    then correct uf values are obtained through the use of a
    normalizing coefficient directly computed by the Scene Builder
    module The profile of uf is defined by relative values. If
    vegetation biomass is defined by the lAI parameter, then correct
    uf values are obtained through the use of a normalizing
    coefficient directly computed by the Scene Builder module Adding
    leaves or holes can modify LAI calculation. This option force
    calculation to conserve the LAI. Adding leaves or holes can
    modify LAI calculation. This option force calculation to
    conserve the LAI. the crown is built only up to the height of
    the crown top) the crown is built only up to the height of the
    crown top) This option allows the user to define, in this tree
    crown level, the horizontal distribution of empty (hole) cells
    and leaf cells This option allows the user to define, in this
    tree crown level, the horizontal distribution of empty (hole)
    cells and leaf cells Trunk diameter in this tree crown level is
    equal to this factor multiplied by the specified below crown
    trunk diameter Trunk diameter in this tree crown level is equal
    to this factor multiplied by the specified below crown trunk
    diameter"""
    member_data_items_ = [
        MemberSpec_('verticalWeightForUf', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('laiConservation', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('relativeHeightVsCrownHeight', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('distribution', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('relativeTrunkDiameterWithinCrown', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('LeavesDistribution', '_LeavesDistribution', 0, 0, {'name': 'LeavesDistribution', 'type': '_LeavesDistribution', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('HolesDistribution', '_HolesDistribution', 0, 0, {'name': 'HolesDistribution', 'type': '_HolesDistribution', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('OpticalPropertyLink', '_OpticalPropertyLink', 0, 0, {'name': 'OpticalPropertyLink', 'type': '_OpticalPropertyLink', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('ThermalPropertyLink', '_ThermalPropertyLink', 0, 0, {'name': 'ThermalPropertyLink', 'type': '_ThermalPropertyLink', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('VegetationProperty', '_VegetationProperty', 0, 0, {'name': 'VegetationProperty', 'type': '_VegetationProperty', 'minOccurs': '1', 'maxOccurs': '1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, verticalWeightForUf=1.00, laiConservation=1, relativeHeightVsCrownHeight=1.00, distribution=0, relativeTrunkDiameterWithinCrown=0.50, LeavesDistribution=None, HolesDistribution=None, OpticalPropertyLink=None, ThermalPropertyLink=None, VegetationProperty=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_CrownLevel')
        self.attrib = ['verticalWeightForUf', 'laiConservation', 'relativeHeightVsCrownHeight', 'distribution', 'relativeTrunkDiameterWithinCrown']
        self.children = ['LeavesDistribution', 'HolesDistribution', 'OpticalPropertyLink', 'ThermalPropertyLink', 'VegetationProperty']
        self.parent = None
        self._verticalWeightForUf = _cast(float, verticalWeightForUf)
        self._laiConservation = _cast(int, laiConservation)
        self._relativeHeightVsCrownHeight = _cast(float, relativeHeightVsCrownHeight)
        self._distribution = _cast(int, distribution)
        self._relativeTrunkDiameterWithinCrown = _cast(float, relativeTrunkDiameterWithinCrown)
        self._LeavesDistribution = LeavesDistribution
        self._HolesDistribution = HolesDistribution
        self._OpticalPropertyLink = OpticalPropertyLink
        self._ThermalPropertyLink = ThermalPropertyLink
        self._VegetationProperty = VegetationProperty
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_CrownLevel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_CrownLevel.subclass:
            return create_CrownLevel.subclass(*args_, **kwargs_)
        else:
            return create_CrownLevel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LeavesDistribution(self): return self._LeavesDistribution
    def set_LeavesDistribution(self, value):
        if value is not None:
            checkclass(value, create_LeavesDistribution)
            value.parent = self
        self._LeavesDistribution = value
    LeavesDistribution = property(get_LeavesDistribution, set_LeavesDistribution)
    def get_HolesDistribution(self): return self._HolesDistribution
    def set_HolesDistribution(self, value):
        if value is not None:
            checkclass(value, create_HolesDistribution)
            value.parent = self
        self._HolesDistribution = value
    HolesDistribution = property(get_HolesDistribution, set_HolesDistribution)
    def get_OpticalPropertyLink(self): return self._OpticalPropertyLink
    def set_OpticalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_OpticalPropertyLink)
            value.parent = self
        self._OpticalPropertyLink = value
    OpticalPropertyLink = property(get_OpticalPropertyLink, set_OpticalPropertyLink)
    def get_ThermalPropertyLink(self): return self._ThermalPropertyLink
    def set_ThermalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_ThermalPropertyLink)
            value.parent = self
        self._ThermalPropertyLink = value
    ThermalPropertyLink = property(get_ThermalPropertyLink, set_ThermalPropertyLink)
    def get_VegetationProperty(self): return self._VegetationProperty
    def set_VegetationProperty(self, value):
        if value is not None:
            checkclass(value, create_VegetationProperty)
            value.parent = self
        self._VegetationProperty = value
    VegetationProperty = property(get_VegetationProperty, set_VegetationProperty)
    def get_verticalWeightForUf(self): return self._verticalWeightForUf
    def set_verticalWeightForUf(self, value):
        self._verticalWeightForUf = value
        update_node(self,self.troot,'trees')
    verticalWeightForUf = property(get_verticalWeightForUf, set_verticalWeightForUf)
    def get_laiConservation(self): return self._laiConservation
    def set_laiConservation(self, value):
        self._laiConservation = value
        update_node(self,self.troot,'trees')
    laiConservation = property(get_laiConservation, set_laiConservation)
    def get_relativeHeightVsCrownHeight(self): return self._relativeHeightVsCrownHeight
    def set_relativeHeightVsCrownHeight(self, value):
        self._relativeHeightVsCrownHeight = value
        update_node(self,self.troot,'trees')
    relativeHeightVsCrownHeight = property(get_relativeHeightVsCrownHeight, set_relativeHeightVsCrownHeight)
    def get_distribution(self): return self._distribution
    def set_distribution(self, value):
        self._distribution = value
        update_node(self,self.troot,'trees')
    distribution = property(get_distribution, set_distribution)
    def get_relativeTrunkDiameterWithinCrown(self): return self._relativeTrunkDiameterWithinCrown
    def set_relativeTrunkDiameterWithinCrown(self, value):
        self._relativeTrunkDiameterWithinCrown = value
        update_node(self,self.troot,'trees')
    relativeTrunkDiameterWithinCrown = property(get_relativeTrunkDiameterWithinCrown, set_relativeTrunkDiameterWithinCrown)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.LeavesDistribution is not None or
            self.HolesDistribution is not None or
            self.OpticalPropertyLink is not None or
            self.ThermalPropertyLink is not None or
            self.VegetationProperty is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_CrownLevel', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_CrownLevel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_CrownLevel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_CrownLevel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_CrownLevel'):
        if self.verticalWeightForUf is not None and 'verticalWeightForUf' not in already_processed:
            already_processed.add('verticalWeightForUf')
            outfile.write(' verticalWeightForUf="%s"' % self.gds_format_double(self.verticalWeightForUf, input_name='verticalWeightForUf'))
        if self.laiConservation is not None and 'laiConservation' not in already_processed:
            already_processed.add('laiConservation')
            outfile.write(' laiConservation="%s"' % self.gds_format_integer(self.laiConservation, input_name='laiConservation'))
        if self.relativeHeightVsCrownHeight is not None and 'relativeHeightVsCrownHeight' not in already_processed:
            already_processed.add('relativeHeightVsCrownHeight')
            outfile.write(' relativeHeightVsCrownHeight="%s"' % self.gds_format_double(self.relativeHeightVsCrownHeight, input_name='relativeHeightVsCrownHeight'))
        if self.distribution is not None and 'distribution' not in already_processed:
            already_processed.add('distribution')
            outfile.write(' distribution="%s"' % self.gds_format_integer(self.distribution, input_name='distribution'))
        if self.relativeTrunkDiameterWithinCrown is not None and 'relativeTrunkDiameterWithinCrown' not in already_processed:
            already_processed.add('relativeTrunkDiameterWithinCrown')
            outfile.write(' relativeTrunkDiameterWithinCrown="%s"' % self.gds_format_double(self.relativeTrunkDiameterWithinCrown, input_name='relativeTrunkDiameterWithinCrown'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_CrownLevel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LeavesDistribution is not None:
            self.LeavesDistribution.export(outfile, level, namespaceprefix_, name_='LeavesDistribution', pretty_print=pretty_print)
        if self.HolesDistribution is not None:
            self.HolesDistribution.export(outfile, level, namespaceprefix_, name_='HolesDistribution', pretty_print=pretty_print)
        if self.OpticalPropertyLink is not None:
            self.OpticalPropertyLink.export(outfile, level, namespaceprefix_, name_='OpticalPropertyLink', pretty_print=pretty_print)
        if self.ThermalPropertyLink is not None:
            self.ThermalPropertyLink.export(outfile, level, namespaceprefix_, name_='ThermalPropertyLink', pretty_print=pretty_print)
        if self.VegetationProperty is not None:
            self.VegetationProperty.export(outfile, level, namespaceprefix_, name_='VegetationProperty', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_CrownLevel', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.verticalWeightForUf is not None:
            element.set('verticalWeightForUf', self.gds_format_double(self.verticalWeightForUf))
        if self.laiConservation is not None:
            element.set('laiConservation', self.gds_format_integer(self.laiConservation))
        if self.relativeHeightVsCrownHeight is not None:
            element.set('relativeHeightVsCrownHeight', self.gds_format_double(self.relativeHeightVsCrownHeight))
        if self.distribution is not None:
            element.set('distribution', self.gds_format_integer(self.distribution))
        if self.relativeTrunkDiameterWithinCrown is not None:
            element.set('relativeTrunkDiameterWithinCrown', self.gds_format_double(self.relativeTrunkDiameterWithinCrown))
        if self.LeavesDistribution is not None:
            LeavesDistribution_ = self.LeavesDistribution
            LeavesDistribution_.to_etree(element, name_='LeavesDistribution', mapping_=mapping_)
        if self.HolesDistribution is not None:
            HolesDistribution_ = self.HolesDistribution
            HolesDistribution_.to_etree(element, name_='HolesDistribution', mapping_=mapping_)
        if self.OpticalPropertyLink is not None:
            OpticalPropertyLink_ = self.OpticalPropertyLink
            OpticalPropertyLink_.to_etree(element, name_='OpticalPropertyLink', mapping_=mapping_)
        if self.ThermalPropertyLink is not None:
            ThermalPropertyLink_ = self.ThermalPropertyLink
            ThermalPropertyLink_.to_etree(element, name_='ThermalPropertyLink', mapping_=mapping_)
        if self.VegetationProperty is not None:
            VegetationProperty_ = self.VegetationProperty
            VegetationProperty_.to_etree(element, name_='VegetationProperty', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_CrownLevel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.verticalWeightForUf is not None and 'verticalWeightForUf' not in already_processed:
            already_processed.add('verticalWeightForUf')
            showIndent(outfile, level)
            outfile.write('verticalWeightForUf=%e,\n' % (self.verticalWeightForUf,))
        if self.laiConservation is not None and 'laiConservation' not in already_processed:
            already_processed.add('laiConservation')
            showIndent(outfile, level)
            outfile.write('laiConservation=%d,\n' % (self.laiConservation,))
        if self.relativeHeightVsCrownHeight is not None and 'relativeHeightVsCrownHeight' not in already_processed:
            already_processed.add('relativeHeightVsCrownHeight')
            showIndent(outfile, level)
            outfile.write('relativeHeightVsCrownHeight=%e,\n' % (self.relativeHeightVsCrownHeight,))
        if self.distribution is not None and 'distribution' not in already_processed:
            already_processed.add('distribution')
            showIndent(outfile, level)
            outfile.write('distribution=%d,\n' % (self.distribution,))
        if self.relativeTrunkDiameterWithinCrown is not None and 'relativeTrunkDiameterWithinCrown' not in already_processed:
            already_processed.add('relativeTrunkDiameterWithinCrown')
            showIndent(outfile, level)
            outfile.write('relativeTrunkDiameterWithinCrown=%e,\n' % (self.relativeTrunkDiameterWithinCrown,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LeavesDistribution is not None:
            showIndent(outfile, level)
            outfile.write('LeavesDistribution=model_._LeavesDistribution(\n')
            self.LeavesDistribution.exportLiteral(outfile, level, name_='LeavesDistribution')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HolesDistribution is not None:
            showIndent(outfile, level)
            outfile.write('HolesDistribution=model_._HolesDistribution(\n')
            self.HolesDistribution.exportLiteral(outfile, level, name_='HolesDistribution')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OpticalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('OpticalPropertyLink=model_._OpticalPropertyLink(\n')
            self.OpticalPropertyLink.exportLiteral(outfile, level, name_='OpticalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ThermalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('ThermalPropertyLink=model_._ThermalPropertyLink(\n')
            self.ThermalPropertyLink.exportLiteral(outfile, level, name_='ThermalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VegetationProperty is not None:
            showIndent(outfile, level)
            outfile.write('VegetationProperty=model_._VegetationProperty(\n')
            self.VegetationProperty.exportLiteral(outfile, level, name_='VegetationProperty')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('verticalWeightForUf', node)
        if value is not None and 'verticalWeightForUf' not in already_processed:
            already_processed.add('verticalWeightForUf')
            try:
                self.verticalWeightForUf = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (verticalWeightForUf): %s' % exp)
        value = find_attr_value_('laiConservation', node)
        if value is not None and 'laiConservation' not in already_processed:
            already_processed.add('laiConservation')
            try:
                self.laiConservation = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('relativeHeightVsCrownHeight', node)
        if value is not None and 'relativeHeightVsCrownHeight' not in already_processed:
            already_processed.add('relativeHeightVsCrownHeight')
            try:
                self.relativeHeightVsCrownHeight = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (relativeHeightVsCrownHeight): %s' % exp)
        value = find_attr_value_('distribution', node)
        if value is not None and 'distribution' not in already_processed:
            already_processed.add('distribution')
            try:
                self.distribution = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('relativeTrunkDiameterWithinCrown', node)
        if value is not None and 'relativeTrunkDiameterWithinCrown' not in already_processed:
            already_processed.add('relativeTrunkDiameterWithinCrown')
            try:
                self.relativeTrunkDiameterWithinCrown = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (relativeTrunkDiameterWithinCrown): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LeavesDistribution':
            obj_ = create_LeavesDistribution.factory()
            obj_.build(child_)
            self.set_LeavesDistribution(obj_)
            obj_.original_tagname_ = 'LeavesDistribution'
        elif nodeName_ == 'HolesDistribution':
            obj_ = create_HolesDistribution.factory()
            obj_.build(child_)
            self.set_HolesDistribution(obj_)
            obj_.original_tagname_ = 'HolesDistribution'
        elif nodeName_ == 'OpticalPropertyLink':
            obj_ = create_OpticalPropertyLink.factory()
            obj_.build(child_)
            self.set_OpticalPropertyLink(obj_)
            obj_.original_tagname_ = 'OpticalPropertyLink'
        elif nodeName_ == 'ThermalPropertyLink':
            obj_ = create_ThermalPropertyLink.factory()
            obj_.build(child_)
            self.set_ThermalPropertyLink(obj_)
            obj_.original_tagname_ = 'ThermalPropertyLink'
        elif nodeName_ == 'VegetationProperty':
            obj_ = create_VegetationProperty.factory()
            obj_.build(child_)
            self.set_VegetationProperty(obj_)
            obj_.original_tagname_ = 'VegetationProperty'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_CrownLevel


class create_LeavesDistribution(GeneratedsSuper):
    """LeavesDistribution LeavesDistribution No leaf cells for cells at a
    distance smaller than "Alpha x local tree crown radius" No leaf
    cells for cells at a distance smaller than "Alpha x local tree
    crown radius" Maximal leaf density between "Beta x local tree
    crown radius" and "Gamma x local tree crown radius" Maximal leaf
    density between "Beta x local tree crown radius" and "Gamma x
    local tree crown radius" No leaf cells for cells at a distance
    from tree crown axis larger than "Kappa x local tree crown
    radius" No leaf cells for cells at a distance from tree crown
    axis larger than "Kappa x local tree crown radius" gamma gamma"""
    member_data_items_ = [
        MemberSpec_('alpha', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('beta', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('kappa', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('gamma', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, alpha=0.10, beta=0.30, kappa=1.00, gamma=0.80):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_LeavesDistribution')
        self.attrib = ['alpha', 'beta', 'kappa', 'gamma']
        self.children = []
        self.parent = None
        self._alpha = _cast(float, alpha)
        self._beta = _cast(float, beta)
        self._kappa = _cast(float, kappa)
        self._gamma = _cast(float, gamma)
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_LeavesDistribution)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_LeavesDistribution.subclass:
            return create_LeavesDistribution.subclass(*args_, **kwargs_)
        else:
            return create_LeavesDistribution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_alpha(self): return self._alpha
    def set_alpha(self, value):
        self._alpha = value
        update_node(self,self.troot,'trees')
    alpha = property(get_alpha, set_alpha)
    def get_beta(self): return self._beta
    def set_beta(self, value):
        self._beta = value
        update_node(self,self.troot,'trees')
    beta = property(get_beta, set_beta)
    def get_kappa(self): return self._kappa
    def set_kappa(self, value):
        self._kappa = value
        update_node(self,self.troot,'trees')
    kappa = property(get_kappa, set_kappa)
    def get_gamma(self): return self._gamma
    def set_gamma(self, value):
        self._gamma = value
        update_node(self,self.troot,'trees')
    gamma = property(get_gamma, set_gamma)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_LeavesDistribution', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_LeavesDistribution')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_LeavesDistribution')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_LeavesDistribution', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_LeavesDistribution'):
        if self.alpha is not None and 'alpha' not in already_processed:
            already_processed.add('alpha')
            outfile.write(' alpha="%s"' % self.gds_format_double(self.alpha, input_name='alpha'))
        if self.beta is not None and 'beta' not in already_processed:
            already_processed.add('beta')
            outfile.write(' beta="%s"' % self.gds_format_double(self.beta, input_name='beta'))
        if self.kappa is not None and 'kappa' not in already_processed:
            already_processed.add('kappa')
            outfile.write(' kappa="%s"' % self.gds_format_double(self.kappa, input_name='kappa'))
        if self.gamma is not None and 'gamma' not in already_processed:
            already_processed.add('gamma')
            outfile.write(' gamma="%s"' % self.gds_format_double(self.gamma, input_name='gamma'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_LeavesDistribution', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_LeavesDistribution', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.alpha is not None:
            element.set('alpha', self.gds_format_double(self.alpha))
        if self.beta is not None:
            element.set('beta', self.gds_format_double(self.beta))
        if self.kappa is not None:
            element.set('kappa', self.gds_format_double(self.kappa))
        if self.gamma is not None:
            element.set('gamma', self.gds_format_double(self.gamma))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_LeavesDistribution'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.alpha is not None and 'alpha' not in already_processed:
            already_processed.add('alpha')
            showIndent(outfile, level)
            outfile.write('alpha=%e,\n' % (self.alpha,))
        if self.beta is not None and 'beta' not in already_processed:
            already_processed.add('beta')
            showIndent(outfile, level)
            outfile.write('beta=%e,\n' % (self.beta,))
        if self.kappa is not None and 'kappa' not in already_processed:
            already_processed.add('kappa')
            showIndent(outfile, level)
            outfile.write('kappa=%e,\n' % (self.kappa,))
        if self.gamma is not None and 'gamma' not in already_processed:
            already_processed.add('gamma')
            showIndent(outfile, level)
            outfile.write('gamma=%e,\n' % (self.gamma,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('alpha', node)
        if value is not None and 'alpha' not in already_processed:
            already_processed.add('alpha')
            try:
                self.alpha = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (alpha): %s' % exp)
        value = find_attr_value_('beta', node)
        if value is not None and 'beta' not in already_processed:
            already_processed.add('beta')
            try:
                self.beta = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (beta): %s' % exp)
        value = find_attr_value_('kappa', node)
        if value is not None and 'kappa' not in already_processed:
            already_processed.add('kappa')
            try:
                self.kappa = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (kappa): %s' % exp)
        value = find_attr_value_('gamma', node)
        if value is not None and 'gamma' not in already_processed:
            already_processed.add('gamma')
            try:
                self.gamma = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (gamma): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_LeavesDistribution


class create_HolesDistribution(GeneratedsSuper):
    """ HolesDistribution HolesDistribution All cells are empty at a
    distance less than "a x local tree crown radius" All cells are
    empty at a distance less than "a x local tree crown radius"
    Proportion [0 1] of non empty cellls between the specified
    thresholds a and b Proportion [0 1] of non empty cellls between
    the specified thresholds a and b All cells are empty at a
    distance larger than "b x local tree crown radius" All cells are
    empty at a distance larger than "b x local tree crown radius" """
    member_data_items_ = [
        MemberSpec_('a', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('percentageOfFullCells', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('b', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, a=0.00, percentageOfFullCells=0.70, b=1.00):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_HolesDistribution')
        self.attrib = ['a', 'percentageOfFullCells', 'b']
        self.children = []
        self.parent = None
        self._a = _cast(float, a)
        self._percentageOfFullCells = _cast(float, percentageOfFullCells)
        self._b = _cast(float, b)
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_HolesDistribution)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_HolesDistribution.subclass:
            return create_HolesDistribution.subclass(*args_, **kwargs_)
        else:
            return create_HolesDistribution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_a(self): return self._a
    def set_a(self, value):
        self._a = value
        update_node(self,self.troot,'trees')
    a = property(get_a, set_a)
    def get_percentageOfFullCells(self): return self._percentageOfFullCells
    def set_percentageOfFullCells(self, value):
        self._percentageOfFullCells = value
        update_node(self,self.troot,'trees')
    percentageOfFullCells = property(get_percentageOfFullCells, set_percentageOfFullCells)
    def get_b(self): return self._b
    def set_b(self, value):
        self._b = value
        update_node(self,self.troot,'trees')
    b = property(get_b, set_b)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_HolesDistribution', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_HolesDistribution')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_HolesDistribution')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_HolesDistribution', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_HolesDistribution'):
        if self.a is not None and 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a="%s"' % self.gds_format_double(self.a, input_name='a'))
        if self.percentageOfFullCells is not None and 'percentageOfFullCells' not in already_processed:
            already_processed.add('percentageOfFullCells')
            outfile.write(' percentageOfFullCells="%s"' % self.gds_format_double(self.percentageOfFullCells, input_name='percentageOfFullCells'))
        if self.b is not None and 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b="%s"' % self.gds_format_double(self.b, input_name='b'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_HolesDistribution', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_HolesDistribution', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.a is not None:
            element.set('a', self.gds_format_double(self.a))
        if self.percentageOfFullCells is not None:
            element.set('percentageOfFullCells', self.gds_format_double(self.percentageOfFullCells))
        if self.b is not None:
            element.set('b', self.gds_format_double(self.b))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_HolesDistribution'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.a is not None and 'a' not in already_processed:
            already_processed.add('a')
            showIndent(outfile, level)
            outfile.write('a=%e,\n' % (self.a,))
        if self.percentageOfFullCells is not None and 'percentageOfFullCells' not in already_processed:
            already_processed.add('percentageOfFullCells')
            showIndent(outfile, level)
            outfile.write('percentageOfFullCells=%e,\n' % (self.percentageOfFullCells,))
        if self.b is not None and 'b' not in already_processed:
            already_processed.add('b')
            showIndent(outfile, level)
            outfile.write('b=%e,\n' % (self.b,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            try:
                self.a = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (a): %s' % exp)
        value = find_attr_value_('percentageOfFullCells', node)
        if value is not None and 'percentageOfFullCells' not in already_processed:
            already_processed.add('percentageOfFullCells')
            try:
                self.percentageOfFullCells = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (percentageOfFullCells): %s' % exp)
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            try:
                self.b = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (b): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_HolesDistribution


class create_VegetationProperty(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('VegetationOpticalPropertyLink', '_VegetationOpticalPropertyLink', 0, 0, {'name': 'VegetationOpticalPropertyLink', 'type': '_VegetationOpticalPropertyLink', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('ThermalPropertyLink', '_ThermalPropertyLink', 0, 0, {'name': 'ThermalPropertyLink', 'type': '_ThermalPropertyLink', 'minOccurs': '1', 'maxOccurs': '1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, VegetationOpticalPropertyLink=None, ThermalPropertyLink=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_VegetationProperty')
        self.attrib = ['']
        self.children = ['VegetationOpticalPropertyLink', 'ThermalPropertyLink']
        self.parent = None
        self._VegetationOpticalPropertyLink = VegetationOpticalPropertyLink
        self._ThermalPropertyLink = ThermalPropertyLink
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_VegetationProperty)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_VegetationProperty.subclass:
            return create_VegetationProperty.subclass(*args_, **kwargs_)
        else:
            return create_VegetationProperty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VegetationOpticalPropertyLink(self): return self._VegetationOpticalPropertyLink
    def set_VegetationOpticalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_VegetationOpticalPropertyLink)
            value.parent = self
        self._VegetationOpticalPropertyLink = value
    VegetationOpticalPropertyLink = property(get_VegetationOpticalPropertyLink, set_VegetationOpticalPropertyLink)
    def get_ThermalPropertyLink(self): return self._ThermalPropertyLink
    def set_ThermalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_ThermalPropertyLink)
            value.parent = self
        self._ThermalPropertyLink = value
    ThermalPropertyLink = property(get_ThermalPropertyLink, set_ThermalPropertyLink)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.VegetationOpticalPropertyLink is not None or
            self.ThermalPropertyLink is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_VegetationProperty', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_VegetationProperty')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_VegetationProperty')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_VegetationProperty', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_VegetationProperty'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_VegetationProperty', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VegetationOpticalPropertyLink is not None:
            self.VegetationOpticalPropertyLink.export(outfile, level, namespaceprefix_, name_='VegetationOpticalPropertyLink', pretty_print=pretty_print)
        if self.ThermalPropertyLink is not None:
            self.ThermalPropertyLink.export(outfile, level, namespaceprefix_, name_='ThermalPropertyLink', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_VegetationProperty', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.VegetationOpticalPropertyLink is not None:
            VegetationOpticalPropertyLink_ = self.VegetationOpticalPropertyLink
            VegetationOpticalPropertyLink_.to_etree(element, name_='VegetationOpticalPropertyLink', mapping_=mapping_)
        if self.ThermalPropertyLink is not None:
            ThermalPropertyLink_ = self.ThermalPropertyLink
            ThermalPropertyLink_.to_etree(element, name_='ThermalPropertyLink', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_VegetationProperty'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.VegetationOpticalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('VegetationOpticalPropertyLink=model_._VegetationOpticalPropertyLink(\n')
            self.VegetationOpticalPropertyLink.exportLiteral(outfile, level, name_='VegetationOpticalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ThermalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('ThermalPropertyLink=model_._ThermalPropertyLink(\n')
            self.ThermalPropertyLink.exportLiteral(outfile, level, name_='ThermalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VegetationOpticalPropertyLink':
            obj_ = create_VegetationOpticalPropertyLink.factory()
            obj_.build(child_)
            self.set_VegetationOpticalPropertyLink(obj_)
            obj_.original_tagname_ = 'VegetationOpticalPropertyLink'
        elif nodeName_ == 'ThermalPropertyLink':
            obj_ = create_ThermalPropertyLink.factory()
            obj_.build(child_)
            self.set_ThermalPropertyLink(obj_)
            obj_.original_tagname_ = 'ThermalPropertyLink'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_VegetationProperty


class create_VegetationOpticalPropertyLink(GeneratedsSuper):
    """Optical properties for a DART vegetation phase function (name, type
    and index). Optical properties for a DART vegetation phase
    function (name, type and index). Index of the DART phase
    function of the ground of the plot. Index of the DART phase
    function of the ground of the plot. proportion of photons
    intercepted along an incident direction that are scattered
    within a solid angle along a given direction proportion of
    photons intercepted along an incident direction that are
    scattered within a solid angle along a given direction"""
    member_data_items_ = [
        MemberSpec_('indexFctPhase', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('ident', 'xsd:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, indexFctPhase=0, ident='f0'):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_VegetationOpticalPropertyLink')
        self.attrib = ['indexFctPhase', 'ident']
        self.children = []
        self.parent = None
        self._indexFctPhase = _cast(int, indexFctPhase)
        self._ident = _cast(None, ident)
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_VegetationOpticalPropertyLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_VegetationOpticalPropertyLink.subclass:
            return create_VegetationOpticalPropertyLink.subclass(*args_, **kwargs_)
        else:
            return create_VegetationOpticalPropertyLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexFctPhase(self): return self._indexFctPhase
    def set_indexFctPhase(self, value):
        self._indexFctPhase = value
        update_node(self,self.troot,'trees')
    indexFctPhase = property(get_indexFctPhase, set_indexFctPhase)
    def get_ident(self): return self._ident
    def set_ident(self, value):
        self._ident = value
        update_node(self,self.troot,'trees')
    ident = property(get_ident, set_ident)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_VegetationOpticalPropertyLink', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_VegetationOpticalPropertyLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_VegetationOpticalPropertyLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_VegetationOpticalPropertyLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_VegetationOpticalPropertyLink'):
        if self.indexFctPhase is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            outfile.write(' indexFctPhase="%s"' % self.gds_format_integer(self.indexFctPhase, input_name='indexFctPhase'))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            outfile.write(' ident=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ident), input_name='ident')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_VegetationOpticalPropertyLink', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_VegetationOpticalPropertyLink', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.indexFctPhase is not None:
            element.set('indexFctPhase', self.gds_format_integer(self.indexFctPhase))
        if self.ident is not None:
            element.set('ident', self.gds_format_string(self.ident))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_VegetationOpticalPropertyLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.indexFctPhase is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            showIndent(outfile, level)
            outfile.write('indexFctPhase=%d,\n' % (self.indexFctPhase,))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            showIndent(outfile, level)
            outfile.write('ident="%s",\n' % (self.ident,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('indexFctPhase', node)
        if value is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            try:
                self.indexFctPhase = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ident', node)
        if value is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            self.ident = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_VegetationOpticalPropertyLink


class create_BranchesAndTwigs(GeneratedsSuper):
    """BranchesAndTwigs BranchesAndTwigs Possibility that cells contain
    branches in addition to leaves and twigs Possibility that cells
    contain branches in addition to leaves and twigs Twig Area Index
    (same as LAI, but applied to twigs instead of leaves) Twig Area
    Index (same as LAI, but applied to twigs instead of leaves) Name
    of the file that stores the geometry of the branches Name of the
    file that stores the geometry of the branches"""
    member_data_items_ = [
        MemberSpec_('possibleBranchTwigMixing', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('twigAreaIndex', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('geometryFileName', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('OpticalPropertyLink', '_OpticalPropertyLink', 0, 0, {'name': 'OpticalPropertyLink', 'type': '_OpticalPropertyLink', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('ThermalPropertyLink', '_ThermalPropertyLink', 0, 0, {'name': 'ThermalPropertyLink', 'type': '_ThermalPropertyLink', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('VegetationOpticalPropertyLink', '_VegetationOpticalPropertyLink', 0, 0, {'name': 'VegetationOpticalPropertyLink', 'type': '_VegetationOpticalPropertyLink', 'minOccurs': '1', 'maxOccurs': '1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, possibleBranchTwigMixing=0, twigAreaIndex=1, geometryFileName='branch.txt', OpticalPropertyLink=None, ThermalPropertyLink=None, VegetationOpticalPropertyLink=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_BranchesAndTwigs')
        self.attrib = ['possibleBranchTwigMixing', 'twigAreaIndex', 'geometryFileName']
        self.children = ['OpticalPropertyLink', 'ThermalPropertyLink', 'VegetationOpticalPropertyLink']
        self.parent = None
        self._possibleBranchTwigMixing = _cast(int, possibleBranchTwigMixing)
        self._twigAreaIndex = _cast(float, twigAreaIndex)
        self._geometryFileName = _cast(None, geometryFileName)
        self._OpticalPropertyLink = OpticalPropertyLink
        self._ThermalPropertyLink = ThermalPropertyLink
        self._VegetationOpticalPropertyLink = VegetationOpticalPropertyLink
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_BranchesAndTwigs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_BranchesAndTwigs.subclass:
            return create_BranchesAndTwigs.subclass(*args_, **kwargs_)
        else:
            return create_BranchesAndTwigs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OpticalPropertyLink(self): return self._OpticalPropertyLink
    def set_OpticalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_OpticalPropertyLink)
            value.parent = self
        self._OpticalPropertyLink = value
    OpticalPropertyLink = property(get_OpticalPropertyLink, set_OpticalPropertyLink)
    def get_ThermalPropertyLink(self): return self._ThermalPropertyLink
    def set_ThermalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_ThermalPropertyLink)
            value.parent = self
        self._ThermalPropertyLink = value
    ThermalPropertyLink = property(get_ThermalPropertyLink, set_ThermalPropertyLink)
    def get_VegetationOpticalPropertyLink(self): return self._VegetationOpticalPropertyLink
    def set_VegetationOpticalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_VegetationOpticalPropertyLink)
            value.parent = self
        self._VegetationOpticalPropertyLink = value
    VegetationOpticalPropertyLink = property(get_VegetationOpticalPropertyLink, set_VegetationOpticalPropertyLink)
    def get_possibleBranchTwigMixing(self): return self._possibleBranchTwigMixing
    def set_possibleBranchTwigMixing(self, value):
        self._possibleBranchTwigMixing = value
        update_node(self,self.troot,'trees')
    possibleBranchTwigMixing = property(get_possibleBranchTwigMixing, set_possibleBranchTwigMixing)
    def get_twigAreaIndex(self): return self._twigAreaIndex
    def set_twigAreaIndex(self, value):
        self._twigAreaIndex = value
        update_node(self,self.troot,'trees')
    twigAreaIndex = property(get_twigAreaIndex, set_twigAreaIndex)
    def get_geometryFileName(self): return self._geometryFileName
    def set_geometryFileName(self, value):
        self._geometryFileName = value
        update_node(self,self.troot,'trees')
    geometryFileName = property(get_geometryFileName, set_geometryFileName)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.OpticalPropertyLink is not None or
            self.ThermalPropertyLink is not None or
            self.VegetationOpticalPropertyLink is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_BranchesAndTwigs', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_BranchesAndTwigs')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_BranchesAndTwigs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_BranchesAndTwigs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_BranchesAndTwigs'):
        if self.possibleBranchTwigMixing is not None and 'possibleBranchTwigMixing' not in already_processed:
            already_processed.add('possibleBranchTwigMixing')
            outfile.write(' possibleBranchTwigMixing="%s"' % self.gds_format_integer(self.possibleBranchTwigMixing, input_name='possibleBranchTwigMixing'))
        if self.twigAreaIndex is not None and 'twigAreaIndex' not in already_processed:
            already_processed.add('twigAreaIndex')
            outfile.write(' twigAreaIndex="%s"' % self.gds_format_double(self.twigAreaIndex, input_name='twigAreaIndex'))
        if self.geometryFileName is not None and 'geometryFileName' not in already_processed:
            already_processed.add('geometryFileName')
            outfile.write(' geometryFileName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.geometryFileName), input_name='geometryFileName')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_BranchesAndTwigs', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OpticalPropertyLink is not None:
            self.OpticalPropertyLink.export(outfile, level, namespaceprefix_, name_='OpticalPropertyLink', pretty_print=pretty_print)
        if self.ThermalPropertyLink is not None:
            self.ThermalPropertyLink.export(outfile, level, namespaceprefix_, name_='ThermalPropertyLink', pretty_print=pretty_print)
        if self.VegetationOpticalPropertyLink is not None:
            self.VegetationOpticalPropertyLink.export(outfile, level, namespaceprefix_, name_='VegetationOpticalPropertyLink', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_BranchesAndTwigs', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.possibleBranchTwigMixing is not None:
            element.set('possibleBranchTwigMixing', self.gds_format_integer(self.possibleBranchTwigMixing))
        if self.twigAreaIndex is not None:
            element.set('twigAreaIndex', self.gds_format_double(self.twigAreaIndex))
        if self.geometryFileName is not None:
            element.set('geometryFileName', self.gds_format_string(self.geometryFileName))
        if self.OpticalPropertyLink is not None:
            OpticalPropertyLink_ = self.OpticalPropertyLink
            OpticalPropertyLink_.to_etree(element, name_='OpticalPropertyLink', mapping_=mapping_)
        if self.ThermalPropertyLink is not None:
            ThermalPropertyLink_ = self.ThermalPropertyLink
            ThermalPropertyLink_.to_etree(element, name_='ThermalPropertyLink', mapping_=mapping_)
        if self.VegetationOpticalPropertyLink is not None:
            VegetationOpticalPropertyLink_ = self.VegetationOpticalPropertyLink
            VegetationOpticalPropertyLink_.to_etree(element, name_='VegetationOpticalPropertyLink', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_BranchesAndTwigs'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.possibleBranchTwigMixing is not None and 'possibleBranchTwigMixing' not in already_processed:
            already_processed.add('possibleBranchTwigMixing')
            showIndent(outfile, level)
            outfile.write('possibleBranchTwigMixing=%d,\n' % (self.possibleBranchTwigMixing,))
        if self.twigAreaIndex is not None and 'twigAreaIndex' not in already_processed:
            already_processed.add('twigAreaIndex')
            showIndent(outfile, level)
            outfile.write('twigAreaIndex=%e,\n' % (self.twigAreaIndex,))
        if self.geometryFileName is not None and 'geometryFileName' not in already_processed:
            already_processed.add('geometryFileName')
            showIndent(outfile, level)
            outfile.write('geometryFileName="%s",\n' % (self.geometryFileName,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.OpticalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('OpticalPropertyLink=model_._OpticalPropertyLink(\n')
            self.OpticalPropertyLink.exportLiteral(outfile, level, name_='OpticalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ThermalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('ThermalPropertyLink=model_._ThermalPropertyLink(\n')
            self.ThermalPropertyLink.exportLiteral(outfile, level, name_='ThermalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VegetationOpticalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('VegetationOpticalPropertyLink=model_._VegetationOpticalPropertyLink(\n')
            self.VegetationOpticalPropertyLink.exportLiteral(outfile, level, name_='VegetationOpticalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('possibleBranchTwigMixing', node)
        if value is not None and 'possibleBranchTwigMixing' not in already_processed:
            already_processed.add('possibleBranchTwigMixing')
            try:
                self.possibleBranchTwigMixing = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('twigAreaIndex', node)
        if value is not None and 'twigAreaIndex' not in already_processed:
            already_processed.add('twigAreaIndex')
            try:
                self.twigAreaIndex = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (twigAreaIndex): %s' % exp)
        value = find_attr_value_('geometryFileName', node)
        if value is not None and 'geometryFileName' not in already_processed:
            already_processed.add('geometryFileName')
            self.geometryFileName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OpticalPropertyLink':
            obj_ = create_OpticalPropertyLink.factory()
            obj_.build(child_)
            self.set_OpticalPropertyLink(obj_)
            obj_.original_tagname_ = 'OpticalPropertyLink'
        elif nodeName_ == 'ThermalPropertyLink':
            obj_ = create_ThermalPropertyLink.factory()
            obj_.build(child_)
            self.set_ThermalPropertyLink(obj_)
            obj_.original_tagname_ = 'ThermalPropertyLink'
        elif nodeName_ == 'VegetationOpticalPropertyLink':
            obj_ = create_VegetationOpticalPropertyLink.factory()
            obj_.build(child_)
            self.set_VegetationOpticalPropertyLink(obj_)
            obj_.original_tagname_ = 'VegetationOpticalPropertyLink'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_BranchesAndTwigs


class create_Trees_2(GeneratedsSuper):
    """Trees_2 Trees_2 1). Knowledge of the LAI of a sub-scene gives the uf
    values of the cells of the sub-scene, which in turn gives the uf
    values of the cells outside the sub-scene. 1). Knowledge of the
    LAI of a sub-scene gives the uf values of the cells of the sub-
    scene, which in turn gives the uf values of the cells outside
    the sub-scene. Name of the file that stores the position of the
    trees. This file is created if it is specified as unavailable
    Name of the file that stores the position of the trees. This
    file is created if it is specified as unavailable"""
    member_data_items_ = [
        MemberSpec_('laiZone', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('treePositionFileName', 'xsd:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('LaiZoneProperties', '_LaiZoneProperties', 0, 0, {'name': 'LaiZoneProperties', 'type': '_LaiZoneProperties', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('Specie_2', '_Specie_2', 1, 0, {'name': 'Specie_2', 'type': '_Specie_2', 'minOccurs': '1', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, laiZone=0, treePositionFileName='Trees_position.txt', LaiZoneProperties=None, Specie_2=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_Trees_2')
        self.attrib = ['laiZone', 'treePositionFileName']
        self.children = ['LaiZoneProperties', 'Specie_2']
        self.parent = None
        self._laiZone = _cast(int, laiZone)
        self._treePositionFileName = _cast(None, treePositionFileName)
        self._LaiZoneProperties = LaiZoneProperties
        if Specie_2 is None:
            self._Specie_2 = []
        else:
            self._Specie_2 = Specie_2
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Trees_2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Trees_2.subclass:
            return create_Trees_2.subclass(*args_, **kwargs_)
        else:
            return create_Trees_2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LaiZoneProperties(self): return self._LaiZoneProperties
    def set_LaiZoneProperties(self, value):
        if value is not None:
            checkclass(value, create_LaiZoneProperties)
            value.parent = self
        self._LaiZoneProperties = value
    LaiZoneProperties = property(get_LaiZoneProperties, set_LaiZoneProperties)
    def get_Specie_2(self): return self._Specie_2
    def set_Specie_2(self, value):
        if value is not None:
            checkclass(value, create_Specie_2)
            for v in value:
                v.parent = self
        self._Specie_2 = value
    def add_Specie_2(self, value):
        value.parent = self
        self._Specie_2.append(value)
    def insert_Specie_2_at(self, index, value):
        value.parent = self
        self.Specie_2.insert(index, value)
    def replace_Specie_2_at(self, index, value):
        value.parent = self
        self.Specie_2[index] = value
    Specie_2 = property(get_Specie_2, set_Specie_2)
    def get_laiZone(self): return self._laiZone
    def set_laiZone(self, value):
        self._laiZone = value
        update_node(self,self.troot,'trees')
    laiZone = property(get_laiZone, set_laiZone)
    def get_treePositionFileName(self): return self._treePositionFileName
    def set_treePositionFileName(self, value):
        self._treePositionFileName = value
        update_node(self,self.troot,'trees')
    treePositionFileName = property(get_treePositionFileName, set_treePositionFileName)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.LaiZoneProperties is not None or
            self.Specie_2
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Trees_2', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Trees_2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Trees_2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Trees_2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Trees_2'):
        if self.laiZone is not None and 'laiZone' not in already_processed:
            already_processed.add('laiZone')
            outfile.write(' laiZone="%s"' % self.gds_format_integer(self.laiZone, input_name='laiZone'))
        if self.treePositionFileName is not None and 'treePositionFileName' not in already_processed:
            already_processed.add('treePositionFileName')
            outfile.write(' treePositionFileName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.treePositionFileName), input_name='treePositionFileName')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Trees_2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LaiZoneProperties is not None:
            self.LaiZoneProperties.export(outfile, level, namespaceprefix_, name_='LaiZoneProperties', pretty_print=pretty_print)
        for Specie_2_ in self.Specie_2:
            Specie_2_.export(outfile, level, namespaceprefix_, name_='Specie_2', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Trees_2', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.laiZone is not None:
            element.set('laiZone', self.gds_format_integer(self.laiZone))
        if self.treePositionFileName is not None:
            element.set('treePositionFileName', self.gds_format_string(self.treePositionFileName))
        if self.LaiZoneProperties is not None:
            LaiZoneProperties_ = self.LaiZoneProperties
            LaiZoneProperties_.to_etree(element, name_='LaiZoneProperties', mapping_=mapping_)
        for Specie_2_ in self.Specie_2:
            Specie_2_.to_etree(element, name_='Specie_2', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Trees_2'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.laiZone is not None and 'laiZone' not in already_processed:
            already_processed.add('laiZone')
            showIndent(outfile, level)
            outfile.write('laiZone=%d,\n' % (self.laiZone,))
        if self.treePositionFileName is not None and 'treePositionFileName' not in already_processed:
            already_processed.add('treePositionFileName')
            showIndent(outfile, level)
            outfile.write('treePositionFileName="%s",\n' % (self.treePositionFileName,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LaiZoneProperties is not None:
            showIndent(outfile, level)
            outfile.write('LaiZoneProperties=model_._LaiZoneProperties(\n')
            self.LaiZoneProperties.exportLiteral(outfile, level, name_='LaiZoneProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Specie_2=[\n')
        level += 1
        for Specie_2_ in self.Specie_2:
            showIndent(outfile, level)
            outfile.write('model_._Specie_2(\n')
            Specie_2_.exportLiteral(outfile, level, name_='_Specie_2')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.Specie_2 = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('laiZone', node)
        if value is not None and 'laiZone' not in already_processed:
            already_processed.add('laiZone')
            try:
                self.laiZone = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('treePositionFileName', node)
        if value is not None and 'treePositionFileName' not in already_processed:
            already_processed.add('treePositionFileName')
            self.treePositionFileName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LaiZoneProperties':
            obj_ = create_LaiZoneProperties.factory()
            obj_.build(child_)
            self.set_LaiZoneProperties(obj_)
            obj_.original_tagname_ = 'LaiZoneProperties'
        elif nodeName_ == 'Specie_2':
            obj_ = create_Specie_2.factory()
            obj_.build(child_)
            self.add_Specie_2(obj_)
            obj_.original_tagname_ = 'Specie_2'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_Trees_2


class create_Specie_2(GeneratedsSuper):
    """Simulation of trees with branches and twigs Simulation of trees with
    branches and twigs LAI LAI"""
    member_data_items_ = [
        MemberSpec_('branchesAndTwigsSimulation', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('lai', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('OpticalPropertyLink', '_OpticalPropertyLink', 0, 0, {'name': 'OpticalPropertyLink', 'type': '_OpticalPropertyLink', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('ThermalPropertyLink', '_ThermalPropertyLink', 0, 0, {'name': 'ThermalPropertyLink', 'type': '_ThermalPropertyLink', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('Trunk', '_Trunk', 0, 0, {'name': 'Trunk', 'type': '_Trunk', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('Crown', '_Crown', 0, 0, {'name': 'Crown', 'type': '_Crown', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('CrownLevel', '_CrownLevel', 1, 0, {'name': 'CrownLevel', 'type': '_CrownLevel', 'minOccurs': '1', 'maxOccurs': 'unbounded'}, None),
        MemberSpec_('BranchesAndTwigs', '_BranchesAndTwigs', 0, 0, {'name': 'BranchesAndTwigs', 'type': '_BranchesAndTwigs', 'minOccurs': '1', 'maxOccurs': '1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, branchesAndTwigsSimulation=0, lai=4.00, OpticalPropertyLink=None, ThermalPropertyLink=None, Trunk=None, Crown=None, CrownLevel=None, BranchesAndTwigs=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_Specie_2')
        self.attrib = ['branchesAndTwigsSimulation', 'lai']
        self.children = ['OpticalPropertyLink', 'ThermalPropertyLink', 'Trunk', 'Crown', 'CrownLevel', 'BranchesAndTwigs']
        self.parent = None
        self._branchesAndTwigsSimulation = _cast(int, branchesAndTwigsSimulation)
        self._lai = _cast(float, lai)
        self._OpticalPropertyLink = OpticalPropertyLink
        self._ThermalPropertyLink = ThermalPropertyLink
        self._Trunk = Trunk
        self._Crown = Crown
        if CrownLevel is None:
            self._CrownLevel = []
        else:
            self._CrownLevel = CrownLevel
        self._BranchesAndTwigs = BranchesAndTwigs
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Specie_2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Specie_2.subclass:
            return create_Specie_2.subclass(*args_, **kwargs_)
        else:
            return create_Specie_2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OpticalPropertyLink(self): return self._OpticalPropertyLink
    def set_OpticalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_OpticalPropertyLink)
            value.parent = self
        self._OpticalPropertyLink = value
    OpticalPropertyLink = property(get_OpticalPropertyLink, set_OpticalPropertyLink)
    def get_ThermalPropertyLink(self): return self._ThermalPropertyLink
    def set_ThermalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_ThermalPropertyLink)
            value.parent = self
        self._ThermalPropertyLink = value
    ThermalPropertyLink = property(get_ThermalPropertyLink, set_ThermalPropertyLink)
    def get_Trunk(self): return self._Trunk
    def set_Trunk(self, value):
        if value is not None:
            checkclass(value, create_Trunk)
            value.parent = self
        self._Trunk = value
    Trunk = property(get_Trunk, set_Trunk)
    def get_Crown(self): return self._Crown
    def set_Crown(self, value):
        if value is not None:
            checkclass(value, create_Crown)
            value.parent = self
        self._Crown = value
    Crown = property(get_Crown, set_Crown)
    def get_CrownLevel(self): return self._CrownLevel
    def set_CrownLevel(self, value):
        if value is not None:
            checkclass(value, create_CrownLevel)
            for v in value:
                v.parent = self
        self._CrownLevel = value
    def add_CrownLevel(self, value):
        value.parent = self
        self._CrownLevel.append(value)
    def insert_CrownLevel_at(self, index, value):
        value.parent = self
        self.CrownLevel.insert(index, value)
    def replace_CrownLevel_at(self, index, value):
        value.parent = self
        self.CrownLevel[index] = value
    CrownLevel = property(get_CrownLevel, set_CrownLevel)
    def get_BranchesAndTwigs(self): return self._BranchesAndTwigs
    def set_BranchesAndTwigs(self, value):
        if value is not None:
            checkclass(value, create_BranchesAndTwigs)
            value.parent = self
        self._BranchesAndTwigs = value
    BranchesAndTwigs = property(get_BranchesAndTwigs, set_BranchesAndTwigs)
    def get_branchesAndTwigsSimulation(self): return self._branchesAndTwigsSimulation
    def set_branchesAndTwigsSimulation(self, value):
        self._branchesAndTwigsSimulation = value
        update_node(self,self.troot,'trees')
    branchesAndTwigsSimulation = property(get_branchesAndTwigsSimulation, set_branchesAndTwigsSimulation)
    def get_lai(self): return self._lai
    def set_lai(self, value):
        self._lai = value
        update_node(self,self.troot,'trees')
    lai = property(get_lai, set_lai)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.OpticalPropertyLink is not None or
            self.ThermalPropertyLink is not None or
            self.Trunk is not None or
            self.Crown is not None or
            self.CrownLevel or
            self.BranchesAndTwigs is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Specie_2', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Specie_2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Specie_2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Specie_2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Specie_2'):
        if self.branchesAndTwigsSimulation is not None and 'branchesAndTwigsSimulation' not in already_processed:
            already_processed.add('branchesAndTwigsSimulation')
            outfile.write(' branchesAndTwigsSimulation="%s"' % self.gds_format_integer(self.branchesAndTwigsSimulation, input_name='branchesAndTwigsSimulation'))
        if self.lai is not None and 'lai' not in already_processed:
            already_processed.add('lai')
            outfile.write(' lai="%s"' % self.gds_format_double(self.lai, input_name='lai'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Specie_2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OpticalPropertyLink is not None:
            self.OpticalPropertyLink.export(outfile, level, namespaceprefix_, name_='OpticalPropertyLink', pretty_print=pretty_print)
        if self.ThermalPropertyLink is not None:
            self.ThermalPropertyLink.export(outfile, level, namespaceprefix_, name_='ThermalPropertyLink', pretty_print=pretty_print)
        if self.Trunk is not None:
            self.Trunk.export(outfile, level, namespaceprefix_, name_='Trunk', pretty_print=pretty_print)
        if self.Crown is not None:
            self.Crown.export(outfile, level, namespaceprefix_, name_='Crown', pretty_print=pretty_print)
        for CrownLevel_ in self.CrownLevel:
            CrownLevel_.export(outfile, level, namespaceprefix_, name_='CrownLevel', pretty_print=pretty_print)
        if self.BranchesAndTwigs is not None:
            self.BranchesAndTwigs.export(outfile, level, namespaceprefix_, name_='BranchesAndTwigs', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Specie_2', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.branchesAndTwigsSimulation is not None:
            element.set('branchesAndTwigsSimulation', self.gds_format_integer(self.branchesAndTwigsSimulation))
        if self.lai is not None:
            element.set('lai', self.gds_format_double(self.lai))
        if self.OpticalPropertyLink is not None:
            OpticalPropertyLink_ = self.OpticalPropertyLink
            OpticalPropertyLink_.to_etree(element, name_='OpticalPropertyLink', mapping_=mapping_)
        if self.ThermalPropertyLink is not None:
            ThermalPropertyLink_ = self.ThermalPropertyLink
            ThermalPropertyLink_.to_etree(element, name_='ThermalPropertyLink', mapping_=mapping_)
        if self.Trunk is not None:
            Trunk_ = self.Trunk
            Trunk_.to_etree(element, name_='Trunk', mapping_=mapping_)
        if self.Crown is not None:
            Crown_ = self.Crown
            Crown_.to_etree(element, name_='Crown', mapping_=mapping_)
        for CrownLevel_ in self.CrownLevel:
            CrownLevel_.to_etree(element, name_='CrownLevel', mapping_=mapping_)
        if self.BranchesAndTwigs is not None:
            BranchesAndTwigs_ = self.BranchesAndTwigs
            BranchesAndTwigs_.to_etree(element, name_='BranchesAndTwigs', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Specie_2'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.branchesAndTwigsSimulation is not None and 'branchesAndTwigsSimulation' not in already_processed:
            already_processed.add('branchesAndTwigsSimulation')
            showIndent(outfile, level)
            outfile.write('branchesAndTwigsSimulation=%d,\n' % (self.branchesAndTwigsSimulation,))
        if self.lai is not None and 'lai' not in already_processed:
            already_processed.add('lai')
            showIndent(outfile, level)
            outfile.write('lai=%e,\n' % (self.lai,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.OpticalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('OpticalPropertyLink=model_._OpticalPropertyLink(\n')
            self.OpticalPropertyLink.exportLiteral(outfile, level, name_='OpticalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ThermalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('ThermalPropertyLink=model_._ThermalPropertyLink(\n')
            self.ThermalPropertyLink.exportLiteral(outfile, level, name_='ThermalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Trunk is not None:
            showIndent(outfile, level)
            outfile.write('Trunk=model_._Trunk(\n')
            self.Trunk.exportLiteral(outfile, level, name_='Trunk')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Crown is not None:
            showIndent(outfile, level)
            outfile.write('Crown=model_._Crown(\n')
            self.Crown.exportLiteral(outfile, level, name_='Crown')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('CrownLevel=[\n')
        level += 1
        for CrownLevel_ in self.CrownLevel:
            showIndent(outfile, level)
            outfile.write('model_._CrownLevel(\n')
            CrownLevel_.exportLiteral(outfile, level, name_='_CrownLevel')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.BranchesAndTwigs is not None:
            showIndent(outfile, level)
            outfile.write('BranchesAndTwigs=model_._BranchesAndTwigs(\n')
            self.BranchesAndTwigs.exportLiteral(outfile, level, name_='BranchesAndTwigs')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.CrownLevel = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('branchesAndTwigsSimulation', node)
        if value is not None and 'branchesAndTwigsSimulation' not in already_processed:
            already_processed.add('branchesAndTwigsSimulation')
            try:
                self.branchesAndTwigsSimulation = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('lai', node)
        if value is not None and 'lai' not in already_processed:
            already_processed.add('lai')
            try:
                self.lai = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (lai): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OpticalPropertyLink':
            obj_ = create_OpticalPropertyLink.factory()
            obj_.build(child_)
            self.set_OpticalPropertyLink(obj_)
            obj_.original_tagname_ = 'OpticalPropertyLink'
        elif nodeName_ == 'ThermalPropertyLink':
            obj_ = create_ThermalPropertyLink.factory()
            obj_.build(child_)
            self.set_ThermalPropertyLink(obj_)
            obj_.original_tagname_ = 'ThermalPropertyLink'
        elif nodeName_ == 'Trunk':
            obj_ = create_Trunk.factory()
            obj_.build(child_)
            self.set_Trunk(obj_)
            obj_.original_tagname_ = 'Trunk'
        elif nodeName_ == 'Crown':
            obj_ = create_Crown.factory()
            obj_.build(child_)
            self.set_Crown(obj_)
            obj_.original_tagname_ = 'Crown'
        elif nodeName_ == 'CrownLevel':
            obj_ = create_CrownLevel.factory()
            obj_.build(child_)
            self.add_CrownLevel(obj_)
            obj_.original_tagname_ = 'CrownLevel'
        elif nodeName_ == 'BranchesAndTwigs':
            obj_ = create_BranchesAndTwigs.factory()
            obj_.build(child_)
            self.set_BranchesAndTwigs(obj_)
            obj_.original_tagname_ = 'BranchesAndTwigs'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_Specie_2


class create_Trunk(GeneratedsSuper):
    """Trunk Trunk 0 and within [mean - std dev ; mean + std dev] 0 and
    within [mean - std dev ; mean + std dev] Standard deviation of
    the trunk height below the tree crown Standard deviation of the
    trunk height below the tree crown 0 and within [mean - std dev ;
    mean + std dev] 0 and within [mean - std dev ; mean + std dev]
    Standard deviation of the trunk diameter below the tree crown
    Standard deviation of the trunk diameter below the tree crown
    Trunk height within the tree crown Trunk height within the tree
    crown"""
    member_data_items_ = [
        MemberSpec_('meanTrunkDiameterBelowCrown', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('stDevMeanTrunkHeightBelowCrown', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('meanTrunkHeightBelowCrown', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('stDevMeanTrunkDiameterBelowCrown', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('trunkHeightWithinCrown', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, meanTrunkDiameterBelowCrown=0.30, stDevMeanTrunkHeightBelowCrown=0.0, meanTrunkHeightBelowCrown=5.00, stDevMeanTrunkDiameterBelowCrown=0.0, trunkHeightWithinCrown=3.00):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_Trunk')
        self.attrib = ['meanTrunkDiameterBelowCrown', 'stDevMeanTrunkHeightBelowCrown', 'meanTrunkHeightBelowCrown', 'stDevMeanTrunkDiameterBelowCrown', 'trunkHeightWithinCrown']
        self.children = []
        self.parent = None
        self._meanTrunkDiameterBelowCrown = _cast(float, meanTrunkDiameterBelowCrown)
        self._stDevMeanTrunkHeightBelowCrown = _cast(float, stDevMeanTrunkHeightBelowCrown)
        self._meanTrunkHeightBelowCrown = _cast(float, meanTrunkHeightBelowCrown)
        self._stDevMeanTrunkDiameterBelowCrown = _cast(float, stDevMeanTrunkDiameterBelowCrown)
        self._trunkHeightWithinCrown = _cast(float, trunkHeightWithinCrown)
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Trunk)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Trunk.subclass:
            return create_Trunk.subclass(*args_, **kwargs_)
        else:
            return create_Trunk(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meanTrunkDiameterBelowCrown(self): return self._meanTrunkDiameterBelowCrown
    def set_meanTrunkDiameterBelowCrown(self, value):
        self._meanTrunkDiameterBelowCrown = value
        update_node(self,self.troot,'trees')
    meanTrunkDiameterBelowCrown = property(get_meanTrunkDiameterBelowCrown, set_meanTrunkDiameterBelowCrown)
    def get_stDevMeanTrunkHeightBelowCrown(self): return self._stDevMeanTrunkHeightBelowCrown
    def set_stDevMeanTrunkHeightBelowCrown(self, value):
        self._stDevMeanTrunkHeightBelowCrown = value
        update_node(self,self.troot,'trees')
    stDevMeanTrunkHeightBelowCrown = property(get_stDevMeanTrunkHeightBelowCrown, set_stDevMeanTrunkHeightBelowCrown)
    def get_meanTrunkHeightBelowCrown(self): return self._meanTrunkHeightBelowCrown
    def set_meanTrunkHeightBelowCrown(self, value):
        self._meanTrunkHeightBelowCrown = value
        update_node(self,self.troot,'trees')
    meanTrunkHeightBelowCrown = property(get_meanTrunkHeightBelowCrown, set_meanTrunkHeightBelowCrown)
    def get_stDevMeanTrunkDiameterBelowCrown(self): return self._stDevMeanTrunkDiameterBelowCrown
    def set_stDevMeanTrunkDiameterBelowCrown(self, value):
        self._stDevMeanTrunkDiameterBelowCrown = value
        update_node(self,self.troot,'trees')
    stDevMeanTrunkDiameterBelowCrown = property(get_stDevMeanTrunkDiameterBelowCrown, set_stDevMeanTrunkDiameterBelowCrown)
    def get_trunkHeightWithinCrown(self): return self._trunkHeightWithinCrown
    def set_trunkHeightWithinCrown(self, value):
        self._trunkHeightWithinCrown = value
        update_node(self,self.troot,'trees')
    trunkHeightWithinCrown = property(get_trunkHeightWithinCrown, set_trunkHeightWithinCrown)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Trunk', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Trunk')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Trunk')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Trunk', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Trunk'):
        if self.meanTrunkDiameterBelowCrown is not None and 'meanTrunkDiameterBelowCrown' not in already_processed:
            already_processed.add('meanTrunkDiameterBelowCrown')
            outfile.write(' meanTrunkDiameterBelowCrown="%s"' % self.gds_format_double(self.meanTrunkDiameterBelowCrown, input_name='meanTrunkDiameterBelowCrown'))
        if self.stDevMeanTrunkHeightBelowCrown is not None and 'stDevMeanTrunkHeightBelowCrown' not in already_processed:
            already_processed.add('stDevMeanTrunkHeightBelowCrown')
            outfile.write(' stDevMeanTrunkHeightBelowCrown="%s"' % self.gds_format_double(self.stDevMeanTrunkHeightBelowCrown, input_name='stDevMeanTrunkHeightBelowCrown'))
        if self.meanTrunkHeightBelowCrown is not None and 'meanTrunkHeightBelowCrown' not in already_processed:
            already_processed.add('meanTrunkHeightBelowCrown')
            outfile.write(' meanTrunkHeightBelowCrown="%s"' % self.gds_format_double(self.meanTrunkHeightBelowCrown, input_name='meanTrunkHeightBelowCrown'))
        if self.stDevMeanTrunkDiameterBelowCrown is not None and 'stDevMeanTrunkDiameterBelowCrown' not in already_processed:
            already_processed.add('stDevMeanTrunkDiameterBelowCrown')
            outfile.write(' stDevMeanTrunkDiameterBelowCrown="%s"' % self.gds_format_double(self.stDevMeanTrunkDiameterBelowCrown, input_name='stDevMeanTrunkDiameterBelowCrown'))
        if self.trunkHeightWithinCrown is not None and 'trunkHeightWithinCrown' not in already_processed:
            already_processed.add('trunkHeightWithinCrown')
            outfile.write(' trunkHeightWithinCrown="%s"' % self.gds_format_double(self.trunkHeightWithinCrown, input_name='trunkHeightWithinCrown'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Trunk', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_Trunk', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.meanTrunkDiameterBelowCrown is not None:
            element.set('meanTrunkDiameterBelowCrown', self.gds_format_double(self.meanTrunkDiameterBelowCrown))
        if self.stDevMeanTrunkHeightBelowCrown is not None:
            element.set('stDevMeanTrunkHeightBelowCrown', self.gds_format_double(self.stDevMeanTrunkHeightBelowCrown))
        if self.meanTrunkHeightBelowCrown is not None:
            element.set('meanTrunkHeightBelowCrown', self.gds_format_double(self.meanTrunkHeightBelowCrown))
        if self.stDevMeanTrunkDiameterBelowCrown is not None:
            element.set('stDevMeanTrunkDiameterBelowCrown', self.gds_format_double(self.stDevMeanTrunkDiameterBelowCrown))
        if self.trunkHeightWithinCrown is not None:
            element.set('trunkHeightWithinCrown', self.gds_format_double(self.trunkHeightWithinCrown))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Trunk'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.meanTrunkDiameterBelowCrown is not None and 'meanTrunkDiameterBelowCrown' not in already_processed:
            already_processed.add('meanTrunkDiameterBelowCrown')
            showIndent(outfile, level)
            outfile.write('meanTrunkDiameterBelowCrown=%e,\n' % (self.meanTrunkDiameterBelowCrown,))
        if self.stDevMeanTrunkHeightBelowCrown is not None and 'stDevMeanTrunkHeightBelowCrown' not in already_processed:
            already_processed.add('stDevMeanTrunkHeightBelowCrown')
            showIndent(outfile, level)
            outfile.write('stDevMeanTrunkHeightBelowCrown=%e,\n' % (self.stDevMeanTrunkHeightBelowCrown,))
        if self.meanTrunkHeightBelowCrown is not None and 'meanTrunkHeightBelowCrown' not in already_processed:
            already_processed.add('meanTrunkHeightBelowCrown')
            showIndent(outfile, level)
            outfile.write('meanTrunkHeightBelowCrown=%e,\n' % (self.meanTrunkHeightBelowCrown,))
        if self.stDevMeanTrunkDiameterBelowCrown is not None and 'stDevMeanTrunkDiameterBelowCrown' not in already_processed:
            already_processed.add('stDevMeanTrunkDiameterBelowCrown')
            showIndent(outfile, level)
            outfile.write('stDevMeanTrunkDiameterBelowCrown=%e,\n' % (self.stDevMeanTrunkDiameterBelowCrown,))
        if self.trunkHeightWithinCrown is not None and 'trunkHeightWithinCrown' not in already_processed:
            already_processed.add('trunkHeightWithinCrown')
            showIndent(outfile, level)
            outfile.write('trunkHeightWithinCrown=%e,\n' % (self.trunkHeightWithinCrown,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('meanTrunkDiameterBelowCrown', node)
        if value is not None and 'meanTrunkDiameterBelowCrown' not in already_processed:
            already_processed.add('meanTrunkDiameterBelowCrown')
            try:
                self.meanTrunkDiameterBelowCrown = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (meanTrunkDiameterBelowCrown): %s' % exp)
        value = find_attr_value_('stDevMeanTrunkHeightBelowCrown', node)
        if value is not None and 'stDevMeanTrunkHeightBelowCrown' not in already_processed:
            already_processed.add('stDevMeanTrunkHeightBelowCrown')
            try:
                self.stDevMeanTrunkHeightBelowCrown = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (stDevMeanTrunkHeightBelowCrown): %s' % exp)
        value = find_attr_value_('meanTrunkHeightBelowCrown', node)
        if value is not None and 'meanTrunkHeightBelowCrown' not in already_processed:
            already_processed.add('meanTrunkHeightBelowCrown')
            try:
                self.meanTrunkHeightBelowCrown = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (meanTrunkHeightBelowCrown): %s' % exp)
        value = find_attr_value_('stDevMeanTrunkDiameterBelowCrown', node)
        if value is not None and 'stDevMeanTrunkDiameterBelowCrown' not in already_processed:
            already_processed.add('stDevMeanTrunkDiameterBelowCrown')
            try:
                self.stDevMeanTrunkDiameterBelowCrown = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (stDevMeanTrunkDiameterBelowCrown): %s' % exp)
        value = find_attr_value_('trunkHeightWithinCrown', node)
        if value is not None and 'trunkHeightWithinCrown' not in already_processed:
            already_processed.add('trunkHeightWithinCrown')
            try:
                self.trunkHeightWithinCrown = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (trunkHeightWithinCrown): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_Trunk


class create_Crown(GeneratedsSuper):
    """Crown Crown Intrinsic rotation of the crown, in degree. The crown
    will rotate on itself around the Z axis (height), counter-
    clockwise. Intrinsic rotation of the crown, in degree. The crown
    will rotate on itself around the Z axis (height), counter-
    clockwise. Crown shape: ellipsoidal, etc. Crown shape:
    ellipsoidal, etc. Standard deviation of crown intrinsic
    rotation. Standard deviation of crown intrinsic rotation.
    Standard deviation of crown height Standard deviation of crown
    height 0 and within [mean - std dev ; mean + std dev] 0 and
    within [mean - std dev ; mean + std dev]"""
    member_data_items_ = [
        MemberSpec_('instrinsicRotation', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('crownShape', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('instrinsicRotationStDev', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('crownHeightStDev', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('crownHeight', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('CrownEllipsoid', '_CrownEllipsoid', 0, 0, {'name': 'CrownEllipsoid', 'type': '_CrownEllipsoid', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('CrownEllipsoidComposed', '_CrownEllipsoidComposed', 0, 0, {'name': 'CrownEllipsoidComposed', 'type': '_CrownEllipsoidComposed', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('CrownTruncatedCone', '_CrownTruncatedCone', 0, 0, {'name': 'CrownTruncatedCone', 'type': '_CrownTruncatedCone', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('CrownTrapezoid', '_CrownTrapezoid', 0, 0, {'name': 'CrownTrapezoid', 'type': '_CrownTrapezoid', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('CrownConeComp', '_CrownConeComp', 0, 0, {'name': 'CrownConeComp', 'type': '_CrownConeComp', 'minOccurs': '1', 'maxOccurs': '1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, instrinsicRotation=0.0, crownShape=0, instrinsicRotationStDev=0.0, crownHeightStDev=0.0, crownHeight=6.00, CrownEllipsoid=None, CrownEllipsoidComposed=None, CrownTruncatedCone=None, CrownTrapezoid=None, CrownConeComp=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_Crown')
        self.attrib = ['instrinsicRotation', 'crownShape', 'instrinsicRotationStDev', 'crownHeightStDev', 'crownHeight']
        self.children = ['CrownEllipsoid', 'CrownEllipsoidComposed', 'CrownTruncatedCone', 'CrownTrapezoid', 'CrownConeComp']
        self.parent = None
        self._instrinsicRotation = _cast(float, instrinsicRotation)
        self._crownShape = _cast(int, crownShape)
        self._instrinsicRotationStDev = _cast(float, instrinsicRotationStDev)
        self._crownHeightStDev = _cast(float, crownHeightStDev)
        self._crownHeight = _cast(float, crownHeight)
        self._CrownEllipsoid = CrownEllipsoid
        self._CrownEllipsoidComposed = CrownEllipsoidComposed
        self._CrownTruncatedCone = CrownTruncatedCone
        self._CrownTrapezoid = CrownTrapezoid
        self._CrownConeComp = CrownConeComp
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Crown)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Crown.subclass:
            return create_Crown.subclass(*args_, **kwargs_)
        else:
            return create_Crown(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CrownEllipsoid(self): return self._CrownEllipsoid
    def set_CrownEllipsoid(self, value):
        if value is not None:
            checkclass(value, create_CrownEllipsoid)
            value.parent = self
        self._CrownEllipsoid = value
    CrownEllipsoid = property(get_CrownEllipsoid, set_CrownEllipsoid)
    def get_CrownEllipsoidComposed(self): return self._CrownEllipsoidComposed
    def set_CrownEllipsoidComposed(self, value):
        if value is not None:
            checkclass(value, create_CrownEllipsoidComposed)
            value.parent = self
        self._CrownEllipsoidComposed = value
    CrownEllipsoidComposed = property(get_CrownEllipsoidComposed, set_CrownEllipsoidComposed)
    def get_CrownTruncatedCone(self): return self._CrownTruncatedCone
    def set_CrownTruncatedCone(self, value):
        if value is not None:
            checkclass(value, create_CrownTruncatedCone)
            value.parent = self
        self._CrownTruncatedCone = value
    CrownTruncatedCone = property(get_CrownTruncatedCone, set_CrownTruncatedCone)
    def get_CrownTrapezoid(self): return self._CrownTrapezoid
    def set_CrownTrapezoid(self, value):
        if value is not None:
            checkclass(value, create_CrownTrapezoid)
            value.parent = self
        self._CrownTrapezoid = value
    CrownTrapezoid = property(get_CrownTrapezoid, set_CrownTrapezoid)
    def get_CrownConeComp(self): return self._CrownConeComp
    def set_CrownConeComp(self, value):
        if value is not None:
            checkclass(value, create_CrownConeComp)
            value.parent = self
        self._CrownConeComp = value
    CrownConeComp = property(get_CrownConeComp, set_CrownConeComp)
    def get_instrinsicRotation(self): return self._instrinsicRotation
    def set_instrinsicRotation(self, value):
        self._instrinsicRotation = value
        update_node(self,self.troot,'trees')
    instrinsicRotation = property(get_instrinsicRotation, set_instrinsicRotation)
    def get_crownShape(self): return self._crownShape
    def set_crownShape(self, value):
        self._crownShape = value
        update_node(self,self.troot,'trees')
    crownShape = property(get_crownShape, set_crownShape)
    def get_instrinsicRotationStDev(self): return self._instrinsicRotationStDev
    def set_instrinsicRotationStDev(self, value):
        self._instrinsicRotationStDev = value
        update_node(self,self.troot,'trees')
    instrinsicRotationStDev = property(get_instrinsicRotationStDev, set_instrinsicRotationStDev)
    def get_crownHeightStDev(self): return self._crownHeightStDev
    def set_crownHeightStDev(self, value):
        self._crownHeightStDev = value
        update_node(self,self.troot,'trees')
    crownHeightStDev = property(get_crownHeightStDev, set_crownHeightStDev)
    def get_crownHeight(self): return self._crownHeight
    def set_crownHeight(self, value):
        self._crownHeight = value
        update_node(self,self.troot,'trees')
    crownHeight = property(get_crownHeight, set_crownHeight)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.CrownEllipsoid is not None or
            self.CrownEllipsoidComposed is not None or
            self.CrownTruncatedCone is not None or
            self.CrownTrapezoid is not None or
            self.CrownConeComp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Crown', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Crown')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Crown')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Crown', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Crown'):
        if self.instrinsicRotation is not None and 'instrinsicRotation' not in already_processed:
            already_processed.add('instrinsicRotation')
            outfile.write(' instrinsicRotation="%s"' % self.gds_format_double(self.instrinsicRotation, input_name='instrinsicRotation'))
        if self.crownShape is not None and 'crownShape' not in already_processed:
            already_processed.add('crownShape')
            outfile.write(' crownShape="%s"' % self.gds_format_integer(self.crownShape, input_name='crownShape'))
        if self.instrinsicRotationStDev is not None and 'instrinsicRotationStDev' not in already_processed:
            already_processed.add('instrinsicRotationStDev')
            outfile.write(' instrinsicRotationStDev="%s"' % self.gds_format_double(self.instrinsicRotationStDev, input_name='instrinsicRotationStDev'))
        if self.crownHeightStDev is not None and 'crownHeightStDev' not in already_processed:
            already_processed.add('crownHeightStDev')
            outfile.write(' crownHeightStDev="%s"' % self.gds_format_double(self.crownHeightStDev, input_name='crownHeightStDev'))
        if self.crownHeight is not None and 'crownHeight' not in already_processed:
            already_processed.add('crownHeight')
            outfile.write(' crownHeight="%s"' % self.gds_format_double(self.crownHeight, input_name='crownHeight'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Crown', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CrownEllipsoid is not None:
            self.CrownEllipsoid.export(outfile, level, namespaceprefix_, name_='CrownEllipsoid', pretty_print=pretty_print)
        if self.CrownEllipsoidComposed is not None:
            self.CrownEllipsoidComposed.export(outfile, level, namespaceprefix_, name_='CrownEllipsoidComposed', pretty_print=pretty_print)
        if self.CrownTruncatedCone is not None:
            self.CrownTruncatedCone.export(outfile, level, namespaceprefix_, name_='CrownTruncatedCone', pretty_print=pretty_print)
        if self.CrownTrapezoid is not None:
            self.CrownTrapezoid.export(outfile, level, namespaceprefix_, name_='CrownTrapezoid', pretty_print=pretty_print)
        if self.CrownConeComp is not None:
            self.CrownConeComp.export(outfile, level, namespaceprefix_, name_='CrownConeComp', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Crown', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.instrinsicRotation is not None:
            element.set('instrinsicRotation', self.gds_format_double(self.instrinsicRotation))
        if self.crownShape is not None:
            element.set('crownShape', self.gds_format_integer(self.crownShape))
        if self.instrinsicRotationStDev is not None:
            element.set('instrinsicRotationStDev', self.gds_format_double(self.instrinsicRotationStDev))
        if self.crownHeightStDev is not None:
            element.set('crownHeightStDev', self.gds_format_double(self.crownHeightStDev))
        if self.crownHeight is not None:
            element.set('crownHeight', self.gds_format_double(self.crownHeight))
        if self.CrownEllipsoid is not None:
            CrownEllipsoid_ = self.CrownEllipsoid
            CrownEllipsoid_.to_etree(element, name_='CrownEllipsoid', mapping_=mapping_)
        if self.CrownEllipsoidComposed is not None:
            CrownEllipsoidComposed_ = self.CrownEllipsoidComposed
            CrownEllipsoidComposed_.to_etree(element, name_='CrownEllipsoidComposed', mapping_=mapping_)
        if self.CrownTruncatedCone is not None:
            CrownTruncatedCone_ = self.CrownTruncatedCone
            CrownTruncatedCone_.to_etree(element, name_='CrownTruncatedCone', mapping_=mapping_)
        if self.CrownTrapezoid is not None:
            CrownTrapezoid_ = self.CrownTrapezoid
            CrownTrapezoid_.to_etree(element, name_='CrownTrapezoid', mapping_=mapping_)
        if self.CrownConeComp is not None:
            CrownConeComp_ = self.CrownConeComp
            CrownConeComp_.to_etree(element, name_='CrownConeComp', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Crown'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.instrinsicRotation is not None and 'instrinsicRotation' not in already_processed:
            already_processed.add('instrinsicRotation')
            showIndent(outfile, level)
            outfile.write('instrinsicRotation=%e,\n' % (self.instrinsicRotation,))
        if self.crownShape is not None and 'crownShape' not in already_processed:
            already_processed.add('crownShape')
            showIndent(outfile, level)
            outfile.write('crownShape=%d,\n' % (self.crownShape,))
        if self.instrinsicRotationStDev is not None and 'instrinsicRotationStDev' not in already_processed:
            already_processed.add('instrinsicRotationStDev')
            showIndent(outfile, level)
            outfile.write('instrinsicRotationStDev=%e,\n' % (self.instrinsicRotationStDev,))
        if self.crownHeightStDev is not None and 'crownHeightStDev' not in already_processed:
            already_processed.add('crownHeightStDev')
            showIndent(outfile, level)
            outfile.write('crownHeightStDev=%e,\n' % (self.crownHeightStDev,))
        if self.crownHeight is not None and 'crownHeight' not in already_processed:
            already_processed.add('crownHeight')
            showIndent(outfile, level)
            outfile.write('crownHeight=%e,\n' % (self.crownHeight,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CrownEllipsoid is not None:
            showIndent(outfile, level)
            outfile.write('CrownEllipsoid=model_._CrownEllipsoid(\n')
            self.CrownEllipsoid.exportLiteral(outfile, level, name_='CrownEllipsoid')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CrownEllipsoidComposed is not None:
            showIndent(outfile, level)
            outfile.write('CrownEllipsoidComposed=model_._CrownEllipsoidComposed(\n')
            self.CrownEllipsoidComposed.exportLiteral(outfile, level, name_='CrownEllipsoidComposed')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CrownTruncatedCone is not None:
            showIndent(outfile, level)
            outfile.write('CrownTruncatedCone=model_._CrownTruncatedCone(\n')
            self.CrownTruncatedCone.exportLiteral(outfile, level, name_='CrownTruncatedCone')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CrownTrapezoid is not None:
            showIndent(outfile, level)
            outfile.write('CrownTrapezoid=model_._CrownTrapezoid(\n')
            self.CrownTrapezoid.exportLiteral(outfile, level, name_='CrownTrapezoid')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CrownConeComp is not None:
            showIndent(outfile, level)
            outfile.write('CrownConeComp=model_._CrownConeComp(\n')
            self.CrownConeComp.exportLiteral(outfile, level, name_='CrownConeComp')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instrinsicRotation', node)
        if value is not None and 'instrinsicRotation' not in already_processed:
            already_processed.add('instrinsicRotation')
            try:
                self.instrinsicRotation = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (instrinsicRotation): %s' % exp)
        value = find_attr_value_('crownShape', node)
        if value is not None and 'crownShape' not in already_processed:
            already_processed.add('crownShape')
            try:
                self.crownShape = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('instrinsicRotationStDev', node)
        if value is not None and 'instrinsicRotationStDev' not in already_processed:
            already_processed.add('instrinsicRotationStDev')
            try:
                self.instrinsicRotationStDev = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (instrinsicRotationStDev): %s' % exp)
        value = find_attr_value_('crownHeightStDev', node)
        if value is not None and 'crownHeightStDev' not in already_processed:
            already_processed.add('crownHeightStDev')
            try:
                self.crownHeightStDev = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (crownHeightStDev): %s' % exp)
        value = find_attr_value_('crownHeight', node)
        if value is not None and 'crownHeight' not in already_processed:
            already_processed.add('crownHeight')
            try:
                self.crownHeight = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (crownHeight): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CrownEllipsoid':
            obj_ = create_CrownEllipsoid.factory()
            obj_.build(child_)
            self.set_CrownEllipsoid(obj_)
            obj_.original_tagname_ = 'CrownEllipsoid'
        elif nodeName_ == 'CrownEllipsoidComposed':
            obj_ = create_CrownEllipsoidComposed.factory()
            obj_.build(child_)
            self.set_CrownEllipsoidComposed(obj_)
            obj_.original_tagname_ = 'CrownEllipsoidComposed'
        elif nodeName_ == 'CrownTruncatedCone':
            obj_ = create_CrownTruncatedCone.factory()
            obj_.build(child_)
            self.set_CrownTruncatedCone(obj_)
            obj_.original_tagname_ = 'CrownTruncatedCone'
        elif nodeName_ == 'CrownTrapezoid':
            obj_ = create_CrownTrapezoid.factory()
            obj_.build(child_)
            self.set_CrownTrapezoid(obj_)
            obj_.original_tagname_ = 'CrownTrapezoid'
        elif nodeName_ == 'CrownConeComp':
            obj_ = create_CrownConeComp.factory()
            obj_.build(child_)
            self.set_CrownConeComp(obj_)
            obj_.original_tagname_ = 'CrownConeComp'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_Crown


class create_CrownEllipsoid(GeneratedsSuper):
    """The tree crown horizontal section is an ellipse The tree crown
    horizontal section is an ellipse The tree crown horizontal
    section is an ellipse The tree crown horizontal section is an
    ellipse"""
    member_data_items_ = [
        MemberSpec_('firstAxis', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('secondAxisStDev', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('secondAxis', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('firstAxisStDev', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, firstAxis=4.00, secondAxisStDev=0.0, secondAxis=4.00, firstAxisStDev=0.0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_CrownEllipsoid')
        self.attrib = ['firstAxis', 'secondAxisStDev', 'secondAxis', 'firstAxisStDev']
        self.children = []
        self.parent = None
        self._firstAxis = _cast(float, firstAxis)
        self._secondAxisStDev = _cast(float, secondAxisStDev)
        self._secondAxis = _cast(float, secondAxis)
        self._firstAxisStDev = _cast(float, firstAxisStDev)
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_CrownEllipsoid)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_CrownEllipsoid.subclass:
            return create_CrownEllipsoid.subclass(*args_, **kwargs_)
        else:
            return create_CrownEllipsoid(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_firstAxis(self): return self._firstAxis
    def set_firstAxis(self, value):
        self._firstAxis = value
        update_node(self,self.troot,'trees')
    firstAxis = property(get_firstAxis, set_firstAxis)
    def get_secondAxisStDev(self): return self._secondAxisStDev
    def set_secondAxisStDev(self, value):
        self._secondAxisStDev = value
        update_node(self,self.troot,'trees')
    secondAxisStDev = property(get_secondAxisStDev, set_secondAxisStDev)
    def get_secondAxis(self): return self._secondAxis
    def set_secondAxis(self, value):
        self._secondAxis = value
        update_node(self,self.troot,'trees')
    secondAxis = property(get_secondAxis, set_secondAxis)
    def get_firstAxisStDev(self): return self._firstAxisStDev
    def set_firstAxisStDev(self, value):
        self._firstAxisStDev = value
        update_node(self,self.troot,'trees')
    firstAxisStDev = property(get_firstAxisStDev, set_firstAxisStDev)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_CrownEllipsoid', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_CrownEllipsoid')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_CrownEllipsoid')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_CrownEllipsoid', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_CrownEllipsoid'):
        if self.firstAxis is not None and 'firstAxis' not in already_processed:
            already_processed.add('firstAxis')
            outfile.write(' firstAxis="%s"' % self.gds_format_double(self.firstAxis, input_name='firstAxis'))
        if self.secondAxisStDev is not None and 'secondAxisStDev' not in already_processed:
            already_processed.add('secondAxisStDev')
            outfile.write(' secondAxisStDev="%s"' % self.gds_format_double(self.secondAxisStDev, input_name='secondAxisStDev'))
        if self.secondAxis is not None and 'secondAxis' not in already_processed:
            already_processed.add('secondAxis')
            outfile.write(' secondAxis="%s"' % self.gds_format_double(self.secondAxis, input_name='secondAxis'))
        if self.firstAxisStDev is not None and 'firstAxisStDev' not in already_processed:
            already_processed.add('firstAxisStDev')
            outfile.write(' firstAxisStDev="%s"' % self.gds_format_double(self.firstAxisStDev, input_name='firstAxisStDev'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_CrownEllipsoid', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_CrownEllipsoid', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.firstAxis is not None:
            element.set('firstAxis', self.gds_format_double(self.firstAxis))
        if self.secondAxisStDev is not None:
            element.set('secondAxisStDev', self.gds_format_double(self.secondAxisStDev))
        if self.secondAxis is not None:
            element.set('secondAxis', self.gds_format_double(self.secondAxis))
        if self.firstAxisStDev is not None:
            element.set('firstAxisStDev', self.gds_format_double(self.firstAxisStDev))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_CrownEllipsoid'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.firstAxis is not None and 'firstAxis' not in already_processed:
            already_processed.add('firstAxis')
            showIndent(outfile, level)
            outfile.write('firstAxis=%e,\n' % (self.firstAxis,))
        if self.secondAxisStDev is not None and 'secondAxisStDev' not in already_processed:
            already_processed.add('secondAxisStDev')
            showIndent(outfile, level)
            outfile.write('secondAxisStDev=%e,\n' % (self.secondAxisStDev,))
        if self.secondAxis is not None and 'secondAxis' not in already_processed:
            already_processed.add('secondAxis')
            showIndent(outfile, level)
            outfile.write('secondAxis=%e,\n' % (self.secondAxis,))
        if self.firstAxisStDev is not None and 'firstAxisStDev' not in already_processed:
            already_processed.add('firstAxisStDev')
            showIndent(outfile, level)
            outfile.write('firstAxisStDev=%e,\n' % (self.firstAxisStDev,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('firstAxis', node)
        if value is not None and 'firstAxis' not in already_processed:
            already_processed.add('firstAxis')
            try:
                self.firstAxis = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (firstAxis): %s' % exp)
        value = find_attr_value_('secondAxisStDev', node)
        if value is not None and 'secondAxisStDev' not in already_processed:
            already_processed.add('secondAxisStDev')
            try:
                self.secondAxisStDev = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (secondAxisStDev): %s' % exp)
        value = find_attr_value_('secondAxis', node)
        if value is not None and 'secondAxis' not in already_processed:
            already_processed.add('secondAxis')
            try:
                self.secondAxis = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (secondAxis): %s' % exp)
        value = find_attr_value_('firstAxisStDev', node)
        if value is not None and 'firstAxisStDev' not in already_processed:
            already_processed.add('firstAxisStDev')
            try:
                self.firstAxisStDev = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (firstAxisStDev): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_CrownEllipsoid


class create_CrownEllipsoidComposed(GeneratedsSuper):
    """The tree crown horizontal section is an ellipse The tree crown
    horizontal section is an ellipse The tree crown horizontal
    section is an ellipse The tree crown horizontal section is an
    ellipse A compose tree crown is made of two half ellipsoids that
    meet at this intermediate height A compose tree crown is made of
    two half ellipsoids that meet at this intermediate height"""
    member_data_items_ = [
        MemberSpec_('secondAxisStDev', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('secondAxis', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('firstAxis', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('intermediateHeightStDev', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('intermediateHeight', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('firstAxisStDev', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, secondAxisStDev=0.0, secondAxis=4.00, firstAxis=4.00, intermediateHeightStDev=0.0, intermediateHeight=2.00, firstAxisStDev=0.0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_CrownEllipsoidComposed')
        self.attrib = ['secondAxisStDev', 'secondAxis', 'firstAxis', 'intermediateHeightStDev', 'intermediateHeight', 'firstAxisStDev']
        self.children = []
        self.parent = None
        self._secondAxisStDev = _cast(float, secondAxisStDev)
        self._secondAxis = _cast(float, secondAxis)
        self._firstAxis = _cast(float, firstAxis)
        self._intermediateHeightStDev = _cast(float, intermediateHeightStDev)
        self._intermediateHeight = _cast(float, intermediateHeight)
        self._firstAxisStDev = _cast(float, firstAxisStDev)
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_CrownEllipsoidComposed)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_CrownEllipsoidComposed.subclass:
            return create_CrownEllipsoidComposed.subclass(*args_, **kwargs_)
        else:
            return create_CrownEllipsoidComposed(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_secondAxisStDev(self): return self._secondAxisStDev
    def set_secondAxisStDev(self, value):
        self._secondAxisStDev = value
        update_node(self,self.troot,'trees')
    secondAxisStDev = property(get_secondAxisStDev, set_secondAxisStDev)
    def get_secondAxis(self): return self._secondAxis
    def set_secondAxis(self, value):
        self._secondAxis = value
        update_node(self,self.troot,'trees')
    secondAxis = property(get_secondAxis, set_secondAxis)
    def get_firstAxis(self): return self._firstAxis
    def set_firstAxis(self, value):
        self._firstAxis = value
        update_node(self,self.troot,'trees')
    firstAxis = property(get_firstAxis, set_firstAxis)
    def get_intermediateHeightStDev(self): return self._intermediateHeightStDev
    def set_intermediateHeightStDev(self, value):
        self._intermediateHeightStDev = value
        update_node(self,self.troot,'trees')
    intermediateHeightStDev = property(get_intermediateHeightStDev, set_intermediateHeightStDev)
    def get_intermediateHeight(self): return self._intermediateHeight
    def set_intermediateHeight(self, value):
        self._intermediateHeight = value
        update_node(self,self.troot,'trees')
    intermediateHeight = property(get_intermediateHeight, set_intermediateHeight)
    def get_firstAxisStDev(self): return self._firstAxisStDev
    def set_firstAxisStDev(self, value):
        self._firstAxisStDev = value
        update_node(self,self.troot,'trees')
    firstAxisStDev = property(get_firstAxisStDev, set_firstAxisStDev)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_CrownEllipsoidComposed', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_CrownEllipsoidComposed')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_CrownEllipsoidComposed')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_CrownEllipsoidComposed', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_CrownEllipsoidComposed'):
        if self.secondAxisStDev is not None and 'secondAxisStDev' not in already_processed:
            already_processed.add('secondAxisStDev')
            outfile.write(' secondAxisStDev="%s"' % self.gds_format_double(self.secondAxisStDev, input_name='secondAxisStDev'))
        if self.secondAxis is not None and 'secondAxis' not in already_processed:
            already_processed.add('secondAxis')
            outfile.write(' secondAxis="%s"' % self.gds_format_double(self.secondAxis, input_name='secondAxis'))
        if self.firstAxis is not None and 'firstAxis' not in already_processed:
            already_processed.add('firstAxis')
            outfile.write(' firstAxis="%s"' % self.gds_format_double(self.firstAxis, input_name='firstAxis'))
        if self.intermediateHeightStDev is not None and 'intermediateHeightStDev' not in already_processed:
            already_processed.add('intermediateHeightStDev')
            outfile.write(' intermediateHeightStDev="%s"' % self.gds_format_double(self.intermediateHeightStDev, input_name='intermediateHeightStDev'))
        if self.intermediateHeight is not None and 'intermediateHeight' not in already_processed:
            already_processed.add('intermediateHeight')
            outfile.write(' intermediateHeight="%s"' % self.gds_format_double(self.intermediateHeight, input_name='intermediateHeight'))
        if self.firstAxisStDev is not None and 'firstAxisStDev' not in already_processed:
            already_processed.add('firstAxisStDev')
            outfile.write(' firstAxisStDev="%s"' % self.gds_format_double(self.firstAxisStDev, input_name='firstAxisStDev'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_CrownEllipsoidComposed', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_CrownEllipsoidComposed', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.secondAxisStDev is not None:
            element.set('secondAxisStDev', self.gds_format_double(self.secondAxisStDev))
        if self.secondAxis is not None:
            element.set('secondAxis', self.gds_format_double(self.secondAxis))
        if self.firstAxis is not None:
            element.set('firstAxis', self.gds_format_double(self.firstAxis))
        if self.intermediateHeightStDev is not None:
            element.set('intermediateHeightStDev', self.gds_format_double(self.intermediateHeightStDev))
        if self.intermediateHeight is not None:
            element.set('intermediateHeight', self.gds_format_double(self.intermediateHeight))
        if self.firstAxisStDev is not None:
            element.set('firstAxisStDev', self.gds_format_double(self.firstAxisStDev))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_CrownEllipsoidComposed'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.secondAxisStDev is not None and 'secondAxisStDev' not in already_processed:
            already_processed.add('secondAxisStDev')
            showIndent(outfile, level)
            outfile.write('secondAxisStDev=%e,\n' % (self.secondAxisStDev,))
        if self.secondAxis is not None and 'secondAxis' not in already_processed:
            already_processed.add('secondAxis')
            showIndent(outfile, level)
            outfile.write('secondAxis=%e,\n' % (self.secondAxis,))
        if self.firstAxis is not None and 'firstAxis' not in already_processed:
            already_processed.add('firstAxis')
            showIndent(outfile, level)
            outfile.write('firstAxis=%e,\n' % (self.firstAxis,))
        if self.intermediateHeightStDev is not None and 'intermediateHeightStDev' not in already_processed:
            already_processed.add('intermediateHeightStDev')
            showIndent(outfile, level)
            outfile.write('intermediateHeightStDev=%e,\n' % (self.intermediateHeightStDev,))
        if self.intermediateHeight is not None and 'intermediateHeight' not in already_processed:
            already_processed.add('intermediateHeight')
            showIndent(outfile, level)
            outfile.write('intermediateHeight=%e,\n' % (self.intermediateHeight,))
        if self.firstAxisStDev is not None and 'firstAxisStDev' not in already_processed:
            already_processed.add('firstAxisStDev')
            showIndent(outfile, level)
            outfile.write('firstAxisStDev=%e,\n' % (self.firstAxisStDev,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('secondAxisStDev', node)
        if value is not None and 'secondAxisStDev' not in already_processed:
            already_processed.add('secondAxisStDev')
            try:
                self.secondAxisStDev = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (secondAxisStDev): %s' % exp)
        value = find_attr_value_('secondAxis', node)
        if value is not None and 'secondAxis' not in already_processed:
            already_processed.add('secondAxis')
            try:
                self.secondAxis = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (secondAxis): %s' % exp)
        value = find_attr_value_('firstAxis', node)
        if value is not None and 'firstAxis' not in already_processed:
            already_processed.add('firstAxis')
            try:
                self.firstAxis = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (firstAxis): %s' % exp)
        value = find_attr_value_('intermediateHeightStDev', node)
        if value is not None and 'intermediateHeightStDev' not in already_processed:
            already_processed.add('intermediateHeightStDev')
            try:
                self.intermediateHeightStDev = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (intermediateHeightStDev): %s' % exp)
        value = find_attr_value_('intermediateHeight', node)
        if value is not None and 'intermediateHeight' not in already_processed:
            already_processed.add('intermediateHeight')
            try:
                self.intermediateHeight = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (intermediateHeight): %s' % exp)
        value = find_attr_value_('firstAxisStDev', node)
        if value is not None and 'firstAxisStDev' not in already_processed:
            already_processed.add('firstAxisStDev')
            try:
                self.firstAxisStDev = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (firstAxisStDev): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_CrownEllipsoidComposed


class create_CrownTruncatedCone(GeneratedsSuper):
    """0 and within [mean - std dev ; mean + std dev] 0 and within [mean -
    std dev ; mean + std dev] 0 and within [mean - std dev ; mean +
    std dev] 0 and within [mean - std dev ; mean + std dev]"""
    member_data_items_ = [
        MemberSpec_('topRadiusStDev', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('topRadius', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('baseRadius', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('baseRadiusStDev', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, topRadiusStDev=0.0, topRadius=2.00, baseRadius=4.00, baseRadiusStDev=0.0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_CrownTruncatedCone')
        self.attrib = ['topRadiusStDev', 'topRadius', 'baseRadius', 'baseRadiusStDev']
        self.children = []
        self.parent = None
        self._topRadiusStDev = _cast(float, topRadiusStDev)
        self._topRadius = _cast(float, topRadius)
        self._baseRadius = _cast(float, baseRadius)
        self._baseRadiusStDev = _cast(float, baseRadiusStDev)
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_CrownTruncatedCone)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_CrownTruncatedCone.subclass:
            return create_CrownTruncatedCone.subclass(*args_, **kwargs_)
        else:
            return create_CrownTruncatedCone(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_topRadiusStDev(self): return self._topRadiusStDev
    def set_topRadiusStDev(self, value):
        self._topRadiusStDev = value
        update_node(self,self.troot,'trees')
    topRadiusStDev = property(get_topRadiusStDev, set_topRadiusStDev)
    def get_topRadius(self): return self._topRadius
    def set_topRadius(self, value):
        self._topRadius = value
        update_node(self,self.troot,'trees')
    topRadius = property(get_topRadius, set_topRadius)
    def get_baseRadius(self): return self._baseRadius
    def set_baseRadius(self, value):
        self._baseRadius = value
        update_node(self,self.troot,'trees')
    baseRadius = property(get_baseRadius, set_baseRadius)
    def get_baseRadiusStDev(self): return self._baseRadiusStDev
    def set_baseRadiusStDev(self, value):
        self._baseRadiusStDev = value
        update_node(self,self.troot,'trees')
    baseRadiusStDev = property(get_baseRadiusStDev, set_baseRadiusStDev)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_CrownTruncatedCone', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_CrownTruncatedCone')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_CrownTruncatedCone')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_CrownTruncatedCone', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_CrownTruncatedCone'):
        if self.topRadiusStDev is not None and 'topRadiusStDev' not in already_processed:
            already_processed.add('topRadiusStDev')
            outfile.write(' topRadiusStDev="%s"' % self.gds_format_double(self.topRadiusStDev, input_name='topRadiusStDev'))
        if self.topRadius is not None and 'topRadius' not in already_processed:
            already_processed.add('topRadius')
            outfile.write(' topRadius="%s"' % self.gds_format_double(self.topRadius, input_name='topRadius'))
        if self.baseRadius is not None and 'baseRadius' not in already_processed:
            already_processed.add('baseRadius')
            outfile.write(' baseRadius="%s"' % self.gds_format_double(self.baseRadius, input_name='baseRadius'))
        if self.baseRadiusStDev is not None and 'baseRadiusStDev' not in already_processed:
            already_processed.add('baseRadiusStDev')
            outfile.write(' baseRadiusStDev="%s"' % self.gds_format_double(self.baseRadiusStDev, input_name='baseRadiusStDev'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_CrownTruncatedCone', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_CrownTruncatedCone', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.topRadiusStDev is not None:
            element.set('topRadiusStDev', self.gds_format_double(self.topRadiusStDev))
        if self.topRadius is not None:
            element.set('topRadius', self.gds_format_double(self.topRadius))
        if self.baseRadius is not None:
            element.set('baseRadius', self.gds_format_double(self.baseRadius))
        if self.baseRadiusStDev is not None:
            element.set('baseRadiusStDev', self.gds_format_double(self.baseRadiusStDev))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_CrownTruncatedCone'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.topRadiusStDev is not None and 'topRadiusStDev' not in already_processed:
            already_processed.add('topRadiusStDev')
            showIndent(outfile, level)
            outfile.write('topRadiusStDev=%e,\n' % (self.topRadiusStDev,))
        if self.topRadius is not None and 'topRadius' not in already_processed:
            already_processed.add('topRadius')
            showIndent(outfile, level)
            outfile.write('topRadius=%e,\n' % (self.topRadius,))
        if self.baseRadius is not None and 'baseRadius' not in already_processed:
            already_processed.add('baseRadius')
            showIndent(outfile, level)
            outfile.write('baseRadius=%e,\n' % (self.baseRadius,))
        if self.baseRadiusStDev is not None and 'baseRadiusStDev' not in already_processed:
            already_processed.add('baseRadiusStDev')
            showIndent(outfile, level)
            outfile.write('baseRadiusStDev=%e,\n' % (self.baseRadiusStDev,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('topRadiusStDev', node)
        if value is not None and 'topRadiusStDev' not in already_processed:
            already_processed.add('topRadiusStDev')
            try:
                self.topRadiusStDev = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (topRadiusStDev): %s' % exp)
        value = find_attr_value_('topRadius', node)
        if value is not None and 'topRadius' not in already_processed:
            already_processed.add('topRadius')
            try:
                self.topRadius = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (topRadius): %s' % exp)
        value = find_attr_value_('baseRadius', node)
        if value is not None and 'baseRadius' not in already_processed:
            already_processed.add('baseRadius')
            try:
                self.baseRadius = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (baseRadius): %s' % exp)
        value = find_attr_value_('baseRadiusStDev', node)
        if value is not None and 'baseRadiusStDev' not in already_processed:
            already_processed.add('baseRadiusStDev')
            try:
                self.baseRadiusStDev = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (baseRadiusStDev): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_CrownTruncatedCone


class create_CrownTrapezoid(GeneratedsSuper):
    """0 and within [mean - std dev ; mean + std dev] 0 and within [mean -
    std dev ; mean + std dev] 0 and within [mean - std dev ; mean +
    std dev] 0 and within [mean - std dev ; mean + std dev] 0 and
    within [mean - std dev ; mean + std dev] 0 and within [mean -
    std dev ; mean + std dev] 0 and within [mean - std dev ; mean +
    std dev] 0 and within [mean - std dev ; mean + std dev]"""
    member_data_items_ = [
        MemberSpec_('topWidthStDev', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('baseLengthStDev', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('baseLength', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('baseWidthStDev', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('topWidth', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('topLength', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('baseWidth', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('topLengthStDev', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, topWidthStDev=0.0, baseLengthStDev=0.0, baseLength=4.00, baseWidthStDev=0.0, topWidth=4.00, topLength=5.00, baseWidth=4.00, topLengthStDev=0.0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_CrownTrapezoid')
        self.attrib = ['topWidthStDev', 'baseLengthStDev', 'baseLength', 'baseWidthStDev', 'topWidth', 'topLength', 'baseWidth', 'topLengthStDev']
        self.children = []
        self.parent = None
        self._topWidthStDev = _cast(float, topWidthStDev)
        self._baseLengthStDev = _cast(float, baseLengthStDev)
        self._baseLength = _cast(float, baseLength)
        self._baseWidthStDev = _cast(float, baseWidthStDev)
        self._topWidth = _cast(float, topWidth)
        self._topLength = _cast(float, topLength)
        self._baseWidth = _cast(float, baseWidth)
        self._topLengthStDev = _cast(float, topLengthStDev)
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_CrownTrapezoid)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_CrownTrapezoid.subclass:
            return create_CrownTrapezoid.subclass(*args_, **kwargs_)
        else:
            return create_CrownTrapezoid(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_topWidthStDev(self): return self._topWidthStDev
    def set_topWidthStDev(self, value):
        self._topWidthStDev = value
        update_node(self,self.troot,'trees')
    topWidthStDev = property(get_topWidthStDev, set_topWidthStDev)
    def get_baseLengthStDev(self): return self._baseLengthStDev
    def set_baseLengthStDev(self, value):
        self._baseLengthStDev = value
        update_node(self,self.troot,'trees')
    baseLengthStDev = property(get_baseLengthStDev, set_baseLengthStDev)
    def get_baseLength(self): return self._baseLength
    def set_baseLength(self, value):
        self._baseLength = value
        update_node(self,self.troot,'trees')
    baseLength = property(get_baseLength, set_baseLength)
    def get_baseWidthStDev(self): return self._baseWidthStDev
    def set_baseWidthStDev(self, value):
        self._baseWidthStDev = value
        update_node(self,self.troot,'trees')
    baseWidthStDev = property(get_baseWidthStDev, set_baseWidthStDev)
    def get_topWidth(self): return self._topWidth
    def set_topWidth(self, value):
        self._topWidth = value
        update_node(self,self.troot,'trees')
    topWidth = property(get_topWidth, set_topWidth)
    def get_topLength(self): return self._topLength
    def set_topLength(self, value):
        self._topLength = value
        update_node(self,self.troot,'trees')
    topLength = property(get_topLength, set_topLength)
    def get_baseWidth(self): return self._baseWidth
    def set_baseWidth(self, value):
        self._baseWidth = value
        update_node(self,self.troot,'trees')
    baseWidth = property(get_baseWidth, set_baseWidth)
    def get_topLengthStDev(self): return self._topLengthStDev
    def set_topLengthStDev(self, value):
        self._topLengthStDev = value
        update_node(self,self.troot,'trees')
    topLengthStDev = property(get_topLengthStDev, set_topLengthStDev)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_CrownTrapezoid', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_CrownTrapezoid')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_CrownTrapezoid')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_CrownTrapezoid', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_CrownTrapezoid'):
        if self.topWidthStDev is not None and 'topWidthStDev' not in already_processed:
            already_processed.add('topWidthStDev')
            outfile.write(' topWidthStDev="%s"' % self.gds_format_double(self.topWidthStDev, input_name='topWidthStDev'))
        if self.baseLengthStDev is not None and 'baseLengthStDev' not in already_processed:
            already_processed.add('baseLengthStDev')
            outfile.write(' baseLengthStDev="%s"' % self.gds_format_double(self.baseLengthStDev, input_name='baseLengthStDev'))
        if self.baseLength is not None and 'baseLength' not in already_processed:
            already_processed.add('baseLength')
            outfile.write(' baseLength="%s"' % self.gds_format_double(self.baseLength, input_name='baseLength'))
        if self.baseWidthStDev is not None and 'baseWidthStDev' not in already_processed:
            already_processed.add('baseWidthStDev')
            outfile.write(' baseWidthStDev="%s"' % self.gds_format_double(self.baseWidthStDev, input_name='baseWidthStDev'))
        if self.topWidth is not None and 'topWidth' not in already_processed:
            already_processed.add('topWidth')
            outfile.write(' topWidth="%s"' % self.gds_format_double(self.topWidth, input_name='topWidth'))
        if self.topLength is not None and 'topLength' not in already_processed:
            already_processed.add('topLength')
            outfile.write(' topLength="%s"' % self.gds_format_double(self.topLength, input_name='topLength'))
        if self.baseWidth is not None and 'baseWidth' not in already_processed:
            already_processed.add('baseWidth')
            outfile.write(' baseWidth="%s"' % self.gds_format_double(self.baseWidth, input_name='baseWidth'))
        if self.topLengthStDev is not None and 'topLengthStDev' not in already_processed:
            already_processed.add('topLengthStDev')
            outfile.write(' topLengthStDev="%s"' % self.gds_format_double(self.topLengthStDev, input_name='topLengthStDev'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_CrownTrapezoid', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_CrownTrapezoid', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.topWidthStDev is not None:
            element.set('topWidthStDev', self.gds_format_double(self.topWidthStDev))
        if self.baseLengthStDev is not None:
            element.set('baseLengthStDev', self.gds_format_double(self.baseLengthStDev))
        if self.baseLength is not None:
            element.set('baseLength', self.gds_format_double(self.baseLength))
        if self.baseWidthStDev is not None:
            element.set('baseWidthStDev', self.gds_format_double(self.baseWidthStDev))
        if self.topWidth is not None:
            element.set('topWidth', self.gds_format_double(self.topWidth))
        if self.topLength is not None:
            element.set('topLength', self.gds_format_double(self.topLength))
        if self.baseWidth is not None:
            element.set('baseWidth', self.gds_format_double(self.baseWidth))
        if self.topLengthStDev is not None:
            element.set('topLengthStDev', self.gds_format_double(self.topLengthStDev))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_CrownTrapezoid'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.topWidthStDev is not None and 'topWidthStDev' not in already_processed:
            already_processed.add('topWidthStDev')
            showIndent(outfile, level)
            outfile.write('topWidthStDev=%e,\n' % (self.topWidthStDev,))
        if self.baseLengthStDev is not None and 'baseLengthStDev' not in already_processed:
            already_processed.add('baseLengthStDev')
            showIndent(outfile, level)
            outfile.write('baseLengthStDev=%e,\n' % (self.baseLengthStDev,))
        if self.baseLength is not None and 'baseLength' not in already_processed:
            already_processed.add('baseLength')
            showIndent(outfile, level)
            outfile.write('baseLength=%e,\n' % (self.baseLength,))
        if self.baseWidthStDev is not None and 'baseWidthStDev' not in already_processed:
            already_processed.add('baseWidthStDev')
            showIndent(outfile, level)
            outfile.write('baseWidthStDev=%e,\n' % (self.baseWidthStDev,))
        if self.topWidth is not None and 'topWidth' not in already_processed:
            already_processed.add('topWidth')
            showIndent(outfile, level)
            outfile.write('topWidth=%e,\n' % (self.topWidth,))
        if self.topLength is not None and 'topLength' not in already_processed:
            already_processed.add('topLength')
            showIndent(outfile, level)
            outfile.write('topLength=%e,\n' % (self.topLength,))
        if self.baseWidth is not None and 'baseWidth' not in already_processed:
            already_processed.add('baseWidth')
            showIndent(outfile, level)
            outfile.write('baseWidth=%e,\n' % (self.baseWidth,))
        if self.topLengthStDev is not None and 'topLengthStDev' not in already_processed:
            already_processed.add('topLengthStDev')
            showIndent(outfile, level)
            outfile.write('topLengthStDev=%e,\n' % (self.topLengthStDev,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('topWidthStDev', node)
        if value is not None and 'topWidthStDev' not in already_processed:
            already_processed.add('topWidthStDev')
            try:
                self.topWidthStDev = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (topWidthStDev): %s' % exp)
        value = find_attr_value_('baseLengthStDev', node)
        if value is not None and 'baseLengthStDev' not in already_processed:
            already_processed.add('baseLengthStDev')
            try:
                self.baseLengthStDev = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (baseLengthStDev): %s' % exp)
        value = find_attr_value_('baseLength', node)
        if value is not None and 'baseLength' not in already_processed:
            already_processed.add('baseLength')
            try:
                self.baseLength = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (baseLength): %s' % exp)
        value = find_attr_value_('baseWidthStDev', node)
        if value is not None and 'baseWidthStDev' not in already_processed:
            already_processed.add('baseWidthStDev')
            try:
                self.baseWidthStDev = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (baseWidthStDev): %s' % exp)
        value = find_attr_value_('topWidth', node)
        if value is not None and 'topWidth' not in already_processed:
            already_processed.add('topWidth')
            try:
                self.topWidth = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (topWidth): %s' % exp)
        value = find_attr_value_('topLength', node)
        if value is not None and 'topLength' not in already_processed:
            already_processed.add('topLength')
            try:
                self.topLength = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (topLength): %s' % exp)
        value = find_attr_value_('baseWidth', node)
        if value is not None and 'baseWidth' not in already_processed:
            already_processed.add('baseWidth')
            try:
                self.baseWidth = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (baseWidth): %s' % exp)
        value = find_attr_value_('topLengthStDev', node)
        if value is not None and 'topLengthStDev' not in already_processed:
            already_processed.add('topLengthStDev')
            try:
                self.topLengthStDev = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (topLengthStDev): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_CrownTrapezoid


class create_CrownConeComp(GeneratedsSuper):
    """0 and within [mean - std dev ; mean + std dev] 0 and within [mean -
    std dev ; mean + std dev] 0 and within [mean - std dev ; mean +
    std dev] 0 and within [mean - std dev ; mean + std dev] 0 and
    within [mean - std dev ; mean + std dev] 0 and within [mean -
    std dev ; mean + std dev]"""
    member_data_items_ = [
        MemberSpec_('aMoy', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('cMoy', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('bMoy', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('stdDevBMoy', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('stdDevCMoy', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('stdDevAMoy', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, aMoy=4.00, cMoy=3.00, bMoy=3.00, stdDevBMoy=0.0, stdDevCMoy=0.0, stdDevAMoy=0.0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_CrownConeComp')
        self.attrib = ['aMoy', 'cMoy', 'bMoy', 'stdDevBMoy', 'stdDevCMoy', 'stdDevAMoy']
        self.children = []
        self.parent = None
        self._aMoy = _cast(float, aMoy)
        self._cMoy = _cast(float, cMoy)
        self._bMoy = _cast(float, bMoy)
        self._stdDevBMoy = _cast(float, stdDevBMoy)
        self._stdDevCMoy = _cast(float, stdDevCMoy)
        self._stdDevAMoy = _cast(float, stdDevAMoy)
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_CrownConeComp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_CrownConeComp.subclass:
            return create_CrownConeComp.subclass(*args_, **kwargs_)
        else:
            return create_CrownConeComp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_aMoy(self): return self._aMoy
    def set_aMoy(self, value):
        self._aMoy = value
        update_node(self,self.troot,'trees')
    aMoy = property(get_aMoy, set_aMoy)
    def get_cMoy(self): return self._cMoy
    def set_cMoy(self, value):
        self._cMoy = value
        update_node(self,self.troot,'trees')
    cMoy = property(get_cMoy, set_cMoy)
    def get_bMoy(self): return self._bMoy
    def set_bMoy(self, value):
        self._bMoy = value
        update_node(self,self.troot,'trees')
    bMoy = property(get_bMoy, set_bMoy)
    def get_stdDevBMoy(self): return self._stdDevBMoy
    def set_stdDevBMoy(self, value):
        self._stdDevBMoy = value
        update_node(self,self.troot,'trees')
    stdDevBMoy = property(get_stdDevBMoy, set_stdDevBMoy)
    def get_stdDevCMoy(self): return self._stdDevCMoy
    def set_stdDevCMoy(self, value):
        self._stdDevCMoy = value
        update_node(self,self.troot,'trees')
    stdDevCMoy = property(get_stdDevCMoy, set_stdDevCMoy)
    def get_stdDevAMoy(self): return self._stdDevAMoy
    def set_stdDevAMoy(self, value):
        self._stdDevAMoy = value
        update_node(self,self.troot,'trees')
    stdDevAMoy = property(get_stdDevAMoy, set_stdDevAMoy)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_CrownConeComp', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_CrownConeComp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_CrownConeComp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_CrownConeComp', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_CrownConeComp'):
        if self.aMoy is not None and 'aMoy' not in already_processed:
            already_processed.add('aMoy')
            outfile.write(' aMoy="%s"' % self.gds_format_double(self.aMoy, input_name='aMoy'))
        if self.cMoy is not None and 'cMoy' not in already_processed:
            already_processed.add('cMoy')
            outfile.write(' cMoy="%s"' % self.gds_format_double(self.cMoy, input_name='cMoy'))
        if self.bMoy is not None and 'bMoy' not in already_processed:
            already_processed.add('bMoy')
            outfile.write(' bMoy="%s"' % self.gds_format_double(self.bMoy, input_name='bMoy'))
        if self.stdDevBMoy is not None and 'stdDevBMoy' not in already_processed:
            already_processed.add('stdDevBMoy')
            outfile.write(' stdDevBMoy="%s"' % self.gds_format_double(self.stdDevBMoy, input_name='stdDevBMoy'))
        if self.stdDevCMoy is not None and 'stdDevCMoy' not in already_processed:
            already_processed.add('stdDevCMoy')
            outfile.write(' stdDevCMoy="%s"' % self.gds_format_double(self.stdDevCMoy, input_name='stdDevCMoy'))
        if self.stdDevAMoy is not None and 'stdDevAMoy' not in already_processed:
            already_processed.add('stdDevAMoy')
            outfile.write(' stdDevAMoy="%s"' % self.gds_format_double(self.stdDevAMoy, input_name='stdDevAMoy'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_CrownConeComp', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_CrownConeComp', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.aMoy is not None:
            element.set('aMoy', self.gds_format_double(self.aMoy))
        if self.cMoy is not None:
            element.set('cMoy', self.gds_format_double(self.cMoy))
        if self.bMoy is not None:
            element.set('bMoy', self.gds_format_double(self.bMoy))
        if self.stdDevBMoy is not None:
            element.set('stdDevBMoy', self.gds_format_double(self.stdDevBMoy))
        if self.stdDevCMoy is not None:
            element.set('stdDevCMoy', self.gds_format_double(self.stdDevCMoy))
        if self.stdDevAMoy is not None:
            element.set('stdDevAMoy', self.gds_format_double(self.stdDevAMoy))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_CrownConeComp'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.aMoy is not None and 'aMoy' not in already_processed:
            already_processed.add('aMoy')
            showIndent(outfile, level)
            outfile.write('aMoy=%e,\n' % (self.aMoy,))
        if self.cMoy is not None and 'cMoy' not in already_processed:
            already_processed.add('cMoy')
            showIndent(outfile, level)
            outfile.write('cMoy=%e,\n' % (self.cMoy,))
        if self.bMoy is not None and 'bMoy' not in already_processed:
            already_processed.add('bMoy')
            showIndent(outfile, level)
            outfile.write('bMoy=%e,\n' % (self.bMoy,))
        if self.stdDevBMoy is not None and 'stdDevBMoy' not in already_processed:
            already_processed.add('stdDevBMoy')
            showIndent(outfile, level)
            outfile.write('stdDevBMoy=%e,\n' % (self.stdDevBMoy,))
        if self.stdDevCMoy is not None and 'stdDevCMoy' not in already_processed:
            already_processed.add('stdDevCMoy')
            showIndent(outfile, level)
            outfile.write('stdDevCMoy=%e,\n' % (self.stdDevCMoy,))
        if self.stdDevAMoy is not None and 'stdDevAMoy' not in already_processed:
            already_processed.add('stdDevAMoy')
            showIndent(outfile, level)
            outfile.write('stdDevAMoy=%e,\n' % (self.stdDevAMoy,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aMoy', node)
        if value is not None and 'aMoy' not in already_processed:
            already_processed.add('aMoy')
            try:
                self.aMoy = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (aMoy): %s' % exp)
        value = find_attr_value_('cMoy', node)
        if value is not None and 'cMoy' not in already_processed:
            already_processed.add('cMoy')
            try:
                self.cMoy = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (cMoy): %s' % exp)
        value = find_attr_value_('bMoy', node)
        if value is not None and 'bMoy' not in already_processed:
            already_processed.add('bMoy')
            try:
                self.bMoy = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (bMoy): %s' % exp)
        value = find_attr_value_('stdDevBMoy', node)
        if value is not None and 'stdDevBMoy' not in already_processed:
            already_processed.add('stdDevBMoy')
            try:
                self.stdDevBMoy = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (stdDevBMoy): %s' % exp)
        value = find_attr_value_('stdDevCMoy', node)
        if value is not None and 'stdDevCMoy' not in already_processed:
            already_processed.add('stdDevCMoy')
            try:
                self.stdDevCMoy = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (stdDevCMoy): %s' % exp)
        value = find_attr_value_('stdDevAMoy', node)
        if value is not None and 'stdDevAMoy' not in already_processed:
            already_processed.add('stdDevAMoy')
            try:
                self.stdDevAMoy = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (stdDevAMoy): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_CrownConeComp


class create_Trees_3(GeneratedsSuper):
    """Trees_3 Trees_3"""
    member_data_items_ = [
        MemberSpec_('Specie_3', '_Specie_3', 1, 0, {'name': 'Specie_3', 'type': '_Specie_3', 'minOccurs': '1', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Specie_3=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_Trees_3')
        self.attrib = ['']
        self.children = ['Specie_3']
        self.parent = None
        if Specie_3 is None:
            self._Specie_3 = []
        else:
            self._Specie_3 = Specie_3
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Trees_3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Trees_3.subclass:
            return create_Trees_3.subclass(*args_, **kwargs_)
        else:
            return create_Trees_3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Specie_3(self): return self._Specie_3
    def set_Specie_3(self, value):
        if value is not None:
            checkclass(value, create_Specie_3)
            for v in value:
                v.parent = self
        self._Specie_3 = value
    def add_Specie_3(self, value):
        value.parent = self
        self._Specie_3.append(value)
    def insert_Specie_3_at(self, index, value):
        value.parent = self
        self.Specie_3.insert(index, value)
    def replace_Specie_3_at(self, index, value):
        value.parent = self
        self.Specie_3[index] = value
    Specie_3 = property(get_Specie_3, set_Specie_3)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Specie_3
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Trees_3', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Trees_3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Trees_3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Trees_3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Trees_3'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Trees_3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Specie_3_ in self.Specie_3:
            Specie_3_.export(outfile, level, namespaceprefix_, name_='Specie_3', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Trees_3', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for Specie_3_ in self.Specie_3:
            Specie_3_.to_etree(element, name_='Specie_3', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Trees_3'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Specie_3=[\n')
        level += 1
        for Specie_3_ in self.Specie_3:
            showIndent(outfile, level)
            outfile.write('model_._Specie_3(\n')
            Specie_3_.exportLiteral(outfile, level, name_='_Specie_3')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.Specie_3 = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Specie_3':
            obj_ = create_Specie_3.factory()
            obj_.build(child_)
            self.add_Specie_3(obj_)
            obj_.original_tagname_ = 'Specie_3'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_Trees_3


class create_Specie_3(GeneratedsSuper):
    """Specie_3 Specie_3 Probability that trees are present around the
    nodes of the specified grid Probability that trees are present
    around the nodes of the specified grid LAI LAI Radius of the
    disks within which trees must be located. Disks are centred on
    the nodes of the specified grid. Radius of the disks within
    which trees must be located. Disks are centred on the nodes of
    the specified grid. Tree distribution method Tree distribution
    method Simulation of trees with branches and twigs Simulation of
    trees with branches and twigs spatialDistribution
    spatialDistribution"""
    member_data_items_ = [
        MemberSpec_('probabilityOfTreesAtTheNodesOfTheGrid', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('lai', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('rayon', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('treeDistributionMethod', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('branchesAndTwigsSimulation', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('spatialDistribution', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('IntervalDistribution', '_IntervalDistribution', 0, 0, {'name': 'IntervalDistribution', 'type': '_IntervalDistribution', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('EstimatedNumberOfTreeDistribution', '_EstimatedNumberOfTreeDistribution', 0, 0, {'name': 'EstimatedNumberOfTreeDistribution', 'type': '_EstimatedNumberOfTreeDistribution', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('OpticalPropertyLink', '_OpticalPropertyLink', 0, 0, {'name': 'OpticalPropertyLink', 'type': '_OpticalPropertyLink', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('ThermalPropertyLink', '_ThermalPropertyLink', 0, 0, {'name': 'ThermalPropertyLink', 'type': '_ThermalPropertyLink', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('Trunk', '_Trunk', 0, 0, {'name': 'Trunk', 'type': '_Trunk', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('Crown', '_Crown', 0, 0, {'name': 'Crown', 'type': '_Crown', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('EllipsoidSubZone', '_EllipsoidSubZone', 0, 0, {'name': 'EllipsoidSubZone', 'type': '_EllipsoidSubZone', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('Polygon2D', '_Polygon2D', 0, 0, {'name': 'Polygon2D', 'type': '_Polygon2D', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('CrownLevel', '_CrownLevel', 1, 0, {'name': 'CrownLevel', 'type': '_CrownLevel', 'minOccurs': '1', 'maxOccurs': 'unbounded'}, None),
        MemberSpec_('BranchesAndTwigs', '_BranchesAndTwigs', 0, 0, {'name': 'BranchesAndTwigs', 'type': '_BranchesAndTwigs', 'minOccurs': '1', 'maxOccurs': '1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, probabilityOfTreesAtTheNodesOfTheGrid=0.90, lai=4.00, rayon=5.00, treeDistributionMethod=0, branchesAndTwigsSimulation=0, spatialDistribution=0, IntervalDistribution=None, EstimatedNumberOfTreeDistribution=None, OpticalPropertyLink=None, ThermalPropertyLink=None, Trunk=None, Crown=None, EllipsoidSubZone=None, Polygon2D=None, CrownLevel=None, BranchesAndTwigs=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_Specie_3')
        self.attrib = ['probabilityOfTreesAtTheNodesOfTheGrid', 'lai', 'rayon', 'treeDistributionMethod', 'branchesAndTwigsSimulation', 'spatialDistribution']
        self.children = ['IntervalDistribution', 'EstimatedNumberOfTreeDistribution', 'OpticalPropertyLink', 'ThermalPropertyLink', 'Trunk', 'Crown', 'EllipsoidSubZone', 'Polygon2D', 'CrownLevel', 'BranchesAndTwigs']
        self.parent = None
        self._probabilityOfTreesAtTheNodesOfTheGrid = _cast(float, probabilityOfTreesAtTheNodesOfTheGrid)
        self._lai = _cast(float, lai)
        self._rayon = _cast(float, rayon)
        self._treeDistributionMethod = _cast(int, treeDistributionMethod)
        self._branchesAndTwigsSimulation = _cast(int, branchesAndTwigsSimulation)
        self._spatialDistribution = _cast(int, spatialDistribution)
        self._IntervalDistribution = IntervalDistribution
        self._EstimatedNumberOfTreeDistribution = EstimatedNumberOfTreeDistribution
        self._OpticalPropertyLink = OpticalPropertyLink
        self._ThermalPropertyLink = ThermalPropertyLink
        self._Trunk = Trunk
        self._Crown = Crown
        self._EllipsoidSubZone = EllipsoidSubZone
        self._Polygon2D = Polygon2D
        if CrownLevel is None:
            self._CrownLevel = []
        else:
            self._CrownLevel = CrownLevel
        self._BranchesAndTwigs = BranchesAndTwigs
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Specie_3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Specie_3.subclass:
            return create_Specie_3.subclass(*args_, **kwargs_)
        else:
            return create_Specie_3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IntervalDistribution(self): return self._IntervalDistribution
    def set_IntervalDistribution(self, value):
        if value is not None:
            checkclass(value, create_IntervalDistribution)
            value.parent = self
        self._IntervalDistribution = value
    IntervalDistribution = property(get_IntervalDistribution, set_IntervalDistribution)
    def get_EstimatedNumberOfTreeDistribution(self): return self._EstimatedNumberOfTreeDistribution
    def set_EstimatedNumberOfTreeDistribution(self, value):
        if value is not None:
            checkclass(value, create_EstimatedNumberOfTreeDistribution)
            value.parent = self
        self._EstimatedNumberOfTreeDistribution = value
    EstimatedNumberOfTreeDistribution = property(get_EstimatedNumberOfTreeDistribution, set_EstimatedNumberOfTreeDistribution)
    def get_OpticalPropertyLink(self): return self._OpticalPropertyLink
    def set_OpticalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_OpticalPropertyLink)
            value.parent = self
        self._OpticalPropertyLink = value
    OpticalPropertyLink = property(get_OpticalPropertyLink, set_OpticalPropertyLink)
    def get_ThermalPropertyLink(self): return self._ThermalPropertyLink
    def set_ThermalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_ThermalPropertyLink)
            value.parent = self
        self._ThermalPropertyLink = value
    ThermalPropertyLink = property(get_ThermalPropertyLink, set_ThermalPropertyLink)
    def get_Trunk(self): return self._Trunk
    def set_Trunk(self, value):
        if value is not None:
            checkclass(value, create_Trunk)
            value.parent = self
        self._Trunk = value
    Trunk = property(get_Trunk, set_Trunk)
    def get_Crown(self): return self._Crown
    def set_Crown(self, value):
        if value is not None:
            checkclass(value, create_Crown)
            value.parent = self
        self._Crown = value
    Crown = property(get_Crown, set_Crown)
    def get_EllipsoidSubZone(self): return self._EllipsoidSubZone
    def set_EllipsoidSubZone(self, value):
        if value is not None:
            checkclass(value, create_EllipsoidSubZone)
            value.parent = self
        self._EllipsoidSubZone = value
    EllipsoidSubZone = property(get_EllipsoidSubZone, set_EllipsoidSubZone)
    def get_Polygon2D(self): return self._Polygon2D
    def set_Polygon2D(self, value):
        if value is not None:
            checkclass(value, create_Polygon2D)
            value.parent = self
        self._Polygon2D = value
    Polygon2D = property(get_Polygon2D, set_Polygon2D)
    def get_CrownLevel(self): return self._CrownLevel
    def set_CrownLevel(self, value):
        if value is not None:
            checkclass(value, create_CrownLevel)
            for v in value:
                v.parent = self
        self._CrownLevel = value
    def add_CrownLevel(self, value):
        value.parent = self
        self._CrownLevel.append(value)
    def insert_CrownLevel_at(self, index, value):
        value.parent = self
        self.CrownLevel.insert(index, value)
    def replace_CrownLevel_at(self, index, value):
        value.parent = self
        self.CrownLevel[index] = value
    CrownLevel = property(get_CrownLevel, set_CrownLevel)
    def get_BranchesAndTwigs(self): return self._BranchesAndTwigs
    def set_BranchesAndTwigs(self, value):
        if value is not None:
            checkclass(value, create_BranchesAndTwigs)
            value.parent = self
        self._BranchesAndTwigs = value
    BranchesAndTwigs = property(get_BranchesAndTwigs, set_BranchesAndTwigs)
    def get_probabilityOfTreesAtTheNodesOfTheGrid(self): return self._probabilityOfTreesAtTheNodesOfTheGrid
    def set_probabilityOfTreesAtTheNodesOfTheGrid(self, value):
        self._probabilityOfTreesAtTheNodesOfTheGrid = value
        update_node(self,self.troot,'trees')
    probabilityOfTreesAtTheNodesOfTheGrid = property(get_probabilityOfTreesAtTheNodesOfTheGrid, set_probabilityOfTreesAtTheNodesOfTheGrid)
    def get_lai(self): return self._lai
    def set_lai(self, value):
        self._lai = value
        update_node(self,self.troot,'trees')
    lai = property(get_lai, set_lai)
    def get_rayon(self): return self._rayon
    def set_rayon(self, value):
        self._rayon = value
        update_node(self,self.troot,'trees')
    rayon = property(get_rayon, set_rayon)
    def get_treeDistributionMethod(self): return self._treeDistributionMethod
    def set_treeDistributionMethod(self, value):
        self._treeDistributionMethod = value
        update_node(self,self.troot,'trees')
    treeDistributionMethod = property(get_treeDistributionMethod, set_treeDistributionMethod)
    def get_branchesAndTwigsSimulation(self): return self._branchesAndTwigsSimulation
    def set_branchesAndTwigsSimulation(self, value):
        self._branchesAndTwigsSimulation = value
        update_node(self,self.troot,'trees')
    branchesAndTwigsSimulation = property(get_branchesAndTwigsSimulation, set_branchesAndTwigsSimulation)
    def get_spatialDistribution(self): return self._spatialDistribution
    def set_spatialDistribution(self, value):
        self._spatialDistribution = value
        update_node(self,self.troot,'trees')
    spatialDistribution = property(get_spatialDistribution, set_spatialDistribution)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.IntervalDistribution is not None or
            self.EstimatedNumberOfTreeDistribution is not None or
            self.OpticalPropertyLink is not None or
            self.ThermalPropertyLink is not None or
            self.Trunk is not None or
            self.Crown is not None or
            self.EllipsoidSubZone is not None or
            self.Polygon2D is not None or
            self.CrownLevel or
            self.BranchesAndTwigs is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Specie_3', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Specie_3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Specie_3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Specie_3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Specie_3'):
        if self.probabilityOfTreesAtTheNodesOfTheGrid is not None and 'probabilityOfTreesAtTheNodesOfTheGrid' not in already_processed:
            already_processed.add('probabilityOfTreesAtTheNodesOfTheGrid')
            outfile.write(' probabilityOfTreesAtTheNodesOfTheGrid="%s"' % self.gds_format_double(self.probabilityOfTreesAtTheNodesOfTheGrid, input_name='probabilityOfTreesAtTheNodesOfTheGrid'))
        if self.lai is not None and 'lai' not in already_processed:
            already_processed.add('lai')
            outfile.write(' lai="%s"' % self.gds_format_double(self.lai, input_name='lai'))
        if self.rayon is not None and 'rayon' not in already_processed:
            already_processed.add('rayon')
            outfile.write(' rayon="%s"' % self.gds_format_double(self.rayon, input_name='rayon'))
        if self.treeDistributionMethod is not None and 'treeDistributionMethod' not in already_processed:
            already_processed.add('treeDistributionMethod')
            outfile.write(' treeDistributionMethod="%s"' % self.gds_format_integer(self.treeDistributionMethod, input_name='treeDistributionMethod'))
        if self.branchesAndTwigsSimulation is not None and 'branchesAndTwigsSimulation' not in already_processed:
            already_processed.add('branchesAndTwigsSimulation')
            outfile.write(' branchesAndTwigsSimulation="%s"' % self.gds_format_integer(self.branchesAndTwigsSimulation, input_name='branchesAndTwigsSimulation'))
        if self.spatialDistribution is not None and 'spatialDistribution' not in already_processed:
            already_processed.add('spatialDistribution')
            outfile.write(' spatialDistribution="%s"' % self.gds_format_integer(self.spatialDistribution, input_name='spatialDistribution'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Specie_3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IntervalDistribution is not None:
            self.IntervalDistribution.export(outfile, level, namespaceprefix_, name_='IntervalDistribution', pretty_print=pretty_print)
        if self.EstimatedNumberOfTreeDistribution is not None:
            self.EstimatedNumberOfTreeDistribution.export(outfile, level, namespaceprefix_, name_='EstimatedNumberOfTreeDistribution', pretty_print=pretty_print)
        if self.OpticalPropertyLink is not None:
            self.OpticalPropertyLink.export(outfile, level, namespaceprefix_, name_='OpticalPropertyLink', pretty_print=pretty_print)
        if self.ThermalPropertyLink is not None:
            self.ThermalPropertyLink.export(outfile, level, namespaceprefix_, name_='ThermalPropertyLink', pretty_print=pretty_print)
        if self.Trunk is not None:
            self.Trunk.export(outfile, level, namespaceprefix_, name_='Trunk', pretty_print=pretty_print)
        if self.Crown is not None:
            self.Crown.export(outfile, level, namespaceprefix_, name_='Crown', pretty_print=pretty_print)
        if self.EllipsoidSubZone is not None:
            self.EllipsoidSubZone.export(outfile, level, namespaceprefix_, name_='EllipsoidSubZone', pretty_print=pretty_print)
        if self.Polygon2D is not None:
            self.Polygon2D.export(outfile, level, namespaceprefix_, name_='Polygon2D', pretty_print=pretty_print)
        for CrownLevel_ in self.CrownLevel:
            CrownLevel_.export(outfile, level, namespaceprefix_, name_='CrownLevel', pretty_print=pretty_print)
        if self.BranchesAndTwigs is not None:
            self.BranchesAndTwigs.export(outfile, level, namespaceprefix_, name_='BranchesAndTwigs', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Specie_3', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.probabilityOfTreesAtTheNodesOfTheGrid is not None:
            element.set('probabilityOfTreesAtTheNodesOfTheGrid', self.gds_format_double(self.probabilityOfTreesAtTheNodesOfTheGrid))
        if self.lai is not None:
            element.set('lai', self.gds_format_double(self.lai))
        if self.rayon is not None:
            element.set('rayon', self.gds_format_double(self.rayon))
        if self.treeDistributionMethod is not None:
            element.set('treeDistributionMethod', self.gds_format_integer(self.treeDistributionMethod))
        if self.branchesAndTwigsSimulation is not None:
            element.set('branchesAndTwigsSimulation', self.gds_format_integer(self.branchesAndTwigsSimulation))
        if self.spatialDistribution is not None:
            element.set('spatialDistribution', self.gds_format_integer(self.spatialDistribution))
        if self.IntervalDistribution is not None:
            IntervalDistribution_ = self.IntervalDistribution
            IntervalDistribution_.to_etree(element, name_='IntervalDistribution', mapping_=mapping_)
        if self.EstimatedNumberOfTreeDistribution is not None:
            EstimatedNumberOfTreeDistribution_ = self.EstimatedNumberOfTreeDistribution
            EstimatedNumberOfTreeDistribution_.to_etree(element, name_='EstimatedNumberOfTreeDistribution', mapping_=mapping_)
        if self.OpticalPropertyLink is not None:
            OpticalPropertyLink_ = self.OpticalPropertyLink
            OpticalPropertyLink_.to_etree(element, name_='OpticalPropertyLink', mapping_=mapping_)
        if self.ThermalPropertyLink is not None:
            ThermalPropertyLink_ = self.ThermalPropertyLink
            ThermalPropertyLink_.to_etree(element, name_='ThermalPropertyLink', mapping_=mapping_)
        if self.Trunk is not None:
            Trunk_ = self.Trunk
            Trunk_.to_etree(element, name_='Trunk', mapping_=mapping_)
        if self.Crown is not None:
            Crown_ = self.Crown
            Crown_.to_etree(element, name_='Crown', mapping_=mapping_)
        if self.EllipsoidSubZone is not None:
            EllipsoidSubZone_ = self.EllipsoidSubZone
            EllipsoidSubZone_.to_etree(element, name_='EllipsoidSubZone', mapping_=mapping_)
        if self.Polygon2D is not None:
            Polygon2D_ = self.Polygon2D
            Polygon2D_.to_etree(element, name_='Polygon2D', mapping_=mapping_)
        for CrownLevel_ in self.CrownLevel:
            CrownLevel_.to_etree(element, name_='CrownLevel', mapping_=mapping_)
        if self.BranchesAndTwigs is not None:
            BranchesAndTwigs_ = self.BranchesAndTwigs
            BranchesAndTwigs_.to_etree(element, name_='BranchesAndTwigs', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Specie_3'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.probabilityOfTreesAtTheNodesOfTheGrid is not None and 'probabilityOfTreesAtTheNodesOfTheGrid' not in already_processed:
            already_processed.add('probabilityOfTreesAtTheNodesOfTheGrid')
            showIndent(outfile, level)
            outfile.write('probabilityOfTreesAtTheNodesOfTheGrid=%e,\n' % (self.probabilityOfTreesAtTheNodesOfTheGrid,))
        if self.lai is not None and 'lai' not in already_processed:
            already_processed.add('lai')
            showIndent(outfile, level)
            outfile.write('lai=%e,\n' % (self.lai,))
        if self.rayon is not None and 'rayon' not in already_processed:
            already_processed.add('rayon')
            showIndent(outfile, level)
            outfile.write('rayon=%e,\n' % (self.rayon,))
        if self.treeDistributionMethod is not None and 'treeDistributionMethod' not in already_processed:
            already_processed.add('treeDistributionMethod')
            showIndent(outfile, level)
            outfile.write('treeDistributionMethod=%d,\n' % (self.treeDistributionMethod,))
        if self.branchesAndTwigsSimulation is not None and 'branchesAndTwigsSimulation' not in already_processed:
            already_processed.add('branchesAndTwigsSimulation')
            showIndent(outfile, level)
            outfile.write('branchesAndTwigsSimulation=%d,\n' % (self.branchesAndTwigsSimulation,))
        if self.spatialDistribution is not None and 'spatialDistribution' not in already_processed:
            already_processed.add('spatialDistribution')
            showIndent(outfile, level)
            outfile.write('spatialDistribution=%d,\n' % (self.spatialDistribution,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.IntervalDistribution is not None:
            showIndent(outfile, level)
            outfile.write('IntervalDistribution=model_._IntervalDistribution(\n')
            self.IntervalDistribution.exportLiteral(outfile, level, name_='IntervalDistribution')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EstimatedNumberOfTreeDistribution is not None:
            showIndent(outfile, level)
            outfile.write('EstimatedNumberOfTreeDistribution=model_._EstimatedNumberOfTreeDistribution(\n')
            self.EstimatedNumberOfTreeDistribution.exportLiteral(outfile, level, name_='EstimatedNumberOfTreeDistribution')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OpticalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('OpticalPropertyLink=model_._OpticalPropertyLink(\n')
            self.OpticalPropertyLink.exportLiteral(outfile, level, name_='OpticalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ThermalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('ThermalPropertyLink=model_._ThermalPropertyLink(\n')
            self.ThermalPropertyLink.exportLiteral(outfile, level, name_='ThermalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Trunk is not None:
            showIndent(outfile, level)
            outfile.write('Trunk=model_._Trunk(\n')
            self.Trunk.exportLiteral(outfile, level, name_='Trunk')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Crown is not None:
            showIndent(outfile, level)
            outfile.write('Crown=model_._Crown(\n')
            self.Crown.exportLiteral(outfile, level, name_='Crown')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EllipsoidSubZone is not None:
            showIndent(outfile, level)
            outfile.write('EllipsoidSubZone=model_._EllipsoidSubZone(\n')
            self.EllipsoidSubZone.exportLiteral(outfile, level, name_='EllipsoidSubZone')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Polygon2D is not None:
            showIndent(outfile, level)
            outfile.write('Polygon2D=model_._Polygon2D(\n')
            self.Polygon2D.exportLiteral(outfile, level, name_='Polygon2D')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('CrownLevel=[\n')
        level += 1
        for CrownLevel_ in self.CrownLevel:
            showIndent(outfile, level)
            outfile.write('model_._CrownLevel(\n')
            CrownLevel_.exportLiteral(outfile, level, name_='_CrownLevel')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.BranchesAndTwigs is not None:
            showIndent(outfile, level)
            outfile.write('BranchesAndTwigs=model_._BranchesAndTwigs(\n')
            self.BranchesAndTwigs.exportLiteral(outfile, level, name_='BranchesAndTwigs')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.CrownLevel = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('probabilityOfTreesAtTheNodesOfTheGrid', node)
        if value is not None and 'probabilityOfTreesAtTheNodesOfTheGrid' not in already_processed:
            already_processed.add('probabilityOfTreesAtTheNodesOfTheGrid')
            try:
                self.probabilityOfTreesAtTheNodesOfTheGrid = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (probabilityOfTreesAtTheNodesOfTheGrid): %s' % exp)
        value = find_attr_value_('lai', node)
        if value is not None and 'lai' not in already_processed:
            already_processed.add('lai')
            try:
                self.lai = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (lai): %s' % exp)
        value = find_attr_value_('rayon', node)
        if value is not None and 'rayon' not in already_processed:
            already_processed.add('rayon')
            try:
                self.rayon = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (rayon): %s' % exp)
        value = find_attr_value_('treeDistributionMethod', node)
        if value is not None and 'treeDistributionMethod' not in already_processed:
            already_processed.add('treeDistributionMethod')
            try:
                self.treeDistributionMethod = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('branchesAndTwigsSimulation', node)
        if value is not None and 'branchesAndTwigsSimulation' not in already_processed:
            already_processed.add('branchesAndTwigsSimulation')
            try:
                self.branchesAndTwigsSimulation = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('spatialDistribution', node)
        if value is not None and 'spatialDistribution' not in already_processed:
            already_processed.add('spatialDistribution')
            try:
                self.spatialDistribution = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IntervalDistribution':
            obj_ = create_IntervalDistribution.factory()
            obj_.build(child_)
            self.set_IntervalDistribution(obj_)
            obj_.original_tagname_ = 'IntervalDistribution'
        elif nodeName_ == 'EstimatedNumberOfTreeDistribution':
            obj_ = create_EstimatedNumberOfTreeDistribution.factory()
            obj_.build(child_)
            self.set_EstimatedNumberOfTreeDistribution(obj_)
            obj_.original_tagname_ = 'EstimatedNumberOfTreeDistribution'
        elif nodeName_ == 'OpticalPropertyLink':
            obj_ = create_OpticalPropertyLink.factory()
            obj_.build(child_)
            self.set_OpticalPropertyLink(obj_)
            obj_.original_tagname_ = 'OpticalPropertyLink'
        elif nodeName_ == 'ThermalPropertyLink':
            obj_ = create_ThermalPropertyLink.factory()
            obj_.build(child_)
            self.set_ThermalPropertyLink(obj_)
            obj_.original_tagname_ = 'ThermalPropertyLink'
        elif nodeName_ == 'Trunk':
            obj_ = create_Trunk.factory()
            obj_.build(child_)
            self.set_Trunk(obj_)
            obj_.original_tagname_ = 'Trunk'
        elif nodeName_ == 'Crown':
            obj_ = create_Crown.factory()
            obj_.build(child_)
            self.set_Crown(obj_)
            obj_.original_tagname_ = 'Crown'
        elif nodeName_ == 'EllipsoidSubZone':
            obj_ = create_EllipsoidSubZone.factory()
            obj_.build(child_)
            self.set_EllipsoidSubZone(obj_)
            obj_.original_tagname_ = 'EllipsoidSubZone'
        elif nodeName_ == 'Polygon2D':
            obj_ = create_Polygon2D.factory()
            obj_.build(child_)
            self.set_Polygon2D(obj_)
            obj_.original_tagname_ = 'Polygon2D'
        elif nodeName_ == 'CrownLevel':
            obj_ = create_CrownLevel.factory()
            obj_.build(child_)
            self.add_CrownLevel(obj_)
            obj_.original_tagname_ = 'CrownLevel'
        elif nodeName_ == 'BranchesAndTwigs':
            obj_ = create_BranchesAndTwigs.factory()
            obj_.build(child_)
            self.set_BranchesAndTwigs(obj_)
            obj_.original_tagname_ = 'BranchesAndTwigs'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_Specie_3


class create_IntervalDistribution(GeneratedsSuper):
    """Interval between trees Interval between trees Inter-trees distance
    (dx) Inter-trees distance (dx) Inter-trees distance (dy) Inter-
    trees distance (dy)"""
    member_data_items_ = [
        MemberSpec_('rawX', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('rawY', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, rawX=5.00, rawY=5.00):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_IntervalDistribution')
        self.attrib = ['rawX', 'rawY']
        self.children = []
        self.parent = None
        self._rawX = _cast(float, rawX)
        self._rawY = _cast(float, rawY)
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_IntervalDistribution)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_IntervalDistribution.subclass:
            return create_IntervalDistribution.subclass(*args_, **kwargs_)
        else:
            return create_IntervalDistribution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rawX(self): return self._rawX
    def set_rawX(self, value):
        self._rawX = value
        update_node(self,self.troot,'trees')
    rawX = property(get_rawX, set_rawX)
    def get_rawY(self): return self._rawY
    def set_rawY(self, value):
        self._rawY = value
        update_node(self,self.troot,'trees')
    rawY = property(get_rawY, set_rawY)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_IntervalDistribution', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_IntervalDistribution')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_IntervalDistribution')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_IntervalDistribution', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_IntervalDistribution'):
        if self.rawX is not None and 'rawX' not in already_processed:
            already_processed.add('rawX')
            outfile.write(' rawX="%s"' % self.gds_format_double(self.rawX, input_name='rawX'))
        if self.rawY is not None and 'rawY' not in already_processed:
            already_processed.add('rawY')
            outfile.write(' rawY="%s"' % self.gds_format_double(self.rawY, input_name='rawY'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_IntervalDistribution', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_IntervalDistribution', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.rawX is not None:
            element.set('rawX', self.gds_format_double(self.rawX))
        if self.rawY is not None:
            element.set('rawY', self.gds_format_double(self.rawY))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_IntervalDistribution'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.rawX is not None and 'rawX' not in already_processed:
            already_processed.add('rawX')
            showIndent(outfile, level)
            outfile.write('rawX=%e,\n' % (self.rawX,))
        if self.rawY is not None and 'rawY' not in already_processed:
            already_processed.add('rawY')
            showIndent(outfile, level)
            outfile.write('rawY=%e,\n' % (self.rawY,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rawX', node)
        if value is not None and 'rawX' not in already_processed:
            already_processed.add('rawX')
            try:
                self.rawX = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (rawX): %s' % exp)
        value = find_attr_value_('rawY', node)
        if value is not None and 'rawY' not in already_processed:
            already_processed.add('rawY')
            try:
                self.rawY = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (rawY): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_IntervalDistribution


class create_EstimatedNumberOfTreeDistribution(GeneratedsSuper):
    """Estimated number of trees Estimated number of trees Estimated number
    of trees Estimated number of trees"""
    member_data_items_ = [
        MemberSpec_('estimatedNumberOfTrees', 'xsd:int', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, estimatedNumberOfTrees=12):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_EstimatedNumberOfTreeDistribution')
        self.attrib = ['estimatedNumberOfTrees']
        self.children = []
        self.parent = None
        self._estimatedNumberOfTrees = _cast(int, estimatedNumberOfTrees)
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_EstimatedNumberOfTreeDistribution)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_EstimatedNumberOfTreeDistribution.subclass:
            return create_EstimatedNumberOfTreeDistribution.subclass(*args_, **kwargs_)
        else:
            return create_EstimatedNumberOfTreeDistribution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_estimatedNumberOfTrees(self): return self._estimatedNumberOfTrees
    def set_estimatedNumberOfTrees(self, value):
        self._estimatedNumberOfTrees = value
        update_node(self,self.troot,'trees')
    estimatedNumberOfTrees = property(get_estimatedNumberOfTrees, set_estimatedNumberOfTrees)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_EstimatedNumberOfTreeDistribution', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_EstimatedNumberOfTreeDistribution')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_EstimatedNumberOfTreeDistribution')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_EstimatedNumberOfTreeDistribution', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_EstimatedNumberOfTreeDistribution'):
        if self.estimatedNumberOfTrees is not None and 'estimatedNumberOfTrees' not in already_processed:
            already_processed.add('estimatedNumberOfTrees')
            outfile.write(' estimatedNumberOfTrees="%s"' % self.gds_format_integer(self.estimatedNumberOfTrees, input_name='estimatedNumberOfTrees'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_EstimatedNumberOfTreeDistribution', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_EstimatedNumberOfTreeDistribution', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.estimatedNumberOfTrees is not None:
            element.set('estimatedNumberOfTrees', self.gds_format_integer(self.estimatedNumberOfTrees))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_EstimatedNumberOfTreeDistribution'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.estimatedNumberOfTrees is not None and 'estimatedNumberOfTrees' not in already_processed:
            already_processed.add('estimatedNumberOfTrees')
            showIndent(outfile, level)
            outfile.write('estimatedNumberOfTrees=%d,\n' % (self.estimatedNumberOfTrees,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('estimatedNumberOfTrees', node)
        if value is not None and 'estimatedNumberOfTrees' not in already_processed:
            already_processed.add('estimatedNumberOfTrees')
            try:
                self.estimatedNumberOfTrees = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_EstimatedNumberOfTreeDistribution


class create_EllipsoidSubZone(GeneratedsSuper):
    """EllipsoidSubZone EllipsoidSubZone X axis (radius) for ellipse X axis
    (radius) for ellipse y coordinate of the center of the
    elliptical zone y coordinate of the center of the elliptical
    zone Y axis (radius) for ellipse Y axis (radius) for ellipse x
    coordinate of the center of the elliptical zone x coordinate of
    the center of the elliptical zone"""
    member_data_items_ = [
        MemberSpec_('radiusXEllipseZoneTree', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('ellipseCenterY0', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('radiusYEllipseZoneTree', 'xsd:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('ellipseCenterX0', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, radiusXEllipseZoneTree=2.0, ellipseCenterY0=5.0, radiusYEllipseZoneTree=3.0, ellipseCenterX0=5.0):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_EllipsoidSubZone')
        self.attrib = ['radiusXEllipseZoneTree', 'ellipseCenterY0', 'radiusYEllipseZoneTree', 'ellipseCenterX0']
        self.children = []
        self.parent = None
        self._radiusXEllipseZoneTree = _cast(float, radiusXEllipseZoneTree)
        self._ellipseCenterY0 = _cast(float, ellipseCenterY0)
        self._radiusYEllipseZoneTree = _cast(float, radiusYEllipseZoneTree)
        self._ellipseCenterX0 = _cast(float, ellipseCenterX0)
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_EllipsoidSubZone)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_EllipsoidSubZone.subclass:
            return create_EllipsoidSubZone.subclass(*args_, **kwargs_)
        else:
            return create_EllipsoidSubZone(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_radiusXEllipseZoneTree(self): return self._radiusXEllipseZoneTree
    def set_radiusXEllipseZoneTree(self, value):
        self._radiusXEllipseZoneTree = value
        update_node(self,self.troot,'trees')
    radiusXEllipseZoneTree = property(get_radiusXEllipseZoneTree, set_radiusXEllipseZoneTree)
    def get_ellipseCenterY0(self): return self._ellipseCenterY0
    def set_ellipseCenterY0(self, value):
        self._ellipseCenterY0 = value
        update_node(self,self.troot,'trees')
    ellipseCenterY0 = property(get_ellipseCenterY0, set_ellipseCenterY0)
    def get_radiusYEllipseZoneTree(self): return self._radiusYEllipseZoneTree
    def set_radiusYEllipseZoneTree(self, value):
        self._radiusYEllipseZoneTree = value
        update_node(self,self.troot,'trees')
    radiusYEllipseZoneTree = property(get_radiusYEllipseZoneTree, set_radiusYEllipseZoneTree)
    def get_ellipseCenterX0(self): return self._ellipseCenterX0
    def set_ellipseCenterX0(self, value):
        self._ellipseCenterX0 = value
        update_node(self,self.troot,'trees')
    ellipseCenterX0 = property(get_ellipseCenterX0, set_ellipseCenterX0)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_EllipsoidSubZone', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_EllipsoidSubZone')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_EllipsoidSubZone')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_EllipsoidSubZone', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_EllipsoidSubZone'):
        if self.radiusXEllipseZoneTree is not None and 'radiusXEllipseZoneTree' not in already_processed:
            already_processed.add('radiusXEllipseZoneTree')
            outfile.write(' radiusXEllipseZoneTree="%s"' % self.gds_format_double(self.radiusXEllipseZoneTree, input_name='radiusXEllipseZoneTree'))
        if self.ellipseCenterY0 is not None and 'ellipseCenterY0' not in already_processed:
            already_processed.add('ellipseCenterY0')
            outfile.write(' ellipseCenterY0="%s"' % self.gds_format_double(self.ellipseCenterY0, input_name='ellipseCenterY0'))
        if self.radiusYEllipseZoneTree is not None and 'radiusYEllipseZoneTree' not in already_processed:
            already_processed.add('radiusYEllipseZoneTree')
            outfile.write(' radiusYEllipseZoneTree="%s"' % self.gds_format_double(self.radiusYEllipseZoneTree, input_name='radiusYEllipseZoneTree'))
        if self.ellipseCenterX0 is not None and 'ellipseCenterX0' not in already_processed:
            already_processed.add('ellipseCenterX0')
            outfile.write(' ellipseCenterX0="%s"' % self.gds_format_double(self.ellipseCenterX0, input_name='ellipseCenterX0'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_EllipsoidSubZone', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_EllipsoidSubZone', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.radiusXEllipseZoneTree is not None:
            element.set('radiusXEllipseZoneTree', self.gds_format_double(self.radiusXEllipseZoneTree))
        if self.ellipseCenterY0 is not None:
            element.set('ellipseCenterY0', self.gds_format_double(self.ellipseCenterY0))
        if self.radiusYEllipseZoneTree is not None:
            element.set('radiusYEllipseZoneTree', self.gds_format_double(self.radiusYEllipseZoneTree))
        if self.ellipseCenterX0 is not None:
            element.set('ellipseCenterX0', self.gds_format_double(self.ellipseCenterX0))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_EllipsoidSubZone'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.radiusXEllipseZoneTree is not None and 'radiusXEllipseZoneTree' not in already_processed:
            already_processed.add('radiusXEllipseZoneTree')
            showIndent(outfile, level)
            outfile.write('radiusXEllipseZoneTree=%e,\n' % (self.radiusXEllipseZoneTree,))
        if self.ellipseCenterY0 is not None and 'ellipseCenterY0' not in already_processed:
            already_processed.add('ellipseCenterY0')
            showIndent(outfile, level)
            outfile.write('ellipseCenterY0=%e,\n' % (self.ellipseCenterY0,))
        if self.radiusYEllipseZoneTree is not None and 'radiusYEllipseZoneTree' not in already_processed:
            already_processed.add('radiusYEllipseZoneTree')
            showIndent(outfile, level)
            outfile.write('radiusYEllipseZoneTree=%e,\n' % (self.radiusYEllipseZoneTree,))
        if self.ellipseCenterX0 is not None and 'ellipseCenterX0' not in already_processed:
            already_processed.add('ellipseCenterX0')
            showIndent(outfile, level)
            outfile.write('ellipseCenterX0=%e,\n' % (self.ellipseCenterX0,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('radiusXEllipseZoneTree', node)
        if value is not None and 'radiusXEllipseZoneTree' not in already_processed:
            already_processed.add('radiusXEllipseZoneTree')
            try:
                self.radiusXEllipseZoneTree = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (radiusXEllipseZoneTree): %s' % exp)
        value = find_attr_value_('ellipseCenterY0', node)
        if value is not None and 'ellipseCenterY0' not in already_processed:
            already_processed.add('ellipseCenterY0')
            try:
                self.ellipseCenterY0 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (ellipseCenterY0): %s' % exp)
        value = find_attr_value_('radiusYEllipseZoneTree', node)
        if value is not None and 'radiusYEllipseZoneTree' not in already_processed:
            already_processed.add('radiusYEllipseZoneTree')
            try:
                self.radiusYEllipseZoneTree = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (radiusYEllipseZoneTree): %s' % exp)
        value = find_attr_value_('ellipseCenterX0', node)
        if value is not None and 'ellipseCenterX0' not in already_processed:
            already_processed.add('ellipseCenterX0')
            try:
                self.ellipseCenterX0 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (ellipseCenterX0): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_EllipsoidSubZone


class create_Polygon2D(GeneratedsSuper):
    """Representation of a DART polygon. It's defined by its 4 corners,
    starting form the top left one, and turning anticlockwise.
    Representation of a DART polygon. It's defined by its 4 corners,
    starting form the top left one, and turning anticlockwise."""
    member_data_items_ = [
        MemberSpec_('Point2D', '_Point2D', 1, 0, {'name': 'Point2D', 'type': '_Point2D', 'minOccurs': '4', 'maxOccurs': '4'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Point2D=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_Polygon2D')
        self.attrib = ['']
        self.children = ['Point2D']
        self.parent = None
        if Point2D is None:
            self._Point2D = []
        else:
            self._Point2D = Point2D
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Polygon2D)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Polygon2D.subclass:
            return create_Polygon2D.subclass(*args_, **kwargs_)
        else:
            return create_Polygon2D(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Point2D(self): return self._Point2D
    def set_Point2D(self, value):
        if value is not None:
            checkclass(value, create_Point2D)
            for v in value:
                v.parent = self
        self._Point2D = value
    def add_Point2D(self, value):
        if (value is not None) and (len(self._Point2D) == 4):
            raise ValueError('Maximum length already reached.')
        value.parent = self
        self._Point2D.append(value)
    def insert_Point2D_at(self, index, value):
        if (value is not None) and (len(self._Point2D) == 4):
            raise ValueError('Maximum length already reached.')
        value.parent = self
        self.Point2D.insert(index, value)
    def replace_Point2D_at(self, index, value):
        value.parent = self
        self.Point2D[index] = value
    Point2D = property(get_Point2D, set_Point2D)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Point2D
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Polygon2D', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Polygon2D')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Polygon2D')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Polygon2D', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Polygon2D'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Polygon2D', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Point2D_ in self.Point2D:
            Point2D_.export(outfile, level, namespaceprefix_, name_='Point2D', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Polygon2D', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for Point2D_ in self.Point2D:
            Point2D_.to_etree(element, name_='Point2D', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Polygon2D'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Point2D=[\n')
        level += 1
        for Point2D_ in self.Point2D:
            showIndent(outfile, level)
            outfile.write('model_._Point2D(\n')
            Point2D_.exportLiteral(outfile, level, name_='_Point2D')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.Point2D = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Point2D':
            obj_ = create_Point2D.factory()
            obj_.build(child_)
            self.add_Point2D(obj_)
            obj_.original_tagname_ = 'Point2D'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_Polygon2D


class create_TreeGeneralOptions(GeneratedsSuper):
    """If checked, the tree's crowns will be represented as a cloud of
    triangles. Otherwise, they will be represented as a
    juxtaposition of turbid cells. If checked, the tree's crowns
    will be represented as a cloud of triangles. Otherwise, they
    will be represented as a juxtaposition of turbid cells."""
    member_data_items_ = [
        MemberSpec_('triangleTreeRepresentation', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('MeshTreeRepresentation', '_MeshTreeRepresentation', 0, 0, {'name': 'MeshTreeRepresentation', 'type': '_MeshTreeRepresentation', 'minOccurs': '1', 'maxOccurs': '1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, triangleTreeRepresentation=0, MeshTreeRepresentation=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_TreeGeneralOptions')
        self.attrib = ['triangleTreeRepresentation']
        self.children = ['MeshTreeRepresentation']
        self.parent = None
        self._triangleTreeRepresentation = _cast(int, triangleTreeRepresentation)
        self._MeshTreeRepresentation = MeshTreeRepresentation
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_TreeGeneralOptions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_TreeGeneralOptions.subclass:
            return create_TreeGeneralOptions.subclass(*args_, **kwargs_)
        else:
            return create_TreeGeneralOptions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MeshTreeRepresentation(self): return self._MeshTreeRepresentation
    def set_MeshTreeRepresentation(self, value):
        if value is not None:
            checkclass(value, create_MeshTreeRepresentation)
            value.parent = self
        self._MeshTreeRepresentation = value
    MeshTreeRepresentation = property(get_MeshTreeRepresentation, set_MeshTreeRepresentation)
    def get_triangleTreeRepresentation(self): return self._triangleTreeRepresentation
    def set_triangleTreeRepresentation(self, value):
        self._triangleTreeRepresentation = value
        update_node(self,self.troot,'trees')
    triangleTreeRepresentation = property(get_triangleTreeRepresentation, set_triangleTreeRepresentation)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.MeshTreeRepresentation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_TreeGeneralOptions', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_TreeGeneralOptions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_TreeGeneralOptions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_TreeGeneralOptions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_TreeGeneralOptions'):
        if self.triangleTreeRepresentation is not None and 'triangleTreeRepresentation' not in already_processed:
            already_processed.add('triangleTreeRepresentation')
            outfile.write(' triangleTreeRepresentation="%s"' % self.gds_format_integer(self.triangleTreeRepresentation, input_name='triangleTreeRepresentation'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_TreeGeneralOptions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MeshTreeRepresentation is not None:
            self.MeshTreeRepresentation.export(outfile, level, namespaceprefix_, name_='MeshTreeRepresentation', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_TreeGeneralOptions', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.triangleTreeRepresentation is not None:
            element.set('triangleTreeRepresentation', self.gds_format_integer(self.triangleTreeRepresentation))
        if self.MeshTreeRepresentation is not None:
            MeshTreeRepresentation_ = self.MeshTreeRepresentation
            MeshTreeRepresentation_.to_etree(element, name_='MeshTreeRepresentation', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_TreeGeneralOptions'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.triangleTreeRepresentation is not None and 'triangleTreeRepresentation' not in already_processed:
            already_processed.add('triangleTreeRepresentation')
            showIndent(outfile, level)
            outfile.write('triangleTreeRepresentation=%d,\n' % (self.triangleTreeRepresentation,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MeshTreeRepresentation is not None:
            showIndent(outfile, level)
            outfile.write('MeshTreeRepresentation=model_._MeshTreeRepresentation(\n')
            self.MeshTreeRepresentation.exportLiteral(outfile, level, name_='MeshTreeRepresentation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('triangleTreeRepresentation', node)
        if value is not None and 'triangleTreeRepresentation' not in already_processed:
            already_processed.add('triangleTreeRepresentation')
            try:
                self.triangleTreeRepresentation = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeshTreeRepresentation':
            obj_ = create_MeshTreeRepresentation.factory()
            obj_.build(child_)
            self.set_MeshTreeRepresentation(obj_)
            obj_.original_tagname_ = 'MeshTreeRepresentation'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_TreeGeneralOptions


class create_MeshTreeRepresentation(GeneratedsSuper):
    """Defines how the leaves are geometrically distributed in the crown.
    Defines how the leaves are geometrically distributed in the
    crown. Definition of the leaves geometry and numbers. Definition
    of the leaves geometry and numbers."""
    member_data_items_ = [
        MemberSpec_('distributionMode', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('leafDefinition', 'xsd:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('NumberOfTriangleParameters', '_NumberOfTriangleParameters', 0, 0, {'name': 'NumberOfTriangleParameters', 'type': '_NumberOfTriangleParameters', 'minOccurs': '1', 'maxOccurs': '1'}, None),
        MemberSpec_('MeshLeafDimensionParameters', '_MeshLeafDimensionParameters', 0, 0, {'name': 'MeshLeafDimensionParameters', 'type': '_MeshLeafDimensionParameters', 'minOccurs': '1', 'maxOccurs': '1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, distributionMode=0, leafDefinition=1, NumberOfTriangleParameters=None, MeshLeafDimensionParameters=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_MeshTreeRepresentation')
        self.attrib = ['distributionMode', 'leafDefinition']
        self.children = ['NumberOfTriangleParameters', 'MeshLeafDimensionParameters']
        self.parent = None
        self._distributionMode = _cast(int, distributionMode)
        self._leafDefinition = _cast(int, leafDefinition)
        self._NumberOfTriangleParameters = NumberOfTriangleParameters
        self._MeshLeafDimensionParameters = MeshLeafDimensionParameters
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_MeshTreeRepresentation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_MeshTreeRepresentation.subclass:
            return create_MeshTreeRepresentation.subclass(*args_, **kwargs_)
        else:
            return create_MeshTreeRepresentation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NumberOfTriangleParameters(self): return self._NumberOfTriangleParameters
    def set_NumberOfTriangleParameters(self, value):
        if value is not None:
            checkclass(value, create_NumberOfTriangleParameters)
            value.parent = self
        self._NumberOfTriangleParameters = value
    NumberOfTriangleParameters = property(get_NumberOfTriangleParameters, set_NumberOfTriangleParameters)
    def get_MeshLeafDimensionParameters(self): return self._MeshLeafDimensionParameters
    def set_MeshLeafDimensionParameters(self, value):
        if value is not None:
            checkclass(value, create_MeshLeafDimensionParameters)
            value.parent = self
        self._MeshLeafDimensionParameters = value
    MeshLeafDimensionParameters = property(get_MeshLeafDimensionParameters, set_MeshLeafDimensionParameters)
    def get_distributionMode(self): return self._distributionMode
    def set_distributionMode(self, value):
        self._distributionMode = value
        update_node(self,self.troot,'trees')
    distributionMode = property(get_distributionMode, set_distributionMode)
    def get_leafDefinition(self): return self._leafDefinition
    def set_leafDefinition(self, value):
        self._leafDefinition = value
        update_node(self,self.troot,'trees')
    leafDefinition = property(get_leafDefinition, set_leafDefinition)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.NumberOfTriangleParameters is not None or
            self.MeshLeafDimensionParameters is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_MeshTreeRepresentation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_MeshTreeRepresentation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_MeshTreeRepresentation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_MeshTreeRepresentation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_MeshTreeRepresentation'):
        if self.distributionMode is not None and 'distributionMode' not in already_processed:
            already_processed.add('distributionMode')
            outfile.write(' distributionMode="%s"' % self.gds_format_integer(self.distributionMode, input_name='distributionMode'))
        if self.leafDefinition is not None and 'leafDefinition' not in already_processed:
            already_processed.add('leafDefinition')
            outfile.write(' leafDefinition="%s"' % self.gds_format_integer(self.leafDefinition, input_name='leafDefinition'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_MeshTreeRepresentation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NumberOfTriangleParameters is not None:
            self.NumberOfTriangleParameters.export(outfile, level, namespaceprefix_, name_='NumberOfTriangleParameters', pretty_print=pretty_print)
        if self.MeshLeafDimensionParameters is not None:
            self.MeshLeafDimensionParameters.export(outfile, level, namespaceprefix_, name_='MeshLeafDimensionParameters', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_MeshTreeRepresentation', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.distributionMode is not None:
            element.set('distributionMode', self.gds_format_integer(self.distributionMode))
        if self.leafDefinition is not None:
            element.set('leafDefinition', self.gds_format_integer(self.leafDefinition))
        if self.NumberOfTriangleParameters is not None:
            NumberOfTriangleParameters_ = self.NumberOfTriangleParameters
            NumberOfTriangleParameters_.to_etree(element, name_='NumberOfTriangleParameters', mapping_=mapping_)
        if self.MeshLeafDimensionParameters is not None:
            MeshLeafDimensionParameters_ = self.MeshLeafDimensionParameters
            MeshLeafDimensionParameters_.to_etree(element, name_='MeshLeafDimensionParameters', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_MeshTreeRepresentation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.distributionMode is not None and 'distributionMode' not in already_processed:
            already_processed.add('distributionMode')
            showIndent(outfile, level)
            outfile.write('distributionMode=%d,\n' % (self.distributionMode,))
        if self.leafDefinition is not None and 'leafDefinition' not in already_processed:
            already_processed.add('leafDefinition')
            showIndent(outfile, level)
            outfile.write('leafDefinition=%d,\n' % (self.leafDefinition,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.NumberOfTriangleParameters is not None:
            showIndent(outfile, level)
            outfile.write('NumberOfTriangleParameters=model_._NumberOfTriangleParameters(\n')
            self.NumberOfTriangleParameters.exportLiteral(outfile, level, name_='NumberOfTriangleParameters')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MeshLeafDimensionParameters is not None:
            showIndent(outfile, level)
            outfile.write('MeshLeafDimensionParameters=model_._MeshLeafDimensionParameters(\n')
            self.MeshLeafDimensionParameters.exportLiteral(outfile, level, name_='MeshLeafDimensionParameters')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('distributionMode', node)
        if value is not None and 'distributionMode' not in already_processed:
            already_processed.add('distributionMode')
            try:
                self.distributionMode = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('leafDefinition', node)
        if value is not None and 'leafDefinition' not in already_processed:
            already_processed.add('leafDefinition')
            try:
                self.leafDefinition = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NumberOfTriangleParameters':
            obj_ = create_NumberOfTriangleParameters.factory()
            obj_.build(child_)
            self.set_NumberOfTriangleParameters(obj_)
            obj_.original_tagname_ = 'NumberOfTriangleParameters'
        elif nodeName_ == 'MeshLeafDimensionParameters':
            obj_ = create_MeshLeafDimensionParameters.factory()
            obj_.build(child_)
            self.set_MeshLeafDimensionParameters(obj_)
            obj_.original_tagname_ = 'MeshLeafDimensionParameters'
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_MeshTreeRepresentation


class create_NumberOfTriangleParameters(GeneratedsSuper):
    """Fix the number of leaves/triangles per tree. The leaf area will then
    be the total area of leaves in the crown divided by this number.
    The real final number per tree generated may vary due to
    rounding and distribution errors. Fix the number of
    leaves/triangles per tree. The leaf area will then be the total
    area of leaves in the crown divided by this number. The real
    final number per tree generated may vary due to rounding and
    distribution errors."""
    member_data_items_ = [
        MemberSpec_('nbTrianglesPerTree', 'xsd:int', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, nbTrianglesPerTree=10000):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_NumberOfTriangleParameters')
        self.attrib = ['nbTrianglesPerTree']
        self.children = []
        self.parent = None
        self._nbTrianglesPerTree = _cast(int, nbTrianglesPerTree)
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_NumberOfTriangleParameters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_NumberOfTriangleParameters.subclass:
            return create_NumberOfTriangleParameters.subclass(*args_, **kwargs_)
        else:
            return create_NumberOfTriangleParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nbTrianglesPerTree(self): return self._nbTrianglesPerTree
    def set_nbTrianglesPerTree(self, value):
        self._nbTrianglesPerTree = value
        update_node(self,self.troot,'trees')
    nbTrianglesPerTree = property(get_nbTrianglesPerTree, set_nbTrianglesPerTree)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_NumberOfTriangleParameters', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_NumberOfTriangleParameters')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_NumberOfTriangleParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_NumberOfTriangleParameters', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_NumberOfTriangleParameters'):
        if self.nbTrianglesPerTree is not None and 'nbTrianglesPerTree' not in already_processed:
            already_processed.add('nbTrianglesPerTree')
            outfile.write(' nbTrianglesPerTree="%s"' % self.gds_format_integer(self.nbTrianglesPerTree, input_name='nbTrianglesPerTree'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_NumberOfTriangleParameters', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_NumberOfTriangleParameters', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.nbTrianglesPerTree is not None:
            element.set('nbTrianglesPerTree', self.gds_format_integer(self.nbTrianglesPerTree))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_NumberOfTriangleParameters'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nbTrianglesPerTree is not None and 'nbTrianglesPerTree' not in already_processed:
            already_processed.add('nbTrianglesPerTree')
            showIndent(outfile, level)
            outfile.write('nbTrianglesPerTree=%d,\n' % (self.nbTrianglesPerTree,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nbTrianglesPerTree', node)
        if value is not None and 'nbTrianglesPerTree' not in already_processed:
            already_processed.add('nbTrianglesPerTree')
            try:
                self.nbTrianglesPerTree = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_NumberOfTriangleParameters


class create_MeshLeafDimensionParameters(GeneratedsSuper):
    """Area of each individual leaf/triangle. The number of
    leaves/triangles will then be the total area of leaves in the
    crown divided by this number. The real final number per tree
    generated may vary due to rounding and distribution errors. Area
    of each individual leaf/triangle. The number of leaves/triangles
    will then be the total area of leaves in the crown divided by
    this number. The real final number per tree generated may vary
    due to rounding and distribution errors."""
    member_data_items_ = [
        MemberSpec_('meshLeafDimension', 'xsd:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, meshLeafDimension=0.003):
        self.original_tagname_ = None
        self.troot=get_gs_troot('trees','_MeshLeafDimensionParameters')
        self.attrib = ['meshLeafDimension']
        self.children = []
        self.parent = None
        self._meshLeafDimension = _cast(float, meshLeafDimension)
        update_node(self,self.troot,'trees')
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_MeshLeafDimensionParameters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_MeshLeafDimensionParameters.subclass:
            return create_MeshLeafDimensionParameters.subclass(*args_, **kwargs_)
        else:
            return create_MeshLeafDimensionParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meshLeafDimension(self): return self._meshLeafDimension
    def set_meshLeafDimension(self, value):
        self._meshLeafDimension = value
        update_node(self,self.troot,'trees')
    meshLeafDimension = property(get_meshLeafDimension, set_meshLeafDimension)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_MeshLeafDimensionParameters', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_MeshLeafDimensionParameters')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_MeshLeafDimensionParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_MeshLeafDimensionParameters', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_MeshLeafDimensionParameters'):
        if self.meshLeafDimension is not None and 'meshLeafDimension' not in already_processed:
            already_processed.add('meshLeafDimension')
            outfile.write(' meshLeafDimension="%s"' % self.gds_format_double(self.meshLeafDimension, input_name='meshLeafDimension'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_MeshLeafDimensionParameters', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_MeshLeafDimensionParameters', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.meshLeafDimension is not None:
            element.set('meshLeafDimension', self.gds_format_double(self.meshLeafDimension))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_MeshLeafDimensionParameters'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.meshLeafDimension is not None and 'meshLeafDimension' not in already_processed:
            already_processed.add('meshLeafDimension')
            showIndent(outfile, level)
            outfile.write('meshLeafDimension=%e,\n' % (self.meshLeafDimension,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('meshLeafDimension', node)
        if value is not None and 'meshLeafDimension' not in already_processed:
            already_processed.add('meshLeafDimension')
            try:
                self.meshLeafDimension = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (meshLeafDimension): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    
    def to_string(self, pretty_print=True):
        return etree_.tostring(self.to_etree(), pretty_print=pretty_print)
        
        
    def path(self, index=True):
        """
        Get the dartnode path of the corenode
        Parameters
        ----------
        corenode: object
            a core object
    
        index: bool
    
            If True gets the dartnode path with index if list,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction[0]'
    
            If False gets the dartnode path without index,
            e.g. 'Coeff_diff.AirMultiFunctions.AirFunction'
    
        Returns
        -------
            str
        """

        return get_path(self, index=index)
        
                         
    def findpaths(self, pat, case=False, regex=True):
        return findpaths(self, pat=pat, case=case, regex=regex)
    
    
    def subpaths(self):
        return subpaths(self)

    
    def set_nodes(self, **kwargs):
        return set_nodes(self, **kwargs)

    # end class create_MeshLeafDimensionParameters


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <createParser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from trees import *\n\n')
        sys.stdout.write('import trees as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "createDartFile",
    "create_BranchesAndTwigs",
    "create_Crown",
    "create_CrownConeComp",
    "create_CrownEllipsoid",
    "create_CrownEllipsoidComposed",
    "create_CrownLevel",
    "create_CrownTrapezoid",
    "create_CrownTruncatedCone",
    "create_EllipsoidSubZone",
    "create_EstimatedNumberOfTreeDistribution",
    "create_HolesDistribution",
    "create_IntervalDistribution",
    "create_LaiZoneProperties",
    "create_LeavesDistribution",
    "create_MeshLeafDimensionParameters",
    "create_MeshTreeRepresentation",
    "create_NumberOfTriangleParameters",
    "create_OpticalPropertyLink",
    "create_Point2D",
    "create_Polygon2D",
    "create_Specie",
    "create_Specie_2",
    "create_Specie_3",
    "create_ThermalPropertyLink",
    "create_TreeGeneralOptions",
    "create_Trees",
    "create_Trees_1",
    "create_Trees_2",
    "create_Trees_3",
    "create_Trunk",
    "create_VegetationOpticalPropertyLink",
    "create_VegetationProperty"
]
