#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Sun Oct 14 19:16:03 2018 by generateDS.py version 2.29.25.
# Python 2.7.3 (default, Oct 26 2016, 21:01:49)  [GCC 4.6.3]
#
# Command line options:
#   ('-m', '')
#   ('--always-export-default', '')
#   ('--export', 'write literal etree')
#   ('-p', 'create')
#   ('--post-attrib-setter', 'update_node(self,self.troot,"phase")')
#   ('--pre-ctor', 'self.troot=get_gs_troot("phase","{classname}")')
#   ('--post-ctor', 'update_node(self,self.troot,"phase")')
#   ('--imports', 'from pytools4dart.core_ui.utils import get_gs_troot, update_node')
#   ('-o', '/home/boissieu/Scripts/pytools4dartMTD/pytools4dart/core_ui/phase.py')
#
# Command line arguments:
#   /home/boissieu/Scripts/pytools4dartMTD/pytools4dart/core_ui/phase.xsd
#
# Command line:
#   generateDS.py -m --always-export-default --export="write literal etree" -p "create" --post-attrib-setter="update_node(self,self.troot,"phase")" --pre-ctor="self.troot=get_gs_troot("phase","{classname}")" --post-ctor="update_node(self,self.troot,"phase")" --imports="from pytools4dart.core_ui.utils import get_gs_troot, update_node" -o "/home/boissieu/Scripts/pytools4dartMTD/pytools4dart/core_ui/phase.py" /home/boissieu/Scripts/pytools4dartMTD/pytools4dart/core_ui/phase.xsd
#
# Current working directory (os.getcwd()):
#   generateds
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_
from pytools4dart.core_ui.utils import get_gs_troot, update_node


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#

def checkclass(value, cl):
    if isinstance(value, list):
        for v in value:
            if not isinstance(v, cl):
                raise ValueError("invalid class")
    else:
        if not isinstance(value, cl):
            raise ValueError("invalid class")

def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class createDartFile(GeneratedsSuper):
    """Version of the plots.xml file. Depends of the version on DART
    itself. Version of the plots.xml file. Depends of the version on
    DART itself."""
    subclass = None
    superclass = None
    def __init__(self, version='5.7.1', build_='0', Phase=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","DartFile")
        self.attrib = ['version', 'build_']
        self.children = ['Phase']
        self.parent = None
        self._version = _cast(None, version)
        self._build_ = _cast(None, build_)
        self._Phase = Phase
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, createDartFile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if createDartFile.subclass:
            return createDartFile.subclass(*args_, **kwargs_)
        else:
            return createDartFile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Phase(self): return self._Phase
    def set_Phase(self, value):
        if value is not None:
            checkclass(value, create_Phase)
            value.parent = self
        self._Phase = value
    Phase = property(get_Phase, set_Phase)
    def get_version(self): return self._version
    def set_version(self, value):
        self._version = value
        update_node(self,self.troot,"phase")
    version = property(get_version, set_version)
    def get_build(self): return self._build_
    def set_build(self, value):
        self._build_ = value
        update_node(self,self.troot,"phase")
    build_ = property(get_build, set_build)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Phase is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='DartFile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DartFile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DartFile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='DartFile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DartFile'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
        if self.build_ is not None and 'build_' not in already_processed:
            already_processed.add('build_')
            outfile.write(' build=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.build_), input_name='build')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='DartFile', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Phase is not None:
            self.Phase.export(outfile, level, namespaceprefix_, name_='Phase', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='DartFile', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.version is not None:
            element.set('version', self.gds_format_string(self.version))
        if self.build_ is not None:
            element.set('build', self.gds_format_string(self.build_))
        if self.Phase is not None:
            Phase_ = self.Phase
            Phase_.to_etree(element, name_='Phase', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='DartFile'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.build_ is not None and 'build_' not in already_processed:
            already_processed.add('build_')
            showIndent(outfile, level)
            outfile.write('build_="%s",\n' % (self.build_,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Phase is not None:
            showIndent(outfile, level)
            outfile.write('Phase=model_._Phase(\n')
            self.Phase.exportLiteral(outfile, level, name_='Phase')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('build', node)
        if value is not None and 'build' not in already_processed:
            already_processed.add('build')
            self.build_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Phase':
            obj_ = create_Phase.factory()
            obj_.build(child_)
            self.set_Phase(obj_)
            obj_.original_tagname_ = 'Phase'
# end class createDartFile


class create_Phase(GeneratedsSuper):
    """In mode (R), DART can work with a Monte Carlo approach. With this
    option, scattering is always a succession of scattering
    mechanisms of order 1, which should lead to more accurate
    results, but slower results..... In mode (R), DART can work with
    a Monte Carlo approach. With this option, scattering is always a
    succession of scattering mechanisms of order 1, which should
    lead to more accurate results, but slower results....."""
    subclass = None
    superclass = None
    def __init__(self, calculatorMethod=0, AtmosphereRadiativeTransfer=None, ExpertModeZone=None, DartInputParameters=None, DartProduct=None, SensorImageSimulation=None, ExternalScripts=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_Phase")
        self.attrib = ['calculatorMethod']
        self.children = ['AtmosphereRadiativeTransfer', 'ExpertModeZone', 'DartInputParameters', 'DartProduct', 'SensorImageSimulation', 'ExternalScripts']
        self.parent = None
        self._calculatorMethod = _cast(int, calculatorMethod)
        self._AtmosphereRadiativeTransfer = AtmosphereRadiativeTransfer
        self._ExpertModeZone = ExpertModeZone
        self._DartInputParameters = DartInputParameters
        self._DartProduct = DartProduct
        self._SensorImageSimulation = SensorImageSimulation
        self._ExternalScripts = ExternalScripts
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Phase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Phase.subclass:
            return create_Phase.subclass(*args_, **kwargs_)
        else:
            return create_Phase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AtmosphereRadiativeTransfer(self): return self._AtmosphereRadiativeTransfer
    def set_AtmosphereRadiativeTransfer(self, value):
        if value is not None:
            checkclass(value, create_AtmosphereRadiativeTransfer)
            value.parent = self
        self._AtmosphereRadiativeTransfer = value
    AtmosphereRadiativeTransfer = property(get_AtmosphereRadiativeTransfer, set_AtmosphereRadiativeTransfer)
    def get_ExpertModeZone(self): return self._ExpertModeZone
    def set_ExpertModeZone(self, value):
        if value is not None:
            checkclass(value, create_ExpertModeZone)
            value.parent = self
        self._ExpertModeZone = value
    ExpertModeZone = property(get_ExpertModeZone, set_ExpertModeZone)
    def get_DartInputParameters(self): return self._DartInputParameters
    def set_DartInputParameters(self, value):
        if value is not None:
            checkclass(value, create_DartInputParameters)
            value.parent = self
        self._DartInputParameters = value
    DartInputParameters = property(get_DartInputParameters, set_DartInputParameters)
    def get_DartProduct(self): return self._DartProduct
    def set_DartProduct(self, value):
        if value is not None:
            checkclass(value, create_DartProduct)
            value.parent = self
        self._DartProduct = value
    DartProduct = property(get_DartProduct, set_DartProduct)
    def get_SensorImageSimulation(self): return self._SensorImageSimulation
    def set_SensorImageSimulation(self, value):
        if value is not None:
            checkclass(value, create_SensorImageSimulation)
            value.parent = self
        self._SensorImageSimulation = value
    SensorImageSimulation = property(get_SensorImageSimulation, set_SensorImageSimulation)
    def get_ExternalScripts(self): return self._ExternalScripts
    def set_ExternalScripts(self, value):
        if value is not None:
            checkclass(value, create_ExternalScripts)
            value.parent = self
        self._ExternalScripts = value
    ExternalScripts = property(get_ExternalScripts, set_ExternalScripts)
    def get_calculatorMethod(self): return self._calculatorMethod
    def set_calculatorMethod(self, value):
        self._calculatorMethod = value
        update_node(self,self.troot,"phase")
    calculatorMethod = property(get_calculatorMethod, set_calculatorMethod)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.AtmosphereRadiativeTransfer is not None or
            self.ExpertModeZone is not None or
            self.DartInputParameters is not None or
            self.DartProduct is not None or
            self.SensorImageSimulation is not None or
            self.ExternalScripts is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Phase', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Phase')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Phase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Phase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Phase'):
        if self.calculatorMethod is not None and 'calculatorMethod' not in already_processed:
            already_processed.add('calculatorMethod')
            outfile.write(' calculatorMethod="%s"' % self.gds_format_integer(self.calculatorMethod, input_name='calculatorMethod'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Phase', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AtmosphereRadiativeTransfer is not None:
            self.AtmosphereRadiativeTransfer.export(outfile, level, namespaceprefix_, name_='AtmosphereRadiativeTransfer', pretty_print=pretty_print)
        if self.ExpertModeZone is not None:
            self.ExpertModeZone.export(outfile, level, namespaceprefix_, name_='ExpertModeZone', pretty_print=pretty_print)
        if self.DartInputParameters is not None:
            self.DartInputParameters.export(outfile, level, namespaceprefix_, name_='DartInputParameters', pretty_print=pretty_print)
        if self.DartProduct is not None:
            self.DartProduct.export(outfile, level, namespaceprefix_, name_='DartProduct', pretty_print=pretty_print)
        if self.SensorImageSimulation is not None:
            self.SensorImageSimulation.export(outfile, level, namespaceprefix_, name_='SensorImageSimulation', pretty_print=pretty_print)
        if self.ExternalScripts is not None:
            self.ExternalScripts.export(outfile, level, namespaceprefix_, name_='ExternalScripts', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Phase', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.calculatorMethod is not None:
            element.set('calculatorMethod', self.gds_format_integer(self.calculatorMethod))
        if self.AtmosphereRadiativeTransfer is not None:
            AtmosphereRadiativeTransfer_ = self.AtmosphereRadiativeTransfer
            AtmosphereRadiativeTransfer_.to_etree(element, name_='AtmosphereRadiativeTransfer', mapping_=mapping_)
        if self.ExpertModeZone is not None:
            ExpertModeZone_ = self.ExpertModeZone
            ExpertModeZone_.to_etree(element, name_='ExpertModeZone', mapping_=mapping_)
        if self.DartInputParameters is not None:
            DartInputParameters_ = self.DartInputParameters
            DartInputParameters_.to_etree(element, name_='DartInputParameters', mapping_=mapping_)
        if self.DartProduct is not None:
            DartProduct_ = self.DartProduct
            DartProduct_.to_etree(element, name_='DartProduct', mapping_=mapping_)
        if self.SensorImageSimulation is not None:
            SensorImageSimulation_ = self.SensorImageSimulation
            SensorImageSimulation_.to_etree(element, name_='SensorImageSimulation', mapping_=mapping_)
        if self.ExternalScripts is not None:
            ExternalScripts_ = self.ExternalScripts
            ExternalScripts_.to_etree(element, name_='ExternalScripts', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Phase'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.calculatorMethod is not None and 'calculatorMethod' not in already_processed:
            already_processed.add('calculatorMethod')
            showIndent(outfile, level)
            outfile.write('calculatorMethod=%d,\n' % (self.calculatorMethod,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AtmosphereRadiativeTransfer is not None:
            showIndent(outfile, level)
            outfile.write('AtmosphereRadiativeTransfer=model_._AtmosphereRadiativeTransfer(\n')
            self.AtmosphereRadiativeTransfer.exportLiteral(outfile, level, name_='AtmosphereRadiativeTransfer')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ExpertModeZone is not None:
            showIndent(outfile, level)
            outfile.write('ExpertModeZone=model_._ExpertModeZone(\n')
            self.ExpertModeZone.exportLiteral(outfile, level, name_='ExpertModeZone')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DartInputParameters is not None:
            showIndent(outfile, level)
            outfile.write('DartInputParameters=model_._DartInputParameters(\n')
            self.DartInputParameters.exportLiteral(outfile, level, name_='DartInputParameters')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DartProduct is not None:
            showIndent(outfile, level)
            outfile.write('DartProduct=model_._DartProduct(\n')
            self.DartProduct.exportLiteral(outfile, level, name_='DartProduct')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SensorImageSimulation is not None:
            showIndent(outfile, level)
            outfile.write('SensorImageSimulation=model_._SensorImageSimulation(\n')
            self.SensorImageSimulation.exportLiteral(outfile, level, name_='SensorImageSimulation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ExternalScripts is not None:
            showIndent(outfile, level)
            outfile.write('ExternalScripts=model_._ExternalScripts(\n')
            self.ExternalScripts.exportLiteral(outfile, level, name_='ExternalScripts')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('calculatorMethod', node)
        if value is not None and 'calculatorMethod' not in already_processed:
            already_processed.add('calculatorMethod')
            try:
                self.calculatorMethod = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AtmosphereRadiativeTransfer':
            obj_ = create_AtmosphereRadiativeTransfer.factory()
            obj_.build(child_)
            self.set_AtmosphereRadiativeTransfer(obj_)
            obj_.original_tagname_ = 'AtmosphereRadiativeTransfer'
        elif nodeName_ == 'ExpertModeZone':
            obj_ = create_ExpertModeZone.factory()
            obj_.build(child_)
            self.set_ExpertModeZone(obj_)
            obj_.original_tagname_ = 'ExpertModeZone'
        elif nodeName_ == 'DartInputParameters':
            obj_ = create_DartInputParameters.factory()
            obj_.build(child_)
            self.set_DartInputParameters(obj_)
            obj_.original_tagname_ = 'DartInputParameters'
        elif nodeName_ == 'DartProduct':
            obj_ = create_DartProduct.factory()
            obj_.build(child_)
            self.set_DartProduct(obj_)
            obj_.original_tagname_ = 'DartProduct'
        elif nodeName_ == 'SensorImageSimulation':
            obj_ = create_SensorImageSimulation.factory()
            obj_.build(child_)
            self.set_SensorImageSimulation(obj_)
            obj_.original_tagname_ = 'SensorImageSimulation'
        elif nodeName_ == 'ExternalScripts':
            obj_ = create_ExternalScripts.factory()
            obj_.build(child_)
            self.set_ExternalScripts(obj_)
            obj_.original_tagname_ = 'ExternalScripts'
# end class create_Phase


class create_AtmosphereRadiativeTransfer(GeneratedsSuper):
    """Passage from TOA to BOA.\n - No Atmosphere RT: No simulation of the
    atmosphere radiative transfer. Irradiance Passage from TOA to
    BOA.\n - No Atmosphere RT: No simulation of the atmosphere
    radiative transfer. Irradiance"""
    subclass = None
    superclass = None
    def __init__(self, TOAtoBOA=0, AtmosphereRadiativeTransferOptions=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_AtmosphereRadiativeTransfer")
        self.attrib = ['TOAtoBOA']
        self.children = ['AtmosphereRadiativeTransferOptions']
        self.parent = None
        self._TOAtoBOA = _cast(int, TOAtoBOA)
        self._AtmosphereRadiativeTransferOptions = AtmosphereRadiativeTransferOptions
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_AtmosphereRadiativeTransfer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_AtmosphereRadiativeTransfer.subclass:
            return create_AtmosphereRadiativeTransfer.subclass(*args_, **kwargs_)
        else:
            return create_AtmosphereRadiativeTransfer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AtmosphereRadiativeTransferOptions(self): return self._AtmosphereRadiativeTransferOptions
    def set_AtmosphereRadiativeTransferOptions(self, value):
        if value is not None:
            checkclass(value, create_AtmosphereRadiativeTransferOptions)
            value.parent = self
        self._AtmosphereRadiativeTransferOptions = value
    AtmosphereRadiativeTransferOptions = property(get_AtmosphereRadiativeTransferOptions, set_AtmosphereRadiativeTransferOptions)
    def get_TOAtoBOA(self): return self._TOAtoBOA
    def set_TOAtoBOA(self, value):
        self._TOAtoBOA = value
        update_node(self,self.troot,"phase")
    TOAtoBOA = property(get_TOAtoBOA, set_TOAtoBOA)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.AtmosphereRadiativeTransferOptions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_AtmosphereRadiativeTransfer', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_AtmosphereRadiativeTransfer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_AtmosphereRadiativeTransfer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_AtmosphereRadiativeTransfer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_AtmosphereRadiativeTransfer'):
        if self.TOAtoBOA is not None and 'TOAtoBOA' not in already_processed:
            already_processed.add('TOAtoBOA')
            outfile.write(' TOAtoBOA="%s"' % self.gds_format_integer(self.TOAtoBOA, input_name='TOAtoBOA'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_AtmosphereRadiativeTransfer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AtmosphereRadiativeTransferOptions is not None:
            self.AtmosphereRadiativeTransferOptions.export(outfile, level, namespaceprefix_, name_='AtmosphereRadiativeTransferOptions', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_AtmosphereRadiativeTransfer', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.TOAtoBOA is not None:
            element.set('TOAtoBOA', self.gds_format_integer(self.TOAtoBOA))
        if self.AtmosphereRadiativeTransferOptions is not None:
            AtmosphereRadiativeTransferOptions_ = self.AtmosphereRadiativeTransferOptions
            AtmosphereRadiativeTransferOptions_.to_etree(element, name_='AtmosphereRadiativeTransferOptions', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_AtmosphereRadiativeTransfer'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.TOAtoBOA is not None and 'TOAtoBOA' not in already_processed:
            already_processed.add('TOAtoBOA')
            showIndent(outfile, level)
            outfile.write('TOAtoBOA=%d,\n' % (self.TOAtoBOA,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AtmosphereRadiativeTransferOptions is not None:
            showIndent(outfile, level)
            outfile.write('AtmosphereRadiativeTransferOptions=model_._AtmosphereRadiativeTransferOptions(\n')
            self.AtmosphereRadiativeTransferOptions.exportLiteral(outfile, level, name_='AtmosphereRadiativeTransferOptions')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TOAtoBOA', node)
        if value is not None and 'TOAtoBOA' not in already_processed:
            already_processed.add('TOAtoBOA')
            try:
                self.TOAtoBOA = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AtmosphereRadiativeTransferOptions':
            obj_ = create_AtmosphereRadiativeTransferOptions.factory()
            obj_.build(child_)
            self.set_AtmosphereRadiativeTransferOptions(obj_)
            obj_.original_tagname_ = 'AtmosphereRadiativeTransferOptions'
# end class create_AtmosphereRadiativeTransfer


class create_AtmosphereRadiativeTransferOptions(GeneratedsSuper):
    """Disable COUPL and TOA level product.\nThe Earth-Atmosphere coupling
    simulates the exchange process of energy between the Earth scene
    and the atmosphere:\npart of the energy scattered by the Earth-
    scene is intercepted again by the atmosphere and back-scattered
    toward the Earth, and this potentially multiple times.\nThis
    process can be sometimes fairly time-consuming for a small
    contribution to the radiative budget, depending on the spectral
    band and the scene constitution. Disable COUPL and TOA level
    product.\nThe Earth-Atmosphere coupling simulates the exchange
    process of energy between the Earth scene and the
    atmosphere:\npart of the energy scattered by the Earth-scene is
    intercepted again by the atmosphere and back-scattered toward
    the Earth, and this potentially multiple times.\nThis process
    can be sometimes fairly time-consuming for a small contribution
    to the radiative budget, depending on the spectral band and the
    scene constitution."""
    subclass = None
    superclass = None
    def __init__(self, couplingEnabled=1):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_AtmosphereRadiativeTransferOptions")
        self.attrib = ['couplingEnabled']
        self.children = []
        self.parent = None
        self._couplingEnabled = _cast(int, couplingEnabled)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_AtmosphereRadiativeTransferOptions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_AtmosphereRadiativeTransferOptions.subclass:
            return create_AtmosphereRadiativeTransferOptions.subclass(*args_, **kwargs_)
        else:
            return create_AtmosphereRadiativeTransferOptions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_couplingEnabled(self): return self._couplingEnabled
    def set_couplingEnabled(self, value):
        self._couplingEnabled = value
        update_node(self,self.troot,"phase")
    couplingEnabled = property(get_couplingEnabled, set_couplingEnabled)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_AtmosphereRadiativeTransferOptions', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_AtmosphereRadiativeTransferOptions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_AtmosphereRadiativeTransferOptions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_AtmosphereRadiativeTransferOptions', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_AtmosphereRadiativeTransferOptions'):
        if self.couplingEnabled is not None and 'couplingEnabled' not in already_processed:
            already_processed.add('couplingEnabled')
            outfile.write(' couplingEnabled="%s"' % self.gds_format_integer(self.couplingEnabled, input_name='couplingEnabled'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_AtmosphereRadiativeTransferOptions', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_AtmosphereRadiativeTransferOptions', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.couplingEnabled is not None:
            element.set('couplingEnabled', self.gds_format_integer(self.couplingEnabled))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_AtmosphereRadiativeTransferOptions'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.couplingEnabled is not None and 'couplingEnabled' not in already_processed:
            already_processed.add('couplingEnabled')
            showIndent(outfile, level)
            outfile.write('couplingEnabled=%d,\n' % (self.couplingEnabled,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('couplingEnabled', node)
        if value is not None and 'couplingEnabled' not in already_processed:
            already_processed.add('couplingEnabled')
            try:
                self.couplingEnabled = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_AtmosphereRadiativeTransferOptions


class create_ExpertModeZone(GeneratedsSuper):
    """Specifies if the intercepted power per direction is stored for the
    specular reflection and refraction or not \n As the specular
    phenomenon is very directional, it is necessary to store the
    intercepted power per direction to well represent it. \n
    However, one can choose to well represent the first order of
    scattering and to assume the other as Lambertian. Specifies if
    the intercepted power per direction is stored for the specular
    reflection and refraction or not \n As the specular phenomenon
    is very directional, it is necessary to store the intercepted
    power per direction to well represent it. \n However, one can
    choose to well represent the first order of scattering and to
    assume the other as Lambertian. Any ray is discarded if its
    energy becomes less than {"Threshold" x "Mean energy /steradian"
    derived from iterations 1 and 2 x "Solid angle of the ray"} Any
    ray is discarded if its energy becomes less than {"Threshold" x
    "Mean energy /steradian" derived from iterations 1 and 2 x
    "Solid angle of the ray"} The number of signals sent back to the
    sensor of one interception within atmosphere. This is in order
    to reduce the signal noise of atmosphere, which comes from
    insufficient number of photons comparing to reality. The number
    of signals sent back to the sensor of one interception within
    atmosphere. This is in order to reduce the signal noise of
    atmosphere, which comes from insufficient number of photons
    comparing to reality. To Write To Write DART will apply multi-
    threading to accelarate processing. \n It is implemented in
    illumination, scattering and atmosphere transfer function
    calculation. DART will apply multi-threading to accelarate
    processing. \n It is implemented in illumination, scattering and
    atmosphere transfer function calculation. The DART run stops if
    the variation of scene albedo between consecutive iterations is
    less than the threshold The DART run stops if the variation of
    scene albedo between consecutive iterations is less than the
    threshold If multiple rays are intercepted by the same surface,
    they are later scattered as a single point (or more, depending
    of the factor N above) in order to minimize the number of rays
    to track. If multiple rays are intercepted by the same surface,
    they are later scattered as a single point (or more, depending
    of the factor N above) in order to minimize the number of rays
    to track. Use sparse voxel data structure to accelerate DART
    simulations and reduce memeory usage. Use sparse voxel data
    structure to accelerate DART simulations and reduce memeory
    usage. If a ray travels through more scene than the specified
    value, it is stopped and its energy registered as lost.\n
    Notably useful to prevent rays parallel or quasi-parallel to the
    scene in infinite slope mode. If a ray travels through more
    scene than the specified value, it is stopped and its energy
    registered as lost.\n Notably useful to prevent rays parallel or
    quasi-parallel to the scene in infinite slope mode. When
    multiple rays exit a cell through the same sub-face with the
    same direction, they are regrouped into a single ray in order to
    minimize tracking time. When multiple rays exit a cell through
    the same sub-face with the same direction, they are regrouped
    into a single ray in order to minimize tracking time.
    Acceleration of ray-tracking: Embree uses float and NanoRT uses
    double. Acceleration of ray-tracking: Embree uses float and
    NanoRT uses double. When number of triangles inside a voxel is
    larger than or equal to this value, DART will use BVH tree to
    accelerate the ray-triangles intersection test. When number of
    triangles inside a voxel is larger than or equal to this value,
    DART will use BVH tree to accelerate the ray-triangles
    intersection test. BOA illumination is simulated with several
    sun and atmosphere rays per cell.\nRay density is
    1/D\u00B2.\nWith direct sun BOA irradiance Esun, atmosphere BOA
    irradiance Eatm (sun scattered + thermal emission), BOA
    irradiance E BOA illumination is simulated with several sun and
    atmosphere rays per cell.\nRay density is 1/D\u00B2.\nWith
    direct sun BOA irradiance Esun, atmosphere BOA irradiance Eatm
    (sun scattered + thermal emission), BOA irradiance E Use
    external python script with DART processing Use external python
    script with DART processing In order to provide faster results,
    DART can extrapolate on the N last iterations. The more
    iterations are used, the more precise usually the results are.
    In order to provide faster results, DART can extrapolate on the
    N last iterations. The more iterations are used, the more
    precise usually the results are. Used to set the number of
    radiation source points from each cell face in coordination with
    the factor N.\n- Each cell face has N\u00B2 * M\u00B2 sub-faces.
    If multiple rays exit the same sub-face with the same direction,
    they are concatenated in a single ray. Used to set the number of
    radiation source points from each cell face in coordination with
    the factor N.\n- Each cell face has N\u00B2 * M\u00B2 sub-faces.
    If multiple rays exit the same sub-face with the same direction,
    they are concatenated in a single ray. A ray will be emitted
    every S m2 during the thermal emission. A ray will be emitted
    every S m2 during the thermal emission. Used to oversample
    within cell scattering and to set the number of radiation source
    points from each cell face in coordination with the factor M.\n-
    Each cell has N^3 sub-cells.\nThere can be 1 scattering point
    per sub-cell (i.e., N\u00B3 scattering points / cell).\nThus, a
    triangle can have m scattering points if it crosses m sub-
    cells.\n- Each cell face has N\u00B2 * M\u00B2 sub-faces. If
    multiple rays exit the same sub-face with the same direction,
    they are concatenated in a single ray. Used to oversample within
    cell scattering and to set the number of radiation source points
    from each cell face in coordination with the factor M.\n- Each
    cell has N^3 sub-cells.\nThere can be 1 scattering point per
    sub-cell (i.e., N\u00B3 scattering points / cell).\nThus, a
    triangle can have m scattering points if it crosses m sub-
    cells.\n- Each cell face has N\u00B2 * M\u00B2 sub-faces. If
    multiple rays exit the same sub-face with the same direction,
    they are concatenated in a single ray. Activation of new
    features in expert mode. Activation of new features in expert
    mode. Thermal emission from a turbid cell arises from the center
    of each cell sub-face.\nIt is equal to "Geometric factor
    G(\u03C9)" x "Planck's radiance L(\u03BC, cell
    temperature)".\nG(\u03C9) is precomputed per cell sub-face as a
    numerical integral, using N\u00B2 integration points per cell
    sub-face. Thermal emission from a turbid cell arises from the
    center of each cell sub-face.\nIt is equal to "Geometric factor
    G(\u03C9)" x "Planck's radiance L(\u03BC, cell
    temperature)".\nG(\u03C9) is precomputed per cell sub-face as a
    numerical integral, using N\u00B2 integration points per cell
    sub-face. The direct mode is the fastest, but also the most
    costly in memory. Cloning can save a lot of memory but will be
    much slower. The direct mode is the fastest, but also the most
    costly in memory. Cloning can save a lot of memory but will be
    much slower."""
    subclass = None
    superclass = None
    def __init__(self, isInterceptedPowerPerDirectionForSpecularCheck=0, lightPropagationThreshold=1E-7, nbRandomPointsPerInteceptionAtmosphere=1, illuminationRepartitionMode=2, nbThreads=4, albedoThreshold=1E-7, surfaceBarycenterEnabled=1, sparseVoxelAcceleration=1, maxNbSceneCrossing=1000, subFaceBarycenterEnabled=1, accelerationEngine=0, nbTrianglesWithinVoxelAcceleration=10, distanceBetweenIlluminationSubCenters=0.1, useExternalScripts=0, extrapolationMethod=0, subFaceBarycenterSubdivision=1, thermalEmissionSurfaceSubdivision=0.01, nbSubcenterVolume=2, expertMode=0, nbSubSubcenterTurbidEmission=40, triangleStorageMode=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_ExpertModeZone")
        self.attrib = ['isInterceptedPowerPerDirectionForSpecularCheck', 'lightPropagationThreshold', 'nbRandomPointsPerInteceptionAtmosphere', 'illuminationRepartitionMode', 'nbThreads', 'albedoThreshold', 'surfaceBarycenterEnabled', 'sparseVoxelAcceleration', 'maxNbSceneCrossing', 'subFaceBarycenterEnabled', 'accelerationEngine', 'nbTrianglesWithinVoxelAcceleration', 'distanceBetweenIlluminationSubCenters', 'useExternalScripts', 'extrapolationMethod', 'subFaceBarycenterSubdivision', 'thermalEmissionSurfaceSubdivision', 'nbSubcenterVolume', 'expertMode', 'nbSubSubcenterTurbidEmission', 'triangleStorageMode']
        self.children = []
        self.parent = None
        self._isInterceptedPowerPerDirectionForSpecularCheck = _cast(int, isInterceptedPowerPerDirectionForSpecularCheck)
        self._lightPropagationThreshold = _cast(float, lightPropagationThreshold)
        self._nbRandomPointsPerInteceptionAtmosphere = _cast(int, nbRandomPointsPerInteceptionAtmosphere)
        self._illuminationRepartitionMode = _cast(int, illuminationRepartitionMode)
        self._nbThreads = _cast(int, nbThreads)
        self._albedoThreshold = _cast(float, albedoThreshold)
        self._surfaceBarycenterEnabled = _cast(int, surfaceBarycenterEnabled)
        self._sparseVoxelAcceleration = _cast(int, sparseVoxelAcceleration)
        self._maxNbSceneCrossing = _cast(int, maxNbSceneCrossing)
        self._subFaceBarycenterEnabled = _cast(int, subFaceBarycenterEnabled)
        self._accelerationEngine = _cast(int, accelerationEngine)
        self._nbTrianglesWithinVoxelAcceleration = _cast(int, nbTrianglesWithinVoxelAcceleration)
        self._distanceBetweenIlluminationSubCenters = _cast(float, distanceBetweenIlluminationSubCenters)
        self._useExternalScripts = _cast(int, useExternalScripts)
        self._extrapolationMethod = _cast(int, extrapolationMethod)
        self._subFaceBarycenterSubdivision = _cast(int, subFaceBarycenterSubdivision)
        self._thermalEmissionSurfaceSubdivision = _cast(float, thermalEmissionSurfaceSubdivision)
        self._nbSubcenterVolume = _cast(int, nbSubcenterVolume)
        self._expertMode = _cast(int, expertMode)
        self._nbSubSubcenterTurbidEmission = _cast(int, nbSubSubcenterTurbidEmission)
        self._triangleStorageMode = _cast(int, triangleStorageMode)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ExpertModeZone)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ExpertModeZone.subclass:
            return create_ExpertModeZone.subclass(*args_, **kwargs_)
        else:
            return create_ExpertModeZone(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isInterceptedPowerPerDirectionForSpecularCheck(self): return self._isInterceptedPowerPerDirectionForSpecularCheck
    def set_isInterceptedPowerPerDirectionForSpecularCheck(self, value):
        self._isInterceptedPowerPerDirectionForSpecularCheck = value
        update_node(self,self.troot,"phase")
    isInterceptedPowerPerDirectionForSpecularCheck = property(get_isInterceptedPowerPerDirectionForSpecularCheck, set_isInterceptedPowerPerDirectionForSpecularCheck)
    def get_lightPropagationThreshold(self): return self._lightPropagationThreshold
    def set_lightPropagationThreshold(self, value):
        self._lightPropagationThreshold = value
        update_node(self,self.troot,"phase")
    lightPropagationThreshold = property(get_lightPropagationThreshold, set_lightPropagationThreshold)
    def get_nbRandomPointsPerInteceptionAtmosphere(self): return self._nbRandomPointsPerInteceptionAtmosphere
    def set_nbRandomPointsPerInteceptionAtmosphere(self, value):
        self._nbRandomPointsPerInteceptionAtmosphere = value
        update_node(self,self.troot,"phase")
    nbRandomPointsPerInteceptionAtmosphere = property(get_nbRandomPointsPerInteceptionAtmosphere, set_nbRandomPointsPerInteceptionAtmosphere)
    def get_illuminationRepartitionMode(self): return self._illuminationRepartitionMode
    def set_illuminationRepartitionMode(self, value):
        self._illuminationRepartitionMode = value
        update_node(self,self.troot,"phase")
    illuminationRepartitionMode = property(get_illuminationRepartitionMode, set_illuminationRepartitionMode)
    def get_nbThreads(self): return self._nbThreads
    def set_nbThreads(self, value):
        self._nbThreads = value
        update_node(self,self.troot,"phase")
    nbThreads = property(get_nbThreads, set_nbThreads)
    def get_albedoThreshold(self): return self._albedoThreshold
    def set_albedoThreshold(self, value):
        self._albedoThreshold = value
        update_node(self,self.troot,"phase")
    albedoThreshold = property(get_albedoThreshold, set_albedoThreshold)
    def get_surfaceBarycenterEnabled(self): return self._surfaceBarycenterEnabled
    def set_surfaceBarycenterEnabled(self, value):
        self._surfaceBarycenterEnabled = value
        update_node(self,self.troot,"phase")
    surfaceBarycenterEnabled = property(get_surfaceBarycenterEnabled, set_surfaceBarycenterEnabled)
    def get_sparseVoxelAcceleration(self): return self._sparseVoxelAcceleration
    def set_sparseVoxelAcceleration(self, value):
        self._sparseVoxelAcceleration = value
        update_node(self,self.troot,"phase")
    sparseVoxelAcceleration = property(get_sparseVoxelAcceleration, set_sparseVoxelAcceleration)
    def get_maxNbSceneCrossing(self): return self._maxNbSceneCrossing
    def set_maxNbSceneCrossing(self, value):
        self._maxNbSceneCrossing = value
        update_node(self,self.troot,"phase")
    maxNbSceneCrossing = property(get_maxNbSceneCrossing, set_maxNbSceneCrossing)
    def get_subFaceBarycenterEnabled(self): return self._subFaceBarycenterEnabled
    def set_subFaceBarycenterEnabled(self, value):
        self._subFaceBarycenterEnabled = value
        update_node(self,self.troot,"phase")
    subFaceBarycenterEnabled = property(get_subFaceBarycenterEnabled, set_subFaceBarycenterEnabled)
    def get_accelerationEngine(self): return self._accelerationEngine
    def set_accelerationEngine(self, value):
        self._accelerationEngine = value
        update_node(self,self.troot,"phase")
    accelerationEngine = property(get_accelerationEngine, set_accelerationEngine)
    def get_nbTrianglesWithinVoxelAcceleration(self): return self._nbTrianglesWithinVoxelAcceleration
    def set_nbTrianglesWithinVoxelAcceleration(self, value):
        self._nbTrianglesWithinVoxelAcceleration = value
        update_node(self,self.troot,"phase")
    nbTrianglesWithinVoxelAcceleration = property(get_nbTrianglesWithinVoxelAcceleration, set_nbTrianglesWithinVoxelAcceleration)
    def get_distanceBetweenIlluminationSubCenters(self): return self._distanceBetweenIlluminationSubCenters
    def set_distanceBetweenIlluminationSubCenters(self, value):
        self._distanceBetweenIlluminationSubCenters = value
        update_node(self,self.troot,"phase")
    distanceBetweenIlluminationSubCenters = property(get_distanceBetweenIlluminationSubCenters, set_distanceBetweenIlluminationSubCenters)
    def get_useExternalScripts(self): return self._useExternalScripts
    def set_useExternalScripts(self, value):
        self._useExternalScripts = value
        update_node(self,self.troot,"phase")
    useExternalScripts = property(get_useExternalScripts, set_useExternalScripts)
    def get_extrapolationMethod(self): return self._extrapolationMethod
    def set_extrapolationMethod(self, value):
        self._extrapolationMethod = value
        update_node(self,self.troot,"phase")
    extrapolationMethod = property(get_extrapolationMethod, set_extrapolationMethod)
    def get_subFaceBarycenterSubdivision(self): return self._subFaceBarycenterSubdivision
    def set_subFaceBarycenterSubdivision(self, value):
        self._subFaceBarycenterSubdivision = value
        update_node(self,self.troot,"phase")
    subFaceBarycenterSubdivision = property(get_subFaceBarycenterSubdivision, set_subFaceBarycenterSubdivision)
    def get_thermalEmissionSurfaceSubdivision(self): return self._thermalEmissionSurfaceSubdivision
    def set_thermalEmissionSurfaceSubdivision(self, value):
        self._thermalEmissionSurfaceSubdivision = value
        update_node(self,self.troot,"phase")
    thermalEmissionSurfaceSubdivision = property(get_thermalEmissionSurfaceSubdivision, set_thermalEmissionSurfaceSubdivision)
    def get_nbSubcenterVolume(self): return self._nbSubcenterVolume
    def set_nbSubcenterVolume(self, value):
        self._nbSubcenterVolume = value
        update_node(self,self.troot,"phase")
    nbSubcenterVolume = property(get_nbSubcenterVolume, set_nbSubcenterVolume)
    def get_expertMode(self): return self._expertMode
    def set_expertMode(self, value):
        self._expertMode = value
        update_node(self,self.troot,"phase")
    expertMode = property(get_expertMode, set_expertMode)
    def get_nbSubSubcenterTurbidEmission(self): return self._nbSubSubcenterTurbidEmission
    def set_nbSubSubcenterTurbidEmission(self, value):
        self._nbSubSubcenterTurbidEmission = value
        update_node(self,self.troot,"phase")
    nbSubSubcenterTurbidEmission = property(get_nbSubSubcenterTurbidEmission, set_nbSubSubcenterTurbidEmission)
    def get_triangleStorageMode(self): return self._triangleStorageMode
    def set_triangleStorageMode(self, value):
        self._triangleStorageMode = value
        update_node(self,self.troot,"phase")
    triangleStorageMode = property(get_triangleStorageMode, set_triangleStorageMode)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ExpertModeZone', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ExpertModeZone')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ExpertModeZone')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ExpertModeZone', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ExpertModeZone'):
        if self.isInterceptedPowerPerDirectionForSpecularCheck is not None and 'isInterceptedPowerPerDirectionForSpecularCheck' not in already_processed:
            already_processed.add('isInterceptedPowerPerDirectionForSpecularCheck')
            outfile.write(' isInterceptedPowerPerDirectionForSpecularCheck="%s"' % self.gds_format_integer(self.isInterceptedPowerPerDirectionForSpecularCheck, input_name='isInterceptedPowerPerDirectionForSpecularCheck'))
        if self.lightPropagationThreshold is not None and 'lightPropagationThreshold' not in already_processed:
            already_processed.add('lightPropagationThreshold')
            outfile.write(' lightPropagationThreshold="%s"' % self.gds_format_double(self.lightPropagationThreshold, input_name='lightPropagationThreshold'))
        if self.nbRandomPointsPerInteceptionAtmosphere is not None and 'nbRandomPointsPerInteceptionAtmosphere' not in already_processed:
            already_processed.add('nbRandomPointsPerInteceptionAtmosphere')
            outfile.write(' nbRandomPointsPerInteceptionAtmosphere="%s"' % self.gds_format_integer(self.nbRandomPointsPerInteceptionAtmosphere, input_name='nbRandomPointsPerInteceptionAtmosphere'))
        if self.illuminationRepartitionMode is not None and 'illuminationRepartitionMode' not in already_processed:
            already_processed.add('illuminationRepartitionMode')
            outfile.write(' illuminationRepartitionMode="%s"' % self.gds_format_integer(self.illuminationRepartitionMode, input_name='illuminationRepartitionMode'))
        if self.nbThreads is not None and 'nbThreads' not in already_processed:
            already_processed.add('nbThreads')
            outfile.write(' nbThreads="%s"' % self.gds_format_integer(self.nbThreads, input_name='nbThreads'))
        if self.albedoThreshold is not None and 'albedoThreshold' not in already_processed:
            already_processed.add('albedoThreshold')
            outfile.write(' albedoThreshold="%s"' % self.gds_format_double(self.albedoThreshold, input_name='albedoThreshold'))
        if self.surfaceBarycenterEnabled is not None and 'surfaceBarycenterEnabled' not in already_processed:
            already_processed.add('surfaceBarycenterEnabled')
            outfile.write(' surfaceBarycenterEnabled="%s"' % self.gds_format_integer(self.surfaceBarycenterEnabled, input_name='surfaceBarycenterEnabled'))
        if self.sparseVoxelAcceleration is not None and 'sparseVoxelAcceleration' not in already_processed:
            already_processed.add('sparseVoxelAcceleration')
            outfile.write(' sparseVoxelAcceleration="%s"' % self.gds_format_integer(self.sparseVoxelAcceleration, input_name='sparseVoxelAcceleration'))
        if self.maxNbSceneCrossing is not None and 'maxNbSceneCrossing' not in already_processed:
            already_processed.add('maxNbSceneCrossing')
            outfile.write(' maxNbSceneCrossing="%s"' % self.gds_format_integer(self.maxNbSceneCrossing, input_name='maxNbSceneCrossing'))
        if self.subFaceBarycenterEnabled is not None and 'subFaceBarycenterEnabled' not in already_processed:
            already_processed.add('subFaceBarycenterEnabled')
            outfile.write(' subFaceBarycenterEnabled="%s"' % self.gds_format_integer(self.subFaceBarycenterEnabled, input_name='subFaceBarycenterEnabled'))
        if self.accelerationEngine is not None and 'accelerationEngine' not in already_processed:
            already_processed.add('accelerationEngine')
            outfile.write(' accelerationEngine="%s"' % self.gds_format_integer(self.accelerationEngine, input_name='accelerationEngine'))
        if self.nbTrianglesWithinVoxelAcceleration is not None and 'nbTrianglesWithinVoxelAcceleration' not in already_processed:
            already_processed.add('nbTrianglesWithinVoxelAcceleration')
            outfile.write(' nbTrianglesWithinVoxelAcceleration="%s"' % self.gds_format_integer(self.nbTrianglesWithinVoxelAcceleration, input_name='nbTrianglesWithinVoxelAcceleration'))
        if self.distanceBetweenIlluminationSubCenters is not None and 'distanceBetweenIlluminationSubCenters' not in already_processed:
            already_processed.add('distanceBetweenIlluminationSubCenters')
            outfile.write(' distanceBetweenIlluminationSubCenters="%s"' % self.gds_format_double(self.distanceBetweenIlluminationSubCenters, input_name='distanceBetweenIlluminationSubCenters'))
        if self.useExternalScripts is not None and 'useExternalScripts' not in already_processed:
            already_processed.add('useExternalScripts')
            outfile.write(' useExternalScripts="%s"' % self.gds_format_integer(self.useExternalScripts, input_name='useExternalScripts'))
        if self.extrapolationMethod is not None and 'extrapolationMethod' not in already_processed:
            already_processed.add('extrapolationMethod')
            outfile.write(' extrapolationMethod="%s"' % self.gds_format_integer(self.extrapolationMethod, input_name='extrapolationMethod'))
        if self.subFaceBarycenterSubdivision is not None and 'subFaceBarycenterSubdivision' not in already_processed:
            already_processed.add('subFaceBarycenterSubdivision')
            outfile.write(' subFaceBarycenterSubdivision="%s"' % self.gds_format_integer(self.subFaceBarycenterSubdivision, input_name='subFaceBarycenterSubdivision'))
        if self.thermalEmissionSurfaceSubdivision is not None and 'thermalEmissionSurfaceSubdivision' not in already_processed:
            already_processed.add('thermalEmissionSurfaceSubdivision')
            outfile.write(' thermalEmissionSurfaceSubdivision="%s"' % self.gds_format_double(self.thermalEmissionSurfaceSubdivision, input_name='thermalEmissionSurfaceSubdivision'))
        if self.nbSubcenterVolume is not None and 'nbSubcenterVolume' not in already_processed:
            already_processed.add('nbSubcenterVolume')
            outfile.write(' nbSubcenterVolume="%s"' % self.gds_format_integer(self.nbSubcenterVolume, input_name='nbSubcenterVolume'))
        if self.expertMode is not None and 'expertMode' not in already_processed:
            already_processed.add('expertMode')
            outfile.write(' expertMode="%s"' % self.gds_format_integer(self.expertMode, input_name='expertMode'))
        if self.nbSubSubcenterTurbidEmission is not None and 'nbSubSubcenterTurbidEmission' not in already_processed:
            already_processed.add('nbSubSubcenterTurbidEmission')
            outfile.write(' nbSubSubcenterTurbidEmission="%s"' % self.gds_format_integer(self.nbSubSubcenterTurbidEmission, input_name='nbSubSubcenterTurbidEmission'))
        if self.triangleStorageMode is not None and 'triangleStorageMode' not in already_processed:
            already_processed.add('triangleStorageMode')
            outfile.write(' triangleStorageMode="%s"' % self.gds_format_integer(self.triangleStorageMode, input_name='triangleStorageMode'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ExpertModeZone', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_ExpertModeZone', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.isInterceptedPowerPerDirectionForSpecularCheck is not None:
            element.set('isInterceptedPowerPerDirectionForSpecularCheck', self.gds_format_integer(self.isInterceptedPowerPerDirectionForSpecularCheck))
        if self.lightPropagationThreshold is not None:
            element.set('lightPropagationThreshold', self.gds_format_double(self.lightPropagationThreshold))
        if self.nbRandomPointsPerInteceptionAtmosphere is not None:
            element.set('nbRandomPointsPerInteceptionAtmosphere', self.gds_format_integer(self.nbRandomPointsPerInteceptionAtmosphere))
        if self.illuminationRepartitionMode is not None:
            element.set('illuminationRepartitionMode', self.gds_format_integer(self.illuminationRepartitionMode))
        if self.nbThreads is not None:
            element.set('nbThreads', self.gds_format_integer(self.nbThreads))
        if self.albedoThreshold is not None:
            element.set('albedoThreshold', self.gds_format_double(self.albedoThreshold))
        if self.surfaceBarycenterEnabled is not None:
            element.set('surfaceBarycenterEnabled', self.gds_format_integer(self.surfaceBarycenterEnabled))
        if self.sparseVoxelAcceleration is not None:
            element.set('sparseVoxelAcceleration', self.gds_format_integer(self.sparseVoxelAcceleration))
        if self.maxNbSceneCrossing is not None:
            element.set('maxNbSceneCrossing', self.gds_format_integer(self.maxNbSceneCrossing))
        if self.subFaceBarycenterEnabled is not None:
            element.set('subFaceBarycenterEnabled', self.gds_format_integer(self.subFaceBarycenterEnabled))
        if self.accelerationEngine is not None:
            element.set('accelerationEngine', self.gds_format_integer(self.accelerationEngine))
        if self.nbTrianglesWithinVoxelAcceleration is not None:
            element.set('nbTrianglesWithinVoxelAcceleration', self.gds_format_integer(self.nbTrianglesWithinVoxelAcceleration))
        if self.distanceBetweenIlluminationSubCenters is not None:
            element.set('distanceBetweenIlluminationSubCenters', self.gds_format_double(self.distanceBetweenIlluminationSubCenters))
        if self.useExternalScripts is not None:
            element.set('useExternalScripts', self.gds_format_integer(self.useExternalScripts))
        if self.extrapolationMethod is not None:
            element.set('extrapolationMethod', self.gds_format_integer(self.extrapolationMethod))
        if self.subFaceBarycenterSubdivision is not None:
            element.set('subFaceBarycenterSubdivision', self.gds_format_integer(self.subFaceBarycenterSubdivision))
        if self.thermalEmissionSurfaceSubdivision is not None:
            element.set('thermalEmissionSurfaceSubdivision', self.gds_format_double(self.thermalEmissionSurfaceSubdivision))
        if self.nbSubcenterVolume is not None:
            element.set('nbSubcenterVolume', self.gds_format_integer(self.nbSubcenterVolume))
        if self.expertMode is not None:
            element.set('expertMode', self.gds_format_integer(self.expertMode))
        if self.nbSubSubcenterTurbidEmission is not None:
            element.set('nbSubSubcenterTurbidEmission', self.gds_format_integer(self.nbSubSubcenterTurbidEmission))
        if self.triangleStorageMode is not None:
            element.set('triangleStorageMode', self.gds_format_integer(self.triangleStorageMode))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ExpertModeZone'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isInterceptedPowerPerDirectionForSpecularCheck is not None and 'isInterceptedPowerPerDirectionForSpecularCheck' not in already_processed:
            already_processed.add('isInterceptedPowerPerDirectionForSpecularCheck')
            showIndent(outfile, level)
            outfile.write('isInterceptedPowerPerDirectionForSpecularCheck=%d,\n' % (self.isInterceptedPowerPerDirectionForSpecularCheck,))
        if self.lightPropagationThreshold is not None and 'lightPropagationThreshold' not in already_processed:
            already_processed.add('lightPropagationThreshold')
            showIndent(outfile, level)
            outfile.write('lightPropagationThreshold=%e,\n' % (self.lightPropagationThreshold,))
        if self.nbRandomPointsPerInteceptionAtmosphere is not None and 'nbRandomPointsPerInteceptionAtmosphere' not in already_processed:
            already_processed.add('nbRandomPointsPerInteceptionAtmosphere')
            showIndent(outfile, level)
            outfile.write('nbRandomPointsPerInteceptionAtmosphere=%d,\n' % (self.nbRandomPointsPerInteceptionAtmosphere,))
        if self.illuminationRepartitionMode is not None and 'illuminationRepartitionMode' not in already_processed:
            already_processed.add('illuminationRepartitionMode')
            showIndent(outfile, level)
            outfile.write('illuminationRepartitionMode=%d,\n' % (self.illuminationRepartitionMode,))
        if self.nbThreads is not None and 'nbThreads' not in already_processed:
            already_processed.add('nbThreads')
            showIndent(outfile, level)
            outfile.write('nbThreads=%d,\n' % (self.nbThreads,))
        if self.albedoThreshold is not None and 'albedoThreshold' not in already_processed:
            already_processed.add('albedoThreshold')
            showIndent(outfile, level)
            outfile.write('albedoThreshold=%e,\n' % (self.albedoThreshold,))
        if self.surfaceBarycenterEnabled is not None and 'surfaceBarycenterEnabled' not in already_processed:
            already_processed.add('surfaceBarycenterEnabled')
            showIndent(outfile, level)
            outfile.write('surfaceBarycenterEnabled=%d,\n' % (self.surfaceBarycenterEnabled,))
        if self.sparseVoxelAcceleration is not None and 'sparseVoxelAcceleration' not in already_processed:
            already_processed.add('sparseVoxelAcceleration')
            showIndent(outfile, level)
            outfile.write('sparseVoxelAcceleration=%d,\n' % (self.sparseVoxelAcceleration,))
        if self.maxNbSceneCrossing is not None and 'maxNbSceneCrossing' not in already_processed:
            already_processed.add('maxNbSceneCrossing')
            showIndent(outfile, level)
            outfile.write('maxNbSceneCrossing=%d,\n' % (self.maxNbSceneCrossing,))
        if self.subFaceBarycenterEnabled is not None and 'subFaceBarycenterEnabled' not in already_processed:
            already_processed.add('subFaceBarycenterEnabled')
            showIndent(outfile, level)
            outfile.write('subFaceBarycenterEnabled=%d,\n' % (self.subFaceBarycenterEnabled,))
        if self.accelerationEngine is not None and 'accelerationEngine' not in already_processed:
            already_processed.add('accelerationEngine')
            showIndent(outfile, level)
            outfile.write('accelerationEngine=%d,\n' % (self.accelerationEngine,))
        if self.nbTrianglesWithinVoxelAcceleration is not None and 'nbTrianglesWithinVoxelAcceleration' not in already_processed:
            already_processed.add('nbTrianglesWithinVoxelAcceleration')
            showIndent(outfile, level)
            outfile.write('nbTrianglesWithinVoxelAcceleration=%d,\n' % (self.nbTrianglesWithinVoxelAcceleration,))
        if self.distanceBetweenIlluminationSubCenters is not None and 'distanceBetweenIlluminationSubCenters' not in already_processed:
            already_processed.add('distanceBetweenIlluminationSubCenters')
            showIndent(outfile, level)
            outfile.write('distanceBetweenIlluminationSubCenters=%e,\n' % (self.distanceBetweenIlluminationSubCenters,))
        if self.useExternalScripts is not None and 'useExternalScripts' not in already_processed:
            already_processed.add('useExternalScripts')
            showIndent(outfile, level)
            outfile.write('useExternalScripts=%d,\n' % (self.useExternalScripts,))
        if self.extrapolationMethod is not None and 'extrapolationMethod' not in already_processed:
            already_processed.add('extrapolationMethod')
            showIndent(outfile, level)
            outfile.write('extrapolationMethod=%d,\n' % (self.extrapolationMethod,))
        if self.subFaceBarycenterSubdivision is not None and 'subFaceBarycenterSubdivision' not in already_processed:
            already_processed.add('subFaceBarycenterSubdivision')
            showIndent(outfile, level)
            outfile.write('subFaceBarycenterSubdivision=%d,\n' % (self.subFaceBarycenterSubdivision,))
        if self.thermalEmissionSurfaceSubdivision is not None and 'thermalEmissionSurfaceSubdivision' not in already_processed:
            already_processed.add('thermalEmissionSurfaceSubdivision')
            showIndent(outfile, level)
            outfile.write('thermalEmissionSurfaceSubdivision=%e,\n' % (self.thermalEmissionSurfaceSubdivision,))
        if self.nbSubcenterVolume is not None and 'nbSubcenterVolume' not in already_processed:
            already_processed.add('nbSubcenterVolume')
            showIndent(outfile, level)
            outfile.write('nbSubcenterVolume=%d,\n' % (self.nbSubcenterVolume,))
        if self.expertMode is not None and 'expertMode' not in already_processed:
            already_processed.add('expertMode')
            showIndent(outfile, level)
            outfile.write('expertMode=%d,\n' % (self.expertMode,))
        if self.nbSubSubcenterTurbidEmission is not None and 'nbSubSubcenterTurbidEmission' not in already_processed:
            already_processed.add('nbSubSubcenterTurbidEmission')
            showIndent(outfile, level)
            outfile.write('nbSubSubcenterTurbidEmission=%d,\n' % (self.nbSubSubcenterTurbidEmission,))
        if self.triangleStorageMode is not None and 'triangleStorageMode' not in already_processed:
            already_processed.add('triangleStorageMode')
            showIndent(outfile, level)
            outfile.write('triangleStorageMode=%d,\n' % (self.triangleStorageMode,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isInterceptedPowerPerDirectionForSpecularCheck', node)
        if value is not None and 'isInterceptedPowerPerDirectionForSpecularCheck' not in already_processed:
            already_processed.add('isInterceptedPowerPerDirectionForSpecularCheck')
            try:
                self.isInterceptedPowerPerDirectionForSpecularCheck = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('lightPropagationThreshold', node)
        if value is not None and 'lightPropagationThreshold' not in already_processed:
            already_processed.add('lightPropagationThreshold')
            try:
                self.lightPropagationThreshold = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (lightPropagationThreshold): %s' % exp)
        value = find_attr_value_('nbRandomPointsPerInteceptionAtmosphere', node)
        if value is not None and 'nbRandomPointsPerInteceptionAtmosphere' not in already_processed:
            already_processed.add('nbRandomPointsPerInteceptionAtmosphere')
            try:
                self.nbRandomPointsPerInteceptionAtmosphere = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('illuminationRepartitionMode', node)
        if value is not None and 'illuminationRepartitionMode' not in already_processed:
            already_processed.add('illuminationRepartitionMode')
            try:
                self.illuminationRepartitionMode = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('nbThreads', node)
        if value is not None and 'nbThreads' not in already_processed:
            already_processed.add('nbThreads')
            try:
                self.nbThreads = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('albedoThreshold', node)
        if value is not None and 'albedoThreshold' not in already_processed:
            already_processed.add('albedoThreshold')
            try:
                self.albedoThreshold = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (albedoThreshold): %s' % exp)
        value = find_attr_value_('surfaceBarycenterEnabled', node)
        if value is not None and 'surfaceBarycenterEnabled' not in already_processed:
            already_processed.add('surfaceBarycenterEnabled')
            try:
                self.surfaceBarycenterEnabled = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('sparseVoxelAcceleration', node)
        if value is not None and 'sparseVoxelAcceleration' not in already_processed:
            already_processed.add('sparseVoxelAcceleration')
            try:
                self.sparseVoxelAcceleration = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('maxNbSceneCrossing', node)
        if value is not None and 'maxNbSceneCrossing' not in already_processed:
            already_processed.add('maxNbSceneCrossing')
            try:
                self.maxNbSceneCrossing = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('subFaceBarycenterEnabled', node)
        if value is not None and 'subFaceBarycenterEnabled' not in already_processed:
            already_processed.add('subFaceBarycenterEnabled')
            try:
                self.subFaceBarycenterEnabled = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('accelerationEngine', node)
        if value is not None and 'accelerationEngine' not in already_processed:
            already_processed.add('accelerationEngine')
            try:
                self.accelerationEngine = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('nbTrianglesWithinVoxelAcceleration', node)
        if value is not None and 'nbTrianglesWithinVoxelAcceleration' not in already_processed:
            already_processed.add('nbTrianglesWithinVoxelAcceleration')
            try:
                self.nbTrianglesWithinVoxelAcceleration = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('distanceBetweenIlluminationSubCenters', node)
        if value is not None and 'distanceBetweenIlluminationSubCenters' not in already_processed:
            already_processed.add('distanceBetweenIlluminationSubCenters')
            try:
                self.distanceBetweenIlluminationSubCenters = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (distanceBetweenIlluminationSubCenters): %s' % exp)
        value = find_attr_value_('useExternalScripts', node)
        if value is not None and 'useExternalScripts' not in already_processed:
            already_processed.add('useExternalScripts')
            try:
                self.useExternalScripts = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('extrapolationMethod', node)
        if value is not None and 'extrapolationMethod' not in already_processed:
            already_processed.add('extrapolationMethod')
            try:
                self.extrapolationMethod = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('subFaceBarycenterSubdivision', node)
        if value is not None and 'subFaceBarycenterSubdivision' not in already_processed:
            already_processed.add('subFaceBarycenterSubdivision')
            try:
                self.subFaceBarycenterSubdivision = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('thermalEmissionSurfaceSubdivision', node)
        if value is not None and 'thermalEmissionSurfaceSubdivision' not in already_processed:
            already_processed.add('thermalEmissionSurfaceSubdivision')
            try:
                self.thermalEmissionSurfaceSubdivision = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (thermalEmissionSurfaceSubdivision): %s' % exp)
        value = find_attr_value_('nbSubcenterVolume', node)
        if value is not None and 'nbSubcenterVolume' not in already_processed:
            already_processed.add('nbSubcenterVolume')
            try:
                self.nbSubcenterVolume = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('expertMode', node)
        if value is not None and 'expertMode' not in already_processed:
            already_processed.add('expertMode')
            try:
                self.expertMode = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('nbSubSubcenterTurbidEmission', node)
        if value is not None and 'nbSubSubcenterTurbidEmission' not in already_processed:
            already_processed.add('nbSubSubcenterTurbidEmission')
            try:
                self.nbSubSubcenterTurbidEmission = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('triangleStorageMode', node)
        if value is not None and 'triangleStorageMode' not in already_processed:
            already_processed.add('triangleStorageMode')
            try:
                self.triangleStorageMode = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_ExpertModeZone


class create_DartInputParameters(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MonteCarlo=None, Lidar=None, nodefluxtracking=None, SpectralDomainTir=None, SpectralIntervals=None, temperatureAtmosphere=None, ImageSideIllumination=None, nodeIlluminationMode=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_DartInputParameters")
        self.attrib = ['']
        self.children = ['MonteCarlo', 'Lidar', 'nodefluxtracking', 'SpectralDomainTir', 'SpectralIntervals', 'temperatureAtmosphere', 'ImageSideIllumination', 'nodeIlluminationMode']
        self.parent = None
        self._MonteCarlo = MonteCarlo
        self._Lidar = Lidar
        self._nodefluxtracking = nodefluxtracking
        self._SpectralDomainTir = SpectralDomainTir
        self._SpectralIntervals = SpectralIntervals
        self._temperatureAtmosphere = temperatureAtmosphere
        self._ImageSideIllumination = ImageSideIllumination
        self._nodeIlluminationMode = nodeIlluminationMode
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_DartInputParameters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_DartInputParameters.subclass:
            return create_DartInputParameters.subclass(*args_, **kwargs_)
        else:
            return create_DartInputParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MonteCarlo(self): return self._MonteCarlo
    def set_MonteCarlo(self, value):
        if value is not None:
            checkclass(value, create_MonteCarlo)
            value.parent = self
        self._MonteCarlo = value
    MonteCarlo = property(get_MonteCarlo, set_MonteCarlo)
    def get_Lidar(self): return self._Lidar
    def set_Lidar(self, value):
        if value is not None:
            checkclass(value, create_Lidar)
            value.parent = self
        self._Lidar = value
    Lidar = property(get_Lidar, set_Lidar)
    def get_nodefluxtracking(self): return self._nodefluxtracking
    def set_nodefluxtracking(self, value):
        if value is not None:
            checkclass(value, create_nodefluxtracking)
            value.parent = self
        self._nodefluxtracking = value
    nodefluxtracking = property(get_nodefluxtracking, set_nodefluxtracking)
    def get_SpectralDomainTir(self): return self._SpectralDomainTir
    def set_SpectralDomainTir(self, value):
        if value is not None:
            checkclass(value, create_SpectralDomainTir)
            value.parent = self
        self._SpectralDomainTir = value
    SpectralDomainTir = property(get_SpectralDomainTir, set_SpectralDomainTir)
    def get_SpectralIntervals(self): return self._SpectralIntervals
    def set_SpectralIntervals(self, value):
        if value is not None:
            checkclass(value, create_SpectralIntervals)
            value.parent = self
        self._SpectralIntervals = value
    SpectralIntervals = property(get_SpectralIntervals, set_SpectralIntervals)
    def get_temperatureAtmosphere(self): return self._temperatureAtmosphere
    def set_temperatureAtmosphere(self, value):
        if value is not None:
            checkclass(value, create_temperatureAtmosphere)
            value.parent = self
        self._temperatureAtmosphere = value
    temperatureAtmosphere = property(get_temperatureAtmosphere, set_temperatureAtmosphere)
    def get_ImageSideIllumination(self): return self._ImageSideIllumination
    def set_ImageSideIllumination(self, value):
        if value is not None:
            checkclass(value, create_ImageSideIllumination)
            value.parent = self
        self._ImageSideIllumination = value
    ImageSideIllumination = property(get_ImageSideIllumination, set_ImageSideIllumination)
    def get_nodeIlluminationMode(self): return self._nodeIlluminationMode
    def set_nodeIlluminationMode(self, value):
        if value is not None:
            checkclass(value, create_nodeIlluminationMode)
            value.parent = self
        self._nodeIlluminationMode = value
    nodeIlluminationMode = property(get_nodeIlluminationMode, set_nodeIlluminationMode)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.MonteCarlo is not None or
            self.Lidar is not None or
            self.nodefluxtracking is not None or
            self.SpectralDomainTir is not None or
            self.SpectralIntervals is not None or
            self.temperatureAtmosphere is not None or
            self.ImageSideIllumination is not None or
            self.nodeIlluminationMode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_DartInputParameters', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_DartInputParameters')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_DartInputParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_DartInputParameters', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_DartInputParameters'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_DartInputParameters', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MonteCarlo is not None:
            self.MonteCarlo.export(outfile, level, namespaceprefix_, name_='MonteCarlo', pretty_print=pretty_print)
        if self.Lidar is not None:
            self.Lidar.export(outfile, level, namespaceprefix_, name_='Lidar', pretty_print=pretty_print)
        if self.nodefluxtracking is not None:
            self.nodefluxtracking.export(outfile, level, namespaceprefix_, name_='nodefluxtracking', pretty_print=pretty_print)
        if self.SpectralDomainTir is not None:
            self.SpectralDomainTir.export(outfile, level, namespaceprefix_, name_='SpectralDomainTir', pretty_print=pretty_print)
        if self.SpectralIntervals is not None:
            self.SpectralIntervals.export(outfile, level, namespaceprefix_, name_='SpectralIntervals', pretty_print=pretty_print)
        if self.temperatureAtmosphere is not None:
            self.temperatureAtmosphere.export(outfile, level, namespaceprefix_, name_='temperatureAtmosphere', pretty_print=pretty_print)
        if self.ImageSideIllumination is not None:
            self.ImageSideIllumination.export(outfile, level, namespaceprefix_, name_='ImageSideIllumination', pretty_print=pretty_print)
        if self.nodeIlluminationMode is not None:
            self.nodeIlluminationMode.export(outfile, level, namespaceprefix_, name_='nodeIlluminationMode', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_DartInputParameters', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.MonteCarlo is not None:
            MonteCarlo_ = self.MonteCarlo
            MonteCarlo_.to_etree(element, name_='MonteCarlo', mapping_=mapping_)
        if self.Lidar is not None:
            Lidar_ = self.Lidar
            Lidar_.to_etree(element, name_='Lidar', mapping_=mapping_)
        if self.nodefluxtracking is not None:
            nodefluxtracking_ = self.nodefluxtracking
            nodefluxtracking_.to_etree(element, name_='nodefluxtracking', mapping_=mapping_)
        if self.SpectralDomainTir is not None:
            SpectralDomainTir_ = self.SpectralDomainTir
            SpectralDomainTir_.to_etree(element, name_='SpectralDomainTir', mapping_=mapping_)
        if self.SpectralIntervals is not None:
            SpectralIntervals_ = self.SpectralIntervals
            SpectralIntervals_.to_etree(element, name_='SpectralIntervals', mapping_=mapping_)
        if self.temperatureAtmosphere is not None:
            temperatureAtmosphere_ = self.temperatureAtmosphere
            temperatureAtmosphere_.to_etree(element, name_='temperatureAtmosphere', mapping_=mapping_)
        if self.ImageSideIllumination is not None:
            ImageSideIllumination_ = self.ImageSideIllumination
            ImageSideIllumination_.to_etree(element, name_='ImageSideIllumination', mapping_=mapping_)
        if self.nodeIlluminationMode is not None:
            nodeIlluminationMode_ = self.nodeIlluminationMode
            nodeIlluminationMode_.to_etree(element, name_='nodeIlluminationMode', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_DartInputParameters'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MonteCarlo is not None:
            showIndent(outfile, level)
            outfile.write('MonteCarlo=model_._MonteCarlo(\n')
            self.MonteCarlo.exportLiteral(outfile, level, name_='MonteCarlo')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Lidar is not None:
            showIndent(outfile, level)
            outfile.write('Lidar=model_._Lidar(\n')
            self.Lidar.exportLiteral(outfile, level, name_='Lidar')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.nodefluxtracking is not None:
            showIndent(outfile, level)
            outfile.write('nodefluxtracking=model_._nodefluxtracking(\n')
            self.nodefluxtracking.exportLiteral(outfile, level, name_='nodefluxtracking')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SpectralDomainTir is not None:
            showIndent(outfile, level)
            outfile.write('SpectralDomainTir=model_._SpectralDomainTir(\n')
            self.SpectralDomainTir.exportLiteral(outfile, level, name_='SpectralDomainTir')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SpectralIntervals is not None:
            showIndent(outfile, level)
            outfile.write('SpectralIntervals=model_._SpectralIntervals(\n')
            self.SpectralIntervals.exportLiteral(outfile, level, name_='SpectralIntervals')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.temperatureAtmosphere is not None:
            showIndent(outfile, level)
            outfile.write('temperatureAtmosphere=model_._temperatureAtmosphere(\n')
            self.temperatureAtmosphere.exportLiteral(outfile, level, name_='temperatureAtmosphere')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ImageSideIllumination is not None:
            showIndent(outfile, level)
            outfile.write('ImageSideIllumination=model_._ImageSideIllumination(\n')
            self.ImageSideIllumination.exportLiteral(outfile, level, name_='ImageSideIllumination')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.nodeIlluminationMode is not None:
            showIndent(outfile, level)
            outfile.write('nodeIlluminationMode=model_._nodeIlluminationMode(\n')
            self.nodeIlluminationMode.exportLiteral(outfile, level, name_='nodeIlluminationMode')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MonteCarlo':
            obj_ = create_MonteCarlo.factory()
            obj_.build(child_)
            self.set_MonteCarlo(obj_)
            obj_.original_tagname_ = 'MonteCarlo'
        elif nodeName_ == 'Lidar':
            obj_ = create_Lidar.factory()
            obj_.build(child_)
            self.set_Lidar(obj_)
            obj_.original_tagname_ = 'Lidar'
        elif nodeName_ == 'nodefluxtracking':
            obj_ = create_nodefluxtracking.factory()
            obj_.build(child_)
            self.set_nodefluxtracking(obj_)
            obj_.original_tagname_ = 'nodefluxtracking'
        elif nodeName_ == 'SpectralDomainTir':
            obj_ = create_SpectralDomainTir.factory()
            obj_.build(child_)
            self.set_SpectralDomainTir(obj_)
            obj_.original_tagname_ = 'SpectralDomainTir'
        elif nodeName_ == 'SpectralIntervals':
            obj_ = create_SpectralIntervals.factory()
            obj_.build(child_)
            self.set_SpectralIntervals(obj_)
            obj_.original_tagname_ = 'SpectralIntervals'
        elif nodeName_ == 'temperatureAtmosphere':
            obj_ = create_temperatureAtmosphere.factory()
            obj_.build(child_)
            self.set_temperatureAtmosphere(obj_)
            obj_.original_tagname_ = 'temperatureAtmosphere'
        elif nodeName_ == 'ImageSideIllumination':
            obj_ = create_ImageSideIllumination.factory()
            obj_.build(child_)
            self.set_ImageSideIllumination(obj_)
            obj_.original_tagname_ = 'ImageSideIllumination'
        elif nodeName_ == 'nodeIlluminationMode':
            obj_ = create_nodeIlluminationMode.factory()
            obj_.build(child_)
            self.set_nodeIlluminationMode(obj_)
            obj_.original_tagname_ = 'nodeIlluminationMode'
# end class create_DartInputParameters


class create_MonteCarlo(GeneratedsSuper):
    """MonteCarlo MonteCarlo If a photon reach the maximum order of
    scattering + 1, it is considered lost If a photon reach the
    maximum order of scattering + 1, it is considered lost This
    information is used for a better management of RAM This
    information is used for a better management of RAM -LIDAR:
    approximate number of photons emitted by the LIDAR\n-Monte
    Carlo: number of photons emitted per illumination cell. -LIDAR:
    approximate number of photons emitted by the LIDAR\n-Monte
    Carlo: number of photons emitted per illumination cell."""
    subclass = None
    superclass = None
    def __init__(self, maximumScatteringOrder=100, calculatorMaximumRAM=1000, numberofPhotons=10000):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_MonteCarlo")
        self.attrib = ['maximumScatteringOrder', 'calculatorMaximumRAM', 'numberofPhotons']
        self.children = []
        self.parent = None
        self._maximumScatteringOrder = _cast(int, maximumScatteringOrder)
        self._calculatorMaximumRAM = _cast(int, calculatorMaximumRAM)
        self._numberofPhotons = _cast(int, numberofPhotons)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_MonteCarlo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_MonteCarlo.subclass:
            return create_MonteCarlo.subclass(*args_, **kwargs_)
        else:
            return create_MonteCarlo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_maximumScatteringOrder(self): return self._maximumScatteringOrder
    def set_maximumScatteringOrder(self, value):
        self._maximumScatteringOrder = value
        update_node(self,self.troot,"phase")
    maximumScatteringOrder = property(get_maximumScatteringOrder, set_maximumScatteringOrder)
    def get_calculatorMaximumRAM(self): return self._calculatorMaximumRAM
    def set_calculatorMaximumRAM(self, value):
        self._calculatorMaximumRAM = value
        update_node(self,self.troot,"phase")
    calculatorMaximumRAM = property(get_calculatorMaximumRAM, set_calculatorMaximumRAM)
    def get_numberofPhotons(self): return self._numberofPhotons
    def set_numberofPhotons(self, value):
        self._numberofPhotons = value
        update_node(self,self.troot,"phase")
    numberofPhotons = property(get_numberofPhotons, set_numberofPhotons)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_MonteCarlo', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_MonteCarlo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_MonteCarlo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_MonteCarlo', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_MonteCarlo'):
        if self.maximumScatteringOrder is not None and 'maximumScatteringOrder' not in already_processed:
            already_processed.add('maximumScatteringOrder')
            outfile.write(' maximumScatteringOrder="%s"' % self.gds_format_integer(self.maximumScatteringOrder, input_name='maximumScatteringOrder'))
        if self.calculatorMaximumRAM is not None and 'calculatorMaximumRAM' not in already_processed:
            already_processed.add('calculatorMaximumRAM')
            outfile.write(' calculatorMaximumRAM="%s"' % self.gds_format_integer(self.calculatorMaximumRAM, input_name='calculatorMaximumRAM'))
        if self.numberofPhotons is not None and 'numberofPhotons' not in already_processed:
            already_processed.add('numberofPhotons')
            outfile.write(' numberofPhotons="%s"' % self.gds_format_integer(self.numberofPhotons, input_name='numberofPhotons'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_MonteCarlo', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_MonteCarlo', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.maximumScatteringOrder is not None:
            element.set('maximumScatteringOrder', self.gds_format_integer(self.maximumScatteringOrder))
        if self.calculatorMaximumRAM is not None:
            element.set('calculatorMaximumRAM', self.gds_format_integer(self.calculatorMaximumRAM))
        if self.numberofPhotons is not None:
            element.set('numberofPhotons', self.gds_format_integer(self.numberofPhotons))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_MonteCarlo'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.maximumScatteringOrder is not None and 'maximumScatteringOrder' not in already_processed:
            already_processed.add('maximumScatteringOrder')
            showIndent(outfile, level)
            outfile.write('maximumScatteringOrder=%d,\n' % (self.maximumScatteringOrder,))
        if self.calculatorMaximumRAM is not None and 'calculatorMaximumRAM' not in already_processed:
            already_processed.add('calculatorMaximumRAM')
            showIndent(outfile, level)
            outfile.write('calculatorMaximumRAM=%d,\n' % (self.calculatorMaximumRAM,))
        if self.numberofPhotons is not None and 'numberofPhotons' not in already_processed:
            already_processed.add('numberofPhotons')
            showIndent(outfile, level)
            outfile.write('numberofPhotons=%d,\n' % (self.numberofPhotons,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('maximumScatteringOrder', node)
        if value is not None and 'maximumScatteringOrder' not in already_processed:
            already_processed.add('maximumScatteringOrder')
            try:
                self.maximumScatteringOrder = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('calculatorMaximumRAM', node)
        if value is not None and 'calculatorMaximumRAM' not in already_processed:
            already_processed.add('calculatorMaximumRAM')
            try:
                self.calculatorMaximumRAM = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('numberofPhotons', node)
        if value is not None and 'numberofPhotons' not in already_processed:
            already_processed.add('numberofPhotons')
            try:
                self.numberofPhotons = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_MonteCarlo


class create_Lidar(GeneratedsSuper):
    """Image mode will generate multiple pulse across a defined area. The
    results are an image as well as a waveform for each pulse. Image
    mode will generate multiple pulse across a defined area. The
    results are an image as well as a waveform for each pulse. Check
    to simulate Solar Noise Check to simulate Solar Noise"""
    subclass = None
    superclass = None
    def __init__(self, simulateImage=0, simulateSolarNoise=0, PhotonCounting=None, RunningMode=None, FluxtrackingSolarNoise=None, PulseDuration=None, LidarGeometry=None, LidarIlluminationIntensity=None, LidarAcquisitionParameters=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_Lidar")
        self.attrib = ['simulateImage', 'simulateSolarNoise']
        self.children = ['PhotonCounting', 'RunningMode', 'FluxtrackingSolarNoise', 'PulseDuration', 'LidarGeometry', 'LidarIlluminationIntensity', 'LidarAcquisitionParameters']
        self.parent = None
        self._simulateImage = _cast(int, simulateImage)
        self._simulateSolarNoise = _cast(int, simulateSolarNoise)
        self._PhotonCounting = PhotonCounting
        self._RunningMode = RunningMode
        self._FluxtrackingSolarNoise = FluxtrackingSolarNoise
        self._PulseDuration = PulseDuration
        self._LidarGeometry = LidarGeometry
        self._LidarIlluminationIntensity = LidarIlluminationIntensity
        self._LidarAcquisitionParameters = LidarAcquisitionParameters
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Lidar)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Lidar.subclass:
            return create_Lidar.subclass(*args_, **kwargs_)
        else:
            return create_Lidar(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PhotonCounting(self): return self._PhotonCounting
    def set_PhotonCounting(self, value):
        if value is not None:
            checkclass(value, create_PhotonCounting)
            value.parent = self
        self._PhotonCounting = value
    PhotonCounting = property(get_PhotonCounting, set_PhotonCounting)
    def get_RunningMode(self): return self._RunningMode
    def set_RunningMode(self, value):
        if value is not None:
            checkclass(value, create_RunningMode)
            value.parent = self
        self._RunningMode = value
    RunningMode = property(get_RunningMode, set_RunningMode)
    def get_FluxtrackingSolarNoise(self): return self._FluxtrackingSolarNoise
    def set_FluxtrackingSolarNoise(self, value):
        if value is not None:
            checkclass(value, create_FluxtrackingSolarNoise)
            value.parent = self
        self._FluxtrackingSolarNoise = value
    FluxtrackingSolarNoise = property(get_FluxtrackingSolarNoise, set_FluxtrackingSolarNoise)
    def get_PulseDuration(self): return self._PulseDuration
    def set_PulseDuration(self, value):
        if value is not None:
            checkclass(value, create_PulseDuration)
            value.parent = self
        self._PulseDuration = value
    PulseDuration = property(get_PulseDuration, set_PulseDuration)
    def get_LidarGeometry(self): return self._LidarGeometry
    def set_LidarGeometry(self, value):
        if value is not None:
            checkclass(value, create_LidarGeometry)
            value.parent = self
        self._LidarGeometry = value
    LidarGeometry = property(get_LidarGeometry, set_LidarGeometry)
    def get_LidarIlluminationIntensity(self): return self._LidarIlluminationIntensity
    def set_LidarIlluminationIntensity(self, value):
        if value is not None:
            checkclass(value, create_LidarIlluminationIntensity)
            value.parent = self
        self._LidarIlluminationIntensity = value
    LidarIlluminationIntensity = property(get_LidarIlluminationIntensity, set_LidarIlluminationIntensity)
    def get_LidarAcquisitionParameters(self): return self._LidarAcquisitionParameters
    def set_LidarAcquisitionParameters(self, value):
        if value is not None:
            checkclass(value, create_LidarAcquisitionParameters)
            value.parent = self
        self._LidarAcquisitionParameters = value
    LidarAcquisitionParameters = property(get_LidarAcquisitionParameters, set_LidarAcquisitionParameters)
    def get_simulateImage(self): return self._simulateImage
    def set_simulateImage(self, value):
        self._simulateImage = value
        update_node(self,self.troot,"phase")
    simulateImage = property(get_simulateImage, set_simulateImage)
    def get_simulateSolarNoise(self): return self._simulateSolarNoise
    def set_simulateSolarNoise(self, value):
        self._simulateSolarNoise = value
        update_node(self,self.troot,"phase")
    simulateSolarNoise = property(get_simulateSolarNoise, set_simulateSolarNoise)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.PhotonCounting is not None or
            self.RunningMode is not None or
            self.FluxtrackingSolarNoise is not None or
            self.PulseDuration is not None or
            self.LidarGeometry is not None or
            self.LidarIlluminationIntensity is not None or
            self.LidarAcquisitionParameters is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Lidar', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Lidar')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Lidar')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Lidar', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Lidar'):
        if self.simulateImage is not None and 'simulateImage' not in already_processed:
            already_processed.add('simulateImage')
            outfile.write(' simulateImage="%s"' % self.gds_format_integer(self.simulateImage, input_name='simulateImage'))
        if self.simulateSolarNoise is not None and 'simulateSolarNoise' not in already_processed:
            already_processed.add('simulateSolarNoise')
            outfile.write(' simulateSolarNoise="%s"' % self.gds_format_integer(self.simulateSolarNoise, input_name='simulateSolarNoise'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Lidar', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PhotonCounting is not None:
            self.PhotonCounting.export(outfile, level, namespaceprefix_, name_='PhotonCounting', pretty_print=pretty_print)
        if self.RunningMode is not None:
            self.RunningMode.export(outfile, level, namespaceprefix_, name_='RunningMode', pretty_print=pretty_print)
        if self.FluxtrackingSolarNoise is not None:
            self.FluxtrackingSolarNoise.export(outfile, level, namespaceprefix_, name_='FluxtrackingSolarNoise', pretty_print=pretty_print)
        if self.PulseDuration is not None:
            self.PulseDuration.export(outfile, level, namespaceprefix_, name_='PulseDuration', pretty_print=pretty_print)
        if self.LidarGeometry is not None:
            self.LidarGeometry.export(outfile, level, namespaceprefix_, name_='LidarGeometry', pretty_print=pretty_print)
        if self.LidarIlluminationIntensity is not None:
            self.LidarIlluminationIntensity.export(outfile, level, namespaceprefix_, name_='LidarIlluminationIntensity', pretty_print=pretty_print)
        if self.LidarAcquisitionParameters is not None:
            self.LidarAcquisitionParameters.export(outfile, level, namespaceprefix_, name_='LidarAcquisitionParameters', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Lidar', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.simulateImage is not None:
            element.set('simulateImage', self.gds_format_integer(self.simulateImage))
        if self.simulateSolarNoise is not None:
            element.set('simulateSolarNoise', self.gds_format_integer(self.simulateSolarNoise))
        if self.PhotonCounting is not None:
            PhotonCounting_ = self.PhotonCounting
            PhotonCounting_.to_etree(element, name_='PhotonCounting', mapping_=mapping_)
        if self.RunningMode is not None:
            RunningMode_ = self.RunningMode
            RunningMode_.to_etree(element, name_='RunningMode', mapping_=mapping_)
        if self.FluxtrackingSolarNoise is not None:
            FluxtrackingSolarNoise_ = self.FluxtrackingSolarNoise
            FluxtrackingSolarNoise_.to_etree(element, name_='FluxtrackingSolarNoise', mapping_=mapping_)
        if self.PulseDuration is not None:
            PulseDuration_ = self.PulseDuration
            PulseDuration_.to_etree(element, name_='PulseDuration', mapping_=mapping_)
        if self.LidarGeometry is not None:
            LidarGeometry_ = self.LidarGeometry
            LidarGeometry_.to_etree(element, name_='LidarGeometry', mapping_=mapping_)
        if self.LidarIlluminationIntensity is not None:
            LidarIlluminationIntensity_ = self.LidarIlluminationIntensity
            LidarIlluminationIntensity_.to_etree(element, name_='LidarIlluminationIntensity', mapping_=mapping_)
        if self.LidarAcquisitionParameters is not None:
            LidarAcquisitionParameters_ = self.LidarAcquisitionParameters
            LidarAcquisitionParameters_.to_etree(element, name_='LidarAcquisitionParameters', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Lidar'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.simulateImage is not None and 'simulateImage' not in already_processed:
            already_processed.add('simulateImage')
            showIndent(outfile, level)
            outfile.write('simulateImage=%d,\n' % (self.simulateImage,))
        if self.simulateSolarNoise is not None and 'simulateSolarNoise' not in already_processed:
            already_processed.add('simulateSolarNoise')
            showIndent(outfile, level)
            outfile.write('simulateSolarNoise=%d,\n' % (self.simulateSolarNoise,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PhotonCounting is not None:
            showIndent(outfile, level)
            outfile.write('PhotonCounting=model_._PhotonCounting(\n')
            self.PhotonCounting.exportLiteral(outfile, level, name_='PhotonCounting')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RunningMode is not None:
            showIndent(outfile, level)
            outfile.write('RunningMode=model_._RunningMode(\n')
            self.RunningMode.exportLiteral(outfile, level, name_='RunningMode')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FluxtrackingSolarNoise is not None:
            showIndent(outfile, level)
            outfile.write('FluxtrackingSolarNoise=model_._FluxtrackingSolarNoise(\n')
            self.FluxtrackingSolarNoise.exportLiteral(outfile, level, name_='FluxtrackingSolarNoise')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PulseDuration is not None:
            showIndent(outfile, level)
            outfile.write('PulseDuration=model_._PulseDuration(\n')
            self.PulseDuration.exportLiteral(outfile, level, name_='PulseDuration')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LidarGeometry is not None:
            showIndent(outfile, level)
            outfile.write('LidarGeometry=model_._LidarGeometry(\n')
            self.LidarGeometry.exportLiteral(outfile, level, name_='LidarGeometry')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LidarIlluminationIntensity is not None:
            showIndent(outfile, level)
            outfile.write('LidarIlluminationIntensity=model_._LidarIlluminationIntensity(\n')
            self.LidarIlluminationIntensity.exportLiteral(outfile, level, name_='LidarIlluminationIntensity')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LidarAcquisitionParameters is not None:
            showIndent(outfile, level)
            outfile.write('LidarAcquisitionParameters=model_._LidarAcquisitionParameters(\n')
            self.LidarAcquisitionParameters.exportLiteral(outfile, level, name_='LidarAcquisitionParameters')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('simulateImage', node)
        if value is not None and 'simulateImage' not in already_processed:
            already_processed.add('simulateImage')
            try:
                self.simulateImage = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('simulateSolarNoise', node)
        if value is not None and 'simulateSolarNoise' not in already_processed:
            already_processed.add('simulateSolarNoise')
            try:
                self.simulateSolarNoise = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PhotonCounting':
            obj_ = create_PhotonCounting.factory()
            obj_.build(child_)
            self.set_PhotonCounting(obj_)
            obj_.original_tagname_ = 'PhotonCounting'
        elif nodeName_ == 'RunningMode':
            obj_ = create_RunningMode.factory()
            obj_.build(child_)
            self.set_RunningMode(obj_)
            obj_.original_tagname_ = 'RunningMode'
        elif nodeName_ == 'FluxtrackingSolarNoise':
            obj_ = create_FluxtrackingSolarNoise.factory()
            obj_.build(child_)
            self.set_FluxtrackingSolarNoise(obj_)
            obj_.original_tagname_ = 'FluxtrackingSolarNoise'
        elif nodeName_ == 'PulseDuration':
            obj_ = create_PulseDuration.factory()
            obj_.build(child_)
            self.set_PulseDuration(obj_)
            obj_.original_tagname_ = 'PulseDuration'
        elif nodeName_ == 'LidarGeometry':
            obj_ = create_LidarGeometry.factory()
            obj_.build(child_)
            self.set_LidarGeometry(obj_)
            obj_.original_tagname_ = 'LidarGeometry'
        elif nodeName_ == 'LidarIlluminationIntensity':
            obj_ = create_LidarIlluminationIntensity.factory()
            obj_.build(child_)
            self.set_LidarIlluminationIntensity(obj_)
            obj_.original_tagname_ = 'LidarIlluminationIntensity'
        elif nodeName_ == 'LidarAcquisitionParameters':
            obj_ = create_LidarAcquisitionParameters.factory()
            obj_.build(child_)
            self.set_LidarAcquisitionParameters(obj_)
            obj_.original_tagname_ = 'LidarAcquisitionParameters'
# end class create_Lidar


class create_PhotonCounting(GeneratedsSuper):
    """LiDAR Type LiDAR Type Select Type Select Type"""
    subclass = None
    superclass = None
    def __init__(self, pcDef=0, PhotonCountingParam=None, DiscreteReturnParam=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_PhotonCounting")
        self.attrib = ['pcDef']
        self.children = ['PhotonCountingParam', 'DiscreteReturnParam']
        self.parent = None
        self._pcDef = _cast(int, pcDef)
        self._PhotonCountingParam = PhotonCountingParam
        self._DiscreteReturnParam = DiscreteReturnParam
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_PhotonCounting)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_PhotonCounting.subclass:
            return create_PhotonCounting.subclass(*args_, **kwargs_)
        else:
            return create_PhotonCounting(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PhotonCountingParam(self): return self._PhotonCountingParam
    def set_PhotonCountingParam(self, value):
        if value is not None:
            checkclass(value, create_PhotonCountingParam)
            value.parent = self
        self._PhotonCountingParam = value
    PhotonCountingParam = property(get_PhotonCountingParam, set_PhotonCountingParam)
    def get_DiscreteReturnParam(self): return self._DiscreteReturnParam
    def set_DiscreteReturnParam(self, value):
        if value is not None:
            checkclass(value, create_DiscreteReturnParam)
            value.parent = self
        self._DiscreteReturnParam = value
    DiscreteReturnParam = property(get_DiscreteReturnParam, set_DiscreteReturnParam)
    def get_pcDef(self): return self._pcDef
    def set_pcDef(self, value):
        self._pcDef = value
        update_node(self,self.troot,"phase")
    pcDef = property(get_pcDef, set_pcDef)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.PhotonCountingParam is not None or
            self.DiscreteReturnParam is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_PhotonCounting', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_PhotonCounting')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_PhotonCounting')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_PhotonCounting', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_PhotonCounting'):
        if self.pcDef is not None and 'pcDef' not in already_processed:
            already_processed.add('pcDef')
            outfile.write(' pcDef="%s"' % self.gds_format_integer(self.pcDef, input_name='pcDef'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_PhotonCounting', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PhotonCountingParam is not None:
            self.PhotonCountingParam.export(outfile, level, namespaceprefix_, name_='PhotonCountingParam', pretty_print=pretty_print)
        if self.DiscreteReturnParam is not None:
            self.DiscreteReturnParam.export(outfile, level, namespaceprefix_, name_='DiscreteReturnParam', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_PhotonCounting', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.pcDef is not None:
            element.set('pcDef', self.gds_format_integer(self.pcDef))
        if self.PhotonCountingParam is not None:
            PhotonCountingParam_ = self.PhotonCountingParam
            PhotonCountingParam_.to_etree(element, name_='PhotonCountingParam', mapping_=mapping_)
        if self.DiscreteReturnParam is not None:
            DiscreteReturnParam_ = self.DiscreteReturnParam
            DiscreteReturnParam_.to_etree(element, name_='DiscreteReturnParam', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_PhotonCounting'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.pcDef is not None and 'pcDef' not in already_processed:
            already_processed.add('pcDef')
            showIndent(outfile, level)
            outfile.write('pcDef=%d,\n' % (self.pcDef,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PhotonCountingParam is not None:
            showIndent(outfile, level)
            outfile.write('PhotonCountingParam=model_._PhotonCountingParam(\n')
            self.PhotonCountingParam.exportLiteral(outfile, level, name_='PhotonCountingParam')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DiscreteReturnParam is not None:
            showIndent(outfile, level)
            outfile.write('DiscreteReturnParam=model_._DiscreteReturnParam(\n')
            self.DiscreteReturnParam.exportLiteral(outfile, level, name_='DiscreteReturnParam')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pcDef', node)
        if value is not None and 'pcDef' not in already_processed:
            already_processed.add('pcDef')
            try:
                self.pcDef = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PhotonCountingParam':
            obj_ = create_PhotonCountingParam.factory()
            obj_.build(child_)
            self.set_PhotonCountingParam(obj_)
            obj_.original_tagname_ = 'PhotonCountingParam'
        elif nodeName_ == 'DiscreteReturnParam':
            obj_ = create_DiscreteReturnParam.factory()
            obj_.build(child_)
            self.set_DiscreteReturnParam(obj_)
            obj_.original_tagname_ = 'DiscreteReturnParam'
# end class create_PhotonCounting


class create_PhotonCountingParam(GeneratedsSuper):
    """Single-photon detector Single-photon detector the probability to
    detect a photon that reaches the detector in the an aquisition
    period the probability to detect a photon that reaches the
    detector in the an aquisition period the period needed by the
    detector to recover from a detection event, before another
    photon can be detected the period needed by the detector to
    recover from a detection event, before another photon can be
    detected the detector's minimum count rate without light source
    the detector's minimum count rate without light source"""
    subclass = None
    superclass = None
    def __init__(self, quantEff=15, deadTime=2.5, darkCountRate=100):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_PhotonCountingParam")
        self.attrib = ['quantEff', 'deadTime', 'darkCountRate']
        self.children = []
        self.parent = None
        self._quantEff = _cast(float, quantEff)
        self._deadTime = _cast(float, deadTime)
        self._darkCountRate = _cast(float, darkCountRate)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_PhotonCountingParam)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_PhotonCountingParam.subclass:
            return create_PhotonCountingParam.subclass(*args_, **kwargs_)
        else:
            return create_PhotonCountingParam(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quantEff(self): return self._quantEff
    def set_quantEff(self, value):
        self._quantEff = value
        update_node(self,self.troot,"phase")
    quantEff = property(get_quantEff, set_quantEff)
    def get_deadTime(self): return self._deadTime
    def set_deadTime(self, value):
        self._deadTime = value
        update_node(self,self.troot,"phase")
    deadTime = property(get_deadTime, set_deadTime)
    def get_darkCountRate(self): return self._darkCountRate
    def set_darkCountRate(self, value):
        self._darkCountRate = value
        update_node(self,self.troot,"phase")
    darkCountRate = property(get_darkCountRate, set_darkCountRate)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_PhotonCountingParam', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_PhotonCountingParam')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_PhotonCountingParam')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_PhotonCountingParam', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_PhotonCountingParam'):
        if self.quantEff is not None and 'quantEff' not in already_processed:
            already_processed.add('quantEff')
            outfile.write(' quantEff="%s"' % self.gds_format_double(self.quantEff, input_name='quantEff'))
        if self.deadTime is not None and 'deadTime' not in already_processed:
            already_processed.add('deadTime')
            outfile.write(' deadTime="%s"' % self.gds_format_double(self.deadTime, input_name='deadTime'))
        if self.darkCountRate is not None and 'darkCountRate' not in already_processed:
            already_processed.add('darkCountRate')
            outfile.write(' darkCountRate="%s"' % self.gds_format_double(self.darkCountRate, input_name='darkCountRate'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_PhotonCountingParam', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_PhotonCountingParam', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.quantEff is not None:
            element.set('quantEff', self.gds_format_double(self.quantEff))
        if self.deadTime is not None:
            element.set('deadTime', self.gds_format_double(self.deadTime))
        if self.darkCountRate is not None:
            element.set('darkCountRate', self.gds_format_double(self.darkCountRate))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_PhotonCountingParam'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.quantEff is not None and 'quantEff' not in already_processed:
            already_processed.add('quantEff')
            showIndent(outfile, level)
            outfile.write('quantEff=%e,\n' % (self.quantEff,))
        if self.deadTime is not None and 'deadTime' not in already_processed:
            already_processed.add('deadTime')
            showIndent(outfile, level)
            outfile.write('deadTime=%e,\n' % (self.deadTime,))
        if self.darkCountRate is not None and 'darkCountRate' not in already_processed:
            already_processed.add('darkCountRate')
            showIndent(outfile, level)
            outfile.write('darkCountRate=%e,\n' % (self.darkCountRate,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('quantEff', node)
        if value is not None and 'quantEff' not in already_processed:
            already_processed.add('quantEff')
            try:
                self.quantEff = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (quantEff): %s' % exp)
        value = find_attr_value_('deadTime', node)
        if value is not None and 'deadTime' not in already_processed:
            already_processed.add('deadTime')
            try:
                self.deadTime = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (deadTime): %s' % exp)
        value = find_attr_value_('darkCountRate', node)
        if value is not None and 'darkCountRate' not in already_processed:
            already_processed.add('darkCountRate')
            try:
                self.darkCountRate = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (darkCountRate): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_PhotonCountingParam


class create_DiscreteReturnParam(GeneratedsSuper):
    """Discrete-return parameters Discrete-return parameters The type of
    the intensity in the discrete point cloud. None: no output. The
    type of the intensity in the discrete point cloud. None: no
    output. Minimum Target Reflectance for Detection. It is
    sometimes specified in the white paper of the LiDAR device. It
    may vary with distance. Minimum Target Reflectance for
    Detection. It is sometimes specified in the white paper of the
    LiDAR device. It may vary with distance. Number of points per
    pulse Number of points per pulse"""
    subclass = None
    superclass = None
    def __init__(self, intensityValueType=2, thresAppRef='0.01', nbPoints='1'):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_DiscreteReturnParam")
        self.attrib = ['intensityValueType', 'thresAppRef', 'nbPoints']
        self.children = []
        self.parent = None
        self._intensityValueType = _cast(int, intensityValueType)
        self._thresAppRef = _cast(None, thresAppRef)
        self._nbPoints = _cast(None, nbPoints)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_DiscreteReturnParam)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_DiscreteReturnParam.subclass:
            return create_DiscreteReturnParam.subclass(*args_, **kwargs_)
        else:
            return create_DiscreteReturnParam(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_intensityValueType(self): return self._intensityValueType
    def set_intensityValueType(self, value):
        self._intensityValueType = value
        update_node(self,self.troot,"phase")
    intensityValueType = property(get_intensityValueType, set_intensityValueType)
    def get_thresAppRef(self): return self._thresAppRef
    def set_thresAppRef(self, value):
        self._thresAppRef = value
        update_node(self,self.troot,"phase")
    thresAppRef = property(get_thresAppRef, set_thresAppRef)
    def get_nbPoints(self): return self._nbPoints
    def set_nbPoints(self, value):
        self._nbPoints = value
        update_node(self,self.troot,"phase")
    nbPoints = property(get_nbPoints, set_nbPoints)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_DiscreteReturnParam', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_DiscreteReturnParam')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_DiscreteReturnParam')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_DiscreteReturnParam', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_DiscreteReturnParam'):
        if self.intensityValueType is not None and 'intensityValueType' not in already_processed:
            already_processed.add('intensityValueType')
            outfile.write(' intensityValueType="%s"' % self.gds_format_integer(self.intensityValueType, input_name='intensityValueType'))
        if self.thresAppRef is not None and 'thresAppRef' not in already_processed:
            already_processed.add('thresAppRef')
            outfile.write(' thresAppRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.thresAppRef), input_name='thresAppRef')), ))
        if self.nbPoints is not None and 'nbPoints' not in already_processed:
            already_processed.add('nbPoints')
            outfile.write(' nbPoints=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.nbPoints), input_name='nbPoints')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_DiscreteReturnParam', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_DiscreteReturnParam', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.intensityValueType is not None:
            element.set('intensityValueType', self.gds_format_integer(self.intensityValueType))
        if self.thresAppRef is not None:
            element.set('thresAppRef', self.gds_format_string(self.thresAppRef))
        if self.nbPoints is not None:
            element.set('nbPoints', self.gds_format_string(self.nbPoints))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_DiscreteReturnParam'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.intensityValueType is not None and 'intensityValueType' not in already_processed:
            already_processed.add('intensityValueType')
            showIndent(outfile, level)
            outfile.write('intensityValueType=%d,\n' % (self.intensityValueType,))
        if self.thresAppRef is not None and 'thresAppRef' not in already_processed:
            already_processed.add('thresAppRef')
            showIndent(outfile, level)
            outfile.write('thresAppRef="%s",\n' % (self.thresAppRef,))
        if self.nbPoints is not None and 'nbPoints' not in already_processed:
            already_processed.add('nbPoints')
            showIndent(outfile, level)
            outfile.write('nbPoints="%s",\n' % (self.nbPoints,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('intensityValueType', node)
        if value is not None and 'intensityValueType' not in already_processed:
            already_processed.add('intensityValueType')
            try:
                self.intensityValueType = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('thresAppRef', node)
        if value is not None and 'thresAppRef' not in already_processed:
            already_processed.add('thresAppRef')
            self.thresAppRef = value
        value = find_attr_value_('nbPoints', node)
        if value is not None and 'nbPoints' not in already_processed:
            already_processed.add('nbPoints')
            self.nbPoints = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_DiscreteReturnParam


class create_RunningMode(GeneratedsSuper):
    """Solar noise running parameters Solar noise running parameters
    Running mode Running mode"""
    subclass = None
    superclass = None
    def __init__(self, snMode=0, AirConfig=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_RunningMode")
        self.attrib = ['snMode']
        self.children = ['AirConfig']
        self.parent = None
        self._snMode = _cast(int, snMode)
        self._AirConfig = AirConfig
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_RunningMode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_RunningMode.subclass:
            return create_RunningMode.subclass(*args_, **kwargs_)
        else:
            return create_RunningMode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AirConfig(self): return self._AirConfig
    def set_AirConfig(self, value):
        if value is not None:
            checkclass(value, create_AirConfig)
            value.parent = self
        self._AirConfig = value
    AirConfig = property(get_AirConfig, set_AirConfig)
    def get_snMode(self): return self._snMode
    def set_snMode(self, value):
        self._snMode = value
        update_node(self,self.troot,"phase")
    snMode = property(get_snMode, set_snMode)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.AirConfig is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_RunningMode', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_RunningMode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_RunningMode')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_RunningMode', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_RunningMode'):
        if self.snMode is not None and 'snMode' not in already_processed:
            already_processed.add('snMode')
            outfile.write(' snMode="%s"' % self.gds_format_integer(self.snMode, input_name='snMode'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_RunningMode', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AirConfig is not None:
            self.AirConfig.export(outfile, level, namespaceprefix_, name_='AirConfig', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_RunningMode', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.snMode is not None:
            element.set('snMode', self.gds_format_integer(self.snMode))
        if self.AirConfig is not None:
            AirConfig_ = self.AirConfig
            AirConfig_.to_etree(element, name_='AirConfig', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_RunningMode'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.snMode is not None and 'snMode' not in already_processed:
            already_processed.add('snMode')
            showIndent(outfile, level)
            outfile.write('snMode=%d,\n' % (self.snMode,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AirConfig is not None:
            showIndent(outfile, level)
            outfile.write('AirConfig=model_._AirConfig(\n')
            self.AirConfig.exportLiteral(outfile, level, name_='AirConfig')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('snMode', node)
        if value is not None and 'snMode' not in already_processed:
            already_processed.add('snMode')
            try:
                self.snMode = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AirConfig':
            obj_ = create_AirConfig.factory()
            obj_.build(child_)
            self.set_AirConfig(obj_)
            obj_.original_tagname_ = 'AirConfig'
# end class create_RunningMode


class create_AirConfig(GeneratedsSuper):
    """Airborne configuration Airborne configuration Airborne Airborne"""
    subclass = None
    superclass = None
    def __init__(self, airSNConfig=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_AirConfig")
        self.attrib = ['airSNConfig']
        self.children = []
        self.parent = None
        self._airSNConfig = _cast(int, airSNConfig)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_AirConfig)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_AirConfig.subclass:
            return create_AirConfig.subclass(*args_, **kwargs_)
        else:
            return create_AirConfig(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_airSNConfig(self): return self._airSNConfig
    def set_airSNConfig(self, value):
        self._airSNConfig = value
        update_node(self,self.troot,"phase")
    airSNConfig = property(get_airSNConfig, set_airSNConfig)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_AirConfig', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_AirConfig')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_AirConfig')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_AirConfig', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_AirConfig'):
        if self.airSNConfig is not None and 'airSNConfig' not in already_processed:
            already_processed.add('airSNConfig')
            outfile.write(' airSNConfig="%s"' % self.gds_format_integer(self.airSNConfig, input_name='airSNConfig'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_AirConfig', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_AirConfig', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.airSNConfig is not None:
            element.set('airSNConfig', self.gds_format_integer(self.airSNConfig))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_AirConfig'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.airSNConfig is not None and 'airSNConfig' not in already_processed:
            already_processed.add('airSNConfig')
            showIndent(outfile, level)
            outfile.write('airSNConfig=%d,\n' % (self.airSNConfig,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('airSNConfig', node)
        if value is not None and 'airSNConfig' not in already_processed:
            already_processed.add('airSNConfig')
            try:
                self.airSNConfig = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_AirConfig


class create_FluxtrackingSolarNoise(GeneratedsSuper):
    """Solar Illumination (Flux Tracking) Solar Illumination (Flux
    Tracking)"""
    subclass = None
    superclass = None
    def __init__(self, nodefluxtracking=None, SpectralDomainTir=None, temperatureAtmosphere=None, nodeIlluminationMode=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_FluxtrackingSolarNoise")
        self.attrib = ['']
        self.children = ['nodefluxtracking', 'SpectralDomainTir', 'temperatureAtmosphere', 'nodeIlluminationMode']
        self.parent = None
        self._nodefluxtracking = nodefluxtracking
        self._SpectralDomainTir = SpectralDomainTir
        self._temperatureAtmosphere = temperatureAtmosphere
        self._nodeIlluminationMode = nodeIlluminationMode
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_FluxtrackingSolarNoise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_FluxtrackingSolarNoise.subclass:
            return create_FluxtrackingSolarNoise.subclass(*args_, **kwargs_)
        else:
            return create_FluxtrackingSolarNoise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nodefluxtracking(self): return self._nodefluxtracking
    def set_nodefluxtracking(self, value):
        if value is not None:
            checkclass(value, create_nodefluxtracking)
            value.parent = self
        self._nodefluxtracking = value
    nodefluxtracking = property(get_nodefluxtracking, set_nodefluxtracking)
    def get_SpectralDomainTir(self): return self._SpectralDomainTir
    def set_SpectralDomainTir(self, value):
        if value is not None:
            checkclass(value, create_SpectralDomainTir)
            value.parent = self
        self._SpectralDomainTir = value
    SpectralDomainTir = property(get_SpectralDomainTir, set_SpectralDomainTir)
    def get_temperatureAtmosphere(self): return self._temperatureAtmosphere
    def set_temperatureAtmosphere(self, value):
        if value is not None:
            checkclass(value, create_temperatureAtmosphere)
            value.parent = self
        self._temperatureAtmosphere = value
    temperatureAtmosphere = property(get_temperatureAtmosphere, set_temperatureAtmosphere)
    def get_nodeIlluminationMode(self): return self._nodeIlluminationMode
    def set_nodeIlluminationMode(self, value):
        if value is not None:
            checkclass(value, create_nodeIlluminationMode)
            value.parent = self
        self._nodeIlluminationMode = value
    nodeIlluminationMode = property(get_nodeIlluminationMode, set_nodeIlluminationMode)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.nodefluxtracking is not None or
            self.SpectralDomainTir is not None or
            self.temperatureAtmosphere is not None or
            self.nodeIlluminationMode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_FluxtrackingSolarNoise', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_FluxtrackingSolarNoise')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_FluxtrackingSolarNoise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_FluxtrackingSolarNoise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_FluxtrackingSolarNoise'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_FluxtrackingSolarNoise', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nodefluxtracking is not None:
            self.nodefluxtracking.export(outfile, level, namespaceprefix_, name_='nodefluxtracking', pretty_print=pretty_print)
        if self.SpectralDomainTir is not None:
            self.SpectralDomainTir.export(outfile, level, namespaceprefix_, name_='SpectralDomainTir', pretty_print=pretty_print)
        if self.temperatureAtmosphere is not None:
            self.temperatureAtmosphere.export(outfile, level, namespaceprefix_, name_='temperatureAtmosphere', pretty_print=pretty_print)
        if self.nodeIlluminationMode is not None:
            self.nodeIlluminationMode.export(outfile, level, namespaceprefix_, name_='nodeIlluminationMode', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_FluxtrackingSolarNoise', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.nodefluxtracking is not None:
            nodefluxtracking_ = self.nodefluxtracking
            nodefluxtracking_.to_etree(element, name_='nodefluxtracking', mapping_=mapping_)
        if self.SpectralDomainTir is not None:
            SpectralDomainTir_ = self.SpectralDomainTir
            SpectralDomainTir_.to_etree(element, name_='SpectralDomainTir', mapping_=mapping_)
        if self.temperatureAtmosphere is not None:
            temperatureAtmosphere_ = self.temperatureAtmosphere
            temperatureAtmosphere_.to_etree(element, name_='temperatureAtmosphere', mapping_=mapping_)
        if self.nodeIlluminationMode is not None:
            nodeIlluminationMode_ = self.nodeIlluminationMode
            nodeIlluminationMode_.to_etree(element, name_='nodeIlluminationMode', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_FluxtrackingSolarNoise'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.nodefluxtracking is not None:
            showIndent(outfile, level)
            outfile.write('nodefluxtracking=model_._nodefluxtracking(\n')
            self.nodefluxtracking.exportLiteral(outfile, level, name_='nodefluxtracking')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SpectralDomainTir is not None:
            showIndent(outfile, level)
            outfile.write('SpectralDomainTir=model_._SpectralDomainTir(\n')
            self.SpectralDomainTir.exportLiteral(outfile, level, name_='SpectralDomainTir')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.temperatureAtmosphere is not None:
            showIndent(outfile, level)
            outfile.write('temperatureAtmosphere=model_._temperatureAtmosphere(\n')
            self.temperatureAtmosphere.exportLiteral(outfile, level, name_='temperatureAtmosphere')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.nodeIlluminationMode is not None:
            showIndent(outfile, level)
            outfile.write('nodeIlluminationMode=model_._nodeIlluminationMode(\n')
            self.nodeIlluminationMode.exportLiteral(outfile, level, name_='nodeIlluminationMode')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nodefluxtracking':
            obj_ = create_nodefluxtracking.factory()
            obj_.build(child_)
            self.set_nodefluxtracking(obj_)
            obj_.original_tagname_ = 'nodefluxtracking'
        elif nodeName_ == 'SpectralDomainTir':
            obj_ = create_SpectralDomainTir.factory()
            obj_.build(child_)
            self.set_SpectralDomainTir(obj_)
            obj_.original_tagname_ = 'SpectralDomainTir'
        elif nodeName_ == 'temperatureAtmosphere':
            obj_ = create_temperatureAtmosphere.factory()
            obj_.build(child_)
            self.set_temperatureAtmosphere(obj_)
            obj_.original_tagname_ = 'temperatureAtmosphere'
        elif nodeName_ == 'nodeIlluminationMode':
            obj_ = create_nodeIlluminationMode.factory()
            obj_.build(child_)
            self.set_nodeIlluminationMode(obj_)
            obj_.original_tagname_ = 'nodeIlluminationMode'
# end class create_FluxtrackingSolarNoise


class create_nodefluxtracking(GeneratedsSuper):
    """nodefluxtracking nodefluxtracking Usually 3-4 in the visible and 4-5
    in the near infrared. A minimum of 3 iterations is necessary for
    completing the extrapolation Usually 3-4 in the visible and 4-5
    in the near infrared. A minimum of 3 iterations is necessary for
    completing the extrapolation This option speeds up DART runs.
    However, it mixes several scattering orders within the same
    iteration This option speeds up DART runs. However, it mixes
    several scattering orders within the same iteration"""
    subclass = None
    superclass = None
    def __init__(self, numberOfIteration=5, gaussSiedelAcceleratingTechnique=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_nodefluxtracking")
        self.attrib = ['numberOfIteration', 'gaussSiedelAcceleratingTechnique']
        self.children = []
        self.parent = None
        self._numberOfIteration = _cast(int, numberOfIteration)
        self._gaussSiedelAcceleratingTechnique = _cast(int, gaussSiedelAcceleratingTechnique)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_nodefluxtracking)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_nodefluxtracking.subclass:
            return create_nodefluxtracking.subclass(*args_, **kwargs_)
        else:
            return create_nodefluxtracking(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_numberOfIteration(self): return self._numberOfIteration
    def set_numberOfIteration(self, value):
        self._numberOfIteration = value
        update_node(self,self.troot,"phase")
    numberOfIteration = property(get_numberOfIteration, set_numberOfIteration)
    def get_gaussSiedelAcceleratingTechnique(self): return self._gaussSiedelAcceleratingTechnique
    def set_gaussSiedelAcceleratingTechnique(self, value):
        self._gaussSiedelAcceleratingTechnique = value
        update_node(self,self.troot,"phase")
    gaussSiedelAcceleratingTechnique = property(get_gaussSiedelAcceleratingTechnique, set_gaussSiedelAcceleratingTechnique)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_nodefluxtracking', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_nodefluxtracking')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_nodefluxtracking')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_nodefluxtracking', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_nodefluxtracking'):
        if self.numberOfIteration is not None and 'numberOfIteration' not in already_processed:
            already_processed.add('numberOfIteration')
            outfile.write(' numberOfIteration="%s"' % self.gds_format_integer(self.numberOfIteration, input_name='numberOfIteration'))
        if self.gaussSiedelAcceleratingTechnique is not None and 'gaussSiedelAcceleratingTechnique' not in already_processed:
            already_processed.add('gaussSiedelAcceleratingTechnique')
            outfile.write(' gaussSiedelAcceleratingTechnique="%s"' % self.gds_format_integer(self.gaussSiedelAcceleratingTechnique, input_name='gaussSiedelAcceleratingTechnique'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_nodefluxtracking', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_nodefluxtracking', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.numberOfIteration is not None:
            element.set('numberOfIteration', self.gds_format_integer(self.numberOfIteration))
        if self.gaussSiedelAcceleratingTechnique is not None:
            element.set('gaussSiedelAcceleratingTechnique', self.gds_format_integer(self.gaussSiedelAcceleratingTechnique))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_nodefluxtracking'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numberOfIteration is not None and 'numberOfIteration' not in already_processed:
            already_processed.add('numberOfIteration')
            showIndent(outfile, level)
            outfile.write('numberOfIteration=%d,\n' % (self.numberOfIteration,))
        if self.gaussSiedelAcceleratingTechnique is not None and 'gaussSiedelAcceleratingTechnique' not in already_processed:
            already_processed.add('gaussSiedelAcceleratingTechnique')
            showIndent(outfile, level)
            outfile.write('gaussSiedelAcceleratingTechnique=%d,\n' % (self.gaussSiedelAcceleratingTechnique,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfIteration', node)
        if value is not None and 'numberOfIteration' not in already_processed:
            already_processed.add('numberOfIteration')
            try:
                self.numberOfIteration = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('gaussSiedelAcceleratingTechnique', node)
        if value is not None and 'gaussSiedelAcceleratingTechnique' not in already_processed:
            already_processed.add('gaussSiedelAcceleratingTechnique')
            try:
                self.gaussSiedelAcceleratingTechnique = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_nodefluxtracking


class create_SpectralDomainTir(GeneratedsSuper):
    """SpectralDomainTir SpectralDomainTir Earth temperature is either
    assessed with a simulation in the visible, or it is simply
    derived from a file that gives temperature in every cell Earth
    temperature is either assessed with a simulation in the visible,
    or it is simply derived from a file that gives temperature in
    every cell"""
    subclass = None
    superclass = None
    def __init__(self, temperatureMode=0, TemperatureFile=None, skylTemperature=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_SpectralDomainTir")
        self.attrib = ['temperatureMode']
        self.children = ['TemperatureFile', 'skylTemperature']
        self.parent = None
        self._temperatureMode = _cast(int, temperatureMode)
        self._TemperatureFile = TemperatureFile
        self._skylTemperature = skylTemperature
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_SpectralDomainTir)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_SpectralDomainTir.subclass:
            return create_SpectralDomainTir.subclass(*args_, **kwargs_)
        else:
            return create_SpectralDomainTir(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TemperatureFile(self): return self._TemperatureFile
    def set_TemperatureFile(self, value):
        if value is not None:
            checkclass(value, create_TemperatureFile)
            value.parent = self
        self._TemperatureFile = value
    TemperatureFile = property(get_TemperatureFile, set_TemperatureFile)
    def get_skylTemperature(self): return self._skylTemperature
    def set_skylTemperature(self, value):
        if value is not None:
            checkclass(value, create_skylTemperature)
            value.parent = self
        self._skylTemperature = value
    skylTemperature = property(get_skylTemperature, set_skylTemperature)
    def get_temperatureMode(self): return self._temperatureMode
    def set_temperatureMode(self, value):
        self._temperatureMode = value
        update_node(self,self.troot,"phase")
    temperatureMode = property(get_temperatureMode, set_temperatureMode)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.TemperatureFile is not None or
            self.skylTemperature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_SpectralDomainTir', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_SpectralDomainTir')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_SpectralDomainTir')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_SpectralDomainTir', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_SpectralDomainTir'):
        if self.temperatureMode is not None and 'temperatureMode' not in already_processed:
            already_processed.add('temperatureMode')
            outfile.write(' temperatureMode="%s"' % self.gds_format_integer(self.temperatureMode, input_name='temperatureMode'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_SpectralDomainTir', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TemperatureFile is not None:
            self.TemperatureFile.export(outfile, level, namespaceprefix_, name_='TemperatureFile', pretty_print=pretty_print)
        if self.skylTemperature is not None:
            self.skylTemperature.export(outfile, level, namespaceprefix_, name_='skylTemperature', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_SpectralDomainTir', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.temperatureMode is not None:
            element.set('temperatureMode', self.gds_format_integer(self.temperatureMode))
        if self.TemperatureFile is not None:
            TemperatureFile_ = self.TemperatureFile
            TemperatureFile_.to_etree(element, name_='TemperatureFile', mapping_=mapping_)
        if self.skylTemperature is not None:
            skylTemperature_ = self.skylTemperature
            skylTemperature_.to_etree(element, name_='skylTemperature', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_SpectralDomainTir'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.temperatureMode is not None and 'temperatureMode' not in already_processed:
            already_processed.add('temperatureMode')
            showIndent(outfile, level)
            outfile.write('temperatureMode=%d,\n' % (self.temperatureMode,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TemperatureFile is not None:
            showIndent(outfile, level)
            outfile.write('TemperatureFile=model_._TemperatureFile(\n')
            self.TemperatureFile.exportLiteral(outfile, level, name_='TemperatureFile')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.skylTemperature is not None:
            showIndent(outfile, level)
            outfile.write('skylTemperature=model_._skylTemperature(\n')
            self.skylTemperature.exportLiteral(outfile, level, name_='skylTemperature')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('temperatureMode', node)
        if value is not None and 'temperatureMode' not in already_processed:
            already_processed.add('temperatureMode')
            try:
                self.temperatureMode = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TemperatureFile':
            obj_ = create_TemperatureFile.factory()
            obj_.build(child_)
            self.set_TemperatureFile(obj_)
            obj_.original_tagname_ = 'TemperatureFile'
        elif nodeName_ == 'skylTemperature':
            obj_ = create_skylTemperature.factory()
            obj_.build(child_)
            self.set_skylTemperature(obj_)
            obj_.original_tagname_ = 'skylTemperature'
# end class create_SpectralDomainTir


class create_TemperatureFile(GeneratedsSuper):
    """TemperatureFile TemperatureFile Name of the text file that contains
    temperatures of all cells of the scene Name of the text file
    that contains temperatures of all cells of the scene"""
    subclass = None
    superclass = None
    def __init__(self, temperatureFileName='temperatures.txt'):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_TemperatureFile")
        self.attrib = ['temperatureFileName']
        self.children = []
        self.parent = None
        self._temperatureFileName = _cast(None, temperatureFileName)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_TemperatureFile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_TemperatureFile.subclass:
            return create_TemperatureFile.subclass(*args_, **kwargs_)
        else:
            return create_TemperatureFile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_temperatureFileName(self): return self._temperatureFileName
    def set_temperatureFileName(self, value):
        self._temperatureFileName = value
        update_node(self,self.troot,"phase")
    temperatureFileName = property(get_temperatureFileName, set_temperatureFileName)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_TemperatureFile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_TemperatureFile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_TemperatureFile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_TemperatureFile', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_TemperatureFile'):
        if self.temperatureFileName is not None and 'temperatureFileName' not in already_processed:
            already_processed.add('temperatureFileName')
            outfile.write(' temperatureFileName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.temperatureFileName), input_name='temperatureFileName')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_TemperatureFile', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_TemperatureFile', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.temperatureFileName is not None:
            element.set('temperatureFileName', self.gds_format_string(self.temperatureFileName))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_TemperatureFile'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.temperatureFileName is not None and 'temperatureFileName' not in already_processed:
            already_processed.add('temperatureFileName')
            showIndent(outfile, level)
            outfile.write('temperatureFileName="%s",\n' % (self.temperatureFileName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('temperatureFileName', node)
        if value is not None and 'temperatureFileName' not in already_processed:
            already_processed.add('temperatureFileName')
            self.temperatureFileName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_TemperatureFile


class create_skylTemperature(GeneratedsSuper):
    """BOA illumination is simulated with several sun and atmosphere rays
    per cell.\nRay density is 1/D\u00B2.\nWith direct sun BOA
    irradiance Esun, atmosphere BOA irradiance Eatm (sun scattered +
    thermal emission), BOA irradiance E BOA illumination is
    simulated with several sun and atmosphere rays per cell.\nRay
    density is 1/D\u00B2.\nWith direct sun BOA irradiance Esun,
    atmosphere BOA irradiance Eatm (sun scattered + thermal
    emission), BOA irradiance E Temperatures are "uniformally"
    distributed between the Xth percentile and 100-Xth percentile
    IPARs. IPARS outside these percentile are given the minimum and
    maximum temperatures respectively. Temperatures are
    "uniformally" distributed between the Xth percentile and 100-Xth
    percentile IPARs. IPARS outside these percentile are given the
    minimum and maximum temperatures respectively. Used to define
    the illumination (VIS) in order to calculate scene temperatures
    Used to define the illumination (VIS) in order to calculate
    scene temperatures"""
    subclass = None
    superclass = None
    def __init__(self, distanceBetweenIlluminationSubCenters=0.1, histogramThreshold=5.0, SKYLForTemperatureAssignation=0.0):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_skylTemperature")
        self.attrib = ['distanceBetweenIlluminationSubCenters', 'histogramThreshold', 'SKYLForTemperatureAssignation']
        self.children = []
        self.parent = None
        self._distanceBetweenIlluminationSubCenters = _cast(float, distanceBetweenIlluminationSubCenters)
        self._histogramThreshold = _cast(float, histogramThreshold)
        self._SKYLForTemperatureAssignation = _cast(float, SKYLForTemperatureAssignation)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_skylTemperature)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_skylTemperature.subclass:
            return create_skylTemperature.subclass(*args_, **kwargs_)
        else:
            return create_skylTemperature(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_distanceBetweenIlluminationSubCenters(self): return self._distanceBetweenIlluminationSubCenters
    def set_distanceBetweenIlluminationSubCenters(self, value):
        self._distanceBetweenIlluminationSubCenters = value
        update_node(self,self.troot,"phase")
    distanceBetweenIlluminationSubCenters = property(get_distanceBetweenIlluminationSubCenters, set_distanceBetweenIlluminationSubCenters)
    def get_histogramThreshold(self): return self._histogramThreshold
    def set_histogramThreshold(self, value):
        self._histogramThreshold = value
        update_node(self,self.troot,"phase")
    histogramThreshold = property(get_histogramThreshold, set_histogramThreshold)
    def get_SKYLForTemperatureAssignation(self): return self._SKYLForTemperatureAssignation
    def set_SKYLForTemperatureAssignation(self, value):
        self._SKYLForTemperatureAssignation = value
        update_node(self,self.troot,"phase")
    SKYLForTemperatureAssignation = property(get_SKYLForTemperatureAssignation, set_SKYLForTemperatureAssignation)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_skylTemperature', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_skylTemperature')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_skylTemperature')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_skylTemperature', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_skylTemperature'):
        if self.distanceBetweenIlluminationSubCenters is not None and 'distanceBetweenIlluminationSubCenters' not in already_processed:
            already_processed.add('distanceBetweenIlluminationSubCenters')
            outfile.write(' distanceBetweenIlluminationSubCenters="%s"' % self.gds_format_double(self.distanceBetweenIlluminationSubCenters, input_name='distanceBetweenIlluminationSubCenters'))
        if self.histogramThreshold is not None and 'histogramThreshold' not in already_processed:
            already_processed.add('histogramThreshold')
            outfile.write(' histogramThreshold="%s"' % self.gds_format_double(self.histogramThreshold, input_name='histogramThreshold'))
        if self.SKYLForTemperatureAssignation is not None and 'SKYLForTemperatureAssignation' not in already_processed:
            already_processed.add('SKYLForTemperatureAssignation')
            outfile.write(' SKYLForTemperatureAssignation="%s"' % self.gds_format_double(self.SKYLForTemperatureAssignation, input_name='SKYLForTemperatureAssignation'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_skylTemperature', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_skylTemperature', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.distanceBetweenIlluminationSubCenters is not None:
            element.set('distanceBetweenIlluminationSubCenters', self.gds_format_double(self.distanceBetweenIlluminationSubCenters))
        if self.histogramThreshold is not None:
            element.set('histogramThreshold', self.gds_format_double(self.histogramThreshold))
        if self.SKYLForTemperatureAssignation is not None:
            element.set('SKYLForTemperatureAssignation', self.gds_format_double(self.SKYLForTemperatureAssignation))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_skylTemperature'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.distanceBetweenIlluminationSubCenters is not None and 'distanceBetweenIlluminationSubCenters' not in already_processed:
            already_processed.add('distanceBetweenIlluminationSubCenters')
            showIndent(outfile, level)
            outfile.write('distanceBetweenIlluminationSubCenters=%e,\n' % (self.distanceBetweenIlluminationSubCenters,))
        if self.histogramThreshold is not None and 'histogramThreshold' not in already_processed:
            already_processed.add('histogramThreshold')
            showIndent(outfile, level)
            outfile.write('histogramThreshold=%e,\n' % (self.histogramThreshold,))
        if self.SKYLForTemperatureAssignation is not None and 'SKYLForTemperatureAssignation' not in already_processed:
            already_processed.add('SKYLForTemperatureAssignation')
            showIndent(outfile, level)
            outfile.write('SKYLForTemperatureAssignation=%e,\n' % (self.SKYLForTemperatureAssignation,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('distanceBetweenIlluminationSubCenters', node)
        if value is not None and 'distanceBetweenIlluminationSubCenters' not in already_processed:
            already_processed.add('distanceBetweenIlluminationSubCenters')
            try:
                self.distanceBetweenIlluminationSubCenters = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (distanceBetweenIlluminationSubCenters): %s' % exp)
        value = find_attr_value_('histogramThreshold', node)
        if value is not None and 'histogramThreshold' not in already_processed:
            already_processed.add('histogramThreshold')
            try:
                self.histogramThreshold = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (histogramThreshold): %s' % exp)
        value = find_attr_value_('SKYLForTemperatureAssignation', node)
        if value is not None and 'SKYLForTemperatureAssignation' not in already_processed:
            already_processed.add('SKYLForTemperatureAssignation')
            try:
                self.SKYLForTemperatureAssignation = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (SKYLForTemperatureAssignation): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_skylTemperature


class create_temperatureAtmosphere(GeneratedsSuper):
    """Active in (T) mode only. Atmosphere brightness temperature Active in
    (T) mode only. Atmosphere brightness temperature"""
    subclass = None
    superclass = None
    def __init__(self, atmosphericApparentTemperature=260.0):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_temperatureAtmosphere")
        self.attrib = ['atmosphericApparentTemperature']
        self.children = []
        self.parent = None
        self._atmosphericApparentTemperature = _cast(float, atmosphericApparentTemperature)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_temperatureAtmosphere)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_temperatureAtmosphere.subclass:
            return create_temperatureAtmosphere.subclass(*args_, **kwargs_)
        else:
            return create_temperatureAtmosphere(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_atmosphericApparentTemperature(self): return self._atmosphericApparentTemperature
    def set_atmosphericApparentTemperature(self, value):
        self._atmosphericApparentTemperature = value
        update_node(self,self.troot,"phase")
    atmosphericApparentTemperature = property(get_atmosphericApparentTemperature, set_atmosphericApparentTemperature)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_temperatureAtmosphere', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_temperatureAtmosphere')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_temperatureAtmosphere')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_temperatureAtmosphere', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_temperatureAtmosphere'):
        if self.atmosphericApparentTemperature is not None and 'atmosphericApparentTemperature' not in already_processed:
            already_processed.add('atmosphericApparentTemperature')
            outfile.write(' atmosphericApparentTemperature="%s"' % self.gds_format_double(self.atmosphericApparentTemperature, input_name='atmosphericApparentTemperature'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_temperatureAtmosphere', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_temperatureAtmosphere', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.atmosphericApparentTemperature is not None:
            element.set('atmosphericApparentTemperature', self.gds_format_double(self.atmosphericApparentTemperature))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_temperatureAtmosphere'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.atmosphericApparentTemperature is not None and 'atmosphericApparentTemperature' not in already_processed:
            already_processed.add('atmosphericApparentTemperature')
            showIndent(outfile, level)
            outfile.write('atmosphericApparentTemperature=%e,\n' % (self.atmosphericApparentTemperature,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('atmosphericApparentTemperature', node)
        if value is not None and 'atmosphericApparentTemperature' not in already_processed:
            already_processed.add('atmosphericApparentTemperature')
            try:
                self.atmosphericApparentTemperature = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (atmosphericApparentTemperature): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_temperatureAtmosphere


class create_nodeIlluminationMode(GeneratedsSuper):
    """nodeIlluminationMode nodeIlluminationMode Scenes can be totally
    (normal mode) or partly (discrete illumination) illuminated.
    Fluorescence emssion can be simulated, after a previous DART run
    illuminated the scene. Scenes can be totally (normal mode) or
    partly (discrete illumination) illuminated. Fluorescence emssion
    can be simulated, after a previous DART run illuminated the
    scene. - "TOA: Irradiance spectra": Atmosphere radiative
    transfer gives BOA irradiance. - "TOA: Irradiance spectra":
    Atmosphere radiative transfer gives BOA irradiance."""
    subclass = None
    superclass = None
    def __init__(self, illuminationMode=0, irradianceMode=0, DiscreteIllumination=None, irradianceDatabaseNode=None, illumination=None, ftiImportation=None, SpectralIrradiance=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_nodeIlluminationMode")
        self.attrib = ['illuminationMode', 'irradianceMode']
        self.children = ['DiscreteIllumination', 'irradianceDatabaseNode', 'illumination', 'ftiImportation', 'SpectralIrradiance']
        self.parent = None
        self._illuminationMode = _cast(int, illuminationMode)
        self._irradianceMode = _cast(int, irradianceMode)
        self._DiscreteIllumination = DiscreteIllumination
        self._irradianceDatabaseNode = irradianceDatabaseNode
        self._illumination = illumination
        self._ftiImportation = ftiImportation
        self._SpectralIrradiance = SpectralIrradiance
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_nodeIlluminationMode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_nodeIlluminationMode.subclass:
            return create_nodeIlluminationMode.subclass(*args_, **kwargs_)
        else:
            return create_nodeIlluminationMode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DiscreteIllumination(self): return self._DiscreteIllumination
    def set_DiscreteIllumination(self, value):
        if value is not None:
            checkclass(value, create_DiscreteIllumination)
            value.parent = self
        self._DiscreteIllumination = value
    DiscreteIllumination = property(get_DiscreteIllumination, set_DiscreteIllumination)
    def get_irradianceDatabaseNode(self): return self._irradianceDatabaseNode
    def set_irradianceDatabaseNode(self, value):
        if value is not None:
            checkclass(value, create_irradianceDatabaseNode)
            value.parent = self
        self._irradianceDatabaseNode = value
    irradianceDatabaseNode = property(get_irradianceDatabaseNode, set_irradianceDatabaseNode)
    def get_illumination(self): return self._illumination
    def set_illumination(self, value):
        if value is not None:
            checkclass(value, create_illumination)
            value.parent = self
        self._illumination = value
    illumination = property(get_illumination, set_illumination)
    def get_ftiImportation(self): return self._ftiImportation
    def set_ftiImportation(self, value):
        if value is not None:
            checkclass(value, create_ftiImportation)
            value.parent = self
        self._ftiImportation = value
    ftiImportation = property(get_ftiImportation, set_ftiImportation)
    def get_SpectralIrradiance(self): return self._SpectralIrradiance
    def set_SpectralIrradiance(self, value):
        if value is not None:
            checkclass(value, create_SpectralIrradiance)
            value.parent = self
        self._SpectralIrradiance = value
    SpectralIrradiance = property(get_SpectralIrradiance, set_SpectralIrradiance)
    def get_illuminationMode(self): return self._illuminationMode
    def set_illuminationMode(self, value):
        self._illuminationMode = value
        update_node(self,self.troot,"phase")
    illuminationMode = property(get_illuminationMode, set_illuminationMode)
    def get_irradianceMode(self): return self._irradianceMode
    def set_irradianceMode(self, value):
        self._irradianceMode = value
        update_node(self,self.troot,"phase")
    irradianceMode = property(get_irradianceMode, set_irradianceMode)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.DiscreteIllumination is not None or
            self.irradianceDatabaseNode is not None or
            self.illumination is not None or
            self.ftiImportation is not None or
            self.SpectralIrradiance is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_nodeIlluminationMode', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_nodeIlluminationMode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_nodeIlluminationMode')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_nodeIlluminationMode', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_nodeIlluminationMode'):
        if self.illuminationMode is not None and 'illuminationMode' not in already_processed:
            already_processed.add('illuminationMode')
            outfile.write(' illuminationMode="%s"' % self.gds_format_integer(self.illuminationMode, input_name='illuminationMode'))
        if self.irradianceMode is not None and 'irradianceMode' not in already_processed:
            already_processed.add('irradianceMode')
            outfile.write(' irradianceMode="%s"' % self.gds_format_integer(self.irradianceMode, input_name='irradianceMode'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_nodeIlluminationMode', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DiscreteIllumination is not None:
            self.DiscreteIllumination.export(outfile, level, namespaceprefix_, name_='DiscreteIllumination', pretty_print=pretty_print)
        if self.irradianceDatabaseNode is not None:
            self.irradianceDatabaseNode.export(outfile, level, namespaceprefix_, name_='irradianceDatabaseNode', pretty_print=pretty_print)
        if self.illumination is not None:
            self.illumination.export(outfile, level, namespaceprefix_, name_='illumination', pretty_print=pretty_print)
        if self.ftiImportation is not None:
            self.ftiImportation.export(outfile, level, namespaceprefix_, name_='ftiImportation', pretty_print=pretty_print)
        if self.SpectralIrradiance is not None:
            self.SpectralIrradiance.export(outfile, level, namespaceprefix_, name_='SpectralIrradiance', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_nodeIlluminationMode', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.illuminationMode is not None:
            element.set('illuminationMode', self.gds_format_integer(self.illuminationMode))
        if self.irradianceMode is not None:
            element.set('irradianceMode', self.gds_format_integer(self.irradianceMode))
        if self.DiscreteIllumination is not None:
            DiscreteIllumination_ = self.DiscreteIllumination
            DiscreteIllumination_.to_etree(element, name_='DiscreteIllumination', mapping_=mapping_)
        if self.irradianceDatabaseNode is not None:
            irradianceDatabaseNode_ = self.irradianceDatabaseNode
            irradianceDatabaseNode_.to_etree(element, name_='irradianceDatabaseNode', mapping_=mapping_)
        if self.illumination is not None:
            illumination_ = self.illumination
            illumination_.to_etree(element, name_='illumination', mapping_=mapping_)
        if self.ftiImportation is not None:
            ftiImportation_ = self.ftiImportation
            ftiImportation_.to_etree(element, name_='ftiImportation', mapping_=mapping_)
        if self.SpectralIrradiance is not None:
            SpectralIrradiance_ = self.SpectralIrradiance
            SpectralIrradiance_.to_etree(element, name_='SpectralIrradiance', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_nodeIlluminationMode'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.illuminationMode is not None and 'illuminationMode' not in already_processed:
            already_processed.add('illuminationMode')
            showIndent(outfile, level)
            outfile.write('illuminationMode=%d,\n' % (self.illuminationMode,))
        if self.irradianceMode is not None and 'irradianceMode' not in already_processed:
            already_processed.add('irradianceMode')
            showIndent(outfile, level)
            outfile.write('irradianceMode=%d,\n' % (self.irradianceMode,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DiscreteIllumination is not None:
            showIndent(outfile, level)
            outfile.write('DiscreteIllumination=model_._DiscreteIllumination(\n')
            self.DiscreteIllumination.exportLiteral(outfile, level, name_='DiscreteIllumination')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.irradianceDatabaseNode is not None:
            showIndent(outfile, level)
            outfile.write('irradianceDatabaseNode=model_._irradianceDatabaseNode(\n')
            self.irradianceDatabaseNode.exportLiteral(outfile, level, name_='irradianceDatabaseNode')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.illumination is not None:
            showIndent(outfile, level)
            outfile.write('illumination=model_._illumination(\n')
            self.illumination.exportLiteral(outfile, level, name_='illumination')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ftiImportation is not None:
            showIndent(outfile, level)
            outfile.write('ftiImportation=model_._ftiImportation(\n')
            self.ftiImportation.exportLiteral(outfile, level, name_='ftiImportation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SpectralIrradiance is not None:
            showIndent(outfile, level)
            outfile.write('SpectralIrradiance=model_._SpectralIrradiance(\n')
            self.SpectralIrradiance.exportLiteral(outfile, level, name_='SpectralIrradiance')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('illuminationMode', node)
        if value is not None and 'illuminationMode' not in already_processed:
            already_processed.add('illuminationMode')
            try:
                self.illuminationMode = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('irradianceMode', node)
        if value is not None and 'irradianceMode' not in already_processed:
            already_processed.add('irradianceMode')
            try:
                self.irradianceMode = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DiscreteIllumination':
            obj_ = create_DiscreteIllumination.factory()
            obj_.build(child_)
            self.set_DiscreteIllumination(obj_)
            obj_.original_tagname_ = 'DiscreteIllumination'
        elif nodeName_ == 'irradianceDatabaseNode':
            obj_ = create_irradianceDatabaseNode.factory()
            obj_.build(child_)
            self.set_irradianceDatabaseNode(obj_)
            obj_.original_tagname_ = 'irradianceDatabaseNode'
        elif nodeName_ == 'illumination':
            obj_ = create_illumination.factory()
            obj_.build(child_)
            self.set_illumination(obj_)
            obj_.original_tagname_ = 'illumination'
        elif nodeName_ == 'ftiImportation':
            obj_ = create_ftiImportation.factory()
            obj_.build(child_)
            self.set_ftiImportation(obj_)
            obj_.original_tagname_ = 'ftiImportation'
        elif nodeName_ == 'SpectralIrradiance':
            obj_ = create_SpectralIrradiance.factory()
            obj_.build(child_)
            self.set_SpectralIrradiance(obj_)
            obj_.original_tagname_ = 'SpectralIrradiance'
# end class create_nodeIlluminationMode


class create_DiscreteIllumination(GeneratedsSuper):
    """DiscreteIllumination DiscreteIllumination sizeX sizeX sizeY sizeY
    Coordinates of the center of the rectangle that is illuminated
    in the dicrete illumination mode. Coordinates of the center of
    the rectangle that is illuminated in the dicrete illumination
    mode. centerY centerY"""
    subclass = None
    superclass = None
    def __init__(self, sizeX=0.2, sizeY=0.3, centerX=10.0, centerY=10.0):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_DiscreteIllumination")
        self.attrib = ['sizeX', 'sizeY', 'centerX', 'centerY']
        self.children = []
        self.parent = None
        self._sizeX = _cast(float, sizeX)
        self._sizeY = _cast(float, sizeY)
        self._centerX = _cast(float, centerX)
        self._centerY = _cast(float, centerY)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_DiscreteIllumination)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_DiscreteIllumination.subclass:
            return create_DiscreteIllumination.subclass(*args_, **kwargs_)
        else:
            return create_DiscreteIllumination(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sizeX(self): return self._sizeX
    def set_sizeX(self, value):
        self._sizeX = value
        update_node(self,self.troot,"phase")
    sizeX = property(get_sizeX, set_sizeX)
    def get_sizeY(self): return self._sizeY
    def set_sizeY(self, value):
        self._sizeY = value
        update_node(self,self.troot,"phase")
    sizeY = property(get_sizeY, set_sizeY)
    def get_centerX(self): return self._centerX
    def set_centerX(self, value):
        self._centerX = value
        update_node(self,self.troot,"phase")
    centerX = property(get_centerX, set_centerX)
    def get_centerY(self): return self._centerY
    def set_centerY(self, value):
        self._centerY = value
        update_node(self,self.troot,"phase")
    centerY = property(get_centerY, set_centerY)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_DiscreteIllumination', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_DiscreteIllumination')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_DiscreteIllumination')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_DiscreteIllumination', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_DiscreteIllumination'):
        if self.sizeX is not None and 'sizeX' not in already_processed:
            already_processed.add('sizeX')
            outfile.write(' sizeX="%s"' % self.gds_format_double(self.sizeX, input_name='sizeX'))
        if self.sizeY is not None and 'sizeY' not in already_processed:
            already_processed.add('sizeY')
            outfile.write(' sizeY="%s"' % self.gds_format_double(self.sizeY, input_name='sizeY'))
        if self.centerX is not None and 'centerX' not in already_processed:
            already_processed.add('centerX')
            outfile.write(' centerX="%s"' % self.gds_format_double(self.centerX, input_name='centerX'))
        if self.centerY is not None and 'centerY' not in already_processed:
            already_processed.add('centerY')
            outfile.write(' centerY="%s"' % self.gds_format_double(self.centerY, input_name='centerY'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_DiscreteIllumination', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_DiscreteIllumination', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.sizeX is not None:
            element.set('sizeX', self.gds_format_double(self.sizeX))
        if self.sizeY is not None:
            element.set('sizeY', self.gds_format_double(self.sizeY))
        if self.centerX is not None:
            element.set('centerX', self.gds_format_double(self.centerX))
        if self.centerY is not None:
            element.set('centerY', self.gds_format_double(self.centerY))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_DiscreteIllumination'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sizeX is not None and 'sizeX' not in already_processed:
            already_processed.add('sizeX')
            showIndent(outfile, level)
            outfile.write('sizeX=%e,\n' % (self.sizeX,))
        if self.sizeY is not None and 'sizeY' not in already_processed:
            already_processed.add('sizeY')
            showIndent(outfile, level)
            outfile.write('sizeY=%e,\n' % (self.sizeY,))
        if self.centerX is not None and 'centerX' not in already_processed:
            already_processed.add('centerX')
            showIndent(outfile, level)
            outfile.write('centerX=%e,\n' % (self.centerX,))
        if self.centerY is not None and 'centerY' not in already_processed:
            already_processed.add('centerY')
            showIndent(outfile, level)
            outfile.write('centerY=%e,\n' % (self.centerY,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sizeX', node)
        if value is not None and 'sizeX' not in already_processed:
            already_processed.add('sizeX')
            try:
                self.sizeX = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sizeX): %s' % exp)
        value = find_attr_value_('sizeY', node)
        if value is not None and 'sizeY' not in already_processed:
            already_processed.add('sizeY')
            try:
                self.sizeY = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sizeY): %s' % exp)
        value = find_attr_value_('centerX', node)
        if value is not None and 'centerX' not in already_processed:
            already_processed.add('centerX')
            try:
                self.centerX = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (centerX): %s' % exp)
        value = find_attr_value_('centerY', node)
        if value is not None and 'centerY' not in already_processed:
            already_processed.add('centerY')
            try:
                self.centerY = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (centerY): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_DiscreteIllumination


class create_irradianceDatabaseNode(GeneratedsSuper):
    """Irradiance database Irradiance database Irradiance table Irradiance
    table Irradiance model Irradiance model Reflectance database
    Reflectance database Weighting of atmospheric parameters by the
    solar spectrum for the computation of per band mean values.
    Weighting of atmospheric parameters by the solar spectrum for
    the computation of per band mean values. Weighting of
    reflectance parameters by the solar spectrum for the computation
    of per band mean values. Weighting of reflectance parameters by
    the solar spectrum for the computation of per band mean values."""
    subclass = None
    superclass = None
    def __init__(self, irradianceTable='TOASolar_THKUR', irradianceColumn='irradiance', databaseName='Solar_constant.db', weightAtmosphereParameters=1, weightReflectanceParameters=1, WeightingParameters=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_irradianceDatabaseNode")
        self.attrib = ['irradianceTable', 'irradianceColumn', 'databaseName', 'weightAtmosphereParameters', 'weightReflectanceParameters']
        self.children = ['WeightingParameters']
        self.parent = None
        self._irradianceTable = _cast(None, irradianceTable)
        self._irradianceColumn = _cast(None, irradianceColumn)
        self._databaseName = _cast(None, databaseName)
        self._weightAtmosphereParameters = _cast(int, weightAtmosphereParameters)
        self._weightReflectanceParameters = _cast(int, weightReflectanceParameters)
        self._WeightingParameters = WeightingParameters
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_irradianceDatabaseNode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_irradianceDatabaseNode.subclass:
            return create_irradianceDatabaseNode.subclass(*args_, **kwargs_)
        else:
            return create_irradianceDatabaseNode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WeightingParameters(self): return self._WeightingParameters
    def set_WeightingParameters(self, value):
        if value is not None:
            checkclass(value, create_WeightingParameters)
            value.parent = self
        self._WeightingParameters = value
    WeightingParameters = property(get_WeightingParameters, set_WeightingParameters)
    def get_irradianceTable(self): return self._irradianceTable
    def set_irradianceTable(self, value):
        self._irradianceTable = value
        update_node(self,self.troot,"phase")
    irradianceTable = property(get_irradianceTable, set_irradianceTable)
    def get_irradianceColumn(self): return self._irradianceColumn
    def set_irradianceColumn(self, value):
        self._irradianceColumn = value
        update_node(self,self.troot,"phase")
    irradianceColumn = property(get_irradianceColumn, set_irradianceColumn)
    def get_databaseName(self): return self._databaseName
    def set_databaseName(self, value):
        self._databaseName = value
        update_node(self,self.troot,"phase")
    databaseName = property(get_databaseName, set_databaseName)
    def get_weightAtmosphereParameters(self): return self._weightAtmosphereParameters
    def set_weightAtmosphereParameters(self, value):
        self._weightAtmosphereParameters = value
        update_node(self,self.troot,"phase")
    weightAtmosphereParameters = property(get_weightAtmosphereParameters, set_weightAtmosphereParameters)
    def get_weightReflectanceParameters(self): return self._weightReflectanceParameters
    def set_weightReflectanceParameters(self, value):
        self._weightReflectanceParameters = value
        update_node(self,self.troot,"phase")
    weightReflectanceParameters = property(get_weightReflectanceParameters, set_weightReflectanceParameters)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.WeightingParameters is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_irradianceDatabaseNode', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_irradianceDatabaseNode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_irradianceDatabaseNode')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_irradianceDatabaseNode', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_irradianceDatabaseNode'):
        if self.irradianceTable is not None and 'irradianceTable' not in already_processed:
            already_processed.add('irradianceTable')
            outfile.write(' irradianceTable=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.irradianceTable), input_name='irradianceTable')), ))
        if self.irradianceColumn is not None and 'irradianceColumn' not in already_processed:
            already_processed.add('irradianceColumn')
            outfile.write(' irradianceColumn=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.irradianceColumn), input_name='irradianceColumn')), ))
        if self.databaseName is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            outfile.write(' databaseName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.databaseName), input_name='databaseName')), ))
        if self.weightAtmosphereParameters is not None and 'weightAtmosphereParameters' not in already_processed:
            already_processed.add('weightAtmosphereParameters')
            outfile.write(' weightAtmosphereParameters="%s"' % self.gds_format_integer(self.weightAtmosphereParameters, input_name='weightAtmosphereParameters'))
        if self.weightReflectanceParameters is not None and 'weightReflectanceParameters' not in already_processed:
            already_processed.add('weightReflectanceParameters')
            outfile.write(' weightReflectanceParameters="%s"' % self.gds_format_integer(self.weightReflectanceParameters, input_name='weightReflectanceParameters'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_irradianceDatabaseNode', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.WeightingParameters is not None:
            self.WeightingParameters.export(outfile, level, namespaceprefix_, name_='WeightingParameters', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_irradianceDatabaseNode', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.irradianceTable is not None:
            element.set('irradianceTable', self.gds_format_string(self.irradianceTable))
        if self.irradianceColumn is not None:
            element.set('irradianceColumn', self.gds_format_string(self.irradianceColumn))
        if self.databaseName is not None:
            element.set('databaseName', self.gds_format_string(self.databaseName))
        if self.weightAtmosphereParameters is not None:
            element.set('weightAtmosphereParameters', self.gds_format_integer(self.weightAtmosphereParameters))
        if self.weightReflectanceParameters is not None:
            element.set('weightReflectanceParameters', self.gds_format_integer(self.weightReflectanceParameters))
        if self.WeightingParameters is not None:
            WeightingParameters_ = self.WeightingParameters
            WeightingParameters_.to_etree(element, name_='WeightingParameters', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_irradianceDatabaseNode'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.irradianceTable is not None and 'irradianceTable' not in already_processed:
            already_processed.add('irradianceTable')
            showIndent(outfile, level)
            outfile.write('irradianceTable="%s",\n' % (self.irradianceTable,))
        if self.irradianceColumn is not None and 'irradianceColumn' not in already_processed:
            already_processed.add('irradianceColumn')
            showIndent(outfile, level)
            outfile.write('irradianceColumn="%s",\n' % (self.irradianceColumn,))
        if self.databaseName is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            showIndent(outfile, level)
            outfile.write('databaseName="%s",\n' % (self.databaseName,))
        if self.weightAtmosphereParameters is not None and 'weightAtmosphereParameters' not in already_processed:
            already_processed.add('weightAtmosphereParameters')
            showIndent(outfile, level)
            outfile.write('weightAtmosphereParameters=%d,\n' % (self.weightAtmosphereParameters,))
        if self.weightReflectanceParameters is not None and 'weightReflectanceParameters' not in already_processed:
            already_processed.add('weightReflectanceParameters')
            showIndent(outfile, level)
            outfile.write('weightReflectanceParameters=%d,\n' % (self.weightReflectanceParameters,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.WeightingParameters is not None:
            showIndent(outfile, level)
            outfile.write('WeightingParameters=model_._WeightingParameters(\n')
            self.WeightingParameters.exportLiteral(outfile, level, name_='WeightingParameters')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('irradianceTable', node)
        if value is not None and 'irradianceTable' not in already_processed:
            already_processed.add('irradianceTable')
            self.irradianceTable = value
        value = find_attr_value_('irradianceColumn', node)
        if value is not None and 'irradianceColumn' not in already_processed:
            already_processed.add('irradianceColumn')
            self.irradianceColumn = value
        value = find_attr_value_('databaseName', node)
        if value is not None and 'databaseName' not in already_processed:
            already_processed.add('databaseName')
            self.databaseName = value
        value = find_attr_value_('weightAtmosphereParameters', node)
        if value is not None and 'weightAtmosphereParameters' not in already_processed:
            already_processed.add('weightAtmosphereParameters')
            try:
                self.weightAtmosphereParameters = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('weightReflectanceParameters', node)
        if value is not None and 'weightReflectanceParameters' not in already_processed:
            already_processed.add('weightReflectanceParameters')
            try:
                self.weightReflectanceParameters = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WeightingParameters':
            obj_ = create_WeightingParameters.factory()
            obj_.build(child_)
            self.set_WeightingParameters(obj_)
            obj_.original_tagname_ = 'WeightingParameters'
# end class create_irradianceDatabaseNode


class create_WeightingParameters(GeneratedsSuper):
    """Reflectance, and by extension emissivity, will be ponderated across
    the full bandwidth using the inversion of the Plank law of the
    provided temperature. Reflectance, and by extension emissivity,
    will be ponderated across the full bandwidth using the inversion
    of the Plank law of the provided temperature."""
    subclass = None
    superclass = None
    def __init__(self, sceneAverageTemperatureForPonderation=300):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_WeightingParameters")
        self.attrib = ['sceneAverageTemperatureForPonderation']
        self.children = []
        self.parent = None
        self._sceneAverageTemperatureForPonderation = _cast(float, sceneAverageTemperatureForPonderation)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_WeightingParameters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_WeightingParameters.subclass:
            return create_WeightingParameters.subclass(*args_, **kwargs_)
        else:
            return create_WeightingParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sceneAverageTemperatureForPonderation(self): return self._sceneAverageTemperatureForPonderation
    def set_sceneAverageTemperatureForPonderation(self, value):
        self._sceneAverageTemperatureForPonderation = value
        update_node(self,self.troot,"phase")
    sceneAverageTemperatureForPonderation = property(get_sceneAverageTemperatureForPonderation, set_sceneAverageTemperatureForPonderation)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_WeightingParameters', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_WeightingParameters')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_WeightingParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_WeightingParameters', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_WeightingParameters'):
        if self.sceneAverageTemperatureForPonderation is not None and 'sceneAverageTemperatureForPonderation' not in already_processed:
            already_processed.add('sceneAverageTemperatureForPonderation')
            outfile.write(' sceneAverageTemperatureForPonderation="%s"' % self.gds_format_double(self.sceneAverageTemperatureForPonderation, input_name='sceneAverageTemperatureForPonderation'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_WeightingParameters', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_WeightingParameters', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.sceneAverageTemperatureForPonderation is not None:
            element.set('sceneAverageTemperatureForPonderation', self.gds_format_double(self.sceneAverageTemperatureForPonderation))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_WeightingParameters'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sceneAverageTemperatureForPonderation is not None and 'sceneAverageTemperatureForPonderation' not in already_processed:
            already_processed.add('sceneAverageTemperatureForPonderation')
            showIndent(outfile, level)
            outfile.write('sceneAverageTemperatureForPonderation=%e,\n' % (self.sceneAverageTemperatureForPonderation,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sceneAverageTemperatureForPonderation', node)
        if value is not None and 'sceneAverageTemperatureForPonderation' not in already_processed:
            already_processed.add('sceneAverageTemperatureForPonderation')
            try:
                self.sceneAverageTemperatureForPonderation = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sceneAverageTemperatureForPonderation): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_WeightingParameters


class create_illumination(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, illuminationFileName='atmosphere_radiance_before_coupling.binary'):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_illumination")
        self.attrib = ['illuminationFileName']
        self.children = []
        self.parent = None
        self._illuminationFileName = _cast(None, illuminationFileName)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_illumination)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_illumination.subclass:
            return create_illumination.subclass(*args_, **kwargs_)
        else:
            return create_illumination(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_illuminationFileName(self): return self._illuminationFileName
    def set_illuminationFileName(self, value):
        self._illuminationFileName = value
        update_node(self,self.troot,"phase")
    illuminationFileName = property(get_illuminationFileName, set_illuminationFileName)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_illumination', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_illumination')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_illumination')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_illumination', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_illumination'):
        if self.illuminationFileName is not None and 'illuminationFileName' not in already_processed:
            already_processed.add('illuminationFileName')
            outfile.write(' illuminationFileName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.illuminationFileName), input_name='illuminationFileName')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_illumination', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_illumination', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.illuminationFileName is not None:
            element.set('illuminationFileName', self.gds_format_string(self.illuminationFileName))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_illumination'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.illuminationFileName is not None and 'illuminationFileName' not in already_processed:
            already_processed.add('illuminationFileName')
            showIndent(outfile, level)
            outfile.write('illuminationFileName="%s",\n' % (self.illuminationFileName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('illuminationFileName', node)
        if value is not None and 'illuminationFileName' not in already_processed:
            already_processed.add('illuminationFileName')
            self.illuminationFileName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_illumination


class create_ftiImportation(GeneratedsSuper):
    """Mid-Atmosphere transfer function Mid-Atmosphere transfer function
    Transfer function file name Transfer function file name"""
    subclass = None
    superclass = None
    def __init__(self, ftiFileName='atmosphere_transfer_function_from_MA.binary'):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_ftiImportation")
        self.attrib = ['ftiFileName']
        self.children = []
        self.parent = None
        self._ftiFileName = _cast(None, ftiFileName)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ftiImportation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ftiImportation.subclass:
            return create_ftiImportation.subclass(*args_, **kwargs_)
        else:
            return create_ftiImportation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ftiFileName(self): return self._ftiFileName
    def set_ftiFileName(self, value):
        self._ftiFileName = value
        update_node(self,self.troot,"phase")
    ftiFileName = property(get_ftiFileName, set_ftiFileName)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ftiImportation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ftiImportation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ftiImportation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ftiImportation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ftiImportation'):
        if self.ftiFileName is not None and 'ftiFileName' not in already_processed:
            already_processed.add('ftiFileName')
            outfile.write(' ftiFileName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ftiFileName), input_name='ftiFileName')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ftiImportation', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_ftiImportation', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ftiFileName is not None:
            element.set('ftiFileName', self.gds_format_string(self.ftiFileName))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ftiImportation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ftiFileName is not None and 'ftiFileName' not in already_processed:
            already_processed.add('ftiFileName')
            showIndent(outfile, level)
            outfile.write('ftiFileName="%s",\n' % (self.ftiFileName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ftiFileName', node)
        if value is not None and 'ftiFileName' not in already_processed:
            already_processed.add('ftiFileName')
            self.ftiFileName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_ftiImportation


class create_SpectralIrradiance(GeneratedsSuper):
    """SpectralIrradiance SpectralIrradiance"""
    subclass = None
    superclass = None
    def __init__(self, CommonParameters=None, SpectralIrradianceValue=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_SpectralIrradiance")
        self.attrib = ['']
        self.children = ['CommonParameters', 'SpectralIrradianceValue']
        self.parent = None
        self._CommonParameters = CommonParameters
        if SpectralIrradianceValue is None:
            self._SpectralIrradianceValue = []
        else:
            self._SpectralIrradianceValue = SpectralIrradianceValue
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_SpectralIrradiance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_SpectralIrradiance.subclass:
            return create_SpectralIrradiance.subclass(*args_, **kwargs_)
        else:
            return create_SpectralIrradiance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CommonParameters(self): return self._CommonParameters
    def set_CommonParameters(self, value):
        if value is not None:
            checkclass(value, create_CommonParameters)
            value.parent = self
        self._CommonParameters = value
    CommonParameters = property(get_CommonParameters, set_CommonParameters)
    def get_SpectralIrradianceValue(self): return self._SpectralIrradianceValue
    def set_SpectralIrradianceValue(self, value):
        if value is not None:
            checkclass(value, create_SpectralIrradianceValue)
            for v in value:
                v.parent = self
        self._SpectralIrradianceValue = value
    def add_SpectralIrradianceValue(self, value):
        value.parent = self
        self._SpectralIrradianceValue.append(value)
    def insert_SpectralIrradianceValue_at(self, index, value):
        value.parent = self
        self.SpectralIrradianceValue.insert(index, value)
    def replace_SpectralIrradianceValue_at(self, index, value):
        value.parent = self
        self.SpectralIrradianceValue[index] = value
    SpectralIrradianceValue = property(get_SpectralIrradianceValue, set_SpectralIrradianceValue)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.CommonParameters is not None or
            self.SpectralIrradianceValue
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_SpectralIrradiance', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_SpectralIrradiance')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_SpectralIrradiance')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_SpectralIrradiance', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_SpectralIrradiance'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_SpectralIrradiance', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CommonParameters is not None:
            self.CommonParameters.export(outfile, level, namespaceprefix_, name_='CommonParameters', pretty_print=pretty_print)
        for SpectralIrradianceValue_ in self.SpectralIrradianceValue:
            SpectralIrradianceValue_.export(outfile, level, namespaceprefix_, name_='SpectralIrradianceValue', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_SpectralIrradiance', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.CommonParameters is not None:
            CommonParameters_ = self.CommonParameters
            CommonParameters_.to_etree(element, name_='CommonParameters', mapping_=mapping_)
        for SpectralIrradianceValue_ in self.SpectralIrradianceValue:
            SpectralIrradianceValue_.to_etree(element, name_='SpectralIrradianceValue', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_SpectralIrradiance'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CommonParameters is not None:
            showIndent(outfile, level)
            outfile.write('CommonParameters=model_._CommonParameters(\n')
            self.CommonParameters.exportLiteral(outfile, level, name_='CommonParameters')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('SpectralIrradianceValue=[\n')
        level += 1
        for SpectralIrradianceValue_ in self.SpectralIrradianceValue:
            showIndent(outfile, level)
            outfile.write('model_._SpectralIrradianceValue(\n')
            SpectralIrradianceValue_.exportLiteral(outfile, level, name_='_SpectralIrradianceValue')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.SpectralIrradianceValue = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CommonParameters':
            obj_ = create_CommonParameters.factory()
            obj_.build(child_)
            self.set_CommonParameters(obj_)
            obj_.original_tagname_ = 'CommonParameters'
        elif nodeName_ == 'SpectralIrradianceValue':
            obj_ = create_SpectralIrradianceValue.factory()
            obj_.build(child_)
            self.add_SpectralIrradianceValue(obj_)
            obj_.original_tagname_ = 'SpectralIrradianceValue'
# end class create_SpectralIrradiance


class create_CommonParameters(GeneratedsSuper):
    """CommonParameters CommonParameters Incoming radiation definition
    Incoming radiation definition Same irradiance for all bands Same
    irradiance for all bands Same SKYL for all bands Same SKYL for
    all bands"""
    subclass = None
    superclass = None
    def __init__(self, irraDef=0, commonIrradianceCheckBox=1, commonSkylCheckBox=1):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_CommonParameters")
        self.attrib = ['irraDef', 'commonIrradianceCheckBox', 'commonSkylCheckBox']
        self.children = []
        self.parent = None
        self._irraDef = _cast(int, irraDef)
        self._commonIrradianceCheckBox = _cast(int, commonIrradianceCheckBox)
        self._commonSkylCheckBox = _cast(int, commonSkylCheckBox)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_CommonParameters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_CommonParameters.subclass:
            return create_CommonParameters.subclass(*args_, **kwargs_)
        else:
            return create_CommonParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_irraDef(self): return self._irraDef
    def set_irraDef(self, value):
        self._irraDef = value
        update_node(self,self.troot,"phase")
    irraDef = property(get_irraDef, set_irraDef)
    def get_commonIrradianceCheckBox(self): return self._commonIrradianceCheckBox
    def set_commonIrradianceCheckBox(self, value):
        self._commonIrradianceCheckBox = value
        update_node(self,self.troot,"phase")
    commonIrradianceCheckBox = property(get_commonIrradianceCheckBox, set_commonIrradianceCheckBox)
    def get_commonSkylCheckBox(self): return self._commonSkylCheckBox
    def set_commonSkylCheckBox(self, value):
        self._commonSkylCheckBox = value
        update_node(self,self.troot,"phase")
    commonSkylCheckBox = property(get_commonSkylCheckBox, set_commonSkylCheckBox)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_CommonParameters', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_CommonParameters')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_CommonParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_CommonParameters', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_CommonParameters'):
        if self.irraDef is not None and 'irraDef' not in already_processed:
            already_processed.add('irraDef')
            outfile.write(' irraDef="%s"' % self.gds_format_integer(self.irraDef, input_name='irraDef'))
        if self.commonIrradianceCheckBox is not None and 'commonIrradianceCheckBox' not in already_processed:
            already_processed.add('commonIrradianceCheckBox')
            outfile.write(' commonIrradianceCheckBox="%s"' % self.gds_format_integer(self.commonIrradianceCheckBox, input_name='commonIrradianceCheckBox'))
        if self.commonSkylCheckBox is not None and 'commonSkylCheckBox' not in already_processed:
            already_processed.add('commonSkylCheckBox')
            outfile.write(' commonSkylCheckBox="%s"' % self.gds_format_integer(self.commonSkylCheckBox, input_name='commonSkylCheckBox'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_CommonParameters', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_CommonParameters', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.irraDef is not None:
            element.set('irraDef', self.gds_format_integer(self.irraDef))
        if self.commonIrradianceCheckBox is not None:
            element.set('commonIrradianceCheckBox', self.gds_format_integer(self.commonIrradianceCheckBox))
        if self.commonSkylCheckBox is not None:
            element.set('commonSkylCheckBox', self.gds_format_integer(self.commonSkylCheckBox))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_CommonParameters'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.irraDef is not None and 'irraDef' not in already_processed:
            already_processed.add('irraDef')
            showIndent(outfile, level)
            outfile.write('irraDef=%d,\n' % (self.irraDef,))
        if self.commonIrradianceCheckBox is not None and 'commonIrradianceCheckBox' not in already_processed:
            already_processed.add('commonIrradianceCheckBox')
            showIndent(outfile, level)
            outfile.write('commonIrradianceCheckBox=%d,\n' % (self.commonIrradianceCheckBox,))
        if self.commonSkylCheckBox is not None and 'commonSkylCheckBox' not in already_processed:
            already_processed.add('commonSkylCheckBox')
            showIndent(outfile, level)
            outfile.write('commonSkylCheckBox=%d,\n' % (self.commonSkylCheckBox,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('irraDef', node)
        if value is not None and 'irraDef' not in already_processed:
            already_processed.add('irraDef')
            try:
                self.irraDef = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('commonIrradianceCheckBox', node)
        if value is not None and 'commonIrradianceCheckBox' not in already_processed:
            already_processed.add('commonIrradianceCheckBox')
            try:
                self.commonIrradianceCheckBox = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('commonSkylCheckBox', node)
        if value is not None and 'commonSkylCheckBox' not in already_processed:
            already_processed.add('commonSkylCheckBox')
            try:
                self.commonSkylCheckBox = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_CommonParameters


class create_SpectralIrradianceValue(GeneratedsSuper):
    """SpectralIrradianceValue SpectralIrradianceValue 0 for first
    band)\nBe sure that the spectral band number corresponds in
    modus operandi and in LUT generator ! 0 for first band)\nBe sure
    that the spectral band number corresponds in modus operandi and
    in LUT generator ! TOA spectral solar constant
    [W/m\u00B2/\u03BCm] TOA spectral solar constant
    [W/m\u00B2/\u03BCm] SKYL (atmospheric scattering of sun
    radiance) SKYL (atmospheric scattering of sun radiance)"""
    subclass = None
    superclass = None
    def __init__(self, bandNumber=0, irradiance=1000, Skyl=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_SpectralIrradianceValue")
        self.attrib = ['bandNumber', 'irradiance', 'Skyl']
        self.children = []
        self.parent = None
        self._bandNumber = _cast(int, bandNumber)
        self._irradiance = _cast(float, irradiance)
        self._Skyl = _cast(float, Skyl)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_SpectralIrradianceValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_SpectralIrradianceValue.subclass:
            return create_SpectralIrradianceValue.subclass(*args_, **kwargs_)
        else:
            return create_SpectralIrradianceValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bandNumber(self): return self._bandNumber
    def set_bandNumber(self, value):
        self._bandNumber = value
        update_node(self,self.troot,"phase")
    bandNumber = property(get_bandNumber, set_bandNumber)
    def get_irradiance(self): return self._irradiance
    def set_irradiance(self, value):
        self._irradiance = value
        update_node(self,self.troot,"phase")
    irradiance = property(get_irradiance, set_irradiance)
    def get_Skyl(self): return self._Skyl
    def set_Skyl(self, value):
        self._Skyl = value
        update_node(self,self.troot,"phase")
    Skyl = property(get_Skyl, set_Skyl)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_SpectralIrradianceValue', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_SpectralIrradianceValue')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_SpectralIrradianceValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_SpectralIrradianceValue', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_SpectralIrradianceValue'):
        if self.bandNumber is not None and 'bandNumber' not in already_processed:
            already_processed.add('bandNumber')
            outfile.write(' bandNumber="%s"' % self.gds_format_integer(self.bandNumber, input_name='bandNumber'))
        if self.irradiance is not None and 'irradiance' not in already_processed:
            already_processed.add('irradiance')
            outfile.write(' irradiance="%s"' % self.gds_format_double(self.irradiance, input_name='irradiance'))
        if self.Skyl is not None and 'Skyl' not in already_processed:
            already_processed.add('Skyl')
            outfile.write(' Skyl="%s"' % self.gds_format_double(self.Skyl, input_name='Skyl'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_SpectralIrradianceValue', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_SpectralIrradianceValue', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.bandNumber is not None:
            element.set('bandNumber', self.gds_format_integer(self.bandNumber))
        if self.irradiance is not None:
            element.set('irradiance', self.gds_format_double(self.irradiance))
        if self.Skyl is not None:
            element.set('Skyl', self.gds_format_double(self.Skyl))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_SpectralIrradianceValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.bandNumber is not None and 'bandNumber' not in already_processed:
            already_processed.add('bandNumber')
            showIndent(outfile, level)
            outfile.write('bandNumber=%d,\n' % (self.bandNumber,))
        if self.irradiance is not None and 'irradiance' not in already_processed:
            already_processed.add('irradiance')
            showIndent(outfile, level)
            outfile.write('irradiance=%e,\n' % (self.irradiance,))
        if self.Skyl is not None and 'Skyl' not in already_processed:
            already_processed.add('Skyl')
            showIndent(outfile, level)
            outfile.write('Skyl=%e,\n' % (self.Skyl,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('bandNumber', node)
        if value is not None and 'bandNumber' not in already_processed:
            already_processed.add('bandNumber')
            try:
                self.bandNumber = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('irradiance', node)
        if value is not None and 'irradiance' not in already_processed:
            already_processed.add('irradiance')
            try:
                self.irradiance = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (irradiance): %s' % exp)
        value = find_attr_value_('Skyl', node)
        if value is not None and 'Skyl' not in already_processed:
            already_processed.add('Skyl')
            try:
                self.Skyl = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Skyl): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_SpectralIrradianceValue


class create_PulseDuration(GeneratedsSuper):
    """PulseDuration PulseDuration Energy of each pulse Energy of each
    pulse Half pulse duration Half pulse duration"""
    subclass = None
    superclass = None
    def __init__(self, pulse_energy=1, gaussian_pulse_cut=3, SigmaDefinition=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_PulseDuration")
        self.attrib = ['pulse_energy', 'gaussian_pulse_cut']
        self.children = ['SigmaDefinition']
        self.parent = None
        self._pulse_energy = _cast(float, pulse_energy)
        self._gaussian_pulse_cut = _cast(float, gaussian_pulse_cut)
        self._SigmaDefinition = SigmaDefinition
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_PulseDuration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_PulseDuration.subclass:
            return create_PulseDuration.subclass(*args_, **kwargs_)
        else:
            return create_PulseDuration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SigmaDefinition(self): return self._SigmaDefinition
    def set_SigmaDefinition(self, value):
        if value is not None:
            checkclass(value, create_SigmaDefinition)
            value.parent = self
        self._SigmaDefinition = value
    SigmaDefinition = property(get_SigmaDefinition, set_SigmaDefinition)
    def get_pulse_energy(self): return self._pulse_energy
    def set_pulse_energy(self, value):
        self._pulse_energy = value
        update_node(self,self.troot,"phase")
    pulse_energy = property(get_pulse_energy, set_pulse_energy)
    def get_gaussian_pulse_cut(self): return self._gaussian_pulse_cut
    def set_gaussian_pulse_cut(self, value):
        self._gaussian_pulse_cut = value
        update_node(self,self.troot,"phase")
    gaussian_pulse_cut = property(get_gaussian_pulse_cut, set_gaussian_pulse_cut)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.SigmaDefinition is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_PulseDuration', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_PulseDuration')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_PulseDuration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_PulseDuration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_PulseDuration'):
        if self.pulse_energy is not None and 'pulse_energy' not in already_processed:
            already_processed.add('pulse_energy')
            outfile.write(' pulse_energy="%s"' % self.gds_format_double(self.pulse_energy, input_name='pulse_energy'))
        if self.gaussian_pulse_cut is not None and 'gaussian_pulse_cut' not in already_processed:
            already_processed.add('gaussian_pulse_cut')
            outfile.write(' gaussian_pulse_cut="%s"' % self.gds_format_double(self.gaussian_pulse_cut, input_name='gaussian_pulse_cut'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_PulseDuration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SigmaDefinition is not None:
            self.SigmaDefinition.export(outfile, level, namespaceprefix_, name_='SigmaDefinition', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_PulseDuration', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.pulse_energy is not None:
            element.set('pulse_energy', self.gds_format_double(self.pulse_energy))
        if self.gaussian_pulse_cut is not None:
            element.set('gaussian_pulse_cut', self.gds_format_double(self.gaussian_pulse_cut))
        if self.SigmaDefinition is not None:
            SigmaDefinition_ = self.SigmaDefinition
            SigmaDefinition_.to_etree(element, name_='SigmaDefinition', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_PulseDuration'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.pulse_energy is not None and 'pulse_energy' not in already_processed:
            already_processed.add('pulse_energy')
            showIndent(outfile, level)
            outfile.write('pulse_energy=%e,\n' % (self.pulse_energy,))
        if self.gaussian_pulse_cut is not None and 'gaussian_pulse_cut' not in already_processed:
            already_processed.add('gaussian_pulse_cut')
            showIndent(outfile, level)
            outfile.write('gaussian_pulse_cut=%e,\n' % (self.gaussian_pulse_cut,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SigmaDefinition is not None:
            showIndent(outfile, level)
            outfile.write('SigmaDefinition=model_._SigmaDefinition(\n')
            self.SigmaDefinition.exportLiteral(outfile, level, name_='SigmaDefinition')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pulse_energy', node)
        if value is not None and 'pulse_energy' not in already_processed:
            already_processed.add('pulse_energy')
            try:
                self.pulse_energy = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (pulse_energy): %s' % exp)
        value = find_attr_value_('gaussian_pulse_cut', node)
        if value is not None and 'gaussian_pulse_cut' not in already_processed:
            already_processed.add('gaussian_pulse_cut')
            try:
                self.gaussian_pulse_cut = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (gaussian_pulse_cut): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SigmaDefinition':
            obj_ = create_SigmaDefinition.factory()
            obj_.build(child_)
            self.set_SigmaDefinition(obj_)
            obj_.original_tagname_ = 'SigmaDefinition'
# end class create_PulseDuration


class create_SigmaDefinition(GeneratedsSuper):
    """SigmaDefinition SigmaDefinition Relative power of the Gaussian pulse
    at which the pulse duration is specified. Classically the
    relative power is the half value of the Gaussian pulse. Relative
    power of the Gaussian pulse at which the pulse duration is
    specified. Classically the relative power is the half value of
    the Gaussian pulse. This half pulse duration is used to compute
    the Gaussian pulse standard deviation (sigma) This half pulse
    duration is used to compute the Gaussian pulse standard
    deviation (sigma)"""
    subclass = None
    superclass = None
    def __init__(self, relative_power_of_pulse=0.5, half_pulse_duration=2):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_SigmaDefinition")
        self.attrib = ['relative_power_of_pulse', 'half_pulse_duration']
        self.children = []
        self.parent = None
        self._relative_power_of_pulse = _cast(float, relative_power_of_pulse)
        self._half_pulse_duration = _cast(float, half_pulse_duration)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_SigmaDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_SigmaDefinition.subclass:
            return create_SigmaDefinition.subclass(*args_, **kwargs_)
        else:
            return create_SigmaDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_relative_power_of_pulse(self): return self._relative_power_of_pulse
    def set_relative_power_of_pulse(self, value):
        self._relative_power_of_pulse = value
        update_node(self,self.troot,"phase")
    relative_power_of_pulse = property(get_relative_power_of_pulse, set_relative_power_of_pulse)
    def get_half_pulse_duration(self): return self._half_pulse_duration
    def set_half_pulse_duration(self, value):
        self._half_pulse_duration = value
        update_node(self,self.troot,"phase")
    half_pulse_duration = property(get_half_pulse_duration, set_half_pulse_duration)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_SigmaDefinition', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_SigmaDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_SigmaDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_SigmaDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_SigmaDefinition'):
        if self.relative_power_of_pulse is not None and 'relative_power_of_pulse' not in already_processed:
            already_processed.add('relative_power_of_pulse')
            outfile.write(' relative_power_of_pulse="%s"' % self.gds_format_double(self.relative_power_of_pulse, input_name='relative_power_of_pulse'))
        if self.half_pulse_duration is not None and 'half_pulse_duration' not in already_processed:
            already_processed.add('half_pulse_duration')
            outfile.write(' half_pulse_duration="%s"' % self.gds_format_double(self.half_pulse_duration, input_name='half_pulse_duration'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_SigmaDefinition', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_SigmaDefinition', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.relative_power_of_pulse is not None:
            element.set('relative_power_of_pulse', self.gds_format_double(self.relative_power_of_pulse))
        if self.half_pulse_duration is not None:
            element.set('half_pulse_duration', self.gds_format_double(self.half_pulse_duration))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_SigmaDefinition'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.relative_power_of_pulse is not None and 'relative_power_of_pulse' not in already_processed:
            already_processed.add('relative_power_of_pulse')
            showIndent(outfile, level)
            outfile.write('relative_power_of_pulse=%e,\n' % (self.relative_power_of_pulse,))
        if self.half_pulse_duration is not None and 'half_pulse_duration' not in already_processed:
            already_processed.add('half_pulse_duration')
            showIndent(outfile, level)
            outfile.write('half_pulse_duration=%e,\n' % (self.half_pulse_duration,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('relative_power_of_pulse', node)
        if value is not None and 'relative_power_of_pulse' not in already_processed:
            already_processed.add('relative_power_of_pulse')
            try:
                self.relative_power_of_pulse = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (relative_power_of_pulse): %s' % exp)
        value = find_attr_value_('half_pulse_duration', node)
        if value is not None and 'half_pulse_duration' not in already_processed:
            already_processed.add('half_pulse_duration')
            try:
                self.half_pulse_duration = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (half_pulse_duration): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_SigmaDefinition


class create_LidarGeometry(GeneratedsSuper):
    """LidarGeometry LidarGeometry Laser scaning mode Laser scaning mode
    Definition of Footprint and FOV Definition of Footprint and FOV
    Area of LIDAR sensor Area of LIDAR sensor Waveform storage range
    option Waveform storage range option The ground footprints are
    displayed on the 2D view. Yellow corresponds to the illumination
    and orange to the reception. This parameter has no effet on the
    simulation (GUI only). The ground footprints are displayed on
    the 2D view. Yellow corresponds to the illumination and orange
    to the reception. This parameter has no effet on the simulation
    (GUI only). Width of the beam Width of the beam"""
    subclass = None
    superclass = None
    def __init__(self, lsMode=0, fp_fovDef=0, sensorArea=0.1, ifSetZeroDist=0, display=1, beam_width=0.0, StWaveHeightRange=None, SensorAngles=None, CenterOnGround=None, ZeroDist=None, FootPrintAndFOVRadiuses=None, FootPrintAndFOVDispersions=None, ALS=None, TLS=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_LidarGeometry")
        self.attrib = ['lsMode', 'fp_fovDef', 'sensorArea', 'ifSetZeroDist', 'display', 'beam_width']
        self.children = ['StWaveHeightRange', 'SensorAngles', 'CenterOnGround', 'ZeroDist', 'FootPrintAndFOVRadiuses', 'FootPrintAndFOVDispersions', 'ALS', 'TLS']
        self.parent = None
        self._lsMode = _cast(int, lsMode)
        self._fp_fovDef = _cast(int, fp_fovDef)
        self._sensorArea = _cast(float, sensorArea)
        self._ifSetZeroDist = _cast(int, ifSetZeroDist)
        self._display = _cast(int, display)
        self._beam_width = _cast(float, beam_width)
        self._StWaveHeightRange = StWaveHeightRange
        self._SensorAngles = SensorAngles
        self._CenterOnGround = CenterOnGround
        self._ZeroDist = ZeroDist
        self._FootPrintAndFOVRadiuses = FootPrintAndFOVRadiuses
        self._FootPrintAndFOVDispersions = FootPrintAndFOVDispersions
        self._ALS = ALS
        self._TLS = TLS
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_LidarGeometry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_LidarGeometry.subclass:
            return create_LidarGeometry.subclass(*args_, **kwargs_)
        else:
            return create_LidarGeometry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StWaveHeightRange(self): return self._StWaveHeightRange
    def set_StWaveHeightRange(self, value):
        if value is not None:
            checkclass(value, create_StWaveHeightRange)
            value.parent = self
        self._StWaveHeightRange = value
    StWaveHeightRange = property(get_StWaveHeightRange, set_StWaveHeightRange)
    def get_SensorAngles(self): return self._SensorAngles
    def set_SensorAngles(self, value):
        if value is not None:
            checkclass(value, create_SensorAngles)
            value.parent = self
        self._SensorAngles = value
    SensorAngles = property(get_SensorAngles, set_SensorAngles)
    def get_CenterOnGround(self): return self._CenterOnGround
    def set_CenterOnGround(self, value):
        if value is not None:
            checkclass(value, create_CenterOnGround)
            value.parent = self
        self._CenterOnGround = value
    CenterOnGround = property(get_CenterOnGround, set_CenterOnGround)
    def get_ZeroDist(self): return self._ZeroDist
    def set_ZeroDist(self, value):
        if value is not None:
            checkclass(value, create_ZeroDist)
            value.parent = self
        self._ZeroDist = value
    ZeroDist = property(get_ZeroDist, set_ZeroDist)
    def get_FootPrintAndFOVRadiuses(self): return self._FootPrintAndFOVRadiuses
    def set_FootPrintAndFOVRadiuses(self, value):
        if value is not None:
            checkclass(value, create_FootPrintAndFOVRadiuses)
            value.parent = self
        self._FootPrintAndFOVRadiuses = value
    FootPrintAndFOVRadiuses = property(get_FootPrintAndFOVRadiuses, set_FootPrintAndFOVRadiuses)
    def get_FootPrintAndFOVDispersions(self): return self._FootPrintAndFOVDispersions
    def set_FootPrintAndFOVDispersions(self, value):
        if value is not None:
            checkclass(value, create_FootPrintAndFOVDispersions)
            value.parent = self
        self._FootPrintAndFOVDispersions = value
    FootPrintAndFOVDispersions = property(get_FootPrintAndFOVDispersions, set_FootPrintAndFOVDispersions)
    def get_ALS(self): return self._ALS
    def set_ALS(self, value):
        if value is not None:
            checkclass(value, create_ALS)
            value.parent = self
        self._ALS = value
    ALS = property(get_ALS, set_ALS)
    def get_TLS(self): return self._TLS
    def set_TLS(self, value):
        if value is not None:
            checkclass(value, create_TLS)
            value.parent = self
        self._TLS = value
    TLS = property(get_TLS, set_TLS)
    def get_lsMode(self): return self._lsMode
    def set_lsMode(self, value):
        self._lsMode = value
        update_node(self,self.troot,"phase")
    lsMode = property(get_lsMode, set_lsMode)
    def get_fp_fovDef(self): return self._fp_fovDef
    def set_fp_fovDef(self, value):
        self._fp_fovDef = value
        update_node(self,self.troot,"phase")
    fp_fovDef = property(get_fp_fovDef, set_fp_fovDef)
    def get_sensorArea(self): return self._sensorArea
    def set_sensorArea(self, value):
        self._sensorArea = value
        update_node(self,self.troot,"phase")
    sensorArea = property(get_sensorArea, set_sensorArea)
    def get_ifSetZeroDist(self): return self._ifSetZeroDist
    def set_ifSetZeroDist(self, value):
        self._ifSetZeroDist = value
        update_node(self,self.troot,"phase")
    ifSetZeroDist = property(get_ifSetZeroDist, set_ifSetZeroDist)
    def get_display(self): return self._display
    def set_display(self, value):
        self._display = value
        update_node(self,self.troot,"phase")
    display = property(get_display, set_display)
    def get_beam_width(self): return self._beam_width
    def set_beam_width(self, value):
        self._beam_width = value
        update_node(self,self.troot,"phase")
    beam_width = property(get_beam_width, set_beam_width)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.StWaveHeightRange is not None or
            self.SensorAngles is not None or
            self.CenterOnGround is not None or
            self.ZeroDist is not None or
            self.FootPrintAndFOVRadiuses is not None or
            self.FootPrintAndFOVDispersions is not None or
            self.ALS is not None or
            self.TLS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_LidarGeometry', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_LidarGeometry')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_LidarGeometry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_LidarGeometry', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_LidarGeometry'):
        if self.lsMode is not None and 'lsMode' not in already_processed:
            already_processed.add('lsMode')
            outfile.write(' lsMode="%s"' % self.gds_format_integer(self.lsMode, input_name='lsMode'))
        if self.fp_fovDef is not None and 'fp_fovDef' not in already_processed:
            already_processed.add('fp_fovDef')
            outfile.write(' fp_fovDef="%s"' % self.gds_format_integer(self.fp_fovDef, input_name='fp_fovDef'))
        if self.sensorArea is not None and 'sensorArea' not in already_processed:
            already_processed.add('sensorArea')
            outfile.write(' sensorArea="%s"' % self.gds_format_double(self.sensorArea, input_name='sensorArea'))
        if self.ifSetZeroDist is not None and 'ifSetZeroDist' not in already_processed:
            already_processed.add('ifSetZeroDist')
            outfile.write(' ifSetZeroDist="%s"' % self.gds_format_integer(self.ifSetZeroDist, input_name='ifSetZeroDist'))
        if self.display is not None and 'display' not in already_processed:
            already_processed.add('display')
            outfile.write(' display="%s"' % self.gds_format_integer(self.display, input_name='display'))
        if self.beam_width is not None and 'beam_width' not in already_processed:
            already_processed.add('beam_width')
            outfile.write(' beam_width="%s"' % self.gds_format_double(self.beam_width, input_name='beam_width'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_LidarGeometry', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StWaveHeightRange is not None:
            self.StWaveHeightRange.export(outfile, level, namespaceprefix_, name_='StWaveHeightRange', pretty_print=pretty_print)
        if self.SensorAngles is not None:
            self.SensorAngles.export(outfile, level, namespaceprefix_, name_='SensorAngles', pretty_print=pretty_print)
        if self.CenterOnGround is not None:
            self.CenterOnGround.export(outfile, level, namespaceprefix_, name_='CenterOnGround', pretty_print=pretty_print)
        if self.ZeroDist is not None:
            self.ZeroDist.export(outfile, level, namespaceprefix_, name_='ZeroDist', pretty_print=pretty_print)
        if self.FootPrintAndFOVRadiuses is not None:
            self.FootPrintAndFOVRadiuses.export(outfile, level, namespaceprefix_, name_='FootPrintAndFOVRadiuses', pretty_print=pretty_print)
        if self.FootPrintAndFOVDispersions is not None:
            self.FootPrintAndFOVDispersions.export(outfile, level, namespaceprefix_, name_='FootPrintAndFOVDispersions', pretty_print=pretty_print)
        if self.ALS is not None:
            self.ALS.export(outfile, level, namespaceprefix_, name_='ALS', pretty_print=pretty_print)
        if self.TLS is not None:
            self.TLS.export(outfile, level, namespaceprefix_, name_='TLS', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_LidarGeometry', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.lsMode is not None:
            element.set('lsMode', self.gds_format_integer(self.lsMode))
        if self.fp_fovDef is not None:
            element.set('fp_fovDef', self.gds_format_integer(self.fp_fovDef))
        if self.sensorArea is not None:
            element.set('sensorArea', self.gds_format_double(self.sensorArea))
        if self.ifSetZeroDist is not None:
            element.set('ifSetZeroDist', self.gds_format_integer(self.ifSetZeroDist))
        if self.display is not None:
            element.set('display', self.gds_format_integer(self.display))
        if self.beam_width is not None:
            element.set('beam_width', self.gds_format_double(self.beam_width))
        if self.StWaveHeightRange is not None:
            StWaveHeightRange_ = self.StWaveHeightRange
            StWaveHeightRange_.to_etree(element, name_='StWaveHeightRange', mapping_=mapping_)
        if self.SensorAngles is not None:
            SensorAngles_ = self.SensorAngles
            SensorAngles_.to_etree(element, name_='SensorAngles', mapping_=mapping_)
        if self.CenterOnGround is not None:
            CenterOnGround_ = self.CenterOnGround
            CenterOnGround_.to_etree(element, name_='CenterOnGround', mapping_=mapping_)
        if self.ZeroDist is not None:
            ZeroDist_ = self.ZeroDist
            ZeroDist_.to_etree(element, name_='ZeroDist', mapping_=mapping_)
        if self.FootPrintAndFOVRadiuses is not None:
            FootPrintAndFOVRadiuses_ = self.FootPrintAndFOVRadiuses
            FootPrintAndFOVRadiuses_.to_etree(element, name_='FootPrintAndFOVRadiuses', mapping_=mapping_)
        if self.FootPrintAndFOVDispersions is not None:
            FootPrintAndFOVDispersions_ = self.FootPrintAndFOVDispersions
            FootPrintAndFOVDispersions_.to_etree(element, name_='FootPrintAndFOVDispersions', mapping_=mapping_)
        if self.ALS is not None:
            ALS_ = self.ALS
            ALS_.to_etree(element, name_='ALS', mapping_=mapping_)
        if self.TLS is not None:
            TLS_ = self.TLS
            TLS_.to_etree(element, name_='TLS', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_LidarGeometry'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lsMode is not None and 'lsMode' not in already_processed:
            already_processed.add('lsMode')
            showIndent(outfile, level)
            outfile.write('lsMode=%d,\n' % (self.lsMode,))
        if self.fp_fovDef is not None and 'fp_fovDef' not in already_processed:
            already_processed.add('fp_fovDef')
            showIndent(outfile, level)
            outfile.write('fp_fovDef=%d,\n' % (self.fp_fovDef,))
        if self.sensorArea is not None and 'sensorArea' not in already_processed:
            already_processed.add('sensorArea')
            showIndent(outfile, level)
            outfile.write('sensorArea=%e,\n' % (self.sensorArea,))
        if self.ifSetZeroDist is not None and 'ifSetZeroDist' not in already_processed:
            already_processed.add('ifSetZeroDist')
            showIndent(outfile, level)
            outfile.write('ifSetZeroDist=%d,\n' % (self.ifSetZeroDist,))
        if self.display is not None and 'display' not in already_processed:
            already_processed.add('display')
            showIndent(outfile, level)
            outfile.write('display=%d,\n' % (self.display,))
        if self.beam_width is not None and 'beam_width' not in already_processed:
            already_processed.add('beam_width')
            showIndent(outfile, level)
            outfile.write('beam_width=%e,\n' % (self.beam_width,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StWaveHeightRange is not None:
            showIndent(outfile, level)
            outfile.write('StWaveHeightRange=model_._StWaveHeightRange(\n')
            self.StWaveHeightRange.exportLiteral(outfile, level, name_='StWaveHeightRange')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SensorAngles is not None:
            showIndent(outfile, level)
            outfile.write('SensorAngles=model_._SensorAngles(\n')
            self.SensorAngles.exportLiteral(outfile, level, name_='SensorAngles')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CenterOnGround is not None:
            showIndent(outfile, level)
            outfile.write('CenterOnGround=model_._CenterOnGround(\n')
            self.CenterOnGround.exportLiteral(outfile, level, name_='CenterOnGround')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ZeroDist is not None:
            showIndent(outfile, level)
            outfile.write('ZeroDist=model_._ZeroDist(\n')
            self.ZeroDist.exportLiteral(outfile, level, name_='ZeroDist')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FootPrintAndFOVRadiuses is not None:
            showIndent(outfile, level)
            outfile.write('FootPrintAndFOVRadiuses=model_._FootPrintAndFOVRadiuses(\n')
            self.FootPrintAndFOVRadiuses.exportLiteral(outfile, level, name_='FootPrintAndFOVRadiuses')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FootPrintAndFOVDispersions is not None:
            showIndent(outfile, level)
            outfile.write('FootPrintAndFOVDispersions=model_._FootPrintAndFOVDispersions(\n')
            self.FootPrintAndFOVDispersions.exportLiteral(outfile, level, name_='FootPrintAndFOVDispersions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ALS is not None:
            showIndent(outfile, level)
            outfile.write('ALS=model_._ALS(\n')
            self.ALS.exportLiteral(outfile, level, name_='ALS')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TLS is not None:
            showIndent(outfile, level)
            outfile.write('TLS=model_._TLS(\n')
            self.TLS.exportLiteral(outfile, level, name_='TLS')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lsMode', node)
        if value is not None and 'lsMode' not in already_processed:
            already_processed.add('lsMode')
            try:
                self.lsMode = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('fp_fovDef', node)
        if value is not None and 'fp_fovDef' not in already_processed:
            already_processed.add('fp_fovDef')
            try:
                self.fp_fovDef = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('sensorArea', node)
        if value is not None and 'sensorArea' not in already_processed:
            already_processed.add('sensorArea')
            try:
                self.sensorArea = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sensorArea): %s' % exp)
        value = find_attr_value_('ifSetZeroDist', node)
        if value is not None and 'ifSetZeroDist' not in already_processed:
            already_processed.add('ifSetZeroDist')
            try:
                self.ifSetZeroDist = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('display', node)
        if value is not None and 'display' not in already_processed:
            already_processed.add('display')
            try:
                self.display = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('beam_width', node)
        if value is not None and 'beam_width' not in already_processed:
            already_processed.add('beam_width')
            try:
                self.beam_width = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (beam_width): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StWaveHeightRange':
            obj_ = create_StWaveHeightRange.factory()
            obj_.build(child_)
            self.set_StWaveHeightRange(obj_)
            obj_.original_tagname_ = 'StWaveHeightRange'
        elif nodeName_ == 'SensorAngles':
            obj_ = create_SensorAngles.factory()
            obj_.build(child_)
            self.set_SensorAngles(obj_)
            obj_.original_tagname_ = 'SensorAngles'
        elif nodeName_ == 'CenterOnGround':
            obj_ = create_CenterOnGround.factory()
            obj_.build(child_)
            self.set_CenterOnGround(obj_)
            obj_.original_tagname_ = 'CenterOnGround'
        elif nodeName_ == 'ZeroDist':
            obj_ = create_ZeroDist.factory()
            obj_.build(child_)
            self.set_ZeroDist(obj_)
            obj_.original_tagname_ = 'ZeroDist'
        elif nodeName_ == 'FootPrintAndFOVRadiuses':
            obj_ = create_FootPrintAndFOVRadiuses.factory()
            obj_.build(child_)
            self.set_FootPrintAndFOVRadiuses(obj_)
            obj_.original_tagname_ = 'FootPrintAndFOVRadiuses'
        elif nodeName_ == 'FootPrintAndFOVDispersions':
            obj_ = create_FootPrintAndFOVDispersions.factory()
            obj_.build(child_)
            self.set_FootPrintAndFOVDispersions(obj_)
            obj_.original_tagname_ = 'FootPrintAndFOVDispersions'
        elif nodeName_ == 'ALS':
            obj_ = create_ALS.factory()
            obj_.build(child_)
            self.set_ALS(obj_)
            obj_.original_tagname_ = 'ALS'
        elif nodeName_ == 'TLS':
            obj_ = create_TLS.factory()
            obj_.build(child_)
            self.set_TLS(obj_)
            obj_.original_tagname_ = 'TLS'
# end class create_LidarGeometry


class create_StWaveHeightRange(GeneratedsSuper):
    """ LIDAR waveform is made by photons that have crossed a distance
    smaller than "2 x (Distance "Sensor-Scene Minimum Altitude" +
    Max range below Scene Minimum Altitude)" and larger than "2 x
    (Distance "Sensor-Scene Minimum Altitude" - Max range above
    Scene Minimum Altitude)" LIDAR waveform is made by photons that
    have crossed a distance smaller than "2 x (Distance "Sensor-
    Scene Minimum Altitude" + Max range below Scene Minimum
    Altitude)" and larger than "2 x (Distance "Sensor-Scene Minimum
    Altitude" - Max range above Scene Minimum Altitude)" LIDAR
    waveform is made by photons that have crossed a distance smaller
    than "2 x (Distance "Sensor-Scene Minimum Altitude" + Max range
    below Scene Minimum Altitude)" and larger than "2 x (Distance
    "Sensor-Scene Minimum Altitude" - Max range above Scene Minimum
    Altitude)" LIDAR waveform is made by photons that have crossed a
    distance smaller than "2 x (Distance "Sensor-Scene Minimum
    Altitude" + Max range below Scene Minimum Altitude)" and larger
    than "2 x (Distance "Sensor-Scene Minimum Altitude" - Max range
    above Scene Minimum Altitude)" """
    subclass = None
    superclass = None
    def __init__(self, photon_min_LIDAR=50, photon_max_LIDAR=50):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_StWaveHeightRange")
        self.attrib = ['photon_min_LIDAR', 'photon_max_LIDAR']
        self.children = []
        self.parent = None
        self._photon_min_LIDAR = _cast(float, photon_min_LIDAR)
        self._photon_max_LIDAR = _cast(float, photon_max_LIDAR)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_StWaveHeightRange)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_StWaveHeightRange.subclass:
            return create_StWaveHeightRange.subclass(*args_, **kwargs_)
        else:
            return create_StWaveHeightRange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_photon_min_LIDAR(self): return self._photon_min_LIDAR
    def set_photon_min_LIDAR(self, value):
        self._photon_min_LIDAR = value
        update_node(self,self.troot,"phase")
    photon_min_LIDAR = property(get_photon_min_LIDAR, set_photon_min_LIDAR)
    def get_photon_max_LIDAR(self): return self._photon_max_LIDAR
    def set_photon_max_LIDAR(self, value):
        self._photon_max_LIDAR = value
        update_node(self,self.troot,"phase")
    photon_max_LIDAR = property(get_photon_max_LIDAR, set_photon_max_LIDAR)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_StWaveHeightRange', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_StWaveHeightRange')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_StWaveHeightRange')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_StWaveHeightRange', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_StWaveHeightRange'):
        if self.photon_min_LIDAR is not None and 'photon_min_LIDAR' not in already_processed:
            already_processed.add('photon_min_LIDAR')
            outfile.write(' photon_min_LIDAR="%s"' % self.gds_format_double(self.photon_min_LIDAR, input_name='photon_min_LIDAR'))
        if self.photon_max_LIDAR is not None and 'photon_max_LIDAR' not in already_processed:
            already_processed.add('photon_max_LIDAR')
            outfile.write(' photon_max_LIDAR="%s"' % self.gds_format_double(self.photon_max_LIDAR, input_name='photon_max_LIDAR'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_StWaveHeightRange', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_StWaveHeightRange', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.photon_min_LIDAR is not None:
            element.set('photon_min_LIDAR', self.gds_format_double(self.photon_min_LIDAR))
        if self.photon_max_LIDAR is not None:
            element.set('photon_max_LIDAR', self.gds_format_double(self.photon_max_LIDAR))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_StWaveHeightRange'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.photon_min_LIDAR is not None and 'photon_min_LIDAR' not in already_processed:
            already_processed.add('photon_min_LIDAR')
            showIndent(outfile, level)
            outfile.write('photon_min_LIDAR=%e,\n' % (self.photon_min_LIDAR,))
        if self.photon_max_LIDAR is not None and 'photon_max_LIDAR' not in already_processed:
            already_processed.add('photon_max_LIDAR')
            showIndent(outfile, level)
            outfile.write('photon_max_LIDAR=%e,\n' % (self.photon_max_LIDAR,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('photon_min_LIDAR', node)
        if value is not None and 'photon_min_LIDAR' not in already_processed:
            already_processed.add('photon_min_LIDAR')
            try:
                self.photon_min_LIDAR = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (photon_min_LIDAR): %s' % exp)
        value = find_attr_value_('photon_max_LIDAR', node)
        if value is not None and 'photon_max_LIDAR' not in already_processed:
            already_processed.add('photon_max_LIDAR')
            try:
                self.photon_max_LIDAR = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (photon_max_LIDAR): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_StWaveHeightRange


class create_SensorAngles(GeneratedsSuper):
    """Central view direction Central view direction Upward (from ground to
    sensor) Zenith Angle of the LIDAR sensor, for reception. The
    opposite angles are used for emission. Upward (from ground to
    sensor) Zenith Angle of the LIDAR sensor, for reception. The
    opposite angles are used for emission. Upward (from ground to
    sensor) Azimuth Angle of the LIDAR sensor, for reception. The
    opposite angles are used for emission. Upward (from ground to
    sensor) Azimuth Angle of the LIDAR sensor, for reception. The
    opposite angles are used for emission."""
    subclass = None
    superclass = None
    def __init__(self, sensorTheta=30, sensorPhi=45):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_SensorAngles")
        self.attrib = ['sensorTheta', 'sensorPhi']
        self.children = []
        self.parent = None
        self._sensorTheta = _cast(float, sensorTheta)
        self._sensorPhi = _cast(float, sensorPhi)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_SensorAngles)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_SensorAngles.subclass:
            return create_SensorAngles.subclass(*args_, **kwargs_)
        else:
            return create_SensorAngles(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sensorTheta(self): return self._sensorTheta
    def set_sensorTheta(self, value):
        self._sensorTheta = value
        update_node(self,self.troot,"phase")
    sensorTheta = property(get_sensorTheta, set_sensorTheta)
    def get_sensorPhi(self): return self._sensorPhi
    def set_sensorPhi(self, value):
        self._sensorPhi = value
        update_node(self,self.troot,"phase")
    sensorPhi = property(get_sensorPhi, set_sensorPhi)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_SensorAngles', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_SensorAngles')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_SensorAngles')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_SensorAngles', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_SensorAngles'):
        if self.sensorTheta is not None and 'sensorTheta' not in already_processed:
            already_processed.add('sensorTheta')
            outfile.write(' sensorTheta="%s"' % self.gds_format_double(self.sensorTheta, input_name='sensorTheta'))
        if self.sensorPhi is not None and 'sensorPhi' not in already_processed:
            already_processed.add('sensorPhi')
            outfile.write(' sensorPhi="%s"' % self.gds_format_double(self.sensorPhi, input_name='sensorPhi'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_SensorAngles', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_SensorAngles', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.sensorTheta is not None:
            element.set('sensorTheta', self.gds_format_double(self.sensorTheta))
        if self.sensorPhi is not None:
            element.set('sensorPhi', self.gds_format_double(self.sensorPhi))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_SensorAngles'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sensorTheta is not None and 'sensorTheta' not in already_processed:
            already_processed.add('sensorTheta')
            showIndent(outfile, level)
            outfile.write('sensorTheta=%e,\n' % (self.sensorTheta,))
        if self.sensorPhi is not None and 'sensorPhi' not in already_processed:
            already_processed.add('sensorPhi')
            showIndent(outfile, level)
            outfile.write('sensorPhi=%e,\n' % (self.sensorPhi,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sensorTheta', node)
        if value is not None and 'sensorTheta' not in already_processed:
            already_processed.add('sensorTheta')
            try:
                self.sensorTheta = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sensorTheta): %s' % exp)
        value = find_attr_value_('sensorPhi', node)
        if value is not None and 'sensorPhi' not in already_processed:
            already_processed.add('sensorPhi')
            try:
                self.sensorPhi = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sensorPhi): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_SensorAngles


class create_CenterOnGround(GeneratedsSuper):
    """CenterOnGround CenterOnGround x coordinate of illumination of the
    LIDAR on the ground. (0, 0) is the top left corner x coordinate
    of illumination of the LIDAR on the ground. (0, 0) is the top
    left corner y coordinate of illumination of the LIDAR on the
    ground. (0, 0) is the top left corner y coordinate of
    illumination of the LIDAR on the ground. (0, 0) is the top left
    corner"""
    subclass = None
    superclass = None
    def __init__(self, decalageLidar_x=20, decalageLidar_y=20):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_CenterOnGround")
        self.attrib = ['decalageLidar_x', 'decalageLidar_y']
        self.children = []
        self.parent = None
        self._decalageLidar_x = _cast(float, decalageLidar_x)
        self._decalageLidar_y = _cast(float, decalageLidar_y)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_CenterOnGround)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_CenterOnGround.subclass:
            return create_CenterOnGround.subclass(*args_, **kwargs_)
        else:
            return create_CenterOnGround(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_decalageLidar_x(self): return self._decalageLidar_x
    def set_decalageLidar_x(self, value):
        self._decalageLidar_x = value
        update_node(self,self.troot,"phase")
    decalageLidar_x = property(get_decalageLidar_x, set_decalageLidar_x)
    def get_decalageLidar_y(self): return self._decalageLidar_y
    def set_decalageLidar_y(self, value):
        self._decalageLidar_y = value
        update_node(self,self.troot,"phase")
    decalageLidar_y = property(get_decalageLidar_y, set_decalageLidar_y)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_CenterOnGround', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_CenterOnGround')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_CenterOnGround')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_CenterOnGround', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_CenterOnGround'):
        if self.decalageLidar_x is not None and 'decalageLidar_x' not in already_processed:
            already_processed.add('decalageLidar_x')
            outfile.write(' decalageLidar_x="%s"' % self.gds_format_double(self.decalageLidar_x, input_name='decalageLidar_x'))
        if self.decalageLidar_y is not None and 'decalageLidar_y' not in already_processed:
            already_processed.add('decalageLidar_y')
            outfile.write(' decalageLidar_y="%s"' % self.gds_format_double(self.decalageLidar_y, input_name='decalageLidar_y'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_CenterOnGround', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_CenterOnGround', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.decalageLidar_x is not None:
            element.set('decalageLidar_x', self.gds_format_double(self.decalageLidar_x))
        if self.decalageLidar_y is not None:
            element.set('decalageLidar_y', self.gds_format_double(self.decalageLidar_y))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_CenterOnGround'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.decalageLidar_x is not None and 'decalageLidar_x' not in already_processed:
            already_processed.add('decalageLidar_x')
            showIndent(outfile, level)
            outfile.write('decalageLidar_x=%e,\n' % (self.decalageLidar_x,))
        if self.decalageLidar_y is not None and 'decalageLidar_y' not in already_processed:
            already_processed.add('decalageLidar_y')
            showIndent(outfile, level)
            outfile.write('decalageLidar_y=%e,\n' % (self.decalageLidar_y,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('decalageLidar_x', node)
        if value is not None and 'decalageLidar_x' not in already_processed:
            already_processed.add('decalageLidar_x')
            try:
                self.decalageLidar_x = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (decalageLidar_x): %s' % exp)
        value = find_attr_value_('decalageLidar_y', node)
        if value is not None and 'decalageLidar_y' not in already_processed:
            already_processed.add('decalageLidar_y')
            try:
                self.decalageLidar_y = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (decalageLidar_y): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_CenterOnGround


class create_ZeroDist(GeneratedsSuper):
    """Stored waveform distance range from LIDAR Stored waveform distance
    range from LIDAR Distance to reference point Distance to
    reference point Stored distance after reference point Stored
    distance after reference point Stored distance before reference
    point Stored distance before reference point"""
    subclass = None
    superclass = None
    def __init__(self, referenceZeroDistance=-1., distAfterRef=-1., distBeforeRef=-1.):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_ZeroDist")
        self.attrib = ['referenceZeroDistance', 'distAfterRef', 'distBeforeRef']
        self.children = []
        self.parent = None
        self._referenceZeroDistance = _cast(float, referenceZeroDistance)
        self._distAfterRef = _cast(float, distAfterRef)
        self._distBeforeRef = _cast(float, distBeforeRef)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ZeroDist)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ZeroDist.subclass:
            return create_ZeroDist.subclass(*args_, **kwargs_)
        else:
            return create_ZeroDist(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_referenceZeroDistance(self): return self._referenceZeroDistance
    def set_referenceZeroDistance(self, value):
        self._referenceZeroDistance = value
        update_node(self,self.troot,"phase")
    referenceZeroDistance = property(get_referenceZeroDistance, set_referenceZeroDistance)
    def get_distAfterRef(self): return self._distAfterRef
    def set_distAfterRef(self, value):
        self._distAfterRef = value
        update_node(self,self.troot,"phase")
    distAfterRef = property(get_distAfterRef, set_distAfterRef)
    def get_distBeforeRef(self): return self._distBeforeRef
    def set_distBeforeRef(self, value):
        self._distBeforeRef = value
        update_node(self,self.troot,"phase")
    distBeforeRef = property(get_distBeforeRef, set_distBeforeRef)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ZeroDist', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ZeroDist')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ZeroDist')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ZeroDist', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ZeroDist'):
        if self.referenceZeroDistance is not None and 'referenceZeroDistance' not in already_processed:
            already_processed.add('referenceZeroDistance')
            outfile.write(' referenceZeroDistance="%s"' % self.gds_format_double(self.referenceZeroDistance, input_name='referenceZeroDistance'))
        if self.distAfterRef is not None and 'distAfterRef' not in already_processed:
            already_processed.add('distAfterRef')
            outfile.write(' distAfterRef="%s"' % self.gds_format_double(self.distAfterRef, input_name='distAfterRef'))
        if self.distBeforeRef is not None and 'distBeforeRef' not in already_processed:
            already_processed.add('distBeforeRef')
            outfile.write(' distBeforeRef="%s"' % self.gds_format_double(self.distBeforeRef, input_name='distBeforeRef'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ZeroDist', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_ZeroDist', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.referenceZeroDistance is not None:
            element.set('referenceZeroDistance', self.gds_format_double(self.referenceZeroDistance))
        if self.distAfterRef is not None:
            element.set('distAfterRef', self.gds_format_double(self.distAfterRef))
        if self.distBeforeRef is not None:
            element.set('distBeforeRef', self.gds_format_double(self.distBeforeRef))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ZeroDist'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.referenceZeroDistance is not None and 'referenceZeroDistance' not in already_processed:
            already_processed.add('referenceZeroDistance')
            showIndent(outfile, level)
            outfile.write('referenceZeroDistance=%e,\n' % (self.referenceZeroDistance,))
        if self.distAfterRef is not None and 'distAfterRef' not in already_processed:
            already_processed.add('distAfterRef')
            showIndent(outfile, level)
            outfile.write('distAfterRef=%e,\n' % (self.distAfterRef,))
        if self.distBeforeRef is not None and 'distBeforeRef' not in already_processed:
            already_processed.add('distBeforeRef')
            showIndent(outfile, level)
            outfile.write('distBeforeRef=%e,\n' % (self.distBeforeRef,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('referenceZeroDistance', node)
        if value is not None and 'referenceZeroDistance' not in already_processed:
            already_processed.add('referenceZeroDistance')
            try:
                self.referenceZeroDistance = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (referenceZeroDistance): %s' % exp)
        value = find_attr_value_('distAfterRef', node)
        if value is not None and 'distAfterRef' not in already_processed:
            already_processed.add('distAfterRef')
            try:
                self.distAfterRef = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (distAfterRef): %s' % exp)
        value = find_attr_value_('distBeforeRef', node)
        if value is not None and 'distBeforeRef' not in already_processed:
            already_processed.add('distBeforeRef')
            try:
                self.distBeforeRef = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (distBeforeRef): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_ZeroDist


class create_FootPrintAndFOVRadiuses(GeneratedsSuper):
    """Radii Radii Field of view Field of view Footprint Footprint"""
    subclass = None
    superclass = None
    def __init__(self, rayonLidar_reception=15, rayonLidar_emission=12):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_FootPrintAndFOVRadiuses")
        self.attrib = ['rayonLidar_reception', 'rayonLidar_emission']
        self.children = []
        self.parent = None
        self._rayonLidar_reception = _cast(float, rayonLidar_reception)
        self._rayonLidar_emission = _cast(float, rayonLidar_emission)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_FootPrintAndFOVRadiuses)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_FootPrintAndFOVRadiuses.subclass:
            return create_FootPrintAndFOVRadiuses.subclass(*args_, **kwargs_)
        else:
            return create_FootPrintAndFOVRadiuses(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rayonLidar_reception(self): return self._rayonLidar_reception
    def set_rayonLidar_reception(self, value):
        self._rayonLidar_reception = value
        update_node(self,self.troot,"phase")
    rayonLidar_reception = property(get_rayonLidar_reception, set_rayonLidar_reception)
    def get_rayonLidar_emission(self): return self._rayonLidar_emission
    def set_rayonLidar_emission(self, value):
        self._rayonLidar_emission = value
        update_node(self,self.troot,"phase")
    rayonLidar_emission = property(get_rayonLidar_emission, set_rayonLidar_emission)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_FootPrintAndFOVRadiuses', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_FootPrintAndFOVRadiuses')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_FootPrintAndFOVRadiuses')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_FootPrintAndFOVRadiuses', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_FootPrintAndFOVRadiuses'):
        if self.rayonLidar_reception is not None and 'rayonLidar_reception' not in already_processed:
            already_processed.add('rayonLidar_reception')
            outfile.write(' rayonLidar_reception="%s"' % self.gds_format_double(self.rayonLidar_reception, input_name='rayonLidar_reception'))
        if self.rayonLidar_emission is not None and 'rayonLidar_emission' not in already_processed:
            already_processed.add('rayonLidar_emission')
            outfile.write(' rayonLidar_emission="%s"' % self.gds_format_double(self.rayonLidar_emission, input_name='rayonLidar_emission'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_FootPrintAndFOVRadiuses', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_FootPrintAndFOVRadiuses', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.rayonLidar_reception is not None:
            element.set('rayonLidar_reception', self.gds_format_double(self.rayonLidar_reception))
        if self.rayonLidar_emission is not None:
            element.set('rayonLidar_emission', self.gds_format_double(self.rayonLidar_emission))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_FootPrintAndFOVRadiuses'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.rayonLidar_reception is not None and 'rayonLidar_reception' not in already_processed:
            already_processed.add('rayonLidar_reception')
            showIndent(outfile, level)
            outfile.write('rayonLidar_reception=%e,\n' % (self.rayonLidar_reception,))
        if self.rayonLidar_emission is not None and 'rayonLidar_emission' not in already_processed:
            already_processed.add('rayonLidar_emission')
            showIndent(outfile, level)
            outfile.write('rayonLidar_emission=%e,\n' % (self.rayonLidar_emission,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rayonLidar_reception', node)
        if value is not None and 'rayonLidar_reception' not in already_processed:
            already_processed.add('rayonLidar_reception')
            try:
                self.rayonLidar_reception = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (rayonLidar_reception): %s' % exp)
        value = find_attr_value_('rayonLidar_emission', node)
        if value is not None and 'rayonLidar_emission' not in already_processed:
            already_processed.add('rayonLidar_emission')
            try:
                self.rayonLidar_emission = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (rayonLidar_emission): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_FootPrintAndFOVRadiuses


class create_FootPrintAndFOVDispersions(GeneratedsSuper):
    """Half angles Half angles Footprint Footprint Field of view Field of
    view"""
    subclass = None
    superclass = None
    def __init__(self, dispersionFootprint=0.0012, dispersionFOV=0.0015):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_FootPrintAndFOVDispersions")
        self.attrib = ['dispersionFootprint', 'dispersionFOV']
        self.children = []
        self.parent = None
        self._dispersionFootprint = _cast(float, dispersionFootprint)
        self._dispersionFOV = _cast(float, dispersionFOV)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_FootPrintAndFOVDispersions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_FootPrintAndFOVDispersions.subclass:
            return create_FootPrintAndFOVDispersions.subclass(*args_, **kwargs_)
        else:
            return create_FootPrintAndFOVDispersions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dispersionFootprint(self): return self._dispersionFootprint
    def set_dispersionFootprint(self, value):
        self._dispersionFootprint = value
        update_node(self,self.troot,"phase")
    dispersionFootprint = property(get_dispersionFootprint, set_dispersionFootprint)
    def get_dispersionFOV(self): return self._dispersionFOV
    def set_dispersionFOV(self, value):
        self._dispersionFOV = value
        update_node(self,self.troot,"phase")
    dispersionFOV = property(get_dispersionFOV, set_dispersionFOV)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_FootPrintAndFOVDispersions', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_FootPrintAndFOVDispersions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_FootPrintAndFOVDispersions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_FootPrintAndFOVDispersions', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_FootPrintAndFOVDispersions'):
        if self.dispersionFootprint is not None and 'dispersionFootprint' not in already_processed:
            already_processed.add('dispersionFootprint')
            outfile.write(' dispersionFootprint="%s"' % self.gds_format_double(self.dispersionFootprint, input_name='dispersionFootprint'))
        if self.dispersionFOV is not None and 'dispersionFOV' not in already_processed:
            already_processed.add('dispersionFOV')
            outfile.write(' dispersionFOV="%s"' % self.gds_format_double(self.dispersionFOV, input_name='dispersionFOV'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_FootPrintAndFOVDispersions', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_FootPrintAndFOVDispersions', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.dispersionFootprint is not None:
            element.set('dispersionFootprint', self.gds_format_double(self.dispersionFootprint))
        if self.dispersionFOV is not None:
            element.set('dispersionFOV', self.gds_format_double(self.dispersionFOV))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_FootPrintAndFOVDispersions'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.dispersionFootprint is not None and 'dispersionFootprint' not in already_processed:
            already_processed.add('dispersionFootprint')
            showIndent(outfile, level)
            outfile.write('dispersionFootprint=%e,\n' % (self.dispersionFootprint,))
        if self.dispersionFOV is not None and 'dispersionFOV' not in already_processed:
            already_processed.add('dispersionFOV')
            showIndent(outfile, level)
            outfile.write('dispersionFOV=%e,\n' % (self.dispersionFOV,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dispersionFootprint', node)
        if value is not None and 'dispersionFootprint' not in already_processed:
            already_processed.add('dispersionFootprint')
            try:
                self.dispersionFootprint = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (dispersionFootprint): %s' % exp)
        value = find_attr_value_('dispersionFOV', node)
        if value is not None and 'dispersionFOV' not in already_processed:
            already_processed.add('dispersionFOV')
            try:
                self.dispersionFOV = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (dispersionFOV): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_FootPrintAndFOVDispersions


class create_ALS(GeneratedsSuper):
    """ALS ALS Altitude of LIDAR platform Altitude of LIDAR platform"""
    subclass = None
    superclass = None
    def __init__(self, sensorHeight=10, Swath=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_ALS")
        self.attrib = ['sensorHeight']
        self.children = ['Swath']
        self.parent = None
        self._sensorHeight = _cast(float, sensorHeight)
        self._Swath = Swath
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ALS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ALS.subclass:
            return create_ALS.subclass(*args_, **kwargs_)
        else:
            return create_ALS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Swath(self): return self._Swath
    def set_Swath(self, value):
        if value is not None:
            checkclass(value, create_Swath)
            value.parent = self
        self._Swath = value
    Swath = property(get_Swath, set_Swath)
    def get_sensorHeight(self): return self._sensorHeight
    def set_sensorHeight(self, value):
        self._sensorHeight = value
        update_node(self,self.troot,"phase")
    sensorHeight = property(get_sensorHeight, set_sensorHeight)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Swath is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ALS', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ALS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ALS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ALS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ALS'):
        if self.sensorHeight is not None and 'sensorHeight' not in already_processed:
            already_processed.add('sensorHeight')
            outfile.write(' sensorHeight="%s"' % self.gds_format_double(self.sensorHeight, input_name='sensorHeight'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ALS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Swath is not None:
            self.Swath.export(outfile, level, namespaceprefix_, name_='Swath', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_ALS', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.sensorHeight is not None:
            element.set('sensorHeight', self.gds_format_double(self.sensorHeight))
        if self.Swath is not None:
            Swath_ = self.Swath
            Swath_.to_etree(element, name_='Swath', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ALS'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sensorHeight is not None and 'sensorHeight' not in already_processed:
            already_processed.add('sensorHeight')
            showIndent(outfile, level)
            outfile.write('sensorHeight=%e,\n' % (self.sensorHeight,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Swath is not None:
            showIndent(outfile, level)
            outfile.write('Swath=model_._Swath(\n')
            self.Swath.exportLiteral(outfile, level, name_='Swath')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sensorHeight', node)
        if value is not None and 'sensorHeight' not in already_processed:
            already_processed.add('sensorHeight')
            try:
                self.sensorHeight = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sensorHeight): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Swath':
            obj_ = create_Swath.factory()
            obj_.build(child_)
            self.set_Swath(obj_)
            obj_.original_tagname_ = 'Swath'
# end class create_ALS


class create_Swath(GeneratedsSuper):
    """Swath Swath Import a file contains detailed separated pulses Import
    a file contains detailed separated pulses"""
    subclass = None
    superclass = None
    def __init__(self, isSeparatePulsesImport=0, calculatedSwath=None, importedSwath=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_Swath")
        self.attrib = ['isSeparatePulsesImport']
        self.children = ['calculatedSwath', 'importedSwath']
        self.parent = None
        self._isSeparatePulsesImport = _cast(int, isSeparatePulsesImport)
        self._calculatedSwath = calculatedSwath
        self._importedSwath = importedSwath
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Swath)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Swath.subclass:
            return create_Swath.subclass(*args_, **kwargs_)
        else:
            return create_Swath(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_calculatedSwath(self): return self._calculatedSwath
    def set_calculatedSwath(self, value):
        if value is not None:
            checkclass(value, create_calculatedSwath)
            value.parent = self
        self._calculatedSwath = value
    calculatedSwath = property(get_calculatedSwath, set_calculatedSwath)
    def get_importedSwath(self): return self._importedSwath
    def set_importedSwath(self, value):
        if value is not None:
            checkclass(value, create_importedSwath)
            value.parent = self
        self._importedSwath = value
    importedSwath = property(get_importedSwath, set_importedSwath)
    def get_isSeparatePulsesImport(self): return self._isSeparatePulsesImport
    def set_isSeparatePulsesImport(self, value):
        self._isSeparatePulsesImport = value
        update_node(self,self.troot,"phase")
    isSeparatePulsesImport = property(get_isSeparatePulsesImport, set_isSeparatePulsesImport)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.calculatedSwath is not None or
            self.importedSwath is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Swath', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Swath')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Swath')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Swath', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Swath'):
        if self.isSeparatePulsesImport is not None and 'isSeparatePulsesImport' not in already_processed:
            already_processed.add('isSeparatePulsesImport')
            outfile.write(' isSeparatePulsesImport="%s"' % self.gds_format_integer(self.isSeparatePulsesImport, input_name='isSeparatePulsesImport'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Swath', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.calculatedSwath is not None:
            self.calculatedSwath.export(outfile, level, namespaceprefix_, name_='calculatedSwath', pretty_print=pretty_print)
        if self.importedSwath is not None:
            self.importedSwath.export(outfile, level, namespaceprefix_, name_='importedSwath', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Swath', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.isSeparatePulsesImport is not None:
            element.set('isSeparatePulsesImport', self.gds_format_integer(self.isSeparatePulsesImport))
        if self.calculatedSwath is not None:
            calculatedSwath_ = self.calculatedSwath
            calculatedSwath_.to_etree(element, name_='calculatedSwath', mapping_=mapping_)
        if self.importedSwath is not None:
            importedSwath_ = self.importedSwath
            importedSwath_.to_etree(element, name_='importedSwath', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Swath'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isSeparatePulsesImport is not None and 'isSeparatePulsesImport' not in already_processed:
            already_processed.add('isSeparatePulsesImport')
            showIndent(outfile, level)
            outfile.write('isSeparatePulsesImport=%d,\n' % (self.isSeparatePulsesImport,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.calculatedSwath is not None:
            showIndent(outfile, level)
            outfile.write('calculatedSwath=model_._calculatedSwath(\n')
            self.calculatedSwath.exportLiteral(outfile, level, name_='calculatedSwath')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.importedSwath is not None:
            showIndent(outfile, level)
            outfile.write('importedSwath=model_._importedSwath(\n')
            self.importedSwath.exportLiteral(outfile, level, name_='importedSwath')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isSeparatePulsesImport', node)
        if value is not None and 'isSeparatePulsesImport' not in already_processed:
            already_processed.add('isSeparatePulsesImport')
            try:
                self.isSeparatePulsesImport = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'calculatedSwath':
            obj_ = create_calculatedSwath.factory()
            obj_.build(child_)
            self.set_calculatedSwath(obj_)
            obj_.original_tagname_ = 'calculatedSwath'
        elif nodeName_ == 'importedSwath':
            obj_ = create_importedSwath.factory()
            obj_.build(child_)
            self.set_importedSwath(obj_)
            obj_.original_tagname_ = 'importedSwath'
# end class create_Swath


class create_calculatedSwath(GeneratedsSuper):
    """calculatedSwath calculatedSwath Platform azimuth: tilt of the
    scanning axis relative to the movement axis. Platform azimuth:
    tilt of the scanning axis relative to the movement axis. Swath
    width, perpendicular to the movement axis. Swath width,
    perpendicular to the movement axis."""
    subclass = None
    superclass = None
    def __init__(self, platformAzimuth=0., width=30, CenterBegin=None, CenterEnd=None, ControlPoint=None, ImageParameters=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_calculatedSwath")
        self.attrib = ['platformAzimuth', 'width']
        self.children = ['CenterBegin', 'CenterEnd', 'ControlPoint', 'ImageParameters']
        self.parent = None
        self._platformAzimuth = _cast(float, platformAzimuth)
        self._width = _cast(float, width)
        self._CenterBegin = CenterBegin
        self._CenterEnd = CenterEnd
        self._ControlPoint = ControlPoint
        self._ImageParameters = ImageParameters
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_calculatedSwath)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_calculatedSwath.subclass:
            return create_calculatedSwath.subclass(*args_, **kwargs_)
        else:
            return create_calculatedSwath(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CenterBegin(self): return self._CenterBegin
    def set_CenterBegin(self, value):
        if value is not None:
            checkclass(value, create_CenterBegin)
            value.parent = self
        self._CenterBegin = value
    CenterBegin = property(get_CenterBegin, set_CenterBegin)
    def get_CenterEnd(self): return self._CenterEnd
    def set_CenterEnd(self, value):
        if value is not None:
            checkclass(value, create_CenterEnd)
            value.parent = self
        self._CenterEnd = value
    CenterEnd = property(get_CenterEnd, set_CenterEnd)
    def get_ControlPoint(self): return self._ControlPoint
    def set_ControlPoint(self, value):
        if value is not None:
            checkclass(value, create_ControlPoint)
            value.parent = self
        self._ControlPoint = value
    ControlPoint = property(get_ControlPoint, set_ControlPoint)
    def get_ImageParameters(self): return self._ImageParameters
    def set_ImageParameters(self, value):
        if value is not None:
            checkclass(value, create_ImageParameters)
            value.parent = self
        self._ImageParameters = value
    ImageParameters = property(get_ImageParameters, set_ImageParameters)
    def get_platformAzimuth(self): return self._platformAzimuth
    def set_platformAzimuth(self, value):
        self._platformAzimuth = value
        update_node(self,self.troot,"phase")
    platformAzimuth = property(get_platformAzimuth, set_platformAzimuth)
    def get_width(self): return self._width
    def set_width(self, value):
        self._width = value
        update_node(self,self.troot,"phase")
    width = property(get_width, set_width)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.CenterBegin is not None or
            self.CenterEnd is not None or
            self.ControlPoint is not None or
            self.ImageParameters is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_calculatedSwath', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_calculatedSwath')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_calculatedSwath')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_calculatedSwath', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_calculatedSwath'):
        if self.platformAzimuth is not None and 'platformAzimuth' not in already_processed:
            already_processed.add('platformAzimuth')
            outfile.write(' platformAzimuth="%s"' % self.gds_format_double(self.platformAzimuth, input_name='platformAzimuth'))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_calculatedSwath', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CenterBegin is not None:
            self.CenterBegin.export(outfile, level, namespaceprefix_, name_='CenterBegin', pretty_print=pretty_print)
        if self.CenterEnd is not None:
            self.CenterEnd.export(outfile, level, namespaceprefix_, name_='CenterEnd', pretty_print=pretty_print)
        if self.ControlPoint is not None:
            self.ControlPoint.export(outfile, level, namespaceprefix_, name_='ControlPoint', pretty_print=pretty_print)
        if self.ImageParameters is not None:
            self.ImageParameters.export(outfile, level, namespaceprefix_, name_='ImageParameters', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_calculatedSwath', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.platformAzimuth is not None:
            element.set('platformAzimuth', self.gds_format_double(self.platformAzimuth))
        if self.width is not None:
            element.set('width', self.gds_format_double(self.width))
        if self.CenterBegin is not None:
            CenterBegin_ = self.CenterBegin
            CenterBegin_.to_etree(element, name_='CenterBegin', mapping_=mapping_)
        if self.CenterEnd is not None:
            CenterEnd_ = self.CenterEnd
            CenterEnd_.to_etree(element, name_='CenterEnd', mapping_=mapping_)
        if self.ControlPoint is not None:
            ControlPoint_ = self.ControlPoint
            ControlPoint_.to_etree(element, name_='ControlPoint', mapping_=mapping_)
        if self.ImageParameters is not None:
            ImageParameters_ = self.ImageParameters
            ImageParameters_.to_etree(element, name_='ImageParameters', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_calculatedSwath'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.platformAzimuth is not None and 'platformAzimuth' not in already_processed:
            already_processed.add('platformAzimuth')
            showIndent(outfile, level)
            outfile.write('platformAzimuth=%e,\n' % (self.platformAzimuth,))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            showIndent(outfile, level)
            outfile.write('width=%e,\n' % (self.width,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CenterBegin is not None:
            showIndent(outfile, level)
            outfile.write('CenterBegin=model_._CenterBegin(\n')
            self.CenterBegin.exportLiteral(outfile, level, name_='CenterBegin')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CenterEnd is not None:
            showIndent(outfile, level)
            outfile.write('CenterEnd=model_._CenterEnd(\n')
            self.CenterEnd.exportLiteral(outfile, level, name_='CenterEnd')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ControlPoint is not None:
            showIndent(outfile, level)
            outfile.write('ControlPoint=model_._ControlPoint(\n')
            self.ControlPoint.exportLiteral(outfile, level, name_='ControlPoint')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ImageParameters is not None:
            showIndent(outfile, level)
            outfile.write('ImageParameters=model_._ImageParameters(\n')
            self.ImageParameters.exportLiteral(outfile, level, name_='ImageParameters')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('platformAzimuth', node)
        if value is not None and 'platformAzimuth' not in already_processed:
            already_processed.add('platformAzimuth')
            try:
                self.platformAzimuth = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (platformAzimuth): %s' % exp)
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            try:
                self.width = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (width): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CenterBegin':
            obj_ = create_CenterBegin.factory()
            obj_.build(child_)
            self.set_CenterBegin(obj_)
            obj_.original_tagname_ = 'CenterBegin'
        elif nodeName_ == 'CenterEnd':
            obj_ = create_CenterEnd.factory()
            obj_.build(child_)
            self.set_CenterEnd(obj_)
            obj_.original_tagname_ = 'CenterEnd'
        elif nodeName_ == 'ControlPoint':
            obj_ = create_ControlPoint.factory()
            obj_.build(child_)
            self.set_ControlPoint(obj_)
            obj_.original_tagname_ = 'ControlPoint'
        elif nodeName_ == 'ImageParameters':
            obj_ = create_ImageParameters.factory()
            obj_.build(child_)
            self.set_ImageParameters(obj_)
            obj_.original_tagname_ = 'ImageParameters'
# end class create_calculatedSwath


class create_CenterBegin(GeneratedsSuper):
    """CenterBegin CenterBegin Y coordinate of the starting position of the
    LIDAR swath region Y coordinate of the starting position of the
    LIDAR swath region X coordinate of the starting position of the
    LIDAR swath region X coordinate of the starting position of the
    LIDAR swath region"""
    subclass = None
    superclass = None
    def __init__(self, y=20, x=5):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_CenterBegin")
        self.attrib = ['y', 'x']
        self.children = []
        self.parent = None
        self._y = _cast(float, y)
        self._x = _cast(float, x)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_CenterBegin)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_CenterBegin.subclass:
            return create_CenterBegin.subclass(*args_, **kwargs_)
        else:
            return create_CenterBegin(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_y(self): return self._y
    def set_y(self, value):
        self._y = value
        update_node(self,self.troot,"phase")
    y = property(get_y, set_y)
    def get_x(self): return self._x
    def set_x(self, value):
        self._x = value
        update_node(self,self.troot,"phase")
    x = property(get_x, set_x)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_CenterBegin', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_CenterBegin')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_CenterBegin')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_CenterBegin', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_CenterBegin'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y="%s"' % self.gds_format_double(self.y, input_name='y'))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name='x'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_CenterBegin', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_CenterBegin', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.y is not None:
            element.set('y', self.gds_format_double(self.y))
        if self.x is not None:
            element.set('x', self.gds_format_double(self.x))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_CenterBegin'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            showIndent(outfile, level)
            outfile.write('y=%e,\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            showIndent(outfile, level)
            outfile.write('x=%e,\n' % (self.x,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            try:
                self.y = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (y): %s' % exp)
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            try:
                self.x = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_CenterBegin


class create_CenterEnd(GeneratedsSuper):
    """CenterEnd CenterEnd Y coordinate of the finishing position of the
    LIDAR swath region Y coordinate of the finishing position of the
    LIDAR swath region X coordinate of the finishing position of the
    LIDAR swath region X coordinate of the finishing position of the
    LIDAR swath region"""
    subclass = None
    superclass = None
    def __init__(self, y=20, x=35):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_CenterEnd")
        self.attrib = ['y', 'x']
        self.children = []
        self.parent = None
        self._y = _cast(float, y)
        self._x = _cast(float, x)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_CenterEnd)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_CenterEnd.subclass:
            return create_CenterEnd.subclass(*args_, **kwargs_)
        else:
            return create_CenterEnd(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_y(self): return self._y
    def set_y(self, value):
        self._y = value
        update_node(self,self.troot,"phase")
    y = property(get_y, set_y)
    def get_x(self): return self._x
    def set_x(self, value):
        self._x = value
        update_node(self,self.troot,"phase")
    x = property(get_x, set_x)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_CenterEnd', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_CenterEnd')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_CenterEnd')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_CenterEnd', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_CenterEnd'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y="%s"' % self.gds_format_double(self.y, input_name='y'))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name='x'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_CenterEnd', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_CenterEnd', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.y is not None:
            element.set('y', self.gds_format_double(self.y))
        if self.x is not None:
            element.set('x', self.gds_format_double(self.x))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_CenterEnd'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            showIndent(outfile, level)
            outfile.write('y=%e,\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            showIndent(outfile, level)
            outfile.write('x=%e,\n' % (self.x,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            try:
                self.y = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (y): %s' % exp)
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            try:
                self.x = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_CenterEnd


class create_ControlPoint(GeneratedsSuper):
    """ControlPoint ControlPoint Mode of definition of the control point.
    Mode of definition of the control point."""
    subclass = None
    superclass = None
    def __init__(self, definition=1, PositionGround=None, CorrespondingParameters=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_ControlPoint")
        self.attrib = ['definition']
        self.children = ['PositionGround', 'CorrespondingParameters']
        self.parent = None
        self._definition = _cast(int, definition)
        self._PositionGround = PositionGround
        self._CorrespondingParameters = CorrespondingParameters
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ControlPoint)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ControlPoint.subclass:
            return create_ControlPoint.subclass(*args_, **kwargs_)
        else:
            return create_ControlPoint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PositionGround(self): return self._PositionGround
    def set_PositionGround(self, value):
        if value is not None:
            checkclass(value, create_PositionGround)
            value.parent = self
        self._PositionGround = value
    PositionGround = property(get_PositionGround, set_PositionGround)
    def get_CorrespondingParameters(self): return self._CorrespondingParameters
    def set_CorrespondingParameters(self, value):
        if value is not None:
            checkclass(value, create_CorrespondingParameters)
            value.parent = self
        self._CorrespondingParameters = value
    CorrespondingParameters = property(get_CorrespondingParameters, set_CorrespondingParameters)
    def get_definition(self): return self._definition
    def set_definition(self, value):
        self._definition = value
        update_node(self,self.troot,"phase")
    definition = property(get_definition, set_definition)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.PositionGround is not None or
            self.CorrespondingParameters is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ControlPoint', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ControlPoint')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ControlPoint')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ControlPoint', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ControlPoint'):
        if self.definition is not None and 'definition' not in already_processed:
            already_processed.add('definition')
            outfile.write(' definition="%s"' % self.gds_format_integer(self.definition, input_name='definition'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ControlPoint', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PositionGround is not None:
            self.PositionGround.export(outfile, level, namespaceprefix_, name_='PositionGround', pretty_print=pretty_print)
        if self.CorrespondingParameters is not None:
            self.CorrespondingParameters.export(outfile, level, namespaceprefix_, name_='CorrespondingParameters', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_ControlPoint', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.definition is not None:
            element.set('definition', self.gds_format_integer(self.definition))
        if self.PositionGround is not None:
            PositionGround_ = self.PositionGround
            PositionGround_.to_etree(element, name_='PositionGround', mapping_=mapping_)
        if self.CorrespondingParameters is not None:
            CorrespondingParameters_ = self.CorrespondingParameters
            CorrespondingParameters_.to_etree(element, name_='CorrespondingParameters', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ControlPoint'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.definition is not None and 'definition' not in already_processed:
            already_processed.add('definition')
            showIndent(outfile, level)
            outfile.write('definition=%d,\n' % (self.definition,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PositionGround is not None:
            showIndent(outfile, level)
            outfile.write('PositionGround=model_._PositionGround(\n')
            self.PositionGround.exportLiteral(outfile, level, name_='PositionGround')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CorrespondingParameters is not None:
            showIndent(outfile, level)
            outfile.write('CorrespondingParameters=model_._CorrespondingParameters(\n')
            self.CorrespondingParameters.exportLiteral(outfile, level, name_='CorrespondingParameters')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('definition', node)
        if value is not None and 'definition' not in already_processed:
            already_processed.add('definition')
            try:
                self.definition = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PositionGround':
            obj_ = create_PositionGround.factory()
            obj_.build(child_)
            self.set_PositionGround(obj_)
            obj_.original_tagname_ = 'PositionGround'
        elif nodeName_ == 'CorrespondingParameters':
            obj_ = create_CorrespondingParameters.factory()
            obj_.build(child_)
            self.set_CorrespondingParameters(obj_)
            obj_.original_tagname_ = 'CorrespondingParameters'
# end class create_ControlPoint


class create_PositionGround(GeneratedsSuper):
    """PositionGround PositionGround Y coordinate of the control point
    ground position Y coordinate of the control point ground
    position X coordinate of the control point ground position X
    coordinate of the control point ground position"""
    subclass = None
    superclass = None
    def __init__(self, y=20, x=20):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_PositionGround")
        self.attrib = ['y', 'x']
        self.children = []
        self.parent = None
        self._y = _cast(float, y)
        self._x = _cast(float, x)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_PositionGround)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_PositionGround.subclass:
            return create_PositionGround.subclass(*args_, **kwargs_)
        else:
            return create_PositionGround(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_y(self): return self._y
    def set_y(self, value):
        self._y = value
        update_node(self,self.troot,"phase")
    y = property(get_y, set_y)
    def get_x(self): return self._x
    def set_x(self, value):
        self._x = value
        update_node(self,self.troot,"phase")
    x = property(get_x, set_x)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_PositionGround', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_PositionGround')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_PositionGround')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_PositionGround', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_PositionGround'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y="%s"' % self.gds_format_double(self.y, input_name='y'))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name='x'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_PositionGround', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_PositionGround', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.y is not None:
            element.set('y', self.gds_format_double(self.y))
        if self.x is not None:
            element.set('x', self.gds_format_double(self.x))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_PositionGround'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            showIndent(outfile, level)
            outfile.write('y=%e,\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            showIndent(outfile, level)
            outfile.write('x=%e,\n' % (self.x,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            try:
                self.y = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (y): %s' % exp)
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            try:
                self.x = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_PositionGround


class create_CorrespondingParameters(GeneratedsSuper):
    """CorrespondingParameters CorrespondingParameters Look angle of the
    platform for the given control point Look angle of the platform
    for the given control point"""
    subclass = None
    superclass = None
    def __init__(self, lookAngle=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_CorrespondingParameters")
        self.attrib = ['lookAngle']
        self.children = []
        self.parent = None
        self._lookAngle = _cast(float, lookAngle)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_CorrespondingParameters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_CorrespondingParameters.subclass:
            return create_CorrespondingParameters.subclass(*args_, **kwargs_)
        else:
            return create_CorrespondingParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lookAngle(self): return self._lookAngle
    def set_lookAngle(self, value):
        self._lookAngle = value
        update_node(self,self.troot,"phase")
    lookAngle = property(get_lookAngle, set_lookAngle)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_CorrespondingParameters', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_CorrespondingParameters')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_CorrespondingParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_CorrespondingParameters', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_CorrespondingParameters'):
        if self.lookAngle is not None and 'lookAngle' not in already_processed:
            already_processed.add('lookAngle')
            outfile.write(' lookAngle="%s"' % self.gds_format_double(self.lookAngle, input_name='lookAngle'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_CorrespondingParameters', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_CorrespondingParameters', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.lookAngle is not None:
            element.set('lookAngle', self.gds_format_double(self.lookAngle))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_CorrespondingParameters'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lookAngle is not None and 'lookAngle' not in already_processed:
            already_processed.add('lookAngle')
            showIndent(outfile, level)
            outfile.write('lookAngle=%e,\n' % (self.lookAngle,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lookAngle', node)
        if value is not None and 'lookAngle' not in already_processed:
            already_processed.add('lookAngle')
            try:
                self.lookAngle = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (lookAngle): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_CorrespondingParameters


class create_ImageParameters(GeneratedsSuper):
    """ImageParameters ImageParameters Definition of the range (scanning
    axis) resolution. Definition of the range (scanning axis)
    resolution. Step on the scanning axis of the LIDAR. Step on the
    scanning axis of the LIDAR. Step on the movement axis of the
    LIDAR. Step on the movement axis of the LIDAR."""
    subclass = None
    superclass = None
    def __init__(self, rangeResolutionDef=1, resolutionRange=3, resolutionAzimuth=3):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_ImageParameters")
        self.attrib = ['rangeResolutionDef', 'resolutionRange', 'resolutionAzimuth']
        self.children = []
        self.parent = None
        self._rangeResolutionDef = _cast(int, rangeResolutionDef)
        self._resolutionRange = _cast(float, resolutionRange)
        self._resolutionAzimuth = _cast(float, resolutionAzimuth)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ImageParameters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ImageParameters.subclass:
            return create_ImageParameters.subclass(*args_, **kwargs_)
        else:
            return create_ImageParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rangeResolutionDef(self): return self._rangeResolutionDef
    def set_rangeResolutionDef(self, value):
        self._rangeResolutionDef = value
        update_node(self,self.troot,"phase")
    rangeResolutionDef = property(get_rangeResolutionDef, set_rangeResolutionDef)
    def get_resolutionRange(self): return self._resolutionRange
    def set_resolutionRange(self, value):
        self._resolutionRange = value
        update_node(self,self.troot,"phase")
    resolutionRange = property(get_resolutionRange, set_resolutionRange)
    def get_resolutionAzimuth(self): return self._resolutionAzimuth
    def set_resolutionAzimuth(self, value):
        self._resolutionAzimuth = value
        update_node(self,self.troot,"phase")
    resolutionAzimuth = property(get_resolutionAzimuth, set_resolutionAzimuth)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ImageParameters', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ImageParameters')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ImageParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ImageParameters', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ImageParameters'):
        if self.rangeResolutionDef is not None and 'rangeResolutionDef' not in already_processed:
            already_processed.add('rangeResolutionDef')
            outfile.write(' rangeResolutionDef="%s"' % self.gds_format_integer(self.rangeResolutionDef, input_name='rangeResolutionDef'))
        if self.resolutionRange is not None and 'resolutionRange' not in already_processed:
            already_processed.add('resolutionRange')
            outfile.write(' resolutionRange="%s"' % self.gds_format_double(self.resolutionRange, input_name='resolutionRange'))
        if self.resolutionAzimuth is not None and 'resolutionAzimuth' not in already_processed:
            already_processed.add('resolutionAzimuth')
            outfile.write(' resolutionAzimuth="%s"' % self.gds_format_double(self.resolutionAzimuth, input_name='resolutionAzimuth'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ImageParameters', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_ImageParameters', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.rangeResolutionDef is not None:
            element.set('rangeResolutionDef', self.gds_format_integer(self.rangeResolutionDef))
        if self.resolutionRange is not None:
            element.set('resolutionRange', self.gds_format_double(self.resolutionRange))
        if self.resolutionAzimuth is not None:
            element.set('resolutionAzimuth', self.gds_format_double(self.resolutionAzimuth))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ImageParameters'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.rangeResolutionDef is not None and 'rangeResolutionDef' not in already_processed:
            already_processed.add('rangeResolutionDef')
            showIndent(outfile, level)
            outfile.write('rangeResolutionDef=%d,\n' % (self.rangeResolutionDef,))
        if self.resolutionRange is not None and 'resolutionRange' not in already_processed:
            already_processed.add('resolutionRange')
            showIndent(outfile, level)
            outfile.write('resolutionRange=%e,\n' % (self.resolutionRange,))
        if self.resolutionAzimuth is not None and 'resolutionAzimuth' not in already_processed:
            already_processed.add('resolutionAzimuth')
            showIndent(outfile, level)
            outfile.write('resolutionAzimuth=%e,\n' % (self.resolutionAzimuth,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rangeResolutionDef', node)
        if value is not None and 'rangeResolutionDef' not in already_processed:
            already_processed.add('rangeResolutionDef')
            try:
                self.rangeResolutionDef = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('resolutionRange', node)
        if value is not None and 'resolutionRange' not in already_processed:
            already_processed.add('resolutionRange')
            try:
                self.resolutionRange = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (resolutionRange): %s' % exp)
        value = find_attr_value_('resolutionAzimuth', node)
        if value is not None and 'resolutionAzimuth' not in already_processed:
            already_processed.add('resolutionAzimuth')
            try:
                self.resolutionAzimuth = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (resolutionAzimuth): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_ImageParameters


class create_importedSwath(GeneratedsSuper):
    """Importation Importation The separated pulses file The separated
    pulses file"""
    subclass = None
    superclass = None
    def __init__(self, separatePulsesFile='pulses.txt', ApproximatedTrajectory=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_importedSwath")
        self.attrib = ['separatePulsesFile']
        self.children = ['ApproximatedTrajectory']
        self.parent = None
        self._separatePulsesFile = _cast(None, separatePulsesFile)
        self._ApproximatedTrajectory = ApproximatedTrajectory
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_importedSwath)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_importedSwath.subclass:
            return create_importedSwath.subclass(*args_, **kwargs_)
        else:
            return create_importedSwath(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ApproximatedTrajectory(self): return self._ApproximatedTrajectory
    def set_ApproximatedTrajectory(self, value):
        if value is not None:
            checkclass(value, create_ApproximatedTrajectory)
            value.parent = self
        self._ApproximatedTrajectory = value
    ApproximatedTrajectory = property(get_ApproximatedTrajectory, set_ApproximatedTrajectory)
    def get_separatePulsesFile(self): return self._separatePulsesFile
    def set_separatePulsesFile(self, value):
        self._separatePulsesFile = value
        update_node(self,self.troot,"phase")
    separatePulsesFile = property(get_separatePulsesFile, set_separatePulsesFile)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.ApproximatedTrajectory is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_importedSwath', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_importedSwath')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_importedSwath')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_importedSwath', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_importedSwath'):
        if self.separatePulsesFile is not None and 'separatePulsesFile' not in already_processed:
            already_processed.add('separatePulsesFile')
            outfile.write(' separatePulsesFile=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.separatePulsesFile), input_name='separatePulsesFile')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_importedSwath', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ApproximatedTrajectory is not None:
            self.ApproximatedTrajectory.export(outfile, level, namespaceprefix_, name_='ApproximatedTrajectory', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_importedSwath', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.separatePulsesFile is not None:
            element.set('separatePulsesFile', self.gds_format_string(self.separatePulsesFile))
        if self.ApproximatedTrajectory is not None:
            ApproximatedTrajectory_ = self.ApproximatedTrajectory
            ApproximatedTrajectory_.to_etree(element, name_='ApproximatedTrajectory', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_importedSwath'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.separatePulsesFile is not None and 'separatePulsesFile' not in already_processed:
            already_processed.add('separatePulsesFile')
            showIndent(outfile, level)
            outfile.write('separatePulsesFile="%s",\n' % (self.separatePulsesFile,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ApproximatedTrajectory is not None:
            showIndent(outfile, level)
            outfile.write('ApproximatedTrajectory=model_._ApproximatedTrajectory(\n')
            self.ApproximatedTrajectory.exportLiteral(outfile, level, name_='ApproximatedTrajectory')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('separatePulsesFile', node)
        if value is not None and 'separatePulsesFile' not in already_processed:
            already_processed.add('separatePulsesFile')
            self.separatePulsesFile = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ApproximatedTrajectory':
            obj_ = create_ApproximatedTrajectory.factory()
            obj_.build(child_)
            self.set_ApproximatedTrajectory(obj_)
            obj_.original_tagname_ = 'ApproximatedTrajectory'
# end class create_importedSwath


class create_ApproximatedTrajectory(GeneratedsSuper):
    """Approximated Trajectory Approximated Trajectory Acquisition azimuth
    angle relative to the plane perpendicular to the flight
    direction Acquisition azimuth angle relative to the plane
    perpendicular to the flight direction The azimuth angle that
    represent the platform moving direction The azimuth angle that
    represent the platform moving direction"""
    subclass = None
    superclass = None
    def __init__(self, platformAzimuth=0, platformDirection=0, Sensor=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_ApproximatedTrajectory")
        self.attrib = ['platformAzimuth', 'platformDirection']
        self.children = ['Sensor']
        self.parent = None
        self._platformAzimuth = _cast(float, platformAzimuth)
        self._platformDirection = _cast(float, platformDirection)
        self._Sensor = Sensor
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ApproximatedTrajectory)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ApproximatedTrajectory.subclass:
            return create_ApproximatedTrajectory.subclass(*args_, **kwargs_)
        else:
            return create_ApproximatedTrajectory(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Sensor(self): return self._Sensor
    def set_Sensor(self, value):
        if value is not None:
            checkclass(value, create_Sensor)
            value.parent = self
        self._Sensor = value
    Sensor = property(get_Sensor, set_Sensor)
    def get_platformAzimuth(self): return self._platformAzimuth
    def set_platformAzimuth(self, value):
        self._platformAzimuth = value
        update_node(self,self.troot,"phase")
    platformAzimuth = property(get_platformAzimuth, set_platformAzimuth)
    def get_platformDirection(self): return self._platformDirection
    def set_platformDirection(self, value):
        self._platformDirection = value
        update_node(self,self.troot,"phase")
    platformDirection = property(get_platformDirection, set_platformDirection)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Sensor is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ApproximatedTrajectory', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ApproximatedTrajectory')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ApproximatedTrajectory')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ApproximatedTrajectory', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ApproximatedTrajectory'):
        if self.platformAzimuth is not None and 'platformAzimuth' not in already_processed:
            already_processed.add('platformAzimuth')
            outfile.write(' platformAzimuth="%s"' % self.gds_format_double(self.platformAzimuth, input_name='platformAzimuth'))
        if self.platformDirection is not None and 'platformDirection' not in already_processed:
            already_processed.add('platformDirection')
            outfile.write(' platformDirection="%s"' % self.gds_format_double(self.platformDirection, input_name='platformDirection'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ApproximatedTrajectory', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Sensor is not None:
            self.Sensor.export(outfile, level, namespaceprefix_, name_='Sensor', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_ApproximatedTrajectory', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.platformAzimuth is not None:
            element.set('platformAzimuth', self.gds_format_double(self.platformAzimuth))
        if self.platformDirection is not None:
            element.set('platformDirection', self.gds_format_double(self.platformDirection))
        if self.Sensor is not None:
            Sensor_ = self.Sensor
            Sensor_.to_etree(element, name_='Sensor', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ApproximatedTrajectory'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.platformAzimuth is not None and 'platformAzimuth' not in already_processed:
            already_processed.add('platformAzimuth')
            showIndent(outfile, level)
            outfile.write('platformAzimuth=%e,\n' % (self.platformAzimuth,))
        if self.platformDirection is not None and 'platformDirection' not in already_processed:
            already_processed.add('platformDirection')
            showIndent(outfile, level)
            outfile.write('platformDirection=%e,\n' % (self.platformDirection,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Sensor is not None:
            showIndent(outfile, level)
            outfile.write('Sensor=model_._Sensor(\n')
            self.Sensor.exportLiteral(outfile, level, name_='Sensor')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('platformAzimuth', node)
        if value is not None and 'platformAzimuth' not in already_processed:
            already_processed.add('platformAzimuth')
            try:
                self.platformAzimuth = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (platformAzimuth): %s' % exp)
        value = find_attr_value_('platformDirection', node)
        if value is not None and 'platformDirection' not in already_processed:
            already_processed.add('platformDirection')
            try:
                self.platformDirection = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (platformDirection): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Sensor':
            obj_ = create_Sensor.factory()
            obj_.build(child_)
            self.set_Sensor(obj_)
            obj_.original_tagname_ = 'Sensor'
# end class create_ApproximatedTrajectory


class create_Sensor(GeneratedsSuper):
    """Sensor Sensor Z coordinate of sensor Z coordinate of sensor X
    coordinate of sensor X coordinate of sensor Y coordinate of
    sensor Y coordinate of sensor"""
    subclass = None
    superclass = None
    def __init__(self, sensorPosZ=1000, sensorPosX=0, sensorPosY=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_Sensor")
        self.attrib = ['sensorPosZ', 'sensorPosX', 'sensorPosY']
        self.children = []
        self.parent = None
        self._sensorPosZ = _cast(float, sensorPosZ)
        self._sensorPosX = _cast(float, sensorPosX)
        self._sensorPosY = _cast(float, sensorPosY)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Sensor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Sensor.subclass:
            return create_Sensor.subclass(*args_, **kwargs_)
        else:
            return create_Sensor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sensorPosZ(self): return self._sensorPosZ
    def set_sensorPosZ(self, value):
        self._sensorPosZ = value
        update_node(self,self.troot,"phase")
    sensorPosZ = property(get_sensorPosZ, set_sensorPosZ)
    def get_sensorPosX(self): return self._sensorPosX
    def set_sensorPosX(self, value):
        self._sensorPosX = value
        update_node(self,self.troot,"phase")
    sensorPosX = property(get_sensorPosX, set_sensorPosX)
    def get_sensorPosY(self): return self._sensorPosY
    def set_sensorPosY(self, value):
        self._sensorPosY = value
        update_node(self,self.troot,"phase")
    sensorPosY = property(get_sensorPosY, set_sensorPosY)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Sensor', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Sensor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Sensor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Sensor', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Sensor'):
        if self.sensorPosZ is not None and 'sensorPosZ' not in already_processed:
            already_processed.add('sensorPosZ')
            outfile.write(' sensorPosZ="%s"' % self.gds_format_double(self.sensorPosZ, input_name='sensorPosZ'))
        if self.sensorPosX is not None and 'sensorPosX' not in already_processed:
            already_processed.add('sensorPosX')
            outfile.write(' sensorPosX="%s"' % self.gds_format_double(self.sensorPosX, input_name='sensorPosX'))
        if self.sensorPosY is not None and 'sensorPosY' not in already_processed:
            already_processed.add('sensorPosY')
            outfile.write(' sensorPosY="%s"' % self.gds_format_double(self.sensorPosY, input_name='sensorPosY'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Sensor', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_Sensor', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.sensorPosZ is not None:
            element.set('sensorPosZ', self.gds_format_double(self.sensorPosZ))
        if self.sensorPosX is not None:
            element.set('sensorPosX', self.gds_format_double(self.sensorPosX))
        if self.sensorPosY is not None:
            element.set('sensorPosY', self.gds_format_double(self.sensorPosY))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Sensor'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sensorPosZ is not None and 'sensorPosZ' not in already_processed:
            already_processed.add('sensorPosZ')
            showIndent(outfile, level)
            outfile.write('sensorPosZ=%e,\n' % (self.sensorPosZ,))
        if self.sensorPosX is not None and 'sensorPosX' not in already_processed:
            already_processed.add('sensorPosX')
            showIndent(outfile, level)
            outfile.write('sensorPosX=%e,\n' % (self.sensorPosX,))
        if self.sensorPosY is not None and 'sensorPosY' not in already_processed:
            already_processed.add('sensorPosY')
            showIndent(outfile, level)
            outfile.write('sensorPosY=%e,\n' % (self.sensorPosY,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sensorPosZ', node)
        if value is not None and 'sensorPosZ' not in already_processed:
            already_processed.add('sensorPosZ')
            try:
                self.sensorPosZ = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sensorPosZ): %s' % exp)
        value = find_attr_value_('sensorPosX', node)
        if value is not None and 'sensorPosX' not in already_processed:
            already_processed.add('sensorPosX')
            try:
                self.sensorPosX = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sensorPosX): %s' % exp)
        value = find_attr_value_('sensorPosY', node)
        if value is not None and 'sensorPosY' not in already_processed:
            already_processed.add('sensorPosY')
            try:
                self.sensorPosY = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sensorPosY): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_Sensor


class create_TLS(GeneratedsSuper):
    """TLS TLS Lidar position (Y) Lidar position (Y) Lidar position (X)
    Lidar position (X) Lidar position (Z) Lidar position (Z)"""
    subclass = None
    superclass = None
    def __init__(self, lidarPosY=360.82, lidarPosX=360.82, lidarPosZ=10, TLSRegion=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_TLS")
        self.attrib = ['lidarPosY', 'lidarPosX', 'lidarPosZ']
        self.children = ['TLSRegion']
        self.parent = None
        self._lidarPosY = _cast(float, lidarPosY)
        self._lidarPosX = _cast(float, lidarPosX)
        self._lidarPosZ = _cast(float, lidarPosZ)
        self._TLSRegion = TLSRegion
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_TLS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_TLS.subclass:
            return create_TLS.subclass(*args_, **kwargs_)
        else:
            return create_TLS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TLSRegion(self): return self._TLSRegion
    def set_TLSRegion(self, value):
        if value is not None:
            checkclass(value, create_TLSRegion)
            value.parent = self
        self._TLSRegion = value
    TLSRegion = property(get_TLSRegion, set_TLSRegion)
    def get_lidarPosY(self): return self._lidarPosY
    def set_lidarPosY(self, value):
        self._lidarPosY = value
        update_node(self,self.troot,"phase")
    lidarPosY = property(get_lidarPosY, set_lidarPosY)
    def get_lidarPosX(self): return self._lidarPosX
    def set_lidarPosX(self, value):
        self._lidarPosX = value
        update_node(self,self.troot,"phase")
    lidarPosX = property(get_lidarPosX, set_lidarPosX)
    def get_lidarPosZ(self): return self._lidarPosZ
    def set_lidarPosZ(self, value):
        self._lidarPosZ = value
        update_node(self,self.troot,"phase")
    lidarPosZ = property(get_lidarPosZ, set_lidarPosZ)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.TLSRegion is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_TLS', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_TLS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_TLS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_TLS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_TLS'):
        if self.lidarPosY is not None and 'lidarPosY' not in already_processed:
            already_processed.add('lidarPosY')
            outfile.write(' lidarPosY="%s"' % self.gds_format_double(self.lidarPosY, input_name='lidarPosY'))
        if self.lidarPosX is not None and 'lidarPosX' not in already_processed:
            already_processed.add('lidarPosX')
            outfile.write(' lidarPosX="%s"' % self.gds_format_double(self.lidarPosX, input_name='lidarPosX'))
        if self.lidarPosZ is not None and 'lidarPosZ' not in already_processed:
            already_processed.add('lidarPosZ')
            outfile.write(' lidarPosZ="%s"' % self.gds_format_double(self.lidarPosZ, input_name='lidarPosZ'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_TLS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TLSRegion is not None:
            self.TLSRegion.export(outfile, level, namespaceprefix_, name_='TLSRegion', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_TLS', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.lidarPosY is not None:
            element.set('lidarPosY', self.gds_format_double(self.lidarPosY))
        if self.lidarPosX is not None:
            element.set('lidarPosX', self.gds_format_double(self.lidarPosX))
        if self.lidarPosZ is not None:
            element.set('lidarPosZ', self.gds_format_double(self.lidarPosZ))
        if self.TLSRegion is not None:
            TLSRegion_ = self.TLSRegion
            TLSRegion_.to_etree(element, name_='TLSRegion', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_TLS'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lidarPosY is not None and 'lidarPosY' not in already_processed:
            already_processed.add('lidarPosY')
            showIndent(outfile, level)
            outfile.write('lidarPosY=%e,\n' % (self.lidarPosY,))
        if self.lidarPosX is not None and 'lidarPosX' not in already_processed:
            already_processed.add('lidarPosX')
            showIndent(outfile, level)
            outfile.write('lidarPosX=%e,\n' % (self.lidarPosX,))
        if self.lidarPosZ is not None and 'lidarPosZ' not in already_processed:
            already_processed.add('lidarPosZ')
            showIndent(outfile, level)
            outfile.write('lidarPosZ=%e,\n' % (self.lidarPosZ,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TLSRegion is not None:
            showIndent(outfile, level)
            outfile.write('TLSRegion=model_._TLSRegion(\n')
            self.TLSRegion.exportLiteral(outfile, level, name_='TLSRegion')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lidarPosY', node)
        if value is not None and 'lidarPosY' not in already_processed:
            already_processed.add('lidarPosY')
            try:
                self.lidarPosY = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (lidarPosY): %s' % exp)
        value = find_attr_value_('lidarPosX', node)
        if value is not None and 'lidarPosX' not in already_processed:
            already_processed.add('lidarPosX')
            try:
                self.lidarPosX = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (lidarPosX): %s' % exp)
        value = find_attr_value_('lidarPosZ', node)
        if value is not None and 'lidarPosZ' not in already_processed:
            already_processed.add('lidarPosZ')
            try:
                self.lidarPosZ = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (lidarPosZ): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TLSRegion':
            obj_ = create_TLSRegion.factory()
            obj_.build(child_)
            self.set_TLSRegion(obj_)
            obj_.original_tagname_ = 'TLSRegion'
# end class create_TLS


class create_TLSRegion(GeneratedsSuper):
    """TLS Region TLS Region Import a separated pulse file Import a
    separated pulse file"""
    subclass = None
    superclass = None
    def __init__(self, isSeparatePulsesImport=0, terresScanRange=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_TLSRegion")
        self.attrib = ['isSeparatePulsesImport']
        self.children = ['terresScanRange']
        self.parent = None
        self._isSeparatePulsesImport = _cast(int, isSeparatePulsesImport)
        self._terresScanRange = terresScanRange
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_TLSRegion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_TLSRegion.subclass:
            return create_TLSRegion.subclass(*args_, **kwargs_)
        else:
            return create_TLSRegion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_terresScanRange(self): return self._terresScanRange
    def set_terresScanRange(self, value):
        if value is not None:
            checkclass(value, create_terresScanRange)
            value.parent = self
        self._terresScanRange = value
    terresScanRange = property(get_terresScanRange, set_terresScanRange)
    def get_isSeparatePulsesImport(self): return self._isSeparatePulsesImport
    def set_isSeparatePulsesImport(self, value):
        self._isSeparatePulsesImport = value
        update_node(self,self.troot,"phase")
    isSeparatePulsesImport = property(get_isSeparatePulsesImport, set_isSeparatePulsesImport)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.terresScanRange is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_TLSRegion', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_TLSRegion')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_TLSRegion')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_TLSRegion', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_TLSRegion'):
        if self.isSeparatePulsesImport is not None and 'isSeparatePulsesImport' not in already_processed:
            already_processed.add('isSeparatePulsesImport')
            outfile.write(' isSeparatePulsesImport="%s"' % self.gds_format_integer(self.isSeparatePulsesImport, input_name='isSeparatePulsesImport'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_TLSRegion', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.terresScanRange is not None:
            self.terresScanRange.export(outfile, level, namespaceprefix_, name_='terresScanRange', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_TLSRegion', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.isSeparatePulsesImport is not None:
            element.set('isSeparatePulsesImport', self.gds_format_integer(self.isSeparatePulsesImport))
        if self.terresScanRange is not None:
            terresScanRange_ = self.terresScanRange
            terresScanRange_.to_etree(element, name_='terresScanRange', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_TLSRegion'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isSeparatePulsesImport is not None and 'isSeparatePulsesImport' not in already_processed:
            already_processed.add('isSeparatePulsesImport')
            showIndent(outfile, level)
            outfile.write('isSeparatePulsesImport=%d,\n' % (self.isSeparatePulsesImport,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.terresScanRange is not None:
            showIndent(outfile, level)
            outfile.write('terresScanRange=model_._terresScanRange(\n')
            self.terresScanRange.exportLiteral(outfile, level, name_='terresScanRange')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isSeparatePulsesImport', node)
        if value is not None and 'isSeparatePulsesImport' not in already_processed:
            already_processed.add('isSeparatePulsesImport')
            try:
                self.isSeparatePulsesImport = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'terresScanRange':
            obj_ = create_terresScanRange.factory()
            obj_.build(child_)
            self.set_terresScanRange(obj_)
            obj_.original_tagname_ = 'terresScanRange'
# end class create_TLSRegion


class create_terresScanRange(GeneratedsSuper):
    """terresScanRange terresScanRange Zenithal range of acquisition.
    Zenithal range of acquisition. The grid of acquisition is (Delta
    zenith x Delta azimuth) / (Resolution zenith x Resolution
    azimuth) The grid of acquisition is (Delta zenith x Delta
    azimuth) / (Resolution zenith x Resolution azimuth) In degrees.
    The direction is defined from the target to the TLS.\n0deg
    points toward the South in the 2D view. In degrees. The
    direction is defined from the target to the TLS.\n0deg points
    toward the South in the 2D view. The grid of acquisition is
    (Delta zenith x Delta azimuth) / (Resolution zenith x Resolution
    azimuth) The grid of acquisition is (Delta zenith x Delta
    azimuth) / (Resolution zenith x Resolution azimuth) In degrees.
    The direction is defined from the target to the TLS.\n0deg goes
    verticaly upward. In degrees. The direction is defined from the
    target to the TLS.\n0deg goes verticaly upward. Azimuthal range
    of acquisition. Azimuthal range of acquisition."""
    subclass = None
    superclass = None
    def __init__(self, deltaTheta=10, resPhi=1, centerPhi=45, resTheta=1, centerTheta=90, deltaPhi=10):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_terresScanRange")
        self.attrib = ['deltaTheta', 'resPhi', 'centerPhi', 'resTheta', 'centerTheta', 'deltaPhi']
        self.children = []
        self.parent = None
        self._deltaTheta = _cast(float, deltaTheta)
        self._resPhi = _cast(float, resPhi)
        self._centerPhi = _cast(float, centerPhi)
        self._resTheta = _cast(float, resTheta)
        self._centerTheta = _cast(float, centerTheta)
        self._deltaPhi = _cast(float, deltaPhi)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_terresScanRange)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_terresScanRange.subclass:
            return create_terresScanRange.subclass(*args_, **kwargs_)
        else:
            return create_terresScanRange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deltaTheta(self): return self._deltaTheta
    def set_deltaTheta(self, value):
        self._deltaTheta = value
        update_node(self,self.troot,"phase")
    deltaTheta = property(get_deltaTheta, set_deltaTheta)
    def get_resPhi(self): return self._resPhi
    def set_resPhi(self, value):
        self._resPhi = value
        update_node(self,self.troot,"phase")
    resPhi = property(get_resPhi, set_resPhi)
    def get_centerPhi(self): return self._centerPhi
    def set_centerPhi(self, value):
        self._centerPhi = value
        update_node(self,self.troot,"phase")
    centerPhi = property(get_centerPhi, set_centerPhi)
    def get_resTheta(self): return self._resTheta
    def set_resTheta(self, value):
        self._resTheta = value
        update_node(self,self.troot,"phase")
    resTheta = property(get_resTheta, set_resTheta)
    def get_centerTheta(self): return self._centerTheta
    def set_centerTheta(self, value):
        self._centerTheta = value
        update_node(self,self.troot,"phase")
    centerTheta = property(get_centerTheta, set_centerTheta)
    def get_deltaPhi(self): return self._deltaPhi
    def set_deltaPhi(self, value):
        self._deltaPhi = value
        update_node(self,self.troot,"phase")
    deltaPhi = property(get_deltaPhi, set_deltaPhi)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_terresScanRange', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_terresScanRange')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_terresScanRange')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_terresScanRange', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_terresScanRange'):
        if self.deltaTheta is not None and 'deltaTheta' not in already_processed:
            already_processed.add('deltaTheta')
            outfile.write(' deltaTheta="%s"' % self.gds_format_double(self.deltaTheta, input_name='deltaTheta'))
        if self.resPhi is not None and 'resPhi' not in already_processed:
            already_processed.add('resPhi')
            outfile.write(' resPhi="%s"' % self.gds_format_double(self.resPhi, input_name='resPhi'))
        if self.centerPhi is not None and 'centerPhi' not in already_processed:
            already_processed.add('centerPhi')
            outfile.write(' centerPhi="%s"' % self.gds_format_double(self.centerPhi, input_name='centerPhi'))
        if self.resTheta is not None and 'resTheta' not in already_processed:
            already_processed.add('resTheta')
            outfile.write(' resTheta="%s"' % self.gds_format_double(self.resTheta, input_name='resTheta'))
        if self.centerTheta is not None and 'centerTheta' not in already_processed:
            already_processed.add('centerTheta')
            outfile.write(' centerTheta="%s"' % self.gds_format_double(self.centerTheta, input_name='centerTheta'))
        if self.deltaPhi is not None and 'deltaPhi' not in already_processed:
            already_processed.add('deltaPhi')
            outfile.write(' deltaPhi="%s"' % self.gds_format_double(self.deltaPhi, input_name='deltaPhi'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_terresScanRange', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_terresScanRange', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.deltaTheta is not None:
            element.set('deltaTheta', self.gds_format_double(self.deltaTheta))
        if self.resPhi is not None:
            element.set('resPhi', self.gds_format_double(self.resPhi))
        if self.centerPhi is not None:
            element.set('centerPhi', self.gds_format_double(self.centerPhi))
        if self.resTheta is not None:
            element.set('resTheta', self.gds_format_double(self.resTheta))
        if self.centerTheta is not None:
            element.set('centerTheta', self.gds_format_double(self.centerTheta))
        if self.deltaPhi is not None:
            element.set('deltaPhi', self.gds_format_double(self.deltaPhi))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_terresScanRange'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.deltaTheta is not None and 'deltaTheta' not in already_processed:
            already_processed.add('deltaTheta')
            showIndent(outfile, level)
            outfile.write('deltaTheta=%e,\n' % (self.deltaTheta,))
        if self.resPhi is not None and 'resPhi' not in already_processed:
            already_processed.add('resPhi')
            showIndent(outfile, level)
            outfile.write('resPhi=%e,\n' % (self.resPhi,))
        if self.centerPhi is not None and 'centerPhi' not in already_processed:
            already_processed.add('centerPhi')
            showIndent(outfile, level)
            outfile.write('centerPhi=%e,\n' % (self.centerPhi,))
        if self.resTheta is not None and 'resTheta' not in already_processed:
            already_processed.add('resTheta')
            showIndent(outfile, level)
            outfile.write('resTheta=%e,\n' % (self.resTheta,))
        if self.centerTheta is not None and 'centerTheta' not in already_processed:
            already_processed.add('centerTheta')
            showIndent(outfile, level)
            outfile.write('centerTheta=%e,\n' % (self.centerTheta,))
        if self.deltaPhi is not None and 'deltaPhi' not in already_processed:
            already_processed.add('deltaPhi')
            showIndent(outfile, level)
            outfile.write('deltaPhi=%e,\n' % (self.deltaPhi,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('deltaTheta', node)
        if value is not None and 'deltaTheta' not in already_processed:
            already_processed.add('deltaTheta')
            try:
                self.deltaTheta = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (deltaTheta): %s' % exp)
        value = find_attr_value_('resPhi', node)
        if value is not None and 'resPhi' not in already_processed:
            already_processed.add('resPhi')
            try:
                self.resPhi = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (resPhi): %s' % exp)
        value = find_attr_value_('centerPhi', node)
        if value is not None and 'centerPhi' not in already_processed:
            already_processed.add('centerPhi')
            try:
                self.centerPhi = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (centerPhi): %s' % exp)
        value = find_attr_value_('resTheta', node)
        if value is not None and 'resTheta' not in already_processed:
            already_processed.add('resTheta')
            try:
                self.resTheta = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (resTheta): %s' % exp)
        value = find_attr_value_('centerTheta', node)
        if value is not None and 'centerTheta' not in already_processed:
            already_processed.add('centerTheta')
            try:
                self.centerTheta = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (centerTheta): %s' % exp)
        value = find_attr_value_('deltaPhi', node)
        if value is not None and 'deltaPhi' not in already_processed:
            already_processed.add('deltaPhi')
            try:
                self.deltaPhi = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (deltaPhi): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_terresScanRange


class create_LidarIlluminationIntensity(GeneratedsSuper):
    """LidarIlluminationIntensity LidarIlluminationIntensity Import a pulse
    file Import a pulse file It's used to compute the standard
    deviation of the LIDAR intensity Gaussian spatial distribution.
    It's used to compute the standard deviation of the LIDAR
    intensity Gaussian spatial distribution. The threshold of the
    minimum number of photons per subcenter. If the number assigned
    to a subcenter is less than this threshold, the weight of photon
    in this subcenter will be reduced in order to keep the photon
    number at the threshold. The threshold of the minimum number of
    photons per subcenter. If the number assigned to a subcenter is
    less than this threshold, the weight of photon in this subcenter
    will be reduced in order to keep the photon number at the
    threshold. -LIDAR: approximate number of photons emitted by the
    LIDAR\n-Monte Carlo: number of photons emitted per illumination
    cell. -LIDAR: approximate number of photons emitted by the
    LIDAR\n-Monte Carlo: number of photons emitted per illumination
    cell. shortAxisSubdivitionIllum shortAxisSubdivitionIllum"""
    subclass = None
    superclass = None
    def __init__(self, isImportedPulse=0, gaussian_sigma_illu=0.368, minNoPhotonPerSubCenter=5, numberofPhotons=100000, shortAxisSubdivitionIllum=100, ImportedPulse=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_LidarIlluminationIntensity")
        self.attrib = ['isImportedPulse', 'gaussian_sigma_illu', 'minNoPhotonPerSubCenter', 'numberofPhotons', 'shortAxisSubdivitionIllum']
        self.children = ['ImportedPulse']
        self.parent = None
        self._isImportedPulse = _cast(int, isImportedPulse)
        self._gaussian_sigma_illu = _cast(float, gaussian_sigma_illu)
        self._minNoPhotonPerSubCenter = _cast(int, minNoPhotonPerSubCenter)
        self._numberofPhotons = _cast(int, numberofPhotons)
        self._shortAxisSubdivitionIllum = _cast(int, shortAxisSubdivitionIllum)
        self._ImportedPulse = ImportedPulse
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_LidarIlluminationIntensity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_LidarIlluminationIntensity.subclass:
            return create_LidarIlluminationIntensity.subclass(*args_, **kwargs_)
        else:
            return create_LidarIlluminationIntensity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ImportedPulse(self): return self._ImportedPulse
    def set_ImportedPulse(self, value):
        if value is not None:
            checkclass(value, create_ImportedPulse)
            value.parent = self
        self._ImportedPulse = value
    ImportedPulse = property(get_ImportedPulse, set_ImportedPulse)
    def get_isImportedPulse(self): return self._isImportedPulse
    def set_isImportedPulse(self, value):
        self._isImportedPulse = value
        update_node(self,self.troot,"phase")
    isImportedPulse = property(get_isImportedPulse, set_isImportedPulse)
    def get_gaussian_sigma_illu(self): return self._gaussian_sigma_illu
    def set_gaussian_sigma_illu(self, value):
        self._gaussian_sigma_illu = value
        update_node(self,self.troot,"phase")
    gaussian_sigma_illu = property(get_gaussian_sigma_illu, set_gaussian_sigma_illu)
    def get_minNoPhotonPerSubCenter(self): return self._minNoPhotonPerSubCenter
    def set_minNoPhotonPerSubCenter(self, value):
        self._minNoPhotonPerSubCenter = value
        update_node(self,self.troot,"phase")
    minNoPhotonPerSubCenter = property(get_minNoPhotonPerSubCenter, set_minNoPhotonPerSubCenter)
    def get_numberofPhotons(self): return self._numberofPhotons
    def set_numberofPhotons(self, value):
        self._numberofPhotons = value
        update_node(self,self.troot,"phase")
    numberofPhotons = property(get_numberofPhotons, set_numberofPhotons)
    def get_shortAxisSubdivitionIllum(self): return self._shortAxisSubdivitionIllum
    def set_shortAxisSubdivitionIllum(self, value):
        self._shortAxisSubdivitionIllum = value
        update_node(self,self.troot,"phase")
    shortAxisSubdivitionIllum = property(get_shortAxisSubdivitionIllum, set_shortAxisSubdivitionIllum)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.ImportedPulse is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_LidarIlluminationIntensity', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_LidarIlluminationIntensity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_LidarIlluminationIntensity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_LidarIlluminationIntensity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_LidarIlluminationIntensity'):
        if self.isImportedPulse is not None and 'isImportedPulse' not in already_processed:
            already_processed.add('isImportedPulse')
            outfile.write(' isImportedPulse="%s"' % self.gds_format_integer(self.isImportedPulse, input_name='isImportedPulse'))
        if self.gaussian_sigma_illu is not None and 'gaussian_sigma_illu' not in already_processed:
            already_processed.add('gaussian_sigma_illu')
            outfile.write(' gaussian_sigma_illu="%s"' % self.gds_format_double(self.gaussian_sigma_illu, input_name='gaussian_sigma_illu'))
        if self.minNoPhotonPerSubCenter is not None and 'minNoPhotonPerSubCenter' not in already_processed:
            already_processed.add('minNoPhotonPerSubCenter')
            outfile.write(' minNoPhotonPerSubCenter="%s"' % self.gds_format_integer(self.minNoPhotonPerSubCenter, input_name='minNoPhotonPerSubCenter'))
        if self.numberofPhotons is not None and 'numberofPhotons' not in already_processed:
            already_processed.add('numberofPhotons')
            outfile.write(' numberofPhotons="%s"' % self.gds_format_integer(self.numberofPhotons, input_name='numberofPhotons'))
        if self.shortAxisSubdivitionIllum is not None and 'shortAxisSubdivitionIllum' not in already_processed:
            already_processed.add('shortAxisSubdivitionIllum')
            outfile.write(' shortAxisSubdivitionIllum="%s"' % self.gds_format_integer(self.shortAxisSubdivitionIllum, input_name='shortAxisSubdivitionIllum'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_LidarIlluminationIntensity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ImportedPulse is not None:
            self.ImportedPulse.export(outfile, level, namespaceprefix_, name_='ImportedPulse', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_LidarIlluminationIntensity', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.isImportedPulse is not None:
            element.set('isImportedPulse', self.gds_format_integer(self.isImportedPulse))
        if self.gaussian_sigma_illu is not None:
            element.set('gaussian_sigma_illu', self.gds_format_double(self.gaussian_sigma_illu))
        if self.minNoPhotonPerSubCenter is not None:
            element.set('minNoPhotonPerSubCenter', self.gds_format_integer(self.minNoPhotonPerSubCenter))
        if self.numberofPhotons is not None:
            element.set('numberofPhotons', self.gds_format_integer(self.numberofPhotons))
        if self.shortAxisSubdivitionIllum is not None:
            element.set('shortAxisSubdivitionIllum', self.gds_format_integer(self.shortAxisSubdivitionIllum))
        if self.ImportedPulse is not None:
            ImportedPulse_ = self.ImportedPulse
            ImportedPulse_.to_etree(element, name_='ImportedPulse', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_LidarIlluminationIntensity'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isImportedPulse is not None and 'isImportedPulse' not in already_processed:
            already_processed.add('isImportedPulse')
            showIndent(outfile, level)
            outfile.write('isImportedPulse=%d,\n' % (self.isImportedPulse,))
        if self.gaussian_sigma_illu is not None and 'gaussian_sigma_illu' not in already_processed:
            already_processed.add('gaussian_sigma_illu')
            showIndent(outfile, level)
            outfile.write('gaussian_sigma_illu=%e,\n' % (self.gaussian_sigma_illu,))
        if self.minNoPhotonPerSubCenter is not None and 'minNoPhotonPerSubCenter' not in already_processed:
            already_processed.add('minNoPhotonPerSubCenter')
            showIndent(outfile, level)
            outfile.write('minNoPhotonPerSubCenter=%d,\n' % (self.minNoPhotonPerSubCenter,))
        if self.numberofPhotons is not None and 'numberofPhotons' not in already_processed:
            already_processed.add('numberofPhotons')
            showIndent(outfile, level)
            outfile.write('numberofPhotons=%d,\n' % (self.numberofPhotons,))
        if self.shortAxisSubdivitionIllum is not None and 'shortAxisSubdivitionIllum' not in already_processed:
            already_processed.add('shortAxisSubdivitionIllum')
            showIndent(outfile, level)
            outfile.write('shortAxisSubdivitionIllum=%d,\n' % (self.shortAxisSubdivitionIllum,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ImportedPulse is not None:
            showIndent(outfile, level)
            outfile.write('ImportedPulse=model_._ImportedPulse(\n')
            self.ImportedPulse.exportLiteral(outfile, level, name_='ImportedPulse')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isImportedPulse', node)
        if value is not None and 'isImportedPulse' not in already_processed:
            already_processed.add('isImportedPulse')
            try:
                self.isImportedPulse = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('gaussian_sigma_illu', node)
        if value is not None and 'gaussian_sigma_illu' not in already_processed:
            already_processed.add('gaussian_sigma_illu')
            try:
                self.gaussian_sigma_illu = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (gaussian_sigma_illu): %s' % exp)
        value = find_attr_value_('minNoPhotonPerSubCenter', node)
        if value is not None and 'minNoPhotonPerSubCenter' not in already_processed:
            already_processed.add('minNoPhotonPerSubCenter')
            try:
                self.minNoPhotonPerSubCenter = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('numberofPhotons', node)
        if value is not None and 'numberofPhotons' not in already_processed:
            already_processed.add('numberofPhotons')
            try:
                self.numberofPhotons = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('shortAxisSubdivitionIllum', node)
        if value is not None and 'shortAxisSubdivitionIllum' not in already_processed:
            already_processed.add('shortAxisSubdivitionIllum')
            try:
                self.shortAxisSubdivitionIllum = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ImportedPulse':
            obj_ = create_ImportedPulse.factory()
            obj_.build(child_)
            self.set_ImportedPulse(obj_)
            obj_.original_tagname_ = 'ImportedPulse'
# end class create_LidarIlluminationIntensity


class create_ImportedPulse(GeneratedsSuper):
    """ImportedPulse ImportedPulse Impulse file Impulse file Resolution of
    the matrix Resolution of the matrix Offset on the X axis Offset
    on the X axis Offset on the Y axis Offset on the Y axis"""
    subclass = None
    superclass = None
    def __init__(self, pulseFile='impulseFile.txt', resolution=1.0, offsetX=0.0, offsetY=0.0):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_ImportedPulse")
        self.attrib = ['pulseFile', 'resolution', 'offsetX', 'offsetY']
        self.children = []
        self.parent = None
        self._pulseFile = _cast(None, pulseFile)
        self._resolution = _cast(float, resolution)
        self._offsetX = _cast(float, offsetX)
        self._offsetY = _cast(float, offsetY)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ImportedPulse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ImportedPulse.subclass:
            return create_ImportedPulse.subclass(*args_, **kwargs_)
        else:
            return create_ImportedPulse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pulseFile(self): return self._pulseFile
    def set_pulseFile(self, value):
        self._pulseFile = value
        update_node(self,self.troot,"phase")
    pulseFile = property(get_pulseFile, set_pulseFile)
    def get_resolution(self): return self._resolution
    def set_resolution(self, value):
        self._resolution = value
        update_node(self,self.troot,"phase")
    resolution = property(get_resolution, set_resolution)
    def get_offsetX(self): return self._offsetX
    def set_offsetX(self, value):
        self._offsetX = value
        update_node(self,self.troot,"phase")
    offsetX = property(get_offsetX, set_offsetX)
    def get_offsetY(self): return self._offsetY
    def set_offsetY(self, value):
        self._offsetY = value
        update_node(self,self.troot,"phase")
    offsetY = property(get_offsetY, set_offsetY)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ImportedPulse', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ImportedPulse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ImportedPulse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ImportedPulse', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ImportedPulse'):
        if self.pulseFile is not None and 'pulseFile' not in already_processed:
            already_processed.add('pulseFile')
            outfile.write(' pulseFile=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.pulseFile), input_name='pulseFile')), ))
        if self.resolution is not None and 'resolution' not in already_processed:
            already_processed.add('resolution')
            outfile.write(' resolution="%s"' % self.gds_format_double(self.resolution, input_name='resolution'))
        if self.offsetX is not None and 'offsetX' not in already_processed:
            already_processed.add('offsetX')
            outfile.write(' offsetX="%s"' % self.gds_format_double(self.offsetX, input_name='offsetX'))
        if self.offsetY is not None and 'offsetY' not in already_processed:
            already_processed.add('offsetY')
            outfile.write(' offsetY="%s"' % self.gds_format_double(self.offsetY, input_name='offsetY'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ImportedPulse', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_ImportedPulse', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.pulseFile is not None:
            element.set('pulseFile', self.gds_format_string(self.pulseFile))
        if self.resolution is not None:
            element.set('resolution', self.gds_format_double(self.resolution))
        if self.offsetX is not None:
            element.set('offsetX', self.gds_format_double(self.offsetX))
        if self.offsetY is not None:
            element.set('offsetY', self.gds_format_double(self.offsetY))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ImportedPulse'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.pulseFile is not None and 'pulseFile' not in already_processed:
            already_processed.add('pulseFile')
            showIndent(outfile, level)
            outfile.write('pulseFile="%s",\n' % (self.pulseFile,))
        if self.resolution is not None and 'resolution' not in already_processed:
            already_processed.add('resolution')
            showIndent(outfile, level)
            outfile.write('resolution=%e,\n' % (self.resolution,))
        if self.offsetX is not None and 'offsetX' not in already_processed:
            already_processed.add('offsetX')
            showIndent(outfile, level)
            outfile.write('offsetX=%e,\n' % (self.offsetX,))
        if self.offsetY is not None and 'offsetY' not in already_processed:
            already_processed.add('offsetY')
            showIndent(outfile, level)
            outfile.write('offsetY=%e,\n' % (self.offsetY,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pulseFile', node)
        if value is not None and 'pulseFile' not in already_processed:
            already_processed.add('pulseFile')
            self.pulseFile = value
        value = find_attr_value_('resolution', node)
        if value is not None and 'resolution' not in already_processed:
            already_processed.add('resolution')
            try:
                self.resolution = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (resolution): %s' % exp)
        value = find_attr_value_('offsetX', node)
        if value is not None and 'offsetX' not in already_processed:
            already_processed.add('offsetX')
            try:
                self.offsetX = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (offsetX): %s' % exp)
        value = find_attr_value_('offsetY', node)
        if value is not None and 'offsetY' not in already_processed:
            already_processed.add('offsetY')
            try:
                self.offsetY = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (offsetY): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_ImportedPulse


class create_LidarAcquisitionParameters(GeneratedsSuper):
    """LidarAcquisitionParameters LidarAcquisitionParameters If this box is
    checked, successive LIDAR and Monte Carlo simulations give the
    same results. If this box is checked, successive LIDAR and Monte
    Carlo simulations give the same results. If a photon reach the
    maximum order of scattering + 1, it is considered lost If a
    photon reach the maximum order of scattering + 1, it is
    considered lost If checked the signal will be cut from first
    non-empty bin to last non-empty bin. If not, the signal length
    is defined by Maximum and Minimum stored distance If checked the
    signal will be cut from first non-empty bin to last non-empty
    bin. If not, the signal length is defined by Maximum and Minimum
    stored distance Duration of each measurement. A 1ns duration
    corresponds to a path of 30cm, which, at NADIR and for
    scattering order 1, corresponds to a 15cm altitude difference.
    Duration of each measurement. A 1ns duration corresponds to a
    path of 30cm, which, at NADIR and for scattering order 1,
    corresponds to a 15cm altitude difference. This information is
    used for a better management of RAM This information is used for
    a better management of RAM"""
    subclass = None
    superclass = None
    def __init__(self, DART_simulation_identical=0, maximumScatteringOrder=10, LIDAR_filter=0, freq_recepteur_signal_LIDAR=1, calculatorMaximumRAM=1000):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_LidarAcquisitionParameters")
        self.attrib = ['DART_simulation_identical', 'maximumScatteringOrder', 'LIDAR_filter', 'freq_recepteur_signal_LIDAR', 'calculatorMaximumRAM']
        self.children = []
        self.parent = None
        self._DART_simulation_identical = _cast(int, DART_simulation_identical)
        self._maximumScatteringOrder = _cast(int, maximumScatteringOrder)
        self._LIDAR_filter = _cast(int, LIDAR_filter)
        self._freq_recepteur_signal_LIDAR = _cast(float, freq_recepteur_signal_LIDAR)
        self._calculatorMaximumRAM = _cast(int, calculatorMaximumRAM)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_LidarAcquisitionParameters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_LidarAcquisitionParameters.subclass:
            return create_LidarAcquisitionParameters.subclass(*args_, **kwargs_)
        else:
            return create_LidarAcquisitionParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DART_simulation_identical(self): return self._DART_simulation_identical
    def set_DART_simulation_identical(self, value):
        self._DART_simulation_identical = value
        update_node(self,self.troot,"phase")
    DART_simulation_identical = property(get_DART_simulation_identical, set_DART_simulation_identical)
    def get_maximumScatteringOrder(self): return self._maximumScatteringOrder
    def set_maximumScatteringOrder(self, value):
        self._maximumScatteringOrder = value
        update_node(self,self.troot,"phase")
    maximumScatteringOrder = property(get_maximumScatteringOrder, set_maximumScatteringOrder)
    def get_LIDAR_filter(self): return self._LIDAR_filter
    def set_LIDAR_filter(self, value):
        self._LIDAR_filter = value
        update_node(self,self.troot,"phase")
    LIDAR_filter = property(get_LIDAR_filter, set_LIDAR_filter)
    def get_freq_recepteur_signal_LIDAR(self): return self._freq_recepteur_signal_LIDAR
    def set_freq_recepteur_signal_LIDAR(self, value):
        self._freq_recepteur_signal_LIDAR = value
        update_node(self,self.troot,"phase")
    freq_recepteur_signal_LIDAR = property(get_freq_recepteur_signal_LIDAR, set_freq_recepteur_signal_LIDAR)
    def get_calculatorMaximumRAM(self): return self._calculatorMaximumRAM
    def set_calculatorMaximumRAM(self, value):
        self._calculatorMaximumRAM = value
        update_node(self,self.troot,"phase")
    calculatorMaximumRAM = property(get_calculatorMaximumRAM, set_calculatorMaximumRAM)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_LidarAcquisitionParameters', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_LidarAcquisitionParameters')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_LidarAcquisitionParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_LidarAcquisitionParameters', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_LidarAcquisitionParameters'):
        if self.DART_simulation_identical is not None and 'DART_simulation_identical' not in already_processed:
            already_processed.add('DART_simulation_identical')
            outfile.write(' DART_simulation_identical="%s"' % self.gds_format_integer(self.DART_simulation_identical, input_name='DART_simulation_identical'))
        if self.maximumScatteringOrder is not None and 'maximumScatteringOrder' not in already_processed:
            already_processed.add('maximumScatteringOrder')
            outfile.write(' maximumScatteringOrder="%s"' % self.gds_format_integer(self.maximumScatteringOrder, input_name='maximumScatteringOrder'))
        if self.LIDAR_filter is not None and 'LIDAR_filter' not in already_processed:
            already_processed.add('LIDAR_filter')
            outfile.write(' LIDAR_filter="%s"' % self.gds_format_integer(self.LIDAR_filter, input_name='LIDAR_filter'))
        if self.freq_recepteur_signal_LIDAR is not None and 'freq_recepteur_signal_LIDAR' not in already_processed:
            already_processed.add('freq_recepteur_signal_LIDAR')
            outfile.write(' freq_recepteur_signal_LIDAR="%s"' % self.gds_format_double(self.freq_recepteur_signal_LIDAR, input_name='freq_recepteur_signal_LIDAR'))
        if self.calculatorMaximumRAM is not None and 'calculatorMaximumRAM' not in already_processed:
            already_processed.add('calculatorMaximumRAM')
            outfile.write(' calculatorMaximumRAM="%s"' % self.gds_format_integer(self.calculatorMaximumRAM, input_name='calculatorMaximumRAM'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_LidarAcquisitionParameters', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_LidarAcquisitionParameters', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.DART_simulation_identical is not None:
            element.set('DART_simulation_identical', self.gds_format_integer(self.DART_simulation_identical))
        if self.maximumScatteringOrder is not None:
            element.set('maximumScatteringOrder', self.gds_format_integer(self.maximumScatteringOrder))
        if self.LIDAR_filter is not None:
            element.set('LIDAR_filter', self.gds_format_integer(self.LIDAR_filter))
        if self.freq_recepteur_signal_LIDAR is not None:
            element.set('freq_recepteur_signal_LIDAR', self.gds_format_double(self.freq_recepteur_signal_LIDAR))
        if self.calculatorMaximumRAM is not None:
            element.set('calculatorMaximumRAM', self.gds_format_integer(self.calculatorMaximumRAM))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_LidarAcquisitionParameters'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DART_simulation_identical is not None and 'DART_simulation_identical' not in already_processed:
            already_processed.add('DART_simulation_identical')
            showIndent(outfile, level)
            outfile.write('DART_simulation_identical=%d,\n' % (self.DART_simulation_identical,))
        if self.maximumScatteringOrder is not None and 'maximumScatteringOrder' not in already_processed:
            already_processed.add('maximumScatteringOrder')
            showIndent(outfile, level)
            outfile.write('maximumScatteringOrder=%d,\n' % (self.maximumScatteringOrder,))
        if self.LIDAR_filter is not None and 'LIDAR_filter' not in already_processed:
            already_processed.add('LIDAR_filter')
            showIndent(outfile, level)
            outfile.write('LIDAR_filter=%d,\n' % (self.LIDAR_filter,))
        if self.freq_recepteur_signal_LIDAR is not None and 'freq_recepteur_signal_LIDAR' not in already_processed:
            already_processed.add('freq_recepteur_signal_LIDAR')
            showIndent(outfile, level)
            outfile.write('freq_recepteur_signal_LIDAR=%e,\n' % (self.freq_recepteur_signal_LIDAR,))
        if self.calculatorMaximumRAM is not None and 'calculatorMaximumRAM' not in already_processed:
            already_processed.add('calculatorMaximumRAM')
            showIndent(outfile, level)
            outfile.write('calculatorMaximumRAM=%d,\n' % (self.calculatorMaximumRAM,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DART_simulation_identical', node)
        if value is not None and 'DART_simulation_identical' not in already_processed:
            already_processed.add('DART_simulation_identical')
            try:
                self.DART_simulation_identical = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('maximumScatteringOrder', node)
        if value is not None and 'maximumScatteringOrder' not in already_processed:
            already_processed.add('maximumScatteringOrder')
            try:
                self.maximumScatteringOrder = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('LIDAR_filter', node)
        if value is not None and 'LIDAR_filter' not in already_processed:
            already_processed.add('LIDAR_filter')
            try:
                self.LIDAR_filter = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('freq_recepteur_signal_LIDAR', node)
        if value is not None and 'freq_recepteur_signal_LIDAR' not in already_processed:
            already_processed.add('freq_recepteur_signal_LIDAR')
            try:
                self.freq_recepteur_signal_LIDAR = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (freq_recepteur_signal_LIDAR): %s' % exp)
        value = find_attr_value_('calculatorMaximumRAM', node)
        if value is not None and 'calculatorMaximumRAM' not in already_processed:
            already_processed.add('calculatorMaximumRAM')
            try:
                self.calculatorMaximumRAM = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_LidarAcquisitionParameters


class create_SpectralIntervals(GeneratedsSuper):
    """Spectral intervals Spectral intervals"""
    subclass = None
    superclass = None
    def __init__(self, SpectralIntervalsProperties=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_SpectralIntervals")
        self.attrib = ['']
        self.children = ['SpectralIntervalsProperties']
        self.parent = None
        if SpectralIntervalsProperties is None:
            self._SpectralIntervalsProperties = []
        else:
            self._SpectralIntervalsProperties = SpectralIntervalsProperties
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_SpectralIntervals)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_SpectralIntervals.subclass:
            return create_SpectralIntervals.subclass(*args_, **kwargs_)
        else:
            return create_SpectralIntervals(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SpectralIntervalsProperties(self): return self._SpectralIntervalsProperties
    def set_SpectralIntervalsProperties(self, value):
        if value is not None:
            checkclass(value, create_SpectralIntervalsProperties)
            for v in value:
                v.parent = self
        self._SpectralIntervalsProperties = value
    def add_SpectralIntervalsProperties(self, value):
        value.parent = self
        self._SpectralIntervalsProperties.append(value)
    def insert_SpectralIntervalsProperties_at(self, index, value):
        value.parent = self
        self.SpectralIntervalsProperties.insert(index, value)
    def replace_SpectralIntervalsProperties_at(self, index, value):
        value.parent = self
        self.SpectralIntervalsProperties[index] = value
    SpectralIntervalsProperties = property(get_SpectralIntervalsProperties, set_SpectralIntervalsProperties)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.SpectralIntervalsProperties
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_SpectralIntervals', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_SpectralIntervals')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_SpectralIntervals')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_SpectralIntervals', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_SpectralIntervals'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_SpectralIntervals', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SpectralIntervalsProperties_ in self.SpectralIntervalsProperties:
            SpectralIntervalsProperties_.export(outfile, level, namespaceprefix_, name_='SpectralIntervalsProperties', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_SpectralIntervals', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for SpectralIntervalsProperties_ in self.SpectralIntervalsProperties:
            SpectralIntervalsProperties_.to_etree(element, name_='SpectralIntervalsProperties', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_SpectralIntervals'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('SpectralIntervalsProperties=[\n')
        level += 1
        for SpectralIntervalsProperties_ in self.SpectralIntervalsProperties:
            showIndent(outfile, level)
            outfile.write('model_._SpectralIntervalsProperties(\n')
            SpectralIntervalsProperties_.exportLiteral(outfile, level, name_='_SpectralIntervalsProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.SpectralIntervalsProperties = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SpectralIntervalsProperties':
            obj_ = create_SpectralIntervalsProperties.factory()
            obj_.build(child_)
            self.add_SpectralIntervalsProperties(obj_)
            obj_.original_tagname_ = 'SpectralIntervalsProperties'
# end class create_SpectralIntervals


class create_SpectralIntervalsProperties(GeneratedsSuper):
    """SpectralIntervalsProperties SpectralIntervalsProperties Central
    wavelength Central wavelength 0 for first band)\nBe sure that
    the spectral band number corresponds in modus operandi and in
    LUT generator ! 0 for first band)\nBe sure that the spectral
    band number corresponds in modus operandi and in LUT generator !
    -Mode R : \nSource: Sun, results: Reflectance \n\n-Mode
    R+T:\nSource: Sun + thermal emission, Results: brightness
    temperature\n\n-Mode T:\nSource : thermal emission, Results :
    brightness temperature -Mode R : \nSource: Sun, results:
    Reflectance \n\n-Mode R+T:\nSource: Sun + thermal emission,
    Results: brightness temperature\n\n-Mode T:\nSource : thermal
    emission, Results : brightness temperature Bandwidth Bandwidth"""
    subclass = None
    superclass = None
    def __init__(self, meanLambda=0.56, bandNumber=0, spectralDartMode=0, deltaLambda=0.02, emissionLawNode=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_SpectralIntervalsProperties")
        self.attrib = ['meanLambda', 'bandNumber', 'spectralDartMode', 'deltaLambda']
        self.children = ['emissionLawNode']
        self.parent = None
        self._meanLambda = _cast(float, meanLambda)
        self._bandNumber = _cast(int, bandNumber)
        self._spectralDartMode = _cast(int, spectralDartMode)
        self._deltaLambda = _cast(float, deltaLambda)
        self._emissionLawNode = emissionLawNode
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_SpectralIntervalsProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_SpectralIntervalsProperties.subclass:
            return create_SpectralIntervalsProperties.subclass(*args_, **kwargs_)
        else:
            return create_SpectralIntervalsProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_emissionLawNode(self): return self._emissionLawNode
    def set_emissionLawNode(self, value):
        if value is not None:
            checkclass(value, create_emissionLawNode)
            value.parent = self
        self._emissionLawNode = value
    emissionLawNode = property(get_emissionLawNode, set_emissionLawNode)
    def get_meanLambda(self): return self._meanLambda
    def set_meanLambda(self, value):
        self._meanLambda = value
        update_node(self,self.troot,"phase")
    meanLambda = property(get_meanLambda, set_meanLambda)
    def get_bandNumber(self): return self._bandNumber
    def set_bandNumber(self, value):
        self._bandNumber = value
        update_node(self,self.troot,"phase")
    bandNumber = property(get_bandNumber, set_bandNumber)
    def get_spectralDartMode(self): return self._spectralDartMode
    def set_spectralDartMode(self, value):
        self._spectralDartMode = value
        update_node(self,self.troot,"phase")
    spectralDartMode = property(get_spectralDartMode, set_spectralDartMode)
    def get_deltaLambda(self): return self._deltaLambda
    def set_deltaLambda(self, value):
        self._deltaLambda = value
        update_node(self,self.troot,"phase")
    deltaLambda = property(get_deltaLambda, set_deltaLambda)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.emissionLawNode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_SpectralIntervalsProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_SpectralIntervalsProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_SpectralIntervalsProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_SpectralIntervalsProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_SpectralIntervalsProperties'):
        if self.meanLambda is not None and 'meanLambda' not in already_processed:
            already_processed.add('meanLambda')
            outfile.write(' meanLambda="%s"' % self.gds_format_double(self.meanLambda, input_name='meanLambda'))
        if self.bandNumber is not None and 'bandNumber' not in already_processed:
            already_processed.add('bandNumber')
            outfile.write(' bandNumber="%s"' % self.gds_format_integer(self.bandNumber, input_name='bandNumber'))
        if self.spectralDartMode is not None and 'spectralDartMode' not in already_processed:
            already_processed.add('spectralDartMode')
            outfile.write(' spectralDartMode="%s"' % self.gds_format_integer(self.spectralDartMode, input_name='spectralDartMode'))
        if self.deltaLambda is not None and 'deltaLambda' not in already_processed:
            already_processed.add('deltaLambda')
            outfile.write(' deltaLambda="%s"' % self.gds_format_double(self.deltaLambda, input_name='deltaLambda'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_SpectralIntervalsProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.emissionLawNode is not None:
            self.emissionLawNode.export(outfile, level, namespaceprefix_, name_='emissionLawNode', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_SpectralIntervalsProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.meanLambda is not None:
            element.set('meanLambda', self.gds_format_double(self.meanLambda))
        if self.bandNumber is not None:
            element.set('bandNumber', self.gds_format_integer(self.bandNumber))
        if self.spectralDartMode is not None:
            element.set('spectralDartMode', self.gds_format_integer(self.spectralDartMode))
        if self.deltaLambda is not None:
            element.set('deltaLambda', self.gds_format_double(self.deltaLambda))
        if self.emissionLawNode is not None:
            emissionLawNode_ = self.emissionLawNode
            emissionLawNode_.to_etree(element, name_='emissionLawNode', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_SpectralIntervalsProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.meanLambda is not None and 'meanLambda' not in already_processed:
            already_processed.add('meanLambda')
            showIndent(outfile, level)
            outfile.write('meanLambda=%e,\n' % (self.meanLambda,))
        if self.bandNumber is not None and 'bandNumber' not in already_processed:
            already_processed.add('bandNumber')
            showIndent(outfile, level)
            outfile.write('bandNumber=%d,\n' % (self.bandNumber,))
        if self.spectralDartMode is not None and 'spectralDartMode' not in already_processed:
            already_processed.add('spectralDartMode')
            showIndent(outfile, level)
            outfile.write('spectralDartMode=%d,\n' % (self.spectralDartMode,))
        if self.deltaLambda is not None and 'deltaLambda' not in already_processed:
            already_processed.add('deltaLambda')
            showIndent(outfile, level)
            outfile.write('deltaLambda=%e,\n' % (self.deltaLambda,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.emissionLawNode is not None:
            showIndent(outfile, level)
            outfile.write('emissionLawNode=model_._emissionLawNode(\n')
            self.emissionLawNode.exportLiteral(outfile, level, name_='emissionLawNode')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('meanLambda', node)
        if value is not None and 'meanLambda' not in already_processed:
            already_processed.add('meanLambda')
            try:
                self.meanLambda = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (meanLambda): %s' % exp)
        value = find_attr_value_('bandNumber', node)
        if value is not None and 'bandNumber' not in already_processed:
            already_processed.add('bandNumber')
            try:
                self.bandNumber = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('spectralDartMode', node)
        if value is not None and 'spectralDartMode' not in already_processed:
            already_processed.add('spectralDartMode')
            try:
                self.spectralDartMode = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('deltaLambda', node)
        if value is not None and 'deltaLambda' not in already_processed:
            already_processed.add('deltaLambda')
            try:
                self.deltaLambda = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (deltaLambda): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'emissionLawNode':
            obj_ = create_emissionLawNode.factory()
            obj_.build(child_)
            self.set_emissionLawNode(obj_)
            obj_.original_tagname_ = 'emissionLawNode'
# end class create_SpectralIntervalsProperties


class create_emissionLawNode(GeneratedsSuper):
    """emissionLawNode emissionLawNode Thermal emission : Planck integrated
    on 1000 steps or Boltzmann (sigma*T^4) (in that case, the
    spectral band is only used to compute optical properties)
    Thermal emission : Planck integrated on 1000 steps or Boltzmann
    (sigma*T^4) (in that case, the spectral band is only used to
    compute optical properties)"""
    subclass = None
    superclass = None
    def __init__(self, emissionLaw=1):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_emissionLawNode")
        self.attrib = ['emissionLaw']
        self.children = []
        self.parent = None
        self._emissionLaw = _cast(int, emissionLaw)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_emissionLawNode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_emissionLawNode.subclass:
            return create_emissionLawNode.subclass(*args_, **kwargs_)
        else:
            return create_emissionLawNode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_emissionLaw(self): return self._emissionLaw
    def set_emissionLaw(self, value):
        self._emissionLaw = value
        update_node(self,self.troot,"phase")
    emissionLaw = property(get_emissionLaw, set_emissionLaw)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_emissionLawNode', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_emissionLawNode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_emissionLawNode')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_emissionLawNode', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_emissionLawNode'):
        if self.emissionLaw is not None and 'emissionLaw' not in already_processed:
            already_processed.add('emissionLaw')
            outfile.write(' emissionLaw="%s"' % self.gds_format_integer(self.emissionLaw, input_name='emissionLaw'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_emissionLawNode', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_emissionLawNode', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.emissionLaw is not None:
            element.set('emissionLaw', self.gds_format_integer(self.emissionLaw))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_emissionLawNode'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.emissionLaw is not None and 'emissionLaw' not in already_processed:
            already_processed.add('emissionLaw')
            showIndent(outfile, level)
            outfile.write('emissionLaw=%d,\n' % (self.emissionLaw,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('emissionLaw', node)
        if value is not None and 'emissionLaw' not in already_processed:
            already_processed.add('emissionLaw')
            try:
                self.emissionLaw = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_emissionLawNode


class create_ImageSideIllumination(GeneratedsSuper):
    """Disable thermal emission. Disable thermal emission. Use precomputed
    side illumination in order to simulate environnement effect. Use
    precomputed side illumination in order to simulate environnement
    effect. Disable solar illumination. Both direct and diffuse.
    Disable solar illumination. Both direct and diffuse."""
    subclass = None
    superclass = None
    def __init__(self, disableThermalEmission=0, sideIlluminationEnabled=0, disableSolarIllumination=0, TopSide=None, BottomSide=None, RightSide=None, LeftSide=None, FrontSide=None, BackSide=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_ImageSideIllumination")
        self.attrib = ['disableThermalEmission', 'sideIlluminationEnabled', 'disableSolarIllumination']
        self.children = ['TopSide', 'BottomSide', 'RightSide', 'LeftSide', 'FrontSide', 'BackSide']
        self.parent = None
        self._disableThermalEmission = _cast(int, disableThermalEmission)
        self._sideIlluminationEnabled = _cast(int, sideIlluminationEnabled)
        self._disableSolarIllumination = _cast(int, disableSolarIllumination)
        self._TopSide = TopSide
        self._BottomSide = BottomSide
        self._RightSide = RightSide
        self._LeftSide = LeftSide
        self._FrontSide = FrontSide
        self._BackSide = BackSide
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ImageSideIllumination)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ImageSideIllumination.subclass:
            return create_ImageSideIllumination.subclass(*args_, **kwargs_)
        else:
            return create_ImageSideIllumination(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TopSide(self): return self._TopSide
    def set_TopSide(self, value):
        if value is not None:
            checkclass(value, create_TopSide)
            value.parent = self
        self._TopSide = value
    TopSide = property(get_TopSide, set_TopSide)
    def get_BottomSide(self): return self._BottomSide
    def set_BottomSide(self, value):
        if value is not None:
            checkclass(value, create_BottomSide)
            value.parent = self
        self._BottomSide = value
    BottomSide = property(get_BottomSide, set_BottomSide)
    def get_RightSide(self): return self._RightSide
    def set_RightSide(self, value):
        if value is not None:
            checkclass(value, create_RightSide)
            value.parent = self
        self._RightSide = value
    RightSide = property(get_RightSide, set_RightSide)
    def get_LeftSide(self): return self._LeftSide
    def set_LeftSide(self, value):
        if value is not None:
            checkclass(value, create_LeftSide)
            value.parent = self
        self._LeftSide = value
    LeftSide = property(get_LeftSide, set_LeftSide)
    def get_FrontSide(self): return self._FrontSide
    def set_FrontSide(self, value):
        if value is not None:
            checkclass(value, create_FrontSide)
            value.parent = self
        self._FrontSide = value
    FrontSide = property(get_FrontSide, set_FrontSide)
    def get_BackSide(self): return self._BackSide
    def set_BackSide(self, value):
        if value is not None:
            checkclass(value, create_BackSide)
            value.parent = self
        self._BackSide = value
    BackSide = property(get_BackSide, set_BackSide)
    def get_disableThermalEmission(self): return self._disableThermalEmission
    def set_disableThermalEmission(self, value):
        self._disableThermalEmission = value
        update_node(self,self.troot,"phase")
    disableThermalEmission = property(get_disableThermalEmission, set_disableThermalEmission)
    def get_sideIlluminationEnabled(self): return self._sideIlluminationEnabled
    def set_sideIlluminationEnabled(self, value):
        self._sideIlluminationEnabled = value
        update_node(self,self.troot,"phase")
    sideIlluminationEnabled = property(get_sideIlluminationEnabled, set_sideIlluminationEnabled)
    def get_disableSolarIllumination(self): return self._disableSolarIllumination
    def set_disableSolarIllumination(self, value):
        self._disableSolarIllumination = value
        update_node(self,self.troot,"phase")
    disableSolarIllumination = property(get_disableSolarIllumination, set_disableSolarIllumination)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.TopSide is not None or
            self.BottomSide is not None or
            self.RightSide is not None or
            self.LeftSide is not None or
            self.FrontSide is not None or
            self.BackSide is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ImageSideIllumination', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ImageSideIllumination')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ImageSideIllumination')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ImageSideIllumination', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ImageSideIllumination'):
        if self.disableThermalEmission is not None and 'disableThermalEmission' not in already_processed:
            already_processed.add('disableThermalEmission')
            outfile.write(' disableThermalEmission="%s"' % self.gds_format_integer(self.disableThermalEmission, input_name='disableThermalEmission'))
        if self.sideIlluminationEnabled is not None and 'sideIlluminationEnabled' not in already_processed:
            already_processed.add('sideIlluminationEnabled')
            outfile.write(' sideIlluminationEnabled="%s"' % self.gds_format_integer(self.sideIlluminationEnabled, input_name='sideIlluminationEnabled'))
        if self.disableSolarIllumination is not None and 'disableSolarIllumination' not in already_processed:
            already_processed.add('disableSolarIllumination')
            outfile.write(' disableSolarIllumination="%s"' % self.gds_format_integer(self.disableSolarIllumination, input_name='disableSolarIllumination'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ImageSideIllumination', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TopSide is not None:
            self.TopSide.export(outfile, level, namespaceprefix_, name_='TopSide', pretty_print=pretty_print)
        if self.BottomSide is not None:
            self.BottomSide.export(outfile, level, namespaceprefix_, name_='BottomSide', pretty_print=pretty_print)
        if self.RightSide is not None:
            self.RightSide.export(outfile, level, namespaceprefix_, name_='RightSide', pretty_print=pretty_print)
        if self.LeftSide is not None:
            self.LeftSide.export(outfile, level, namespaceprefix_, name_='LeftSide', pretty_print=pretty_print)
        if self.FrontSide is not None:
            self.FrontSide.export(outfile, level, namespaceprefix_, name_='FrontSide', pretty_print=pretty_print)
        if self.BackSide is not None:
            self.BackSide.export(outfile, level, namespaceprefix_, name_='BackSide', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_ImageSideIllumination', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.disableThermalEmission is not None:
            element.set('disableThermalEmission', self.gds_format_integer(self.disableThermalEmission))
        if self.sideIlluminationEnabled is not None:
            element.set('sideIlluminationEnabled', self.gds_format_integer(self.sideIlluminationEnabled))
        if self.disableSolarIllumination is not None:
            element.set('disableSolarIllumination', self.gds_format_integer(self.disableSolarIllumination))
        if self.TopSide is not None:
            TopSide_ = self.TopSide
            TopSide_.to_etree(element, name_='TopSide', mapping_=mapping_)
        if self.BottomSide is not None:
            BottomSide_ = self.BottomSide
            BottomSide_.to_etree(element, name_='BottomSide', mapping_=mapping_)
        if self.RightSide is not None:
            RightSide_ = self.RightSide
            RightSide_.to_etree(element, name_='RightSide', mapping_=mapping_)
        if self.LeftSide is not None:
            LeftSide_ = self.LeftSide
            LeftSide_.to_etree(element, name_='LeftSide', mapping_=mapping_)
        if self.FrontSide is not None:
            FrontSide_ = self.FrontSide
            FrontSide_.to_etree(element, name_='FrontSide', mapping_=mapping_)
        if self.BackSide is not None:
            BackSide_ = self.BackSide
            BackSide_.to_etree(element, name_='BackSide', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ImageSideIllumination'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.disableThermalEmission is not None and 'disableThermalEmission' not in already_processed:
            already_processed.add('disableThermalEmission')
            showIndent(outfile, level)
            outfile.write('disableThermalEmission=%d,\n' % (self.disableThermalEmission,))
        if self.sideIlluminationEnabled is not None and 'sideIlluminationEnabled' not in already_processed:
            already_processed.add('sideIlluminationEnabled')
            showIndent(outfile, level)
            outfile.write('sideIlluminationEnabled=%d,\n' % (self.sideIlluminationEnabled,))
        if self.disableSolarIllumination is not None and 'disableSolarIllumination' not in already_processed:
            already_processed.add('disableSolarIllumination')
            showIndent(outfile, level)
            outfile.write('disableSolarIllumination=%d,\n' % (self.disableSolarIllumination,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TopSide is not None:
            showIndent(outfile, level)
            outfile.write('TopSide=model_._TopSide(\n')
            self.TopSide.exportLiteral(outfile, level, name_='TopSide')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BottomSide is not None:
            showIndent(outfile, level)
            outfile.write('BottomSide=model_._BottomSide(\n')
            self.BottomSide.exportLiteral(outfile, level, name_='BottomSide')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RightSide is not None:
            showIndent(outfile, level)
            outfile.write('RightSide=model_._RightSide(\n')
            self.RightSide.exportLiteral(outfile, level, name_='RightSide')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LeftSide is not None:
            showIndent(outfile, level)
            outfile.write('LeftSide=model_._LeftSide(\n')
            self.LeftSide.exportLiteral(outfile, level, name_='LeftSide')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FrontSide is not None:
            showIndent(outfile, level)
            outfile.write('FrontSide=model_._FrontSide(\n')
            self.FrontSide.exportLiteral(outfile, level, name_='FrontSide')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BackSide is not None:
            showIndent(outfile, level)
            outfile.write('BackSide=model_._BackSide(\n')
            self.BackSide.exportLiteral(outfile, level, name_='BackSide')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('disableThermalEmission', node)
        if value is not None and 'disableThermalEmission' not in already_processed:
            already_processed.add('disableThermalEmission')
            try:
                self.disableThermalEmission = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('sideIlluminationEnabled', node)
        if value is not None and 'sideIlluminationEnabled' not in already_processed:
            already_processed.add('sideIlluminationEnabled')
            try:
                self.sideIlluminationEnabled = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('disableSolarIllumination', node)
        if value is not None and 'disableSolarIllumination' not in already_processed:
            already_processed.add('disableSolarIllumination')
            try:
                self.disableSolarIllumination = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TopSide':
            obj_ = create_TopSide.factory()
            obj_.build(child_)
            self.set_TopSide(obj_)
            obj_.original_tagname_ = 'TopSide'
        elif nodeName_ == 'BottomSide':
            obj_ = create_BottomSide.factory()
            obj_.build(child_)
            self.set_BottomSide(obj_)
            obj_.original_tagname_ = 'BottomSide'
        elif nodeName_ == 'RightSide':
            obj_ = create_RightSide.factory()
            obj_.build(child_)
            self.set_RightSide(obj_)
            obj_.original_tagname_ = 'RightSide'
        elif nodeName_ == 'LeftSide':
            obj_ = create_LeftSide.factory()
            obj_.build(child_)
            self.set_LeftSide(obj_)
            obj_.original_tagname_ = 'LeftSide'
        elif nodeName_ == 'FrontSide':
            obj_ = create_FrontSide.factory()
            obj_.build(child_)
            self.set_FrontSide(obj_)
            obj_.original_tagname_ = 'FrontSide'
        elif nodeName_ == 'BackSide':
            obj_ = create_BackSide.factory()
            obj_.build(child_)
            self.set_BackSide(obj_)
            obj_.original_tagname_ = 'BackSide'
# end class create_ImageSideIllumination


class create_TopSide(GeneratedsSuper):
    """Provide precomputed illumination file, as generated by the "Store
    exiting energy" option. Provide precomputed illumination file,
    as generated by the "Store exiting energy" option. Store exiting
    energy on this side. Generates a binary file containing images
    per exiting direction. Store exiting energy on this side.
    Generates a binary file containing images per exiting direction.
    Disable connection on the other side in repetitive or infinite
    slope mode. If a ray exit on this side, it is stopped regarless
    of the other options. Disable connection on the other side in
    repetitive or infinite slope mode. If a ray exit on this side,
    it is stopped regarless of the other options."""
    subclass = None
    superclass = None
    def __init__(self, provideIllumination=0, storeExitingEnergy=0, disableOtherSideConnection=0, SideIlluminationFile=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_TopSide")
        self.attrib = ['provideIllumination', 'storeExitingEnergy', 'disableOtherSideConnection']
        self.children = ['SideIlluminationFile']
        self.parent = None
        self._provideIllumination = _cast(int, provideIllumination)
        self._storeExitingEnergy = _cast(int, storeExitingEnergy)
        self._disableOtherSideConnection = _cast(int, disableOtherSideConnection)
        self._SideIlluminationFile = SideIlluminationFile
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_TopSide)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_TopSide.subclass:
            return create_TopSide.subclass(*args_, **kwargs_)
        else:
            return create_TopSide(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SideIlluminationFile(self): return self._SideIlluminationFile
    def set_SideIlluminationFile(self, value):
        if value is not None:
            checkclass(value, create_SideIlluminationFile)
            value.parent = self
        self._SideIlluminationFile = value
    SideIlluminationFile = property(get_SideIlluminationFile, set_SideIlluminationFile)
    def get_provideIllumination(self): return self._provideIllumination
    def set_provideIllumination(self, value):
        self._provideIllumination = value
        update_node(self,self.troot,"phase")
    provideIllumination = property(get_provideIllumination, set_provideIllumination)
    def get_storeExitingEnergy(self): return self._storeExitingEnergy
    def set_storeExitingEnergy(self, value):
        self._storeExitingEnergy = value
        update_node(self,self.troot,"phase")
    storeExitingEnergy = property(get_storeExitingEnergy, set_storeExitingEnergy)
    def get_disableOtherSideConnection(self): return self._disableOtherSideConnection
    def set_disableOtherSideConnection(self, value):
        self._disableOtherSideConnection = value
        update_node(self,self.troot,"phase")
    disableOtherSideConnection = property(get_disableOtherSideConnection, set_disableOtherSideConnection)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.SideIlluminationFile is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_TopSide', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_TopSide')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_TopSide')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_TopSide', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_TopSide'):
        if self.provideIllumination is not None and 'provideIllumination' not in already_processed:
            already_processed.add('provideIllumination')
            outfile.write(' provideIllumination="%s"' % self.gds_format_integer(self.provideIllumination, input_name='provideIllumination'))
        if self.storeExitingEnergy is not None and 'storeExitingEnergy' not in already_processed:
            already_processed.add('storeExitingEnergy')
            outfile.write(' storeExitingEnergy="%s"' % self.gds_format_integer(self.storeExitingEnergy, input_name='storeExitingEnergy'))
        if self.disableOtherSideConnection is not None and 'disableOtherSideConnection' not in already_processed:
            already_processed.add('disableOtherSideConnection')
            outfile.write(' disableOtherSideConnection="%s"' % self.gds_format_integer(self.disableOtherSideConnection, input_name='disableOtherSideConnection'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_TopSide', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SideIlluminationFile is not None:
            self.SideIlluminationFile.export(outfile, level, namespaceprefix_, name_='SideIlluminationFile', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_TopSide', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.provideIllumination is not None:
            element.set('provideIllumination', self.gds_format_integer(self.provideIllumination))
        if self.storeExitingEnergy is not None:
            element.set('storeExitingEnergy', self.gds_format_integer(self.storeExitingEnergy))
        if self.disableOtherSideConnection is not None:
            element.set('disableOtherSideConnection', self.gds_format_integer(self.disableOtherSideConnection))
        if self.SideIlluminationFile is not None:
            SideIlluminationFile_ = self.SideIlluminationFile
            SideIlluminationFile_.to_etree(element, name_='SideIlluminationFile', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_TopSide'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.provideIllumination is not None and 'provideIllumination' not in already_processed:
            already_processed.add('provideIllumination')
            showIndent(outfile, level)
            outfile.write('provideIllumination=%d,\n' % (self.provideIllumination,))
        if self.storeExitingEnergy is not None and 'storeExitingEnergy' not in already_processed:
            already_processed.add('storeExitingEnergy')
            showIndent(outfile, level)
            outfile.write('storeExitingEnergy=%d,\n' % (self.storeExitingEnergy,))
        if self.disableOtherSideConnection is not None and 'disableOtherSideConnection' not in already_processed:
            already_processed.add('disableOtherSideConnection')
            showIndent(outfile, level)
            outfile.write('disableOtherSideConnection=%d,\n' % (self.disableOtherSideConnection,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SideIlluminationFile is not None:
            showIndent(outfile, level)
            outfile.write('SideIlluminationFile=model_._SideIlluminationFile(\n')
            self.SideIlluminationFile.exportLiteral(outfile, level, name_='SideIlluminationFile')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('provideIllumination', node)
        if value is not None and 'provideIllumination' not in already_processed:
            already_processed.add('provideIllumination')
            try:
                self.provideIllumination = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('storeExitingEnergy', node)
        if value is not None and 'storeExitingEnergy' not in already_processed:
            already_processed.add('storeExitingEnergy')
            try:
                self.storeExitingEnergy = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('disableOtherSideConnection', node)
        if value is not None and 'disableOtherSideConnection' not in already_processed:
            already_processed.add('disableOtherSideConnection')
            try:
                self.disableOtherSideConnection = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SideIlluminationFile':
            obj_ = create_SideIlluminationFile.factory()
            obj_.build(child_)
            self.set_SideIlluminationFile(obj_)
            obj_.original_tagname_ = 'SideIlluminationFile'
# end class create_TopSide


class create_SideIlluminationFile(GeneratedsSuper):
    """Precomputed illumination file path. Precomputed illumination file
    path."""
    subclass = None
    superclass = None
    def __init__(self, sideIlluminationFileName='bottomZExitEnergy.bin'):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_SideIlluminationFile")
        self.attrib = ['sideIlluminationFileName']
        self.children = []
        self.parent = None
        self._sideIlluminationFileName = _cast(None, sideIlluminationFileName)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_SideIlluminationFile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_SideIlluminationFile.subclass:
            return create_SideIlluminationFile.subclass(*args_, **kwargs_)
        else:
            return create_SideIlluminationFile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sideIlluminationFileName(self): return self._sideIlluminationFileName
    def set_sideIlluminationFileName(self, value):
        self._sideIlluminationFileName = value
        update_node(self,self.troot,"phase")
    sideIlluminationFileName = property(get_sideIlluminationFileName, set_sideIlluminationFileName)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_SideIlluminationFile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_SideIlluminationFile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_SideIlluminationFile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_SideIlluminationFile', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_SideIlluminationFile'):
        if self.sideIlluminationFileName is not None and 'sideIlluminationFileName' not in already_processed:
            already_processed.add('sideIlluminationFileName')
            outfile.write(' sideIlluminationFileName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sideIlluminationFileName), input_name='sideIlluminationFileName')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_SideIlluminationFile', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_SideIlluminationFile', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.sideIlluminationFileName is not None:
            element.set('sideIlluminationFileName', self.gds_format_string(self.sideIlluminationFileName))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_SideIlluminationFile'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sideIlluminationFileName is not None and 'sideIlluminationFileName' not in already_processed:
            already_processed.add('sideIlluminationFileName')
            showIndent(outfile, level)
            outfile.write('sideIlluminationFileName="%s",\n' % (self.sideIlluminationFileName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sideIlluminationFileName', node)
        if value is not None and 'sideIlluminationFileName' not in already_processed:
            already_processed.add('sideIlluminationFileName')
            self.sideIlluminationFileName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_SideIlluminationFile


class create_BottomSide(GeneratedsSuper):
    """Provide precomputed illumination file, as generated by the "Store
    exiting energy" option. Provide precomputed illumination file,
    as generated by the "Store exiting energy" option. Store exiting
    energy on this side. Generates a binary file containing images
    per exiting direction. Store exiting energy on this side.
    Generates a binary file containing images per exiting direction.
    Disable connection on the other side in repetitive or infinite
    slope mode. If a ray exit on this side, it is stopped regarless
    of the other options. Disable connection on the other side in
    repetitive or infinite slope mode. If a ray exit on this side,
    it is stopped regarless of the other options."""
    subclass = None
    superclass = None
    def __init__(self, provideIllumination=0, storeExitingEnergy=0, disableOtherSideConnection=0, SideIlluminationFile=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_BottomSide")
        self.attrib = ['provideIllumination', 'storeExitingEnergy', 'disableOtherSideConnection']
        self.children = ['SideIlluminationFile']
        self.parent = None
        self._provideIllumination = _cast(int, provideIllumination)
        self._storeExitingEnergy = _cast(int, storeExitingEnergy)
        self._disableOtherSideConnection = _cast(int, disableOtherSideConnection)
        self._SideIlluminationFile = SideIlluminationFile
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_BottomSide)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_BottomSide.subclass:
            return create_BottomSide.subclass(*args_, **kwargs_)
        else:
            return create_BottomSide(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SideIlluminationFile(self): return self._SideIlluminationFile
    def set_SideIlluminationFile(self, value):
        if value is not None:
            checkclass(value, create_SideIlluminationFile)
            value.parent = self
        self._SideIlluminationFile = value
    SideIlluminationFile = property(get_SideIlluminationFile, set_SideIlluminationFile)
    def get_provideIllumination(self): return self._provideIllumination
    def set_provideIllumination(self, value):
        self._provideIllumination = value
        update_node(self,self.troot,"phase")
    provideIllumination = property(get_provideIllumination, set_provideIllumination)
    def get_storeExitingEnergy(self): return self._storeExitingEnergy
    def set_storeExitingEnergy(self, value):
        self._storeExitingEnergy = value
        update_node(self,self.troot,"phase")
    storeExitingEnergy = property(get_storeExitingEnergy, set_storeExitingEnergy)
    def get_disableOtherSideConnection(self): return self._disableOtherSideConnection
    def set_disableOtherSideConnection(self, value):
        self._disableOtherSideConnection = value
        update_node(self,self.troot,"phase")
    disableOtherSideConnection = property(get_disableOtherSideConnection, set_disableOtherSideConnection)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.SideIlluminationFile is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_BottomSide', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_BottomSide')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_BottomSide')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_BottomSide', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_BottomSide'):
        if self.provideIllumination is not None and 'provideIllumination' not in already_processed:
            already_processed.add('provideIllumination')
            outfile.write(' provideIllumination="%s"' % self.gds_format_integer(self.provideIllumination, input_name='provideIllumination'))
        if self.storeExitingEnergy is not None and 'storeExitingEnergy' not in already_processed:
            already_processed.add('storeExitingEnergy')
            outfile.write(' storeExitingEnergy="%s"' % self.gds_format_integer(self.storeExitingEnergy, input_name='storeExitingEnergy'))
        if self.disableOtherSideConnection is not None and 'disableOtherSideConnection' not in already_processed:
            already_processed.add('disableOtherSideConnection')
            outfile.write(' disableOtherSideConnection="%s"' % self.gds_format_integer(self.disableOtherSideConnection, input_name='disableOtherSideConnection'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_BottomSide', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SideIlluminationFile is not None:
            self.SideIlluminationFile.export(outfile, level, namespaceprefix_, name_='SideIlluminationFile', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_BottomSide', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.provideIllumination is not None:
            element.set('provideIllumination', self.gds_format_integer(self.provideIllumination))
        if self.storeExitingEnergy is not None:
            element.set('storeExitingEnergy', self.gds_format_integer(self.storeExitingEnergy))
        if self.disableOtherSideConnection is not None:
            element.set('disableOtherSideConnection', self.gds_format_integer(self.disableOtherSideConnection))
        if self.SideIlluminationFile is not None:
            SideIlluminationFile_ = self.SideIlluminationFile
            SideIlluminationFile_.to_etree(element, name_='SideIlluminationFile', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_BottomSide'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.provideIllumination is not None and 'provideIllumination' not in already_processed:
            already_processed.add('provideIllumination')
            showIndent(outfile, level)
            outfile.write('provideIllumination=%d,\n' % (self.provideIllumination,))
        if self.storeExitingEnergy is not None and 'storeExitingEnergy' not in already_processed:
            already_processed.add('storeExitingEnergy')
            showIndent(outfile, level)
            outfile.write('storeExitingEnergy=%d,\n' % (self.storeExitingEnergy,))
        if self.disableOtherSideConnection is not None and 'disableOtherSideConnection' not in already_processed:
            already_processed.add('disableOtherSideConnection')
            showIndent(outfile, level)
            outfile.write('disableOtherSideConnection=%d,\n' % (self.disableOtherSideConnection,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SideIlluminationFile is not None:
            showIndent(outfile, level)
            outfile.write('SideIlluminationFile=model_._SideIlluminationFile(\n')
            self.SideIlluminationFile.exportLiteral(outfile, level, name_='SideIlluminationFile')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('provideIllumination', node)
        if value is not None and 'provideIllumination' not in already_processed:
            already_processed.add('provideIllumination')
            try:
                self.provideIllumination = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('storeExitingEnergy', node)
        if value is not None and 'storeExitingEnergy' not in already_processed:
            already_processed.add('storeExitingEnergy')
            try:
                self.storeExitingEnergy = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('disableOtherSideConnection', node)
        if value is not None and 'disableOtherSideConnection' not in already_processed:
            already_processed.add('disableOtherSideConnection')
            try:
                self.disableOtherSideConnection = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SideIlluminationFile':
            obj_ = create_SideIlluminationFile.factory()
            obj_.build(child_)
            self.set_SideIlluminationFile(obj_)
            obj_.original_tagname_ = 'SideIlluminationFile'
# end class create_BottomSide


class create_RightSide(GeneratedsSuper):
    """Provide precomputed illumination file, as generated by the "Store
    exiting energy" option. Provide precomputed illumination file,
    as generated by the "Store exiting energy" option. Store exiting
    energy on this side. Generates a binary file containing images
    per exiting direction. Store exiting energy on this side.
    Generates a binary file containing images per exiting direction.
    Disable connection on the other side in repetitive or infinite
    slope mode. If a ray exit on this side, it is stopped regarless
    of the other options. Disable connection on the other side in
    repetitive or infinite slope mode. If a ray exit on this side,
    it is stopped regarless of the other options."""
    subclass = None
    superclass = None
    def __init__(self, provideIllumination=0, storeExitingEnergy=0, disableOtherSideConnection=0, SideIlluminationFile=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_RightSide")
        self.attrib = ['provideIllumination', 'storeExitingEnergy', 'disableOtherSideConnection']
        self.children = ['SideIlluminationFile']
        self.parent = None
        self._provideIllumination = _cast(int, provideIllumination)
        self._storeExitingEnergy = _cast(int, storeExitingEnergy)
        self._disableOtherSideConnection = _cast(int, disableOtherSideConnection)
        self._SideIlluminationFile = SideIlluminationFile
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_RightSide)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_RightSide.subclass:
            return create_RightSide.subclass(*args_, **kwargs_)
        else:
            return create_RightSide(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SideIlluminationFile(self): return self._SideIlluminationFile
    def set_SideIlluminationFile(self, value):
        if value is not None:
            checkclass(value, create_SideIlluminationFile)
            value.parent = self
        self._SideIlluminationFile = value
    SideIlluminationFile = property(get_SideIlluminationFile, set_SideIlluminationFile)
    def get_provideIllumination(self): return self._provideIllumination
    def set_provideIllumination(self, value):
        self._provideIllumination = value
        update_node(self,self.troot,"phase")
    provideIllumination = property(get_provideIllumination, set_provideIllumination)
    def get_storeExitingEnergy(self): return self._storeExitingEnergy
    def set_storeExitingEnergy(self, value):
        self._storeExitingEnergy = value
        update_node(self,self.troot,"phase")
    storeExitingEnergy = property(get_storeExitingEnergy, set_storeExitingEnergy)
    def get_disableOtherSideConnection(self): return self._disableOtherSideConnection
    def set_disableOtherSideConnection(self, value):
        self._disableOtherSideConnection = value
        update_node(self,self.troot,"phase")
    disableOtherSideConnection = property(get_disableOtherSideConnection, set_disableOtherSideConnection)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.SideIlluminationFile is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_RightSide', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_RightSide')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_RightSide')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_RightSide', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_RightSide'):
        if self.provideIllumination is not None and 'provideIllumination' not in already_processed:
            already_processed.add('provideIllumination')
            outfile.write(' provideIllumination="%s"' % self.gds_format_integer(self.provideIllumination, input_name='provideIllumination'))
        if self.storeExitingEnergy is not None and 'storeExitingEnergy' not in already_processed:
            already_processed.add('storeExitingEnergy')
            outfile.write(' storeExitingEnergy="%s"' % self.gds_format_integer(self.storeExitingEnergy, input_name='storeExitingEnergy'))
        if self.disableOtherSideConnection is not None and 'disableOtherSideConnection' not in already_processed:
            already_processed.add('disableOtherSideConnection')
            outfile.write(' disableOtherSideConnection="%s"' % self.gds_format_integer(self.disableOtherSideConnection, input_name='disableOtherSideConnection'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_RightSide', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SideIlluminationFile is not None:
            self.SideIlluminationFile.export(outfile, level, namespaceprefix_, name_='SideIlluminationFile', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_RightSide', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.provideIllumination is not None:
            element.set('provideIllumination', self.gds_format_integer(self.provideIllumination))
        if self.storeExitingEnergy is not None:
            element.set('storeExitingEnergy', self.gds_format_integer(self.storeExitingEnergy))
        if self.disableOtherSideConnection is not None:
            element.set('disableOtherSideConnection', self.gds_format_integer(self.disableOtherSideConnection))
        if self.SideIlluminationFile is not None:
            SideIlluminationFile_ = self.SideIlluminationFile
            SideIlluminationFile_.to_etree(element, name_='SideIlluminationFile', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_RightSide'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.provideIllumination is not None and 'provideIllumination' not in already_processed:
            already_processed.add('provideIllumination')
            showIndent(outfile, level)
            outfile.write('provideIllumination=%d,\n' % (self.provideIllumination,))
        if self.storeExitingEnergy is not None and 'storeExitingEnergy' not in already_processed:
            already_processed.add('storeExitingEnergy')
            showIndent(outfile, level)
            outfile.write('storeExitingEnergy=%d,\n' % (self.storeExitingEnergy,))
        if self.disableOtherSideConnection is not None and 'disableOtherSideConnection' not in already_processed:
            already_processed.add('disableOtherSideConnection')
            showIndent(outfile, level)
            outfile.write('disableOtherSideConnection=%d,\n' % (self.disableOtherSideConnection,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SideIlluminationFile is not None:
            showIndent(outfile, level)
            outfile.write('SideIlluminationFile=model_._SideIlluminationFile(\n')
            self.SideIlluminationFile.exportLiteral(outfile, level, name_='SideIlluminationFile')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('provideIllumination', node)
        if value is not None and 'provideIllumination' not in already_processed:
            already_processed.add('provideIllumination')
            try:
                self.provideIllumination = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('storeExitingEnergy', node)
        if value is not None and 'storeExitingEnergy' not in already_processed:
            already_processed.add('storeExitingEnergy')
            try:
                self.storeExitingEnergy = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('disableOtherSideConnection', node)
        if value is not None and 'disableOtherSideConnection' not in already_processed:
            already_processed.add('disableOtherSideConnection')
            try:
                self.disableOtherSideConnection = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SideIlluminationFile':
            obj_ = create_SideIlluminationFile.factory()
            obj_.build(child_)
            self.set_SideIlluminationFile(obj_)
            obj_.original_tagname_ = 'SideIlluminationFile'
# end class create_RightSide


class create_LeftSide(GeneratedsSuper):
    """Provide precomputed illumination file, as generated by the "Store
    exiting energy" option. Provide precomputed illumination file,
    as generated by the "Store exiting energy" option. Store exiting
    energy on this side. Generates a binary file containing images
    per exiting direction. Store exiting energy on this side.
    Generates a binary file containing images per exiting direction.
    Disable connection on the other side in repetitive or infinite
    slope mode. If a ray exit on this side, it is stopped regarless
    of the other options. Disable connection on the other side in
    repetitive or infinite slope mode. If a ray exit on this side,
    it is stopped regarless of the other options."""
    subclass = None
    superclass = None
    def __init__(self, provideIllumination=0, storeExitingEnergy=0, disableOtherSideConnection=0, SideIlluminationFile=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_LeftSide")
        self.attrib = ['provideIllumination', 'storeExitingEnergy', 'disableOtherSideConnection']
        self.children = ['SideIlluminationFile']
        self.parent = None
        self._provideIllumination = _cast(int, provideIllumination)
        self._storeExitingEnergy = _cast(int, storeExitingEnergy)
        self._disableOtherSideConnection = _cast(int, disableOtherSideConnection)
        self._SideIlluminationFile = SideIlluminationFile
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_LeftSide)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_LeftSide.subclass:
            return create_LeftSide.subclass(*args_, **kwargs_)
        else:
            return create_LeftSide(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SideIlluminationFile(self): return self._SideIlluminationFile
    def set_SideIlluminationFile(self, value):
        if value is not None:
            checkclass(value, create_SideIlluminationFile)
            value.parent = self
        self._SideIlluminationFile = value
    SideIlluminationFile = property(get_SideIlluminationFile, set_SideIlluminationFile)
    def get_provideIllumination(self): return self._provideIllumination
    def set_provideIllumination(self, value):
        self._provideIllumination = value
        update_node(self,self.troot,"phase")
    provideIllumination = property(get_provideIllumination, set_provideIllumination)
    def get_storeExitingEnergy(self): return self._storeExitingEnergy
    def set_storeExitingEnergy(self, value):
        self._storeExitingEnergy = value
        update_node(self,self.troot,"phase")
    storeExitingEnergy = property(get_storeExitingEnergy, set_storeExitingEnergy)
    def get_disableOtherSideConnection(self): return self._disableOtherSideConnection
    def set_disableOtherSideConnection(self, value):
        self._disableOtherSideConnection = value
        update_node(self,self.troot,"phase")
    disableOtherSideConnection = property(get_disableOtherSideConnection, set_disableOtherSideConnection)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.SideIlluminationFile is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_LeftSide', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_LeftSide')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_LeftSide')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_LeftSide', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_LeftSide'):
        if self.provideIllumination is not None and 'provideIllumination' not in already_processed:
            already_processed.add('provideIllumination')
            outfile.write(' provideIllumination="%s"' % self.gds_format_integer(self.provideIllumination, input_name='provideIllumination'))
        if self.storeExitingEnergy is not None and 'storeExitingEnergy' not in already_processed:
            already_processed.add('storeExitingEnergy')
            outfile.write(' storeExitingEnergy="%s"' % self.gds_format_integer(self.storeExitingEnergy, input_name='storeExitingEnergy'))
        if self.disableOtherSideConnection is not None and 'disableOtherSideConnection' not in already_processed:
            already_processed.add('disableOtherSideConnection')
            outfile.write(' disableOtherSideConnection="%s"' % self.gds_format_integer(self.disableOtherSideConnection, input_name='disableOtherSideConnection'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_LeftSide', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SideIlluminationFile is not None:
            self.SideIlluminationFile.export(outfile, level, namespaceprefix_, name_='SideIlluminationFile', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_LeftSide', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.provideIllumination is not None:
            element.set('provideIllumination', self.gds_format_integer(self.provideIllumination))
        if self.storeExitingEnergy is not None:
            element.set('storeExitingEnergy', self.gds_format_integer(self.storeExitingEnergy))
        if self.disableOtherSideConnection is not None:
            element.set('disableOtherSideConnection', self.gds_format_integer(self.disableOtherSideConnection))
        if self.SideIlluminationFile is not None:
            SideIlluminationFile_ = self.SideIlluminationFile
            SideIlluminationFile_.to_etree(element, name_='SideIlluminationFile', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_LeftSide'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.provideIllumination is not None and 'provideIllumination' not in already_processed:
            already_processed.add('provideIllumination')
            showIndent(outfile, level)
            outfile.write('provideIllumination=%d,\n' % (self.provideIllumination,))
        if self.storeExitingEnergy is not None and 'storeExitingEnergy' not in already_processed:
            already_processed.add('storeExitingEnergy')
            showIndent(outfile, level)
            outfile.write('storeExitingEnergy=%d,\n' % (self.storeExitingEnergy,))
        if self.disableOtherSideConnection is not None and 'disableOtherSideConnection' not in already_processed:
            already_processed.add('disableOtherSideConnection')
            showIndent(outfile, level)
            outfile.write('disableOtherSideConnection=%d,\n' % (self.disableOtherSideConnection,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SideIlluminationFile is not None:
            showIndent(outfile, level)
            outfile.write('SideIlluminationFile=model_._SideIlluminationFile(\n')
            self.SideIlluminationFile.exportLiteral(outfile, level, name_='SideIlluminationFile')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('provideIllumination', node)
        if value is not None and 'provideIllumination' not in already_processed:
            already_processed.add('provideIllumination')
            try:
                self.provideIllumination = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('storeExitingEnergy', node)
        if value is not None and 'storeExitingEnergy' not in already_processed:
            already_processed.add('storeExitingEnergy')
            try:
                self.storeExitingEnergy = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('disableOtherSideConnection', node)
        if value is not None and 'disableOtherSideConnection' not in already_processed:
            already_processed.add('disableOtherSideConnection')
            try:
                self.disableOtherSideConnection = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SideIlluminationFile':
            obj_ = create_SideIlluminationFile.factory()
            obj_.build(child_)
            self.set_SideIlluminationFile(obj_)
            obj_.original_tagname_ = 'SideIlluminationFile'
# end class create_LeftSide


class create_FrontSide(GeneratedsSuper):
    """Provide precomputed illumination file, as generated by the "Store
    exiting energy" option. Provide precomputed illumination file,
    as generated by the "Store exiting energy" option. Store exiting
    energy on this side. Generates a binary file containing images
    per exiting direction. Store exiting energy on this side.
    Generates a binary file containing images per exiting direction.
    Disable connection on the other side in repetitive or infinite
    slope mode. If a ray exit on this side, it is stopped regarless
    of the other options. Disable connection on the other side in
    repetitive or infinite slope mode. If a ray exit on this side,
    it is stopped regarless of the other options."""
    subclass = None
    superclass = None
    def __init__(self, provideIllumination=0, storeExitingEnergy=0, disableOtherSideConnection=0, SideIlluminationFile=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_FrontSide")
        self.attrib = ['provideIllumination', 'storeExitingEnergy', 'disableOtherSideConnection']
        self.children = ['SideIlluminationFile']
        self.parent = None
        self._provideIllumination = _cast(int, provideIllumination)
        self._storeExitingEnergy = _cast(int, storeExitingEnergy)
        self._disableOtherSideConnection = _cast(int, disableOtherSideConnection)
        self._SideIlluminationFile = SideIlluminationFile
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_FrontSide)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_FrontSide.subclass:
            return create_FrontSide.subclass(*args_, **kwargs_)
        else:
            return create_FrontSide(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SideIlluminationFile(self): return self._SideIlluminationFile
    def set_SideIlluminationFile(self, value):
        if value is not None:
            checkclass(value, create_SideIlluminationFile)
            value.parent = self
        self._SideIlluminationFile = value
    SideIlluminationFile = property(get_SideIlluminationFile, set_SideIlluminationFile)
    def get_provideIllumination(self): return self._provideIllumination
    def set_provideIllumination(self, value):
        self._provideIllumination = value
        update_node(self,self.troot,"phase")
    provideIllumination = property(get_provideIllumination, set_provideIllumination)
    def get_storeExitingEnergy(self): return self._storeExitingEnergy
    def set_storeExitingEnergy(self, value):
        self._storeExitingEnergy = value
        update_node(self,self.troot,"phase")
    storeExitingEnergy = property(get_storeExitingEnergy, set_storeExitingEnergy)
    def get_disableOtherSideConnection(self): return self._disableOtherSideConnection
    def set_disableOtherSideConnection(self, value):
        self._disableOtherSideConnection = value
        update_node(self,self.troot,"phase")
    disableOtherSideConnection = property(get_disableOtherSideConnection, set_disableOtherSideConnection)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.SideIlluminationFile is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_FrontSide', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_FrontSide')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_FrontSide')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_FrontSide', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_FrontSide'):
        if self.provideIllumination is not None and 'provideIllumination' not in already_processed:
            already_processed.add('provideIllumination')
            outfile.write(' provideIllumination="%s"' % self.gds_format_integer(self.provideIllumination, input_name='provideIllumination'))
        if self.storeExitingEnergy is not None and 'storeExitingEnergy' not in already_processed:
            already_processed.add('storeExitingEnergy')
            outfile.write(' storeExitingEnergy="%s"' % self.gds_format_integer(self.storeExitingEnergy, input_name='storeExitingEnergy'))
        if self.disableOtherSideConnection is not None and 'disableOtherSideConnection' not in already_processed:
            already_processed.add('disableOtherSideConnection')
            outfile.write(' disableOtherSideConnection="%s"' % self.gds_format_integer(self.disableOtherSideConnection, input_name='disableOtherSideConnection'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_FrontSide', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SideIlluminationFile is not None:
            self.SideIlluminationFile.export(outfile, level, namespaceprefix_, name_='SideIlluminationFile', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_FrontSide', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.provideIllumination is not None:
            element.set('provideIllumination', self.gds_format_integer(self.provideIllumination))
        if self.storeExitingEnergy is not None:
            element.set('storeExitingEnergy', self.gds_format_integer(self.storeExitingEnergy))
        if self.disableOtherSideConnection is not None:
            element.set('disableOtherSideConnection', self.gds_format_integer(self.disableOtherSideConnection))
        if self.SideIlluminationFile is not None:
            SideIlluminationFile_ = self.SideIlluminationFile
            SideIlluminationFile_.to_etree(element, name_='SideIlluminationFile', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_FrontSide'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.provideIllumination is not None and 'provideIllumination' not in already_processed:
            already_processed.add('provideIllumination')
            showIndent(outfile, level)
            outfile.write('provideIllumination=%d,\n' % (self.provideIllumination,))
        if self.storeExitingEnergy is not None and 'storeExitingEnergy' not in already_processed:
            already_processed.add('storeExitingEnergy')
            showIndent(outfile, level)
            outfile.write('storeExitingEnergy=%d,\n' % (self.storeExitingEnergy,))
        if self.disableOtherSideConnection is not None and 'disableOtherSideConnection' not in already_processed:
            already_processed.add('disableOtherSideConnection')
            showIndent(outfile, level)
            outfile.write('disableOtherSideConnection=%d,\n' % (self.disableOtherSideConnection,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SideIlluminationFile is not None:
            showIndent(outfile, level)
            outfile.write('SideIlluminationFile=model_._SideIlluminationFile(\n')
            self.SideIlluminationFile.exportLiteral(outfile, level, name_='SideIlluminationFile')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('provideIllumination', node)
        if value is not None and 'provideIllumination' not in already_processed:
            already_processed.add('provideIllumination')
            try:
                self.provideIllumination = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('storeExitingEnergy', node)
        if value is not None and 'storeExitingEnergy' not in already_processed:
            already_processed.add('storeExitingEnergy')
            try:
                self.storeExitingEnergy = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('disableOtherSideConnection', node)
        if value is not None and 'disableOtherSideConnection' not in already_processed:
            already_processed.add('disableOtherSideConnection')
            try:
                self.disableOtherSideConnection = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SideIlluminationFile':
            obj_ = create_SideIlluminationFile.factory()
            obj_.build(child_)
            self.set_SideIlluminationFile(obj_)
            obj_.original_tagname_ = 'SideIlluminationFile'
# end class create_FrontSide


class create_BackSide(GeneratedsSuper):
    """Provide precomputed illumination file, as generated by the "Store
    exiting energy" option. Provide precomputed illumination file,
    as generated by the "Store exiting energy" option. Store exiting
    energy on this side. Generates a binary file containing images
    per exiting direction. Store exiting energy on this side.
    Generates a binary file containing images per exiting direction.
    Disable connection on the other side in repetitive or infinite
    slope mode. If a ray exit on this side, it is stopped regarless
    of the other options. Disable connection on the other side in
    repetitive or infinite slope mode. If a ray exit on this side,
    it is stopped regarless of the other options."""
    subclass = None
    superclass = None
    def __init__(self, provideIllumination=0, storeExitingEnergy=0, disableOtherSideConnection=0, SideIlluminationFile=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_BackSide")
        self.attrib = ['provideIllumination', 'storeExitingEnergy', 'disableOtherSideConnection']
        self.children = ['SideIlluminationFile']
        self.parent = None
        self._provideIllumination = _cast(int, provideIllumination)
        self._storeExitingEnergy = _cast(int, storeExitingEnergy)
        self._disableOtherSideConnection = _cast(int, disableOtherSideConnection)
        self._SideIlluminationFile = SideIlluminationFile
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_BackSide)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_BackSide.subclass:
            return create_BackSide.subclass(*args_, **kwargs_)
        else:
            return create_BackSide(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SideIlluminationFile(self): return self._SideIlluminationFile
    def set_SideIlluminationFile(self, value):
        if value is not None:
            checkclass(value, create_SideIlluminationFile)
            value.parent = self
        self._SideIlluminationFile = value
    SideIlluminationFile = property(get_SideIlluminationFile, set_SideIlluminationFile)
    def get_provideIllumination(self): return self._provideIllumination
    def set_provideIllumination(self, value):
        self._provideIllumination = value
        update_node(self,self.troot,"phase")
    provideIllumination = property(get_provideIllumination, set_provideIllumination)
    def get_storeExitingEnergy(self): return self._storeExitingEnergy
    def set_storeExitingEnergy(self, value):
        self._storeExitingEnergy = value
        update_node(self,self.troot,"phase")
    storeExitingEnergy = property(get_storeExitingEnergy, set_storeExitingEnergy)
    def get_disableOtherSideConnection(self): return self._disableOtherSideConnection
    def set_disableOtherSideConnection(self, value):
        self._disableOtherSideConnection = value
        update_node(self,self.troot,"phase")
    disableOtherSideConnection = property(get_disableOtherSideConnection, set_disableOtherSideConnection)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.SideIlluminationFile is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_BackSide', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_BackSide')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_BackSide')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_BackSide', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_BackSide'):
        if self.provideIllumination is not None and 'provideIllumination' not in already_processed:
            already_processed.add('provideIllumination')
            outfile.write(' provideIllumination="%s"' % self.gds_format_integer(self.provideIllumination, input_name='provideIllumination'))
        if self.storeExitingEnergy is not None and 'storeExitingEnergy' not in already_processed:
            already_processed.add('storeExitingEnergy')
            outfile.write(' storeExitingEnergy="%s"' % self.gds_format_integer(self.storeExitingEnergy, input_name='storeExitingEnergy'))
        if self.disableOtherSideConnection is not None and 'disableOtherSideConnection' not in already_processed:
            already_processed.add('disableOtherSideConnection')
            outfile.write(' disableOtherSideConnection="%s"' % self.gds_format_integer(self.disableOtherSideConnection, input_name='disableOtherSideConnection'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_BackSide', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SideIlluminationFile is not None:
            self.SideIlluminationFile.export(outfile, level, namespaceprefix_, name_='SideIlluminationFile', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_BackSide', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.provideIllumination is not None:
            element.set('provideIllumination', self.gds_format_integer(self.provideIllumination))
        if self.storeExitingEnergy is not None:
            element.set('storeExitingEnergy', self.gds_format_integer(self.storeExitingEnergy))
        if self.disableOtherSideConnection is not None:
            element.set('disableOtherSideConnection', self.gds_format_integer(self.disableOtherSideConnection))
        if self.SideIlluminationFile is not None:
            SideIlluminationFile_ = self.SideIlluminationFile
            SideIlluminationFile_.to_etree(element, name_='SideIlluminationFile', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_BackSide'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.provideIllumination is not None and 'provideIllumination' not in already_processed:
            already_processed.add('provideIllumination')
            showIndent(outfile, level)
            outfile.write('provideIllumination=%d,\n' % (self.provideIllumination,))
        if self.storeExitingEnergy is not None and 'storeExitingEnergy' not in already_processed:
            already_processed.add('storeExitingEnergy')
            showIndent(outfile, level)
            outfile.write('storeExitingEnergy=%d,\n' % (self.storeExitingEnergy,))
        if self.disableOtherSideConnection is not None and 'disableOtherSideConnection' not in already_processed:
            already_processed.add('disableOtherSideConnection')
            showIndent(outfile, level)
            outfile.write('disableOtherSideConnection=%d,\n' % (self.disableOtherSideConnection,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SideIlluminationFile is not None:
            showIndent(outfile, level)
            outfile.write('SideIlluminationFile=model_._SideIlluminationFile(\n')
            self.SideIlluminationFile.exportLiteral(outfile, level, name_='SideIlluminationFile')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('provideIllumination', node)
        if value is not None and 'provideIllumination' not in already_processed:
            already_processed.add('provideIllumination')
            try:
                self.provideIllumination = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('storeExitingEnergy', node)
        if value is not None and 'storeExitingEnergy' not in already_processed:
            already_processed.add('storeExitingEnergy')
            try:
                self.storeExitingEnergy = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('disableOtherSideConnection', node)
        if value is not None and 'disableOtherSideConnection' not in already_processed:
            already_processed.add('disableOtherSideConnection')
            try:
                self.disableOtherSideConnection = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SideIlluminationFile':
            obj_ = create_SideIlluminationFile.factory()
            obj_.build(child_)
            self.set_SideIlluminationFile(obj_)
            obj_.original_tagname_ = 'SideIlluminationFile'
# end class create_BackSide


class create_overrideBandIrradiance(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, isOverrideBandIrradiance=0, bandIrradianceFileNode=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_overrideBandIrradiance")
        self.attrib = ['isOverrideBandIrradiance']
        self.children = ['bandIrradianceFileNode']
        self.parent = None
        self._isOverrideBandIrradiance = _cast(int, isOverrideBandIrradiance)
        self._bandIrradianceFileNode = bandIrradianceFileNode
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_overrideBandIrradiance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_overrideBandIrradiance.subclass:
            return create_overrideBandIrradiance.subclass(*args_, **kwargs_)
        else:
            return create_overrideBandIrradiance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bandIrradianceFileNode(self): return self._bandIrradianceFileNode
    def set_bandIrradianceFileNode(self, value):
        if value is not None:
            checkclass(value, create_bandIrradianceFileNode)
            value.parent = self
        self._bandIrradianceFileNode = value
    bandIrradianceFileNode = property(get_bandIrradianceFileNode, set_bandIrradianceFileNode)
    def get_isOverrideBandIrradiance(self): return self._isOverrideBandIrradiance
    def set_isOverrideBandIrradiance(self, value):
        self._isOverrideBandIrradiance = value
        update_node(self,self.troot,"phase")
    isOverrideBandIrradiance = property(get_isOverrideBandIrradiance, set_isOverrideBandIrradiance)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.bandIrradianceFileNode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_overrideBandIrradiance', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_overrideBandIrradiance')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_overrideBandIrradiance')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_overrideBandIrradiance', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_overrideBandIrradiance'):
        if self.isOverrideBandIrradiance is not None and 'isOverrideBandIrradiance' not in already_processed:
            already_processed.add('isOverrideBandIrradiance')
            outfile.write(' isOverrideBandIrradiance="%s"' % self.gds_format_integer(self.isOverrideBandIrradiance, input_name='isOverrideBandIrradiance'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_overrideBandIrradiance', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.bandIrradianceFileNode is not None:
            self.bandIrradianceFileNode.export(outfile, level, namespaceprefix_, name_='bandIrradianceFileNode', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_overrideBandIrradiance', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.isOverrideBandIrradiance is not None:
            element.set('isOverrideBandIrradiance', self.gds_format_integer(self.isOverrideBandIrradiance))
        if self.bandIrradianceFileNode is not None:
            bandIrradianceFileNode_ = self.bandIrradianceFileNode
            bandIrradianceFileNode_.to_etree(element, name_='bandIrradianceFileNode', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_overrideBandIrradiance'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isOverrideBandIrradiance is not None and 'isOverrideBandIrradiance' not in already_processed:
            already_processed.add('isOverrideBandIrradiance')
            showIndent(outfile, level)
            outfile.write('isOverrideBandIrradiance=%d,\n' % (self.isOverrideBandIrradiance,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.bandIrradianceFileNode is not None:
            showIndent(outfile, level)
            outfile.write('bandIrradianceFileNode=model_._bandIrradianceFileNode(\n')
            self.bandIrradianceFileNode.exportLiteral(outfile, level, name_='bandIrradianceFileNode')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isOverrideBandIrradiance', node)
        if value is not None and 'isOverrideBandIrradiance' not in already_processed:
            already_processed.add('isOverrideBandIrradiance')
            try:
                self.isOverrideBandIrradiance = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'bandIrradianceFileNode':
            obj_ = create_bandIrradianceFileNode.factory()
            obj_.build(child_)
            self.set_bandIrradianceFileNode(obj_)
            obj_.original_tagname_ = 'bandIrradianceFileNode'
# end class create_overrideBandIrradiance


class create_bandIrradianceFileNode(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, bandIrradianceFile='bandIrradianceFile.txt'):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_bandIrradianceFileNode")
        self.attrib = ['bandIrradianceFile']
        self.children = []
        self.parent = None
        self._bandIrradianceFile = _cast(None, bandIrradianceFile)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_bandIrradianceFileNode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_bandIrradianceFileNode.subclass:
            return create_bandIrradianceFileNode.subclass(*args_, **kwargs_)
        else:
            return create_bandIrradianceFileNode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bandIrradianceFile(self): return self._bandIrradianceFile
    def set_bandIrradianceFile(self, value):
        self._bandIrradianceFile = value
        update_node(self,self.troot,"phase")
    bandIrradianceFile = property(get_bandIrradianceFile, set_bandIrradianceFile)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_bandIrradianceFileNode', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_bandIrradianceFileNode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_bandIrradianceFileNode')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_bandIrradianceFileNode', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_bandIrradianceFileNode'):
        if self.bandIrradianceFile is not None and 'bandIrradianceFile' not in already_processed:
            already_processed.add('bandIrradianceFile')
            outfile.write(' bandIrradianceFile=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.bandIrradianceFile), input_name='bandIrradianceFile')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_bandIrradianceFileNode', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_bandIrradianceFileNode', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.bandIrradianceFile is not None:
            element.set('bandIrradianceFile', self.gds_format_string(self.bandIrradianceFile))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_bandIrradianceFileNode'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.bandIrradianceFile is not None and 'bandIrradianceFile' not in already_processed:
            already_processed.add('bandIrradianceFile')
            showIndent(outfile, level)
            outfile.write('bandIrradianceFile="%s",\n' % (self.bandIrradianceFile,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('bandIrradianceFile', node)
        if value is not None and 'bandIrradianceFile' not in already_processed:
            already_processed.add('bandIrradianceFile')
            self.bandIrradianceFile = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_bandIrradianceFileNode


class create_DartProduct(GeneratedsSuper):
    """DartProduct DartProduct"""
    subclass = None
    superclass = None
    def __init__(self, dartModuleProducts=None, maketModuleProducts=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_DartProduct")
        self.attrib = ['']
        self.children = ['dartModuleProducts', 'maketModuleProducts']
        self.parent = None
        self._dartModuleProducts = dartModuleProducts
        self._maketModuleProducts = maketModuleProducts
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_DartProduct)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_DartProduct.subclass:
            return create_DartProduct.subclass(*args_, **kwargs_)
        else:
            return create_DartProduct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dartModuleProducts(self): return self._dartModuleProducts
    def set_dartModuleProducts(self, value):
        if value is not None:
            checkclass(value, create_dartModuleProducts)
            value.parent = self
        self._dartModuleProducts = value
    dartModuleProducts = property(get_dartModuleProducts, set_dartModuleProducts)
    def get_maketModuleProducts(self): return self._maketModuleProducts
    def set_maketModuleProducts(self, value):
        if value is not None:
            checkclass(value, create_maketModuleProducts)
            value.parent = self
        self._maketModuleProducts = value
    maketModuleProducts = property(get_maketModuleProducts, set_maketModuleProducts)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.dartModuleProducts is not None or
            self.maketModuleProducts is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_DartProduct', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_DartProduct')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_DartProduct')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_DartProduct', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_DartProduct'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_DartProduct', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dartModuleProducts is not None:
            self.dartModuleProducts.export(outfile, level, namespaceprefix_, name_='dartModuleProducts', pretty_print=pretty_print)
        if self.maketModuleProducts is not None:
            self.maketModuleProducts.export(outfile, level, namespaceprefix_, name_='maketModuleProducts', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_DartProduct', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.dartModuleProducts is not None:
            dartModuleProducts_ = self.dartModuleProducts
            dartModuleProducts_.to_etree(element, name_='dartModuleProducts', mapping_=mapping_)
        if self.maketModuleProducts is not None:
            maketModuleProducts_ = self.maketModuleProducts
            maketModuleProducts_.to_etree(element, name_='maketModuleProducts', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_DartProduct'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.dartModuleProducts is not None:
            showIndent(outfile, level)
            outfile.write('dartModuleProducts=model_._dartModuleProducts(\n')
            self.dartModuleProducts.exportLiteral(outfile, level, name_='dartModuleProducts')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.maketModuleProducts is not None:
            showIndent(outfile, level)
            outfile.write('maketModuleProducts=model_._maketModuleProducts(\n')
            self.maketModuleProducts.exportLiteral(outfile, level, name_='maketModuleProducts')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dartModuleProducts':
            obj_ = create_dartModuleProducts.factory()
            obj_.build(child_)
            self.set_dartModuleProducts(obj_)
            obj_.original_tagname_ = 'dartModuleProducts'
        elif nodeName_ == 'maketModuleProducts':
            obj_ = create_maketModuleProducts.factory()
            obj_.build(child_)
            self.set_maketModuleProducts(obj_)
            obj_.original_tagname_ = 'maketModuleProducts'
# end class create_DartProduct


class create_dartModuleProducts(GeneratedsSuper):
    """dartModuleProducts dartModuleProducts LIDAR products LIDAR products
    3D and 1D distribution of radiation that is incident,
    intercepted, absorbed and scattered, for each non empty cell. 3D
    and 1D distribution of radiation that is incident, intercepted,
    absorbed and scattered, for each non empty cell. Options
    specific to the LIDAR Image option. Options specific to the
    LIDAR Image option. Specifies if the polarization is taken into
    account in the radiative transfer or not. \n The state of
    polarization of a wave is described by the 4 components of the
    Stokes Vector. \n Not polarized for the sun illumination, the
    light can be polarized by a physical phenomenon (specular
    reflection, rayleigh scattering). Specifies if the polarization
    is taken into account in the radiative transfer or not. \n The
    state of polarization of a wave is described by the 4 components
    of the Stokes Vector. \n Not polarized for the sun illumination,
    the light can be polarized by a physical phenomenon (specular
    reflection, rayleigh scattering). Create a Order1 directory
    which contains first order scattering products (BRF/BTF,
    radiative budget) Create a Order1 directory which contains first
    order scattering products (BRF/BTF, radiative budget)
    Temperature per triangle per cell using the format
    x.y.z.i:tf;tb;a where x, y and z are the indices of the cell, i
    the indice of the triangle, tf and tb the temperature of the
    front and back respectively and a the area of the triangle
    within the cell. Temperature per triangle per cell using the
    format x.y.z.i:tf;tb;a where x, y and z are the indices of the
    cell, i the indice of the triangle, tf and tb the temperature of
    the front and back respectively and a the area of the triangle
    within the cell. Results obtained at each iteration are stored
    or only first and last Iterations are stored Results obtained at
    each iteration are stored or only first and last Iterations are
    stored Reflectance and/or Brightness temperature products
    (images, etc.). Reflectance and/or Brightness temperature
    products (images, etc.)."""
    subclass = None
    superclass = None
    def __init__(self, lidarProducts=0, radiativeBudgetProducts=0, lidarImageProducts=0, polarizationProducts=0, order1Products=0, temperaturePerTrianglePerCell=0, allIterationsProducts=0, brfProducts=1, BrfProductsProperties=None, lidarProductsProperties=None, Order1Options=None, ImageBinaryProducts=None, radiativeBudgetProperties=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_dartModuleProducts")
        self.attrib = ['lidarProducts', 'radiativeBudgetProducts', 'lidarImageProducts', 'polarizationProducts', 'order1Products', 'temperaturePerTrianglePerCell', 'allIterationsProducts', 'brfProducts']
        self.children = ['BrfProductsProperties', 'lidarProductsProperties', 'Order1Options', 'ImageBinaryProducts', 'radiativeBudgetProperties']
        self.parent = None
        self._lidarProducts = _cast(int, lidarProducts)
        self._radiativeBudgetProducts = _cast(int, radiativeBudgetProducts)
        self._lidarImageProducts = _cast(int, lidarImageProducts)
        self._polarizationProducts = _cast(int, polarizationProducts)
        self._order1Products = _cast(int, order1Products)
        self._temperaturePerTrianglePerCell = _cast(int, temperaturePerTrianglePerCell)
        self._allIterationsProducts = _cast(int, allIterationsProducts)
        self._brfProducts = _cast(int, brfProducts)
        self._BrfProductsProperties = BrfProductsProperties
        self._lidarProductsProperties = lidarProductsProperties
        self._Order1Options = Order1Options
        self._ImageBinaryProducts = ImageBinaryProducts
        self._radiativeBudgetProperties = radiativeBudgetProperties
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_dartModuleProducts)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_dartModuleProducts.subclass:
            return create_dartModuleProducts.subclass(*args_, **kwargs_)
        else:
            return create_dartModuleProducts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BrfProductsProperties(self): return self._BrfProductsProperties
    def set_BrfProductsProperties(self, value):
        if value is not None:
            checkclass(value, create_BrfProductsProperties)
            value.parent = self
        self._BrfProductsProperties = value
    BrfProductsProperties = property(get_BrfProductsProperties, set_BrfProductsProperties)
    def get_lidarProductsProperties(self): return self._lidarProductsProperties
    def set_lidarProductsProperties(self, value):
        if value is not None:
            checkclass(value, create_lidarProductsProperties)
            value.parent = self
        self._lidarProductsProperties = value
    lidarProductsProperties = property(get_lidarProductsProperties, set_lidarProductsProperties)
    def get_Order1Options(self): return self._Order1Options
    def set_Order1Options(self, value):
        if value is not None:
            checkclass(value, create_Order1Options)
            value.parent = self
        self._Order1Options = value
    Order1Options = property(get_Order1Options, set_Order1Options)
    def get_ImageBinaryProducts(self): return self._ImageBinaryProducts
    def set_ImageBinaryProducts(self, value):
        if value is not None:
            checkclass(value, create_ImageBinaryProducts)
            value.parent = self
        self._ImageBinaryProducts = value
    ImageBinaryProducts = property(get_ImageBinaryProducts, set_ImageBinaryProducts)
    def get_radiativeBudgetProperties(self): return self._radiativeBudgetProperties
    def set_radiativeBudgetProperties(self, value):
        if value is not None:
            checkclass(value, create_radiativeBudgetProperties)
            value.parent = self
        self._radiativeBudgetProperties = value
    radiativeBudgetProperties = property(get_radiativeBudgetProperties, set_radiativeBudgetProperties)
    def get_lidarProducts(self): return self._lidarProducts
    def set_lidarProducts(self, value):
        self._lidarProducts = value
        update_node(self,self.troot,"phase")
    lidarProducts = property(get_lidarProducts, set_lidarProducts)
    def get_radiativeBudgetProducts(self): return self._radiativeBudgetProducts
    def set_radiativeBudgetProducts(self, value):
        self._radiativeBudgetProducts = value
        update_node(self,self.troot,"phase")
    radiativeBudgetProducts = property(get_radiativeBudgetProducts, set_radiativeBudgetProducts)
    def get_lidarImageProducts(self): return self._lidarImageProducts
    def set_lidarImageProducts(self, value):
        self._lidarImageProducts = value
        update_node(self,self.troot,"phase")
    lidarImageProducts = property(get_lidarImageProducts, set_lidarImageProducts)
    def get_polarizationProducts(self): return self._polarizationProducts
    def set_polarizationProducts(self, value):
        self._polarizationProducts = value
        update_node(self,self.troot,"phase")
    polarizationProducts = property(get_polarizationProducts, set_polarizationProducts)
    def get_order1Products(self): return self._order1Products
    def set_order1Products(self, value):
        self._order1Products = value
        update_node(self,self.troot,"phase")
    order1Products = property(get_order1Products, set_order1Products)
    def get_temperaturePerTrianglePerCell(self): return self._temperaturePerTrianglePerCell
    def set_temperaturePerTrianglePerCell(self, value):
        self._temperaturePerTrianglePerCell = value
        update_node(self,self.troot,"phase")
    temperaturePerTrianglePerCell = property(get_temperaturePerTrianglePerCell, set_temperaturePerTrianglePerCell)
    def get_allIterationsProducts(self): return self._allIterationsProducts
    def set_allIterationsProducts(self, value):
        self._allIterationsProducts = value
        update_node(self,self.troot,"phase")
    allIterationsProducts = property(get_allIterationsProducts, set_allIterationsProducts)
    def get_brfProducts(self): return self._brfProducts
    def set_brfProducts(self, value):
        self._brfProducts = value
        update_node(self,self.troot,"phase")
    brfProducts = property(get_brfProducts, set_brfProducts)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.BrfProductsProperties is not None or
            self.lidarProductsProperties is not None or
            self.Order1Options is not None or
            self.ImageBinaryProducts is not None or
            self.radiativeBudgetProperties is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_dartModuleProducts', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_dartModuleProducts')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_dartModuleProducts')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_dartModuleProducts', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_dartModuleProducts'):
        if self.lidarProducts is not None and 'lidarProducts' not in already_processed:
            already_processed.add('lidarProducts')
            outfile.write(' lidarProducts="%s"' % self.gds_format_integer(self.lidarProducts, input_name='lidarProducts'))
        if self.radiativeBudgetProducts is not None and 'radiativeBudgetProducts' not in already_processed:
            already_processed.add('radiativeBudgetProducts')
            outfile.write(' radiativeBudgetProducts="%s"' % self.gds_format_integer(self.radiativeBudgetProducts, input_name='radiativeBudgetProducts'))
        if self.lidarImageProducts is not None and 'lidarImageProducts' not in already_processed:
            already_processed.add('lidarImageProducts')
            outfile.write(' lidarImageProducts="%s"' % self.gds_format_integer(self.lidarImageProducts, input_name='lidarImageProducts'))
        if self.polarizationProducts is not None and 'polarizationProducts' not in already_processed:
            already_processed.add('polarizationProducts')
            outfile.write(' polarizationProducts="%s"' % self.gds_format_integer(self.polarizationProducts, input_name='polarizationProducts'))
        if self.order1Products is not None and 'order1Products' not in already_processed:
            already_processed.add('order1Products')
            outfile.write(' order1Products="%s"' % self.gds_format_integer(self.order1Products, input_name='order1Products'))
        if self.temperaturePerTrianglePerCell is not None and 'temperaturePerTrianglePerCell' not in already_processed:
            already_processed.add('temperaturePerTrianglePerCell')
            outfile.write(' temperaturePerTrianglePerCell="%s"' % self.gds_format_integer(self.temperaturePerTrianglePerCell, input_name='temperaturePerTrianglePerCell'))
        if self.allIterationsProducts is not None and 'allIterationsProducts' not in already_processed:
            already_processed.add('allIterationsProducts')
            outfile.write(' allIterationsProducts="%s"' % self.gds_format_integer(self.allIterationsProducts, input_name='allIterationsProducts'))
        if self.brfProducts is not None and 'brfProducts' not in already_processed:
            already_processed.add('brfProducts')
            outfile.write(' brfProducts="%s"' % self.gds_format_integer(self.brfProducts, input_name='brfProducts'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_dartModuleProducts', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BrfProductsProperties is not None:
            self.BrfProductsProperties.export(outfile, level, namespaceprefix_, name_='BrfProductsProperties', pretty_print=pretty_print)
        if self.lidarProductsProperties is not None:
            self.lidarProductsProperties.export(outfile, level, namespaceprefix_, name_='lidarProductsProperties', pretty_print=pretty_print)
        if self.Order1Options is not None:
            self.Order1Options.export(outfile, level, namespaceprefix_, name_='Order1Options', pretty_print=pretty_print)
        if self.ImageBinaryProducts is not None:
            self.ImageBinaryProducts.export(outfile, level, namespaceprefix_, name_='ImageBinaryProducts', pretty_print=pretty_print)
        if self.radiativeBudgetProperties is not None:
            self.radiativeBudgetProperties.export(outfile, level, namespaceprefix_, name_='radiativeBudgetProperties', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_dartModuleProducts', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.lidarProducts is not None:
            element.set('lidarProducts', self.gds_format_integer(self.lidarProducts))
        if self.radiativeBudgetProducts is not None:
            element.set('radiativeBudgetProducts', self.gds_format_integer(self.radiativeBudgetProducts))
        if self.lidarImageProducts is not None:
            element.set('lidarImageProducts', self.gds_format_integer(self.lidarImageProducts))
        if self.polarizationProducts is not None:
            element.set('polarizationProducts', self.gds_format_integer(self.polarizationProducts))
        if self.order1Products is not None:
            element.set('order1Products', self.gds_format_integer(self.order1Products))
        if self.temperaturePerTrianglePerCell is not None:
            element.set('temperaturePerTrianglePerCell', self.gds_format_integer(self.temperaturePerTrianglePerCell))
        if self.allIterationsProducts is not None:
            element.set('allIterationsProducts', self.gds_format_integer(self.allIterationsProducts))
        if self.brfProducts is not None:
            element.set('brfProducts', self.gds_format_integer(self.brfProducts))
        if self.BrfProductsProperties is not None:
            BrfProductsProperties_ = self.BrfProductsProperties
            BrfProductsProperties_.to_etree(element, name_='BrfProductsProperties', mapping_=mapping_)
        if self.lidarProductsProperties is not None:
            lidarProductsProperties_ = self.lidarProductsProperties
            lidarProductsProperties_.to_etree(element, name_='lidarProductsProperties', mapping_=mapping_)
        if self.Order1Options is not None:
            Order1Options_ = self.Order1Options
            Order1Options_.to_etree(element, name_='Order1Options', mapping_=mapping_)
        if self.ImageBinaryProducts is not None:
            ImageBinaryProducts_ = self.ImageBinaryProducts
            ImageBinaryProducts_.to_etree(element, name_='ImageBinaryProducts', mapping_=mapping_)
        if self.radiativeBudgetProperties is not None:
            radiativeBudgetProperties_ = self.radiativeBudgetProperties
            radiativeBudgetProperties_.to_etree(element, name_='radiativeBudgetProperties', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_dartModuleProducts'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lidarProducts is not None and 'lidarProducts' not in already_processed:
            already_processed.add('lidarProducts')
            showIndent(outfile, level)
            outfile.write('lidarProducts=%d,\n' % (self.lidarProducts,))
        if self.radiativeBudgetProducts is not None and 'radiativeBudgetProducts' not in already_processed:
            already_processed.add('radiativeBudgetProducts')
            showIndent(outfile, level)
            outfile.write('radiativeBudgetProducts=%d,\n' % (self.radiativeBudgetProducts,))
        if self.lidarImageProducts is not None and 'lidarImageProducts' not in already_processed:
            already_processed.add('lidarImageProducts')
            showIndent(outfile, level)
            outfile.write('lidarImageProducts=%d,\n' % (self.lidarImageProducts,))
        if self.polarizationProducts is not None and 'polarizationProducts' not in already_processed:
            already_processed.add('polarizationProducts')
            showIndent(outfile, level)
            outfile.write('polarizationProducts=%d,\n' % (self.polarizationProducts,))
        if self.order1Products is not None and 'order1Products' not in already_processed:
            already_processed.add('order1Products')
            showIndent(outfile, level)
            outfile.write('order1Products=%d,\n' % (self.order1Products,))
        if self.temperaturePerTrianglePerCell is not None and 'temperaturePerTrianglePerCell' not in already_processed:
            already_processed.add('temperaturePerTrianglePerCell')
            showIndent(outfile, level)
            outfile.write('temperaturePerTrianglePerCell=%d,\n' % (self.temperaturePerTrianglePerCell,))
        if self.allIterationsProducts is not None and 'allIterationsProducts' not in already_processed:
            already_processed.add('allIterationsProducts')
            showIndent(outfile, level)
            outfile.write('allIterationsProducts=%d,\n' % (self.allIterationsProducts,))
        if self.brfProducts is not None and 'brfProducts' not in already_processed:
            already_processed.add('brfProducts')
            showIndent(outfile, level)
            outfile.write('brfProducts=%d,\n' % (self.brfProducts,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.BrfProductsProperties is not None:
            showIndent(outfile, level)
            outfile.write('BrfProductsProperties=model_._BrfProductsProperties(\n')
            self.BrfProductsProperties.exportLiteral(outfile, level, name_='BrfProductsProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.lidarProductsProperties is not None:
            showIndent(outfile, level)
            outfile.write('lidarProductsProperties=model_._lidarProductsProperties(\n')
            self.lidarProductsProperties.exportLiteral(outfile, level, name_='lidarProductsProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Order1Options is not None:
            showIndent(outfile, level)
            outfile.write('Order1Options=model_._Order1Options(\n')
            self.Order1Options.exportLiteral(outfile, level, name_='Order1Options')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ImageBinaryProducts is not None:
            showIndent(outfile, level)
            outfile.write('ImageBinaryProducts=model_._ImageBinaryProducts(\n')
            self.ImageBinaryProducts.exportLiteral(outfile, level, name_='ImageBinaryProducts')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.radiativeBudgetProperties is not None:
            showIndent(outfile, level)
            outfile.write('radiativeBudgetProperties=model_._radiativeBudgetProperties(\n')
            self.radiativeBudgetProperties.exportLiteral(outfile, level, name_='radiativeBudgetProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lidarProducts', node)
        if value is not None and 'lidarProducts' not in already_processed:
            already_processed.add('lidarProducts')
            try:
                self.lidarProducts = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('radiativeBudgetProducts', node)
        if value is not None and 'radiativeBudgetProducts' not in already_processed:
            already_processed.add('radiativeBudgetProducts')
            try:
                self.radiativeBudgetProducts = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('lidarImageProducts', node)
        if value is not None and 'lidarImageProducts' not in already_processed:
            already_processed.add('lidarImageProducts')
            try:
                self.lidarImageProducts = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('polarizationProducts', node)
        if value is not None and 'polarizationProducts' not in already_processed:
            already_processed.add('polarizationProducts')
            try:
                self.polarizationProducts = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('order1Products', node)
        if value is not None and 'order1Products' not in already_processed:
            already_processed.add('order1Products')
            try:
                self.order1Products = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('temperaturePerTrianglePerCell', node)
        if value is not None and 'temperaturePerTrianglePerCell' not in already_processed:
            already_processed.add('temperaturePerTrianglePerCell')
            try:
                self.temperaturePerTrianglePerCell = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('allIterationsProducts', node)
        if value is not None and 'allIterationsProducts' not in already_processed:
            already_processed.add('allIterationsProducts')
            try:
                self.allIterationsProducts = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('brfProducts', node)
        if value is not None and 'brfProducts' not in already_processed:
            already_processed.add('brfProducts')
            try:
                self.brfProducts = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BrfProductsProperties':
            obj_ = create_BrfProductsProperties.factory()
            obj_.build(child_)
            self.set_BrfProductsProperties(obj_)
            obj_.original_tagname_ = 'BrfProductsProperties'
        elif nodeName_ == 'lidarProductsProperties':
            obj_ = create_lidarProductsProperties.factory()
            obj_.build(child_)
            self.set_lidarProductsProperties(obj_)
            obj_.original_tagname_ = 'lidarProductsProperties'
        elif nodeName_ == 'Order1Options':
            obj_ = create_Order1Options.factory()
            obj_.build(child_)
            self.set_Order1Options(obj_)
            obj_.original_tagname_ = 'Order1Options'
        elif nodeName_ == 'ImageBinaryProducts':
            obj_ = create_ImageBinaryProducts.factory()
            obj_.build(child_)
            self.set_ImageBinaryProducts(obj_)
            obj_.original_tagname_ = 'ImageBinaryProducts'
        elif nodeName_ == 'radiativeBudgetProperties':
            obj_ = create_radiativeBudgetProperties.factory()
            obj_.build(child_)
            self.set_radiativeBudgetProperties(obj_)
            obj_.original_tagname_ = 'radiativeBudgetProperties'
# end class create_dartModuleProducts


class create_BrfProductsProperties(GeneratedsSuper):
    """BrfProductsProperties BrfProductsProperties This is a threshold on
    the zenith angle of view directions: only images with a zenith
    angle smaller than this threshold are stored (in order to save
    computer memory) This is a threshold on the zenith angle of view
    directions: only images with a zenith angle smaller than this
    threshold are stored (in order to save computer memory)
    Orthoprojection (better use without sensor plane image nor
    oversampling) Orthoprojection (better use without sensor plane
    image nor oversampling) sensorOversampling sensorOversampling
    Number of repeated scenes for image creation Number of repeated
    scenes for image creation Images are projected in the sensor
    plane. Similar images are obtained if a geometric transformation
    is applied to "non sensor plane images" (images simulated on the
    horizontal plane above the scene) Images are projected in the
    sensor plane. Similar images are obtained if a geometric
    transformation is applied to "non sensor plane images" (images
    simulated on the horizontal plane above the scene) A text file
    that gives the mean reflectance factor for all bands A text file
    that gives the mean reflectance factor for all bands
    Extrapolation of radiation products Extrapolation of radiation
    products Images are coded in double Images are coded in double
    Produce mean products and images products in radiance
    [W/m\u00B2/sr/\u03BCm] Produce mean products and images products
    in radiance [W/m\u00B2/sr/\u03BCm] Fluid Transmittance images
    Fluid Transmittance images One text file that gives the mean
    reflectance factor for each upward direction that is selected
    One text file that gives the mean reflectance factor for each
    upward direction that is selected horizontalOversampling
    horizontalOversampling"""
    subclass = None
    superclass = None
    def __init__(self, maximalThetaImages=25.0, projection=0, sensorOversampling=1, nb_scene=1, sensorPlaneprojection=1, centralizedBrfProduct=1, extrapolation=1, image=1, luminanceProducts=0, transmittanceImages=0, brfProduct=1, horizontalOversampling=1, ExpertModeZone_Etalement=None, ExpertModeZone_maskProjection=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_BrfProductsProperties")
        self.attrib = ['maximalThetaImages', 'projection', 'sensorOversampling', 'nb_scene', 'sensorPlaneprojection', 'centralizedBrfProduct', 'extrapolation', 'image', 'luminanceProducts', 'transmittanceImages', 'brfProduct', 'horizontalOversampling']
        self.children = ['ExpertModeZone_Etalement', 'ExpertModeZone_maskProjection']
        self.parent = None
        self._maximalThetaImages = _cast(float, maximalThetaImages)
        self._projection = _cast(int, projection)
        self._sensorOversampling = _cast(int, sensorOversampling)
        self._nb_scene = _cast(int, nb_scene)
        self._sensorPlaneprojection = _cast(int, sensorPlaneprojection)
        self._centralizedBrfProduct = _cast(int, centralizedBrfProduct)
        self._extrapolation = _cast(int, extrapolation)
        self._image = _cast(int, image)
        self._luminanceProducts = _cast(int, luminanceProducts)
        self._transmittanceImages = _cast(int, transmittanceImages)
        self._brfProduct = _cast(int, brfProduct)
        self._horizontalOversampling = _cast(int, horizontalOversampling)
        self._ExpertModeZone_Etalement = ExpertModeZone_Etalement
        self._ExpertModeZone_maskProjection = ExpertModeZone_maskProjection
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_BrfProductsProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_BrfProductsProperties.subclass:
            return create_BrfProductsProperties.subclass(*args_, **kwargs_)
        else:
            return create_BrfProductsProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ExpertModeZone_Etalement(self): return self._ExpertModeZone_Etalement
    def set_ExpertModeZone_Etalement(self, value):
        if value is not None:
            checkclass(value, create_ExpertModeZone_Etalement)
            value.parent = self
        self._ExpertModeZone_Etalement = value
    ExpertModeZone_Etalement = property(get_ExpertModeZone_Etalement, set_ExpertModeZone_Etalement)
    def get_ExpertModeZone_maskProjection(self): return self._ExpertModeZone_maskProjection
    def set_ExpertModeZone_maskProjection(self, value):
        if value is not None:
            checkclass(value, create_ExpertModeZone_maskProjection)
            value.parent = self
        self._ExpertModeZone_maskProjection = value
    ExpertModeZone_maskProjection = property(get_ExpertModeZone_maskProjection, set_ExpertModeZone_maskProjection)
    def get_maximalThetaImages(self): return self._maximalThetaImages
    def set_maximalThetaImages(self, value):
        self._maximalThetaImages = value
        update_node(self,self.troot,"phase")
    maximalThetaImages = property(get_maximalThetaImages, set_maximalThetaImages)
    def get_projection(self): return self._projection
    def set_projection(self, value):
        self._projection = value
        update_node(self,self.troot,"phase")
    projection = property(get_projection, set_projection)
    def get_sensorOversampling(self): return self._sensorOversampling
    def set_sensorOversampling(self, value):
        self._sensorOversampling = value
        update_node(self,self.troot,"phase")
    sensorOversampling = property(get_sensorOversampling, set_sensorOversampling)
    def get_nb_scene(self): return self._nb_scene
    def set_nb_scene(self, value):
        self._nb_scene = value
        update_node(self,self.troot,"phase")
    nb_scene = property(get_nb_scene, set_nb_scene)
    def get_sensorPlaneprojection(self): return self._sensorPlaneprojection
    def set_sensorPlaneprojection(self, value):
        self._sensorPlaneprojection = value
        update_node(self,self.troot,"phase")
    sensorPlaneprojection = property(get_sensorPlaneprojection, set_sensorPlaneprojection)
    def get_centralizedBrfProduct(self): return self._centralizedBrfProduct
    def set_centralizedBrfProduct(self, value):
        self._centralizedBrfProduct = value
        update_node(self,self.troot,"phase")
    centralizedBrfProduct = property(get_centralizedBrfProduct, set_centralizedBrfProduct)
    def get_extrapolation(self): return self._extrapolation
    def set_extrapolation(self, value):
        self._extrapolation = value
        update_node(self,self.troot,"phase")
    extrapolation = property(get_extrapolation, set_extrapolation)
    def get_image(self): return self._image
    def set_image(self, value):
        self._image = value
        update_node(self,self.troot,"phase")
    image = property(get_image, set_image)
    def get_luminanceProducts(self): return self._luminanceProducts
    def set_luminanceProducts(self, value):
        self._luminanceProducts = value
        update_node(self,self.troot,"phase")
    luminanceProducts = property(get_luminanceProducts, set_luminanceProducts)
    def get_transmittanceImages(self): return self._transmittanceImages
    def set_transmittanceImages(self, value):
        self._transmittanceImages = value
        update_node(self,self.troot,"phase")
    transmittanceImages = property(get_transmittanceImages, set_transmittanceImages)
    def get_brfProduct(self): return self._brfProduct
    def set_brfProduct(self, value):
        self._brfProduct = value
        update_node(self,self.troot,"phase")
    brfProduct = property(get_brfProduct, set_brfProduct)
    def get_horizontalOversampling(self): return self._horizontalOversampling
    def set_horizontalOversampling(self, value):
        self._horizontalOversampling = value
        update_node(self,self.troot,"phase")
    horizontalOversampling = property(get_horizontalOversampling, set_horizontalOversampling)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.ExpertModeZone_Etalement is not None or
            self.ExpertModeZone_maskProjection is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_BrfProductsProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_BrfProductsProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_BrfProductsProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_BrfProductsProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_BrfProductsProperties'):
        if self.maximalThetaImages is not None and 'maximalThetaImages' not in already_processed:
            already_processed.add('maximalThetaImages')
            outfile.write(' maximalThetaImages="%s"' % self.gds_format_double(self.maximalThetaImages, input_name='maximalThetaImages'))
        if self.projection is not None and 'projection' not in already_processed:
            already_processed.add('projection')
            outfile.write(' projection="%s"' % self.gds_format_integer(self.projection, input_name='projection'))
        if self.sensorOversampling is not None and 'sensorOversampling' not in already_processed:
            already_processed.add('sensorOversampling')
            outfile.write(' sensorOversampling="%s"' % self.gds_format_integer(self.sensorOversampling, input_name='sensorOversampling'))
        if self.nb_scene is not None and 'nb_scene' not in already_processed:
            already_processed.add('nb_scene')
            outfile.write(' nb_scene="%s"' % self.gds_format_integer(self.nb_scene, input_name='nb_scene'))
        if self.sensorPlaneprojection is not None and 'sensorPlaneprojection' not in already_processed:
            already_processed.add('sensorPlaneprojection')
            outfile.write(' sensorPlaneprojection="%s"' % self.gds_format_integer(self.sensorPlaneprojection, input_name='sensorPlaneprojection'))
        if self.centralizedBrfProduct is not None and 'centralizedBrfProduct' not in already_processed:
            already_processed.add('centralizedBrfProduct')
            outfile.write(' centralizedBrfProduct="%s"' % self.gds_format_integer(self.centralizedBrfProduct, input_name='centralizedBrfProduct'))
        if self.extrapolation is not None and 'extrapolation' not in already_processed:
            already_processed.add('extrapolation')
            outfile.write(' extrapolation="%s"' % self.gds_format_integer(self.extrapolation, input_name='extrapolation'))
        if self.image is not None and 'image' not in already_processed:
            already_processed.add('image')
            outfile.write(' image="%s"' % self.gds_format_integer(self.image, input_name='image'))
        if self.luminanceProducts is not None and 'luminanceProducts' not in already_processed:
            already_processed.add('luminanceProducts')
            outfile.write(' luminanceProducts="%s"' % self.gds_format_integer(self.luminanceProducts, input_name='luminanceProducts'))
        if self.transmittanceImages is not None and 'transmittanceImages' not in already_processed:
            already_processed.add('transmittanceImages')
            outfile.write(' transmittanceImages="%s"' % self.gds_format_integer(self.transmittanceImages, input_name='transmittanceImages'))
        if self.brfProduct is not None and 'brfProduct' not in already_processed:
            already_processed.add('brfProduct')
            outfile.write(' brfProduct="%s"' % self.gds_format_integer(self.brfProduct, input_name='brfProduct'))
        if self.horizontalOversampling is not None and 'horizontalOversampling' not in already_processed:
            already_processed.add('horizontalOversampling')
            outfile.write(' horizontalOversampling="%s"' % self.gds_format_integer(self.horizontalOversampling, input_name='horizontalOversampling'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_BrfProductsProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ExpertModeZone_Etalement is not None:
            self.ExpertModeZone_Etalement.export(outfile, level, namespaceprefix_, name_='ExpertModeZone_Etalement', pretty_print=pretty_print)
        if self.ExpertModeZone_maskProjection is not None:
            self.ExpertModeZone_maskProjection.export(outfile, level, namespaceprefix_, name_='ExpertModeZone_maskProjection', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_BrfProductsProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.maximalThetaImages is not None:
            element.set('maximalThetaImages', self.gds_format_double(self.maximalThetaImages))
        if self.projection is not None:
            element.set('projection', self.gds_format_integer(self.projection))
        if self.sensorOversampling is not None:
            element.set('sensorOversampling', self.gds_format_integer(self.sensorOversampling))
        if self.nb_scene is not None:
            element.set('nb_scene', self.gds_format_integer(self.nb_scene))
        if self.sensorPlaneprojection is not None:
            element.set('sensorPlaneprojection', self.gds_format_integer(self.sensorPlaneprojection))
        if self.centralizedBrfProduct is not None:
            element.set('centralizedBrfProduct', self.gds_format_integer(self.centralizedBrfProduct))
        if self.extrapolation is not None:
            element.set('extrapolation', self.gds_format_integer(self.extrapolation))
        if self.image is not None:
            element.set('image', self.gds_format_integer(self.image))
        if self.luminanceProducts is not None:
            element.set('luminanceProducts', self.gds_format_integer(self.luminanceProducts))
        if self.transmittanceImages is not None:
            element.set('transmittanceImages', self.gds_format_integer(self.transmittanceImages))
        if self.brfProduct is not None:
            element.set('brfProduct', self.gds_format_integer(self.brfProduct))
        if self.horizontalOversampling is not None:
            element.set('horizontalOversampling', self.gds_format_integer(self.horizontalOversampling))
        if self.ExpertModeZone_Etalement is not None:
            ExpertModeZone_Etalement_ = self.ExpertModeZone_Etalement
            ExpertModeZone_Etalement_.to_etree(element, name_='ExpertModeZone_Etalement', mapping_=mapping_)
        if self.ExpertModeZone_maskProjection is not None:
            ExpertModeZone_maskProjection_ = self.ExpertModeZone_maskProjection
            ExpertModeZone_maskProjection_.to_etree(element, name_='ExpertModeZone_maskProjection', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_BrfProductsProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.maximalThetaImages is not None and 'maximalThetaImages' not in already_processed:
            already_processed.add('maximalThetaImages')
            showIndent(outfile, level)
            outfile.write('maximalThetaImages=%e,\n' % (self.maximalThetaImages,))
        if self.projection is not None and 'projection' not in already_processed:
            already_processed.add('projection')
            showIndent(outfile, level)
            outfile.write('projection=%d,\n' % (self.projection,))
        if self.sensorOversampling is not None and 'sensorOversampling' not in already_processed:
            already_processed.add('sensorOversampling')
            showIndent(outfile, level)
            outfile.write('sensorOversampling=%d,\n' % (self.sensorOversampling,))
        if self.nb_scene is not None and 'nb_scene' not in already_processed:
            already_processed.add('nb_scene')
            showIndent(outfile, level)
            outfile.write('nb_scene=%d,\n' % (self.nb_scene,))
        if self.sensorPlaneprojection is not None and 'sensorPlaneprojection' not in already_processed:
            already_processed.add('sensorPlaneprojection')
            showIndent(outfile, level)
            outfile.write('sensorPlaneprojection=%d,\n' % (self.sensorPlaneprojection,))
        if self.centralizedBrfProduct is not None and 'centralizedBrfProduct' not in already_processed:
            already_processed.add('centralizedBrfProduct')
            showIndent(outfile, level)
            outfile.write('centralizedBrfProduct=%d,\n' % (self.centralizedBrfProduct,))
        if self.extrapolation is not None and 'extrapolation' not in already_processed:
            already_processed.add('extrapolation')
            showIndent(outfile, level)
            outfile.write('extrapolation=%d,\n' % (self.extrapolation,))
        if self.image is not None and 'image' not in already_processed:
            already_processed.add('image')
            showIndent(outfile, level)
            outfile.write('image=%d,\n' % (self.image,))
        if self.luminanceProducts is not None and 'luminanceProducts' not in already_processed:
            already_processed.add('luminanceProducts')
            showIndent(outfile, level)
            outfile.write('luminanceProducts=%d,\n' % (self.luminanceProducts,))
        if self.transmittanceImages is not None and 'transmittanceImages' not in already_processed:
            already_processed.add('transmittanceImages')
            showIndent(outfile, level)
            outfile.write('transmittanceImages=%d,\n' % (self.transmittanceImages,))
        if self.brfProduct is not None and 'brfProduct' not in already_processed:
            already_processed.add('brfProduct')
            showIndent(outfile, level)
            outfile.write('brfProduct=%d,\n' % (self.brfProduct,))
        if self.horizontalOversampling is not None and 'horizontalOversampling' not in already_processed:
            already_processed.add('horizontalOversampling')
            showIndent(outfile, level)
            outfile.write('horizontalOversampling=%d,\n' % (self.horizontalOversampling,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ExpertModeZone_Etalement is not None:
            showIndent(outfile, level)
            outfile.write('ExpertModeZone_Etalement=model_._ExpertModeZone_Etalement(\n')
            self.ExpertModeZone_Etalement.exportLiteral(outfile, level, name_='ExpertModeZone_Etalement')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ExpertModeZone_maskProjection is not None:
            showIndent(outfile, level)
            outfile.write('ExpertModeZone_maskProjection=model_._ExpertModeZone_maskProjection(\n')
            self.ExpertModeZone_maskProjection.exportLiteral(outfile, level, name_='ExpertModeZone_maskProjection')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('maximalThetaImages', node)
        if value is not None and 'maximalThetaImages' not in already_processed:
            already_processed.add('maximalThetaImages')
            try:
                self.maximalThetaImages = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (maximalThetaImages): %s' % exp)
        value = find_attr_value_('projection', node)
        if value is not None and 'projection' not in already_processed:
            already_processed.add('projection')
            try:
                self.projection = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('sensorOversampling', node)
        if value is not None and 'sensorOversampling' not in already_processed:
            already_processed.add('sensorOversampling')
            try:
                self.sensorOversampling = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('nb_scene', node)
        if value is not None and 'nb_scene' not in already_processed:
            already_processed.add('nb_scene')
            try:
                self.nb_scene = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('sensorPlaneprojection', node)
        if value is not None and 'sensorPlaneprojection' not in already_processed:
            already_processed.add('sensorPlaneprojection')
            try:
                self.sensorPlaneprojection = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('centralizedBrfProduct', node)
        if value is not None and 'centralizedBrfProduct' not in already_processed:
            already_processed.add('centralizedBrfProduct')
            try:
                self.centralizedBrfProduct = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('extrapolation', node)
        if value is not None and 'extrapolation' not in already_processed:
            already_processed.add('extrapolation')
            try:
                self.extrapolation = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('image', node)
        if value is not None and 'image' not in already_processed:
            already_processed.add('image')
            try:
                self.image = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('luminanceProducts', node)
        if value is not None and 'luminanceProducts' not in already_processed:
            already_processed.add('luminanceProducts')
            try:
                self.luminanceProducts = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('transmittanceImages', node)
        if value is not None and 'transmittanceImages' not in already_processed:
            already_processed.add('transmittanceImages')
            try:
                self.transmittanceImages = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('brfProduct', node)
        if value is not None and 'brfProduct' not in already_processed:
            already_processed.add('brfProduct')
            try:
                self.brfProduct = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('horizontalOversampling', node)
        if value is not None and 'horizontalOversampling' not in already_processed:
            already_processed.add('horizontalOversampling')
            try:
                self.horizontalOversampling = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExpertModeZone_Etalement':
            obj_ = create_ExpertModeZone_Etalement.factory()
            obj_.build(child_)
            self.set_ExpertModeZone_Etalement(obj_)
            obj_.original_tagname_ = 'ExpertModeZone_Etalement'
        elif nodeName_ == 'ExpertModeZone_maskProjection':
            obj_ = create_ExpertModeZone_maskProjection.factory()
            obj_.build(child_)
            self.set_ExpertModeZone_maskProjection(obj_)
            obj_.original_tagname_ = 'ExpertModeZone_maskProjection'
# end class create_BrfProductsProperties


class create_ExpertModeZone_Etalement(GeneratedsSuper):
    """ExpertModeZone_Etalement ExpertModeZone_Etalement The energy of rays
    reaching the image layer will be (or not) repartie in the pixels
    in function of the original figure's projection. The energy of
    rays reaching the image layer will be (or not) repartie in the
    pixels in function of the original figure's projection."""
    subclass = None
    superclass = None
    def __init__(self, etalement=2, ExpertModeZone_Projection=None, ExpertModeZone_PerTypeProduct=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_ExpertModeZone_Etalement")
        self.attrib = ['etalement']
        self.children = ['ExpertModeZone_Projection', 'ExpertModeZone_PerTypeProduct']
        self.parent = None
        self._etalement = _cast(int, etalement)
        self._ExpertModeZone_Projection = ExpertModeZone_Projection
        self._ExpertModeZone_PerTypeProduct = ExpertModeZone_PerTypeProduct
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ExpertModeZone_Etalement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ExpertModeZone_Etalement.subclass:
            return create_ExpertModeZone_Etalement.subclass(*args_, **kwargs_)
        else:
            return create_ExpertModeZone_Etalement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ExpertModeZone_Projection(self): return self._ExpertModeZone_Projection
    def set_ExpertModeZone_Projection(self, value):
        if value is not None:
            checkclass(value, create_ExpertModeZone_Projection)
            value.parent = self
        self._ExpertModeZone_Projection = value
    ExpertModeZone_Projection = property(get_ExpertModeZone_Projection, set_ExpertModeZone_Projection)
    def get_ExpertModeZone_PerTypeProduct(self): return self._ExpertModeZone_PerTypeProduct
    def set_ExpertModeZone_PerTypeProduct(self, value):
        if value is not None:
            checkclass(value, create_ExpertModeZone_PerTypeProduct)
            value.parent = self
        self._ExpertModeZone_PerTypeProduct = value
    ExpertModeZone_PerTypeProduct = property(get_ExpertModeZone_PerTypeProduct, set_ExpertModeZone_PerTypeProduct)
    def get_etalement(self): return self._etalement
    def set_etalement(self, value):
        self._etalement = value
        update_node(self,self.troot,"phase")
    etalement = property(get_etalement, set_etalement)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.ExpertModeZone_Projection is not None or
            self.ExpertModeZone_PerTypeProduct is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ExpertModeZone_Etalement', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ExpertModeZone_Etalement')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ExpertModeZone_Etalement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ExpertModeZone_Etalement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ExpertModeZone_Etalement'):
        if self.etalement is not None and 'etalement' not in already_processed:
            already_processed.add('etalement')
            outfile.write(' etalement="%s"' % self.gds_format_integer(self.etalement, input_name='etalement'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ExpertModeZone_Etalement', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ExpertModeZone_Projection is not None:
            self.ExpertModeZone_Projection.export(outfile, level, namespaceprefix_, name_='ExpertModeZone_Projection', pretty_print=pretty_print)
        if self.ExpertModeZone_PerTypeProduct is not None:
            self.ExpertModeZone_PerTypeProduct.export(outfile, level, namespaceprefix_, name_='ExpertModeZone_PerTypeProduct', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_ExpertModeZone_Etalement', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.etalement is not None:
            element.set('etalement', self.gds_format_integer(self.etalement))
        if self.ExpertModeZone_Projection is not None:
            ExpertModeZone_Projection_ = self.ExpertModeZone_Projection
            ExpertModeZone_Projection_.to_etree(element, name_='ExpertModeZone_Projection', mapping_=mapping_)
        if self.ExpertModeZone_PerTypeProduct is not None:
            ExpertModeZone_PerTypeProduct_ = self.ExpertModeZone_PerTypeProduct
            ExpertModeZone_PerTypeProduct_.to_etree(element, name_='ExpertModeZone_PerTypeProduct', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ExpertModeZone_Etalement'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.etalement is not None and 'etalement' not in already_processed:
            already_processed.add('etalement')
            showIndent(outfile, level)
            outfile.write('etalement=%d,\n' % (self.etalement,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ExpertModeZone_Projection is not None:
            showIndent(outfile, level)
            outfile.write('ExpertModeZone_Projection=model_._ExpertModeZone_Projection(\n')
            self.ExpertModeZone_Projection.exportLiteral(outfile, level, name_='ExpertModeZone_Projection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ExpertModeZone_PerTypeProduct is not None:
            showIndent(outfile, level)
            outfile.write('ExpertModeZone_PerTypeProduct=model_._ExpertModeZone_PerTypeProduct(\n')
            self.ExpertModeZone_PerTypeProduct.exportLiteral(outfile, level, name_='ExpertModeZone_PerTypeProduct')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('etalement', node)
        if value is not None and 'etalement' not in already_processed:
            already_processed.add('etalement')
            try:
                self.etalement = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExpertModeZone_Projection':
            obj_ = create_ExpertModeZone_Projection.factory()
            obj_.build(child_)
            self.set_ExpertModeZone_Projection(obj_)
            obj_.original_tagname_ = 'ExpertModeZone_Projection'
        elif nodeName_ == 'ExpertModeZone_PerTypeProduct':
            obj_ = create_ExpertModeZone_PerTypeProduct.factory()
            obj_.build(child_)
            self.set_ExpertModeZone_PerTypeProduct(obj_)
            obj_.original_tagname_ = 'ExpertModeZone_PerTypeProduct'
# end class create_ExpertModeZone_Etalement


class create_ExpertModeZone_Projection(GeneratedsSuper):
    """ExpertModeZone_Projection ExpertModeZone_Projection Select this
    option if you intend to resample your images (through the
    resampling tool).\nAnother way to do it is to deactivate the
    projection in DART itself, and to use the tool to project (and
    resample) the generated horizontal images. Select this option if
    you intend to resample your images (through the resampling
    tool).\nAnother way to do it is to deactivate the projection in
    DART itself, and to use the tool to project (and resample) the
    generated horizontal images."""
    subclass = None
    superclass = None
    def __init__(self, keepNonProjectedImage=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_ExpertModeZone_Projection")
        self.attrib = ['keepNonProjectedImage']
        self.children = []
        self.parent = None
        self._keepNonProjectedImage = _cast(int, keepNonProjectedImage)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ExpertModeZone_Projection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ExpertModeZone_Projection.subclass:
            return create_ExpertModeZone_Projection.subclass(*args_, **kwargs_)
        else:
            return create_ExpertModeZone_Projection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_keepNonProjectedImage(self): return self._keepNonProjectedImage
    def set_keepNonProjectedImage(self, value):
        self._keepNonProjectedImage = value
        update_node(self,self.troot,"phase")
    keepNonProjectedImage = property(get_keepNonProjectedImage, set_keepNonProjectedImage)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ExpertModeZone_Projection', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ExpertModeZone_Projection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ExpertModeZone_Projection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ExpertModeZone_Projection', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ExpertModeZone_Projection'):
        if self.keepNonProjectedImage is not None and 'keepNonProjectedImage' not in already_processed:
            already_processed.add('keepNonProjectedImage')
            outfile.write(' keepNonProjectedImage="%s"' % self.gds_format_integer(self.keepNonProjectedImage, input_name='keepNonProjectedImage'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ExpertModeZone_Projection', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_ExpertModeZone_Projection', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.keepNonProjectedImage is not None:
            element.set('keepNonProjectedImage', self.gds_format_integer(self.keepNonProjectedImage))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ExpertModeZone_Projection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.keepNonProjectedImage is not None and 'keepNonProjectedImage' not in already_processed:
            already_processed.add('keepNonProjectedImage')
            showIndent(outfile, level)
            outfile.write('keepNonProjectedImage=%d,\n' % (self.keepNonProjectedImage,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('keepNonProjectedImage', node)
        if value is not None and 'keepNonProjectedImage' not in already_processed:
            already_processed.add('keepNonProjectedImage')
            try:
                self.keepNonProjectedImage = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_ExpertModeZone_Projection


class create_ExpertModeZone_PerTypeProduct(GeneratedsSuper):
    """Generates seperated images for each type/color defined in the scene
    (such as roads, walls, vegetation or any custom type defined for
    3D imported objects).\nCurrently only available for the option
    "Precise (slow)" Spreading of rays\n Generates seperated images
    for each type/color defined in the scene (such as roads, walls,
    vegetation or any custom type defined for 3D imported
    objects).\nCurrently only available for the option "Precise
    (slow)" Spreading of rays\n"""
    subclass = None
    superclass = None
    def __init__(self, generatePerTypeProduct=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_ExpertModeZone_PerTypeProduct")
        self.attrib = ['generatePerTypeProduct']
        self.children = []
        self.parent = None
        self._generatePerTypeProduct = _cast(int, generatePerTypeProduct)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ExpertModeZone_PerTypeProduct)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ExpertModeZone_PerTypeProduct.subclass:
            return create_ExpertModeZone_PerTypeProduct.subclass(*args_, **kwargs_)
        else:
            return create_ExpertModeZone_PerTypeProduct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_generatePerTypeProduct(self): return self._generatePerTypeProduct
    def set_generatePerTypeProduct(self, value):
        self._generatePerTypeProduct = value
        update_node(self,self.troot,"phase")
    generatePerTypeProduct = property(get_generatePerTypeProduct, set_generatePerTypeProduct)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ExpertModeZone_PerTypeProduct', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ExpertModeZone_PerTypeProduct')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ExpertModeZone_PerTypeProduct')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ExpertModeZone_PerTypeProduct', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ExpertModeZone_PerTypeProduct'):
        if self.generatePerTypeProduct is not None and 'generatePerTypeProduct' not in already_processed:
            already_processed.add('generatePerTypeProduct')
            outfile.write(' generatePerTypeProduct="%s"' % self.gds_format_integer(self.generatePerTypeProduct, input_name='generatePerTypeProduct'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ExpertModeZone_PerTypeProduct', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_ExpertModeZone_PerTypeProduct', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.generatePerTypeProduct is not None:
            element.set('generatePerTypeProduct', self.gds_format_integer(self.generatePerTypeProduct))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ExpertModeZone_PerTypeProduct'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.generatePerTypeProduct is not None and 'generatePerTypeProduct' not in already_processed:
            already_processed.add('generatePerTypeProduct')
            showIndent(outfile, level)
            outfile.write('generatePerTypeProduct=%d,\n' % (self.generatePerTypeProduct,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('generatePerTypeProduct', node)
        if value is not None and 'generatePerTypeProduct' not in already_processed:
            already_processed.add('generatePerTypeProduct')
            try:
                self.generatePerTypeProduct = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_ExpertModeZone_PerTypeProduct


class create_ExpertModeZone_maskProjection(GeneratedsSuper):
    """ExpertModeZone_maskProjection ExpertModeZone_maskProjection
    Irradiance, Exitance and Albedo images Irradiance, Exitance and
    Albedo images"""
    subclass = None
    superclass = None
    def __init__(self, albedoImages=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_ExpertModeZone_maskProjection")
        self.attrib = ['albedoImages']
        self.children = []
        self.parent = None
        self._albedoImages = _cast(int, albedoImages)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ExpertModeZone_maskProjection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ExpertModeZone_maskProjection.subclass:
            return create_ExpertModeZone_maskProjection.subclass(*args_, **kwargs_)
        else:
            return create_ExpertModeZone_maskProjection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_albedoImages(self): return self._albedoImages
    def set_albedoImages(self, value):
        self._albedoImages = value
        update_node(self,self.troot,"phase")
    albedoImages = property(get_albedoImages, set_albedoImages)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ExpertModeZone_maskProjection', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ExpertModeZone_maskProjection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ExpertModeZone_maskProjection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ExpertModeZone_maskProjection', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ExpertModeZone_maskProjection'):
        if self.albedoImages is not None and 'albedoImages' not in already_processed:
            already_processed.add('albedoImages')
            outfile.write(' albedoImages="%s"' % self.gds_format_integer(self.albedoImages, input_name='albedoImages'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ExpertModeZone_maskProjection', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_ExpertModeZone_maskProjection', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.albedoImages is not None:
            element.set('albedoImages', self.gds_format_integer(self.albedoImages))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ExpertModeZone_maskProjection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.albedoImages is not None and 'albedoImages' not in already_processed:
            already_processed.add('albedoImages')
            showIndent(outfile, level)
            outfile.write('albedoImages=%d,\n' % (self.albedoImages,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('albedoImages', node)
        if value is not None and 'albedoImages' not in already_processed:
            already_processed.add('albedoImages')
            try:
                self.albedoImages = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_ExpertModeZone_maskProjection


class create_lidarProductsProperties(GeneratedsSuper):
    """lidarProductsProperties lidarProductsProperties Convolved Waveform
    Convolved Waveform Photons informations (allows a 3D view of
    photon interactions in "view-LIDAR") Photons informations
    (allows a 3D view of photon interactions in "view-LIDAR")
    Photons ground image Photons ground image Generate
    Lidar_image_panel.txt, which is used by DART LiDAR viewer.
    Generate Lidar_image_panel.txt, which is used by DART LiDAR
    viewer."""
    subclass = None
    superclass = None
    def __init__(self, convolvedWaveform=1, photonInformations=0, groundSensorImage=0, lidarImagePanelInformation=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_lidarProductsProperties")
        self.attrib = ['convolvedWaveform', 'photonInformations', 'groundSensorImage', 'lidarImagePanelInformation']
        self.children = []
        self.parent = None
        self._convolvedWaveform = _cast(int, convolvedWaveform)
        self._photonInformations = _cast(int, photonInformations)
        self._groundSensorImage = _cast(int, groundSensorImage)
        self._lidarImagePanelInformation = _cast(int, lidarImagePanelInformation)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_lidarProductsProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_lidarProductsProperties.subclass:
            return create_lidarProductsProperties.subclass(*args_, **kwargs_)
        else:
            return create_lidarProductsProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_convolvedWaveform(self): return self._convolvedWaveform
    def set_convolvedWaveform(self, value):
        self._convolvedWaveform = value
        update_node(self,self.troot,"phase")
    convolvedWaveform = property(get_convolvedWaveform, set_convolvedWaveform)
    def get_photonInformations(self): return self._photonInformations
    def set_photonInformations(self, value):
        self._photonInformations = value
        update_node(self,self.troot,"phase")
    photonInformations = property(get_photonInformations, set_photonInformations)
    def get_groundSensorImage(self): return self._groundSensorImage
    def set_groundSensorImage(self, value):
        self._groundSensorImage = value
        update_node(self,self.troot,"phase")
    groundSensorImage = property(get_groundSensorImage, set_groundSensorImage)
    def get_lidarImagePanelInformation(self): return self._lidarImagePanelInformation
    def set_lidarImagePanelInformation(self, value):
        self._lidarImagePanelInformation = value
        update_node(self,self.troot,"phase")
    lidarImagePanelInformation = property(get_lidarImagePanelInformation, set_lidarImagePanelInformation)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_lidarProductsProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_lidarProductsProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_lidarProductsProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_lidarProductsProperties', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_lidarProductsProperties'):
        if self.convolvedWaveform is not None and 'convolvedWaveform' not in already_processed:
            already_processed.add('convolvedWaveform')
            outfile.write(' convolvedWaveform="%s"' % self.gds_format_integer(self.convolvedWaveform, input_name='convolvedWaveform'))
        if self.photonInformations is not None and 'photonInformations' not in already_processed:
            already_processed.add('photonInformations')
            outfile.write(' photonInformations="%s"' % self.gds_format_integer(self.photonInformations, input_name='photonInformations'))
        if self.groundSensorImage is not None and 'groundSensorImage' not in already_processed:
            already_processed.add('groundSensorImage')
            outfile.write(' groundSensorImage="%s"' % self.gds_format_integer(self.groundSensorImage, input_name='groundSensorImage'))
        if self.lidarImagePanelInformation is not None and 'lidarImagePanelInformation' not in already_processed:
            already_processed.add('lidarImagePanelInformation')
            outfile.write(' lidarImagePanelInformation="%s"' % self.gds_format_integer(self.lidarImagePanelInformation, input_name='lidarImagePanelInformation'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_lidarProductsProperties', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_lidarProductsProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.convolvedWaveform is not None:
            element.set('convolvedWaveform', self.gds_format_integer(self.convolvedWaveform))
        if self.photonInformations is not None:
            element.set('photonInformations', self.gds_format_integer(self.photonInformations))
        if self.groundSensorImage is not None:
            element.set('groundSensorImage', self.gds_format_integer(self.groundSensorImage))
        if self.lidarImagePanelInformation is not None:
            element.set('lidarImagePanelInformation', self.gds_format_integer(self.lidarImagePanelInformation))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_lidarProductsProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.convolvedWaveform is not None and 'convolvedWaveform' not in already_processed:
            already_processed.add('convolvedWaveform')
            showIndent(outfile, level)
            outfile.write('convolvedWaveform=%d,\n' % (self.convolvedWaveform,))
        if self.photonInformations is not None and 'photonInformations' not in already_processed:
            already_processed.add('photonInformations')
            showIndent(outfile, level)
            outfile.write('photonInformations=%d,\n' % (self.photonInformations,))
        if self.groundSensorImage is not None and 'groundSensorImage' not in already_processed:
            already_processed.add('groundSensorImage')
            showIndent(outfile, level)
            outfile.write('groundSensorImage=%d,\n' % (self.groundSensorImage,))
        if self.lidarImagePanelInformation is not None and 'lidarImagePanelInformation' not in already_processed:
            already_processed.add('lidarImagePanelInformation')
            showIndent(outfile, level)
            outfile.write('lidarImagePanelInformation=%d,\n' % (self.lidarImagePanelInformation,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('convolvedWaveform', node)
        if value is not None and 'convolvedWaveform' not in already_processed:
            already_processed.add('convolvedWaveform')
            try:
                self.convolvedWaveform = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('photonInformations', node)
        if value is not None and 'photonInformations' not in already_processed:
            already_processed.add('photonInformations')
            try:
                self.photonInformations = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('groundSensorImage', node)
        if value is not None and 'groundSensorImage' not in already_processed:
            already_processed.add('groundSensorImage')
            try:
                self.groundSensorImage = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('lidarImagePanelInformation', node)
        if value is not None and 'lidarImagePanelInformation' not in already_processed:
            already_processed.add('lidarImagePanelInformation')
            try:
                self.lidarImagePanelInformation = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_lidarProductsProperties


class create_Order1Options(GeneratedsSuper):
    """Storage of intercepted radiation is disabled after order 1
    scattering. Saves RAM usage and time. Storage of intercepted
    radiation is disabled after order 1 scattering. Saves RAM usage
    and time. Scattering/thermal emission only for directions for
    which images are created. May save up a lot of time.
    Scattering/thermal emission only for directions for which images
    are created. May save up a lot of time."""
    subclass = None
    superclass = None
    def __init__(self, order1Only=0, imagesOnly=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_Order1Options")
        self.attrib = ['order1Only', 'imagesOnly']
        self.children = []
        self.parent = None
        self._order1Only = _cast(int, order1Only)
        self._imagesOnly = _cast(int, imagesOnly)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Order1Options)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Order1Options.subclass:
            return create_Order1Options.subclass(*args_, **kwargs_)
        else:
            return create_Order1Options(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_order1Only(self): return self._order1Only
    def set_order1Only(self, value):
        self._order1Only = value
        update_node(self,self.troot,"phase")
    order1Only = property(get_order1Only, set_order1Only)
    def get_imagesOnly(self): return self._imagesOnly
    def set_imagesOnly(self, value):
        self._imagesOnly = value
        update_node(self,self.troot,"phase")
    imagesOnly = property(get_imagesOnly, set_imagesOnly)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Order1Options', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Order1Options')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Order1Options')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Order1Options', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Order1Options'):
        if self.order1Only is not None and 'order1Only' not in already_processed:
            already_processed.add('order1Only')
            outfile.write(' order1Only="%s"' % self.gds_format_integer(self.order1Only, input_name='order1Only'))
        if self.imagesOnly is not None and 'imagesOnly' not in already_processed:
            already_processed.add('imagesOnly')
            outfile.write(' imagesOnly="%s"' % self.gds_format_integer(self.imagesOnly, input_name='imagesOnly'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Order1Options', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_Order1Options', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.order1Only is not None:
            element.set('order1Only', self.gds_format_integer(self.order1Only))
        if self.imagesOnly is not None:
            element.set('imagesOnly', self.gds_format_integer(self.imagesOnly))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Order1Options'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.order1Only is not None and 'order1Only' not in already_processed:
            already_processed.add('order1Only')
            showIndent(outfile, level)
            outfile.write('order1Only=%d,\n' % (self.order1Only,))
        if self.imagesOnly is not None and 'imagesOnly' not in already_processed:
            already_processed.add('imagesOnly')
            showIndent(outfile, level)
            outfile.write('imagesOnly=%d,\n' % (self.imagesOnly,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('order1Only', node)
        if value is not None and 'order1Only' not in already_processed:
            already_processed.add('order1Only')
            try:
                self.order1Only = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('imagesOnly', node)
        if value is not None and 'imagesOnly' not in already_processed:
            already_processed.add('imagesOnly')
            try:
                self.imagesOnly = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_Order1Options


class create_ImageBinaryProducts(GeneratedsSuper):
    """ImageBinaryProducts ImageBinaryProducts Store the static section of
    each pulse in the output binary file. Store the static section
    of each pulse in the output binary file. Store the non-convolved
    waveform of each pulse in the output binary file. The 1st order
    non-convolved waveform will be stored if checked in combination
    with the 1st order option. Store the non-convolved waveform of
    each pulse in the output binary file. The 1st order non-
    convolved waveform will be stored if checked in combination with
    the 1st order option. Store the 1st order waveform of each pulse
    in the output binary file. The 1st order non-convolved waveform
    will be stored if checked in combination with the non-convolved
    option. Store the 1st order waveform of each pulse in the output
    binary file. The 1st order non-convolved waveform will be stored
    if checked in combination with the non-convolved option.
    Determine the precision with which the data for the waveform are
    stored. A better precision implies more space is used to store
    the data in the hard-drive. Determine the precision with which
    the data for the waveform are stored. A better precision implies
    more space is used to store the data in the hard-drive."""
    subclass = None
    superclass = None
    def __init__(self, ifOutputStaticSection=1, ifOutputNonConvolveWaveform=1, ifOutputFirstOrderWaveform=1, outputFloatFormat=1):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_ImageBinaryProducts")
        self.attrib = ['ifOutputStaticSection', 'ifOutputNonConvolveWaveform', 'ifOutputFirstOrderWaveform', 'outputFloatFormat']
        self.children = []
        self.parent = None
        self._ifOutputStaticSection = _cast(int, ifOutputStaticSection)
        self._ifOutputNonConvolveWaveform = _cast(int, ifOutputNonConvolveWaveform)
        self._ifOutputFirstOrderWaveform = _cast(int, ifOutputFirstOrderWaveform)
        self._outputFloatFormat = _cast(int, outputFloatFormat)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ImageBinaryProducts)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ImageBinaryProducts.subclass:
            return create_ImageBinaryProducts.subclass(*args_, **kwargs_)
        else:
            return create_ImageBinaryProducts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ifOutputStaticSection(self): return self._ifOutputStaticSection
    def set_ifOutputStaticSection(self, value):
        self._ifOutputStaticSection = value
        update_node(self,self.troot,"phase")
    ifOutputStaticSection = property(get_ifOutputStaticSection, set_ifOutputStaticSection)
    def get_ifOutputNonConvolveWaveform(self): return self._ifOutputNonConvolveWaveform
    def set_ifOutputNonConvolveWaveform(self, value):
        self._ifOutputNonConvolveWaveform = value
        update_node(self,self.troot,"phase")
    ifOutputNonConvolveWaveform = property(get_ifOutputNonConvolveWaveform, set_ifOutputNonConvolveWaveform)
    def get_ifOutputFirstOrderWaveform(self): return self._ifOutputFirstOrderWaveform
    def set_ifOutputFirstOrderWaveform(self, value):
        self._ifOutputFirstOrderWaveform = value
        update_node(self,self.troot,"phase")
    ifOutputFirstOrderWaveform = property(get_ifOutputFirstOrderWaveform, set_ifOutputFirstOrderWaveform)
    def get_outputFloatFormat(self): return self._outputFloatFormat
    def set_outputFloatFormat(self, value):
        self._outputFloatFormat = value
        update_node(self,self.troot,"phase")
    outputFloatFormat = property(get_outputFloatFormat, set_outputFloatFormat)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ImageBinaryProducts', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ImageBinaryProducts')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ImageBinaryProducts')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ImageBinaryProducts', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ImageBinaryProducts'):
        if self.ifOutputStaticSection is not None and 'ifOutputStaticSection' not in already_processed:
            already_processed.add('ifOutputStaticSection')
            outfile.write(' ifOutputStaticSection="%s"' % self.gds_format_integer(self.ifOutputStaticSection, input_name='ifOutputStaticSection'))
        if self.ifOutputNonConvolveWaveform is not None and 'ifOutputNonConvolveWaveform' not in already_processed:
            already_processed.add('ifOutputNonConvolveWaveform')
            outfile.write(' ifOutputNonConvolveWaveform="%s"' % self.gds_format_integer(self.ifOutputNonConvolveWaveform, input_name='ifOutputNonConvolveWaveform'))
        if self.ifOutputFirstOrderWaveform is not None and 'ifOutputFirstOrderWaveform' not in already_processed:
            already_processed.add('ifOutputFirstOrderWaveform')
            outfile.write(' ifOutputFirstOrderWaveform="%s"' % self.gds_format_integer(self.ifOutputFirstOrderWaveform, input_name='ifOutputFirstOrderWaveform'))
        if self.outputFloatFormat is not None and 'outputFloatFormat' not in already_processed:
            already_processed.add('outputFloatFormat')
            outfile.write(' outputFloatFormat="%s"' % self.gds_format_integer(self.outputFloatFormat, input_name='outputFloatFormat'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ImageBinaryProducts', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_ImageBinaryProducts', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ifOutputStaticSection is not None:
            element.set('ifOutputStaticSection', self.gds_format_integer(self.ifOutputStaticSection))
        if self.ifOutputNonConvolveWaveform is not None:
            element.set('ifOutputNonConvolveWaveform', self.gds_format_integer(self.ifOutputNonConvolveWaveform))
        if self.ifOutputFirstOrderWaveform is not None:
            element.set('ifOutputFirstOrderWaveform', self.gds_format_integer(self.ifOutputFirstOrderWaveform))
        if self.outputFloatFormat is not None:
            element.set('outputFloatFormat', self.gds_format_integer(self.outputFloatFormat))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ImageBinaryProducts'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ifOutputStaticSection is not None and 'ifOutputStaticSection' not in already_processed:
            already_processed.add('ifOutputStaticSection')
            showIndent(outfile, level)
            outfile.write('ifOutputStaticSection=%d,\n' % (self.ifOutputStaticSection,))
        if self.ifOutputNonConvolveWaveform is not None and 'ifOutputNonConvolveWaveform' not in already_processed:
            already_processed.add('ifOutputNonConvolveWaveform')
            showIndent(outfile, level)
            outfile.write('ifOutputNonConvolveWaveform=%d,\n' % (self.ifOutputNonConvolveWaveform,))
        if self.ifOutputFirstOrderWaveform is not None and 'ifOutputFirstOrderWaveform' not in already_processed:
            already_processed.add('ifOutputFirstOrderWaveform')
            showIndent(outfile, level)
            outfile.write('ifOutputFirstOrderWaveform=%d,\n' % (self.ifOutputFirstOrderWaveform,))
        if self.outputFloatFormat is not None and 'outputFloatFormat' not in already_processed:
            already_processed.add('outputFloatFormat')
            showIndent(outfile, level)
            outfile.write('outputFloatFormat=%d,\n' % (self.outputFloatFormat,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ifOutputStaticSection', node)
        if value is not None and 'ifOutputStaticSection' not in already_processed:
            already_processed.add('ifOutputStaticSection')
            try:
                self.ifOutputStaticSection = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ifOutputNonConvolveWaveform', node)
        if value is not None and 'ifOutputNonConvolveWaveform' not in already_processed:
            already_processed.add('ifOutputNonConvolveWaveform')
            try:
                self.ifOutputNonConvolveWaveform = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ifOutputFirstOrderWaveform', node)
        if value is not None and 'ifOutputFirstOrderWaveform' not in already_processed:
            already_processed.add('ifOutputFirstOrderWaveform')
            try:
                self.ifOutputFirstOrderWaveform = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('outputFloatFormat', node)
        if value is not None and 'outputFloatFormat' not in already_processed:
            already_processed.add('outputFloatFormat')
            try:
                self.outputFloatFormat = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_ImageBinaryProducts


class create_radiativeBudgetProperties(GeneratedsSuper):
    """radiativeBudgetProperties radiativeBudgetProperties 2D images of
    fINTR, fABSR, fSCAR per column per iteration and per type 2D
    images of fINTR, fABSR, fSCAR per column per iteration and per
    type Vertical profiles of fractions of incident (fINCR),
    intercepted (fINTR), absorbed (fABSR) and scattered (fSCAR)
    radiation Vertical profiles of fractions of incident (fINCR),
    intercepted (fINTR), absorbed (fABSR) and scattered (fSCAR)
    radiation 3D fINTR, fABSR, fSCAR per iteration and per type of
    triangle 3D fINTR, fABSR, fSCAR per iteration and per type of
    triangle Horizontal sections xy, for each horizontal layer and
    each iteration, of fractions of incident (fINCR), intercepted
    (fINTR), absorbed (fABSR) and scattered (fSCAR) radiation
    Horizontal sections xy, for each horizontal layer and each
    iteration, of fractions of incident (fINCR), intercepted
    (fINTR), absorbed (fABSR) and scattered (fSCAR) radiation
    Extrapolation of radiation products Extrapolation of radiation
    products Images fINTR, fABSR, fSCAR per column per iteration
    Images fINTR, fABSR, fSCAR per column per iteration W W fINTR,
    fABSR, fSCAR total per individual triangle and per
    iteration.\nCan be displayed in the Surface Radiative Budget
    viewer, in the viewer tools. fINTR, fABSR, fSCAR total per
    individual triangle and per iteration.\nCan be displayed in the
    Surface Radiative Budget viewer, in the viewer tools. Output the
    large radiative budgets (3D or per individual triangles) to
    binary files instead of text files. Improves significatively the
    performance during the writing of these files. Output the large
    radiative budgets (3D or per individual triangles) to binary
    files instead of text files. Improves significatively the
    performance during the writing of these files. fINTR, fABSR,
    fSCAR total per type of triangle and per iteration fINTR, fABSR,
    fSCAR total per type of triangle and per iteration"""
    subclass = None
    superclass = None
    def __init__(self, budget2DParType=0, fIRfARfSRfINTR1DProducts=1, budget3DParType=0, fIRfARfSRfINTR3DProducts=1, extrapolation=1, fIRfARfSRfINTR2DProducts=1, budgetUnitModeR=0, budget3DParSurface=0, binaryFormat=0, budgetTotalParType=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_radiativeBudgetProperties")
        self.attrib = ['budget2DParType', 'fIRfARfSRfINTR1DProducts', 'budget3DParType', 'fIRfARfSRfINTR3DProducts', 'extrapolation', 'fIRfARfSRfINTR2DProducts', 'budgetUnitModeR', 'budget3DParSurface', 'binaryFormat', 'budgetTotalParType']
        self.children = []
        self.parent = None
        self._budget2DParType = _cast(int, budget2DParType)
        self._fIRfARfSRfINTR1DProducts = _cast(int, fIRfARfSRfINTR1DProducts)
        self._budget3DParType = _cast(int, budget3DParType)
        self._fIRfARfSRfINTR3DProducts = _cast(int, fIRfARfSRfINTR3DProducts)
        self._extrapolation = _cast(int, extrapolation)
        self._fIRfARfSRfINTR2DProducts = _cast(int, fIRfARfSRfINTR2DProducts)
        self._budgetUnitModeR = _cast(int, budgetUnitModeR)
        self._budget3DParSurface = _cast(int, budget3DParSurface)
        self._binaryFormat = _cast(int, binaryFormat)
        self._budgetTotalParType = _cast(int, budgetTotalParType)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_radiativeBudgetProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_radiativeBudgetProperties.subclass:
            return create_radiativeBudgetProperties.subclass(*args_, **kwargs_)
        else:
            return create_radiativeBudgetProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_budget2DParType(self): return self._budget2DParType
    def set_budget2DParType(self, value):
        self._budget2DParType = value
        update_node(self,self.troot,"phase")
    budget2DParType = property(get_budget2DParType, set_budget2DParType)
    def get_fIRfARfSRfINTR1DProducts(self): return self._fIRfARfSRfINTR1DProducts
    def set_fIRfARfSRfINTR1DProducts(self, value):
        self._fIRfARfSRfINTR1DProducts = value
        update_node(self,self.troot,"phase")
    fIRfARfSRfINTR1DProducts = property(get_fIRfARfSRfINTR1DProducts, set_fIRfARfSRfINTR1DProducts)
    def get_budget3DParType(self): return self._budget3DParType
    def set_budget3DParType(self, value):
        self._budget3DParType = value
        update_node(self,self.troot,"phase")
    budget3DParType = property(get_budget3DParType, set_budget3DParType)
    def get_fIRfARfSRfINTR3DProducts(self): return self._fIRfARfSRfINTR3DProducts
    def set_fIRfARfSRfINTR3DProducts(self, value):
        self._fIRfARfSRfINTR3DProducts = value
        update_node(self,self.troot,"phase")
    fIRfARfSRfINTR3DProducts = property(get_fIRfARfSRfINTR3DProducts, set_fIRfARfSRfINTR3DProducts)
    def get_extrapolation(self): return self._extrapolation
    def set_extrapolation(self, value):
        self._extrapolation = value
        update_node(self,self.troot,"phase")
    extrapolation = property(get_extrapolation, set_extrapolation)
    def get_fIRfARfSRfINTR2DProducts(self): return self._fIRfARfSRfINTR2DProducts
    def set_fIRfARfSRfINTR2DProducts(self, value):
        self._fIRfARfSRfINTR2DProducts = value
        update_node(self,self.troot,"phase")
    fIRfARfSRfINTR2DProducts = property(get_fIRfARfSRfINTR2DProducts, set_fIRfARfSRfINTR2DProducts)
    def get_budgetUnitModeR(self): return self._budgetUnitModeR
    def set_budgetUnitModeR(self, value):
        self._budgetUnitModeR = value
        update_node(self,self.troot,"phase")
    budgetUnitModeR = property(get_budgetUnitModeR, set_budgetUnitModeR)
    def get_budget3DParSurface(self): return self._budget3DParSurface
    def set_budget3DParSurface(self, value):
        self._budget3DParSurface = value
        update_node(self,self.troot,"phase")
    budget3DParSurface = property(get_budget3DParSurface, set_budget3DParSurface)
    def get_binaryFormat(self): return self._binaryFormat
    def set_binaryFormat(self, value):
        self._binaryFormat = value
        update_node(self,self.troot,"phase")
    binaryFormat = property(get_binaryFormat, set_binaryFormat)
    def get_budgetTotalParType(self): return self._budgetTotalParType
    def set_budgetTotalParType(self, value):
        self._budgetTotalParType = value
        update_node(self,self.troot,"phase")
    budgetTotalParType = property(get_budgetTotalParType, set_budgetTotalParType)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_radiativeBudgetProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_radiativeBudgetProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_radiativeBudgetProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_radiativeBudgetProperties', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_radiativeBudgetProperties'):
        if self.budget2DParType is not None and 'budget2DParType' not in already_processed:
            already_processed.add('budget2DParType')
            outfile.write(' budget2DParType="%s"' % self.gds_format_integer(self.budget2DParType, input_name='budget2DParType'))
        if self.fIRfARfSRfINTR1DProducts is not None and 'fIRfARfSRfINTR1DProducts' not in already_processed:
            already_processed.add('fIRfARfSRfINTR1DProducts')
            outfile.write(' fIRfARfSRfINTR1DProducts="%s"' % self.gds_format_integer(self.fIRfARfSRfINTR1DProducts, input_name='fIRfARfSRfINTR1DProducts'))
        if self.budget3DParType is not None and 'budget3DParType' not in already_processed:
            already_processed.add('budget3DParType')
            outfile.write(' budget3DParType="%s"' % self.gds_format_integer(self.budget3DParType, input_name='budget3DParType'))
        if self.fIRfARfSRfINTR3DProducts is not None and 'fIRfARfSRfINTR3DProducts' not in already_processed:
            already_processed.add('fIRfARfSRfINTR3DProducts')
            outfile.write(' fIRfARfSRfINTR3DProducts="%s"' % self.gds_format_integer(self.fIRfARfSRfINTR3DProducts, input_name='fIRfARfSRfINTR3DProducts'))
        if self.extrapolation is not None and 'extrapolation' not in already_processed:
            already_processed.add('extrapolation')
            outfile.write(' extrapolation="%s"' % self.gds_format_integer(self.extrapolation, input_name='extrapolation'))
        if self.fIRfARfSRfINTR2DProducts is not None and 'fIRfARfSRfINTR2DProducts' not in already_processed:
            already_processed.add('fIRfARfSRfINTR2DProducts')
            outfile.write(' fIRfARfSRfINTR2DProducts="%s"' % self.gds_format_integer(self.fIRfARfSRfINTR2DProducts, input_name='fIRfARfSRfINTR2DProducts'))
        if self.budgetUnitModeR is not None and 'budgetUnitModeR' not in already_processed:
            already_processed.add('budgetUnitModeR')
            outfile.write(' budgetUnitModeR="%s"' % self.gds_format_integer(self.budgetUnitModeR, input_name='budgetUnitModeR'))
        if self.budget3DParSurface is not None and 'budget3DParSurface' not in already_processed:
            already_processed.add('budget3DParSurface')
            outfile.write(' budget3DParSurface="%s"' % self.gds_format_integer(self.budget3DParSurface, input_name='budget3DParSurface'))
        if self.binaryFormat is not None and 'binaryFormat' not in already_processed:
            already_processed.add('binaryFormat')
            outfile.write(' binaryFormat="%s"' % self.gds_format_integer(self.binaryFormat, input_name='binaryFormat'))
        if self.budgetTotalParType is not None and 'budgetTotalParType' not in already_processed:
            already_processed.add('budgetTotalParType')
            outfile.write(' budgetTotalParType="%s"' % self.gds_format_integer(self.budgetTotalParType, input_name='budgetTotalParType'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_radiativeBudgetProperties', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_radiativeBudgetProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.budget2DParType is not None:
            element.set('budget2DParType', self.gds_format_integer(self.budget2DParType))
        if self.fIRfARfSRfINTR1DProducts is not None:
            element.set('fIRfARfSRfINTR1DProducts', self.gds_format_integer(self.fIRfARfSRfINTR1DProducts))
        if self.budget3DParType is not None:
            element.set('budget3DParType', self.gds_format_integer(self.budget3DParType))
        if self.fIRfARfSRfINTR3DProducts is not None:
            element.set('fIRfARfSRfINTR3DProducts', self.gds_format_integer(self.fIRfARfSRfINTR3DProducts))
        if self.extrapolation is not None:
            element.set('extrapolation', self.gds_format_integer(self.extrapolation))
        if self.fIRfARfSRfINTR2DProducts is not None:
            element.set('fIRfARfSRfINTR2DProducts', self.gds_format_integer(self.fIRfARfSRfINTR2DProducts))
        if self.budgetUnitModeR is not None:
            element.set('budgetUnitModeR', self.gds_format_integer(self.budgetUnitModeR))
        if self.budget3DParSurface is not None:
            element.set('budget3DParSurface', self.gds_format_integer(self.budget3DParSurface))
        if self.binaryFormat is not None:
            element.set('binaryFormat', self.gds_format_integer(self.binaryFormat))
        if self.budgetTotalParType is not None:
            element.set('budgetTotalParType', self.gds_format_integer(self.budgetTotalParType))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_radiativeBudgetProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.budget2DParType is not None and 'budget2DParType' not in already_processed:
            already_processed.add('budget2DParType')
            showIndent(outfile, level)
            outfile.write('budget2DParType=%d,\n' % (self.budget2DParType,))
        if self.fIRfARfSRfINTR1DProducts is not None and 'fIRfARfSRfINTR1DProducts' not in already_processed:
            already_processed.add('fIRfARfSRfINTR1DProducts')
            showIndent(outfile, level)
            outfile.write('fIRfARfSRfINTR1DProducts=%d,\n' % (self.fIRfARfSRfINTR1DProducts,))
        if self.budget3DParType is not None and 'budget3DParType' not in already_processed:
            already_processed.add('budget3DParType')
            showIndent(outfile, level)
            outfile.write('budget3DParType=%d,\n' % (self.budget3DParType,))
        if self.fIRfARfSRfINTR3DProducts is not None and 'fIRfARfSRfINTR3DProducts' not in already_processed:
            already_processed.add('fIRfARfSRfINTR3DProducts')
            showIndent(outfile, level)
            outfile.write('fIRfARfSRfINTR3DProducts=%d,\n' % (self.fIRfARfSRfINTR3DProducts,))
        if self.extrapolation is not None and 'extrapolation' not in already_processed:
            already_processed.add('extrapolation')
            showIndent(outfile, level)
            outfile.write('extrapolation=%d,\n' % (self.extrapolation,))
        if self.fIRfARfSRfINTR2DProducts is not None and 'fIRfARfSRfINTR2DProducts' not in already_processed:
            already_processed.add('fIRfARfSRfINTR2DProducts')
            showIndent(outfile, level)
            outfile.write('fIRfARfSRfINTR2DProducts=%d,\n' % (self.fIRfARfSRfINTR2DProducts,))
        if self.budgetUnitModeR is not None and 'budgetUnitModeR' not in already_processed:
            already_processed.add('budgetUnitModeR')
            showIndent(outfile, level)
            outfile.write('budgetUnitModeR=%d,\n' % (self.budgetUnitModeR,))
        if self.budget3DParSurface is not None and 'budget3DParSurface' not in already_processed:
            already_processed.add('budget3DParSurface')
            showIndent(outfile, level)
            outfile.write('budget3DParSurface=%d,\n' % (self.budget3DParSurface,))
        if self.binaryFormat is not None and 'binaryFormat' not in already_processed:
            already_processed.add('binaryFormat')
            showIndent(outfile, level)
            outfile.write('binaryFormat=%d,\n' % (self.binaryFormat,))
        if self.budgetTotalParType is not None and 'budgetTotalParType' not in already_processed:
            already_processed.add('budgetTotalParType')
            showIndent(outfile, level)
            outfile.write('budgetTotalParType=%d,\n' % (self.budgetTotalParType,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('budget2DParType', node)
        if value is not None and 'budget2DParType' not in already_processed:
            already_processed.add('budget2DParType')
            try:
                self.budget2DParType = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('fIRfARfSRfINTR1DProducts', node)
        if value is not None and 'fIRfARfSRfINTR1DProducts' not in already_processed:
            already_processed.add('fIRfARfSRfINTR1DProducts')
            try:
                self.fIRfARfSRfINTR1DProducts = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('budget3DParType', node)
        if value is not None and 'budget3DParType' not in already_processed:
            already_processed.add('budget3DParType')
            try:
                self.budget3DParType = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('fIRfARfSRfINTR3DProducts', node)
        if value is not None and 'fIRfARfSRfINTR3DProducts' not in already_processed:
            already_processed.add('fIRfARfSRfINTR3DProducts')
            try:
                self.fIRfARfSRfINTR3DProducts = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('extrapolation', node)
        if value is not None and 'extrapolation' not in already_processed:
            already_processed.add('extrapolation')
            try:
                self.extrapolation = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('fIRfARfSRfINTR2DProducts', node)
        if value is not None and 'fIRfARfSRfINTR2DProducts' not in already_processed:
            already_processed.add('fIRfARfSRfINTR2DProducts')
            try:
                self.fIRfARfSRfINTR2DProducts = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('budgetUnitModeR', node)
        if value is not None and 'budgetUnitModeR' not in already_processed:
            already_processed.add('budgetUnitModeR')
            try:
                self.budgetUnitModeR = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('budget3DParSurface', node)
        if value is not None and 'budget3DParSurface' not in already_processed:
            already_processed.add('budget3DParSurface')
            try:
                self.budget3DParSurface = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('binaryFormat', node)
        if value is not None and 'binaryFormat' not in already_processed:
            already_processed.add('binaryFormat')
            try:
                self.binaryFormat = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('budgetTotalParType', node)
        if value is not None and 'budgetTotalParType' not in already_processed:
            already_processed.add('budgetTotalParType')
            try:
                self.budgetTotalParType = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_radiativeBudgetProperties


class create_maketModuleProducts(GeneratedsSuper):
    """maketModuleProducts maketModuleProducts 3D and 1D distribution of
    LAI, and number of non empty cells per layer. These are products
    directly derived from the processing of the scene simulation. 3D
    and 1D distribution of LAI, and number of non empty cells per
    layer. These are products directly derived from the processing
    of the scene simulation. Scene Builder calculates the total and
    per type cover area of the triangles in the scene (stored in the
    simulation.properties.txt) Scene Builder calculates the total
    and per type cover area of the triangles in the scene (stored in
    the simulation.properties.txt) MNEProducts MNEProducts Scene
    Builder calculates the total and per type area of the triangles
    in the scene in each cell (and gives the results in a file)
    Scene Builder calculates the total and per type area of the
    triangles in the scene in each cell (and gives the results in a
    file) Generate a .obj file of the DSM. Generate a .obj file of
    the DSM."""
    subclass = None
    superclass = None
    def __init__(self, laiProducts=0, coverRateProducts=0, MNEProducts=0, areaMaketProducts=0, objectGeneration=0, areaMaketProductsProperties=None, coverRateProductsProperties=None, LaiProductsProperties=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_maketModuleProducts")
        self.attrib = ['laiProducts', 'coverRateProducts', 'MNEProducts', 'areaMaketProducts', 'objectGeneration']
        self.children = ['areaMaketProductsProperties', 'coverRateProductsProperties', 'LaiProductsProperties']
        self.parent = None
        self._laiProducts = _cast(int, laiProducts)
        self._coverRateProducts = _cast(int, coverRateProducts)
        self._MNEProducts = _cast(int, MNEProducts)
        self._areaMaketProducts = _cast(int, areaMaketProducts)
        self._objectGeneration = _cast(int, objectGeneration)
        self._areaMaketProductsProperties = areaMaketProductsProperties
        self._coverRateProductsProperties = coverRateProductsProperties
        self._LaiProductsProperties = LaiProductsProperties
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_maketModuleProducts)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_maketModuleProducts.subclass:
            return create_maketModuleProducts.subclass(*args_, **kwargs_)
        else:
            return create_maketModuleProducts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_areaMaketProductsProperties(self): return self._areaMaketProductsProperties
    def set_areaMaketProductsProperties(self, value):
        if value is not None:
            checkclass(value, create_areaMaketProductsProperties)
            value.parent = self
        self._areaMaketProductsProperties = value
    areaMaketProductsProperties = property(get_areaMaketProductsProperties, set_areaMaketProductsProperties)
    def get_coverRateProductsProperties(self): return self._coverRateProductsProperties
    def set_coverRateProductsProperties(self, value):
        if value is not None:
            checkclass(value, create_coverRateProductsProperties)
            value.parent = self
        self._coverRateProductsProperties = value
    coverRateProductsProperties = property(get_coverRateProductsProperties, set_coverRateProductsProperties)
    def get_LaiProductsProperties(self): return self._LaiProductsProperties
    def set_LaiProductsProperties(self, value):
        if value is not None:
            checkclass(value, create_LaiProductsProperties)
            value.parent = self
        self._LaiProductsProperties = value
    LaiProductsProperties = property(get_LaiProductsProperties, set_LaiProductsProperties)
    def get_laiProducts(self): return self._laiProducts
    def set_laiProducts(self, value):
        self._laiProducts = value
        update_node(self,self.troot,"phase")
    laiProducts = property(get_laiProducts, set_laiProducts)
    def get_coverRateProducts(self): return self._coverRateProducts
    def set_coverRateProducts(self, value):
        self._coverRateProducts = value
        update_node(self,self.troot,"phase")
    coverRateProducts = property(get_coverRateProducts, set_coverRateProducts)
    def get_MNEProducts(self): return self._MNEProducts
    def set_MNEProducts(self, value):
        self._MNEProducts = value
        update_node(self,self.troot,"phase")
    MNEProducts = property(get_MNEProducts, set_MNEProducts)
    def get_areaMaketProducts(self): return self._areaMaketProducts
    def set_areaMaketProducts(self, value):
        self._areaMaketProducts = value
        update_node(self,self.troot,"phase")
    areaMaketProducts = property(get_areaMaketProducts, set_areaMaketProducts)
    def get_objectGeneration(self): return self._objectGeneration
    def set_objectGeneration(self, value):
        self._objectGeneration = value
        update_node(self,self.troot,"phase")
    objectGeneration = property(get_objectGeneration, set_objectGeneration)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.areaMaketProductsProperties is not None or
            self.coverRateProductsProperties is not None or
            self.LaiProductsProperties is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_maketModuleProducts', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_maketModuleProducts')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_maketModuleProducts')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_maketModuleProducts', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_maketModuleProducts'):
        if self.laiProducts is not None and 'laiProducts' not in already_processed:
            already_processed.add('laiProducts')
            outfile.write(' laiProducts="%s"' % self.gds_format_integer(self.laiProducts, input_name='laiProducts'))
        if self.coverRateProducts is not None and 'coverRateProducts' not in already_processed:
            already_processed.add('coverRateProducts')
            outfile.write(' coverRateProducts="%s"' % self.gds_format_integer(self.coverRateProducts, input_name='coverRateProducts'))
        if self.MNEProducts is not None and 'MNEProducts' not in already_processed:
            already_processed.add('MNEProducts')
            outfile.write(' MNEProducts="%s"' % self.gds_format_integer(self.MNEProducts, input_name='MNEProducts'))
        if self.areaMaketProducts is not None and 'areaMaketProducts' not in already_processed:
            already_processed.add('areaMaketProducts')
            outfile.write(' areaMaketProducts="%s"' % self.gds_format_integer(self.areaMaketProducts, input_name='areaMaketProducts'))
        if self.objectGeneration is not None and 'objectGeneration' not in already_processed:
            already_processed.add('objectGeneration')
            outfile.write(' objectGeneration="%s"' % self.gds_format_integer(self.objectGeneration, input_name='objectGeneration'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_maketModuleProducts', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.areaMaketProductsProperties is not None:
            self.areaMaketProductsProperties.export(outfile, level, namespaceprefix_, name_='areaMaketProductsProperties', pretty_print=pretty_print)
        if self.coverRateProductsProperties is not None:
            self.coverRateProductsProperties.export(outfile, level, namespaceprefix_, name_='coverRateProductsProperties', pretty_print=pretty_print)
        if self.LaiProductsProperties is not None:
            self.LaiProductsProperties.export(outfile, level, namespaceprefix_, name_='LaiProductsProperties', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_maketModuleProducts', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.laiProducts is not None:
            element.set('laiProducts', self.gds_format_integer(self.laiProducts))
        if self.coverRateProducts is not None:
            element.set('coverRateProducts', self.gds_format_integer(self.coverRateProducts))
        if self.MNEProducts is not None:
            element.set('MNEProducts', self.gds_format_integer(self.MNEProducts))
        if self.areaMaketProducts is not None:
            element.set('areaMaketProducts', self.gds_format_integer(self.areaMaketProducts))
        if self.objectGeneration is not None:
            element.set('objectGeneration', self.gds_format_integer(self.objectGeneration))
        if self.areaMaketProductsProperties is not None:
            areaMaketProductsProperties_ = self.areaMaketProductsProperties
            areaMaketProductsProperties_.to_etree(element, name_='areaMaketProductsProperties', mapping_=mapping_)
        if self.coverRateProductsProperties is not None:
            coverRateProductsProperties_ = self.coverRateProductsProperties
            coverRateProductsProperties_.to_etree(element, name_='coverRateProductsProperties', mapping_=mapping_)
        if self.LaiProductsProperties is not None:
            LaiProductsProperties_ = self.LaiProductsProperties
            LaiProductsProperties_.to_etree(element, name_='LaiProductsProperties', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_maketModuleProducts'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.laiProducts is not None and 'laiProducts' not in already_processed:
            already_processed.add('laiProducts')
            showIndent(outfile, level)
            outfile.write('laiProducts=%d,\n' % (self.laiProducts,))
        if self.coverRateProducts is not None and 'coverRateProducts' not in already_processed:
            already_processed.add('coverRateProducts')
            showIndent(outfile, level)
            outfile.write('coverRateProducts=%d,\n' % (self.coverRateProducts,))
        if self.MNEProducts is not None and 'MNEProducts' not in already_processed:
            already_processed.add('MNEProducts')
            showIndent(outfile, level)
            outfile.write('MNEProducts=%d,\n' % (self.MNEProducts,))
        if self.areaMaketProducts is not None and 'areaMaketProducts' not in already_processed:
            already_processed.add('areaMaketProducts')
            showIndent(outfile, level)
            outfile.write('areaMaketProducts=%d,\n' % (self.areaMaketProducts,))
        if self.objectGeneration is not None and 'objectGeneration' not in already_processed:
            already_processed.add('objectGeneration')
            showIndent(outfile, level)
            outfile.write('objectGeneration=%d,\n' % (self.objectGeneration,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.areaMaketProductsProperties is not None:
            showIndent(outfile, level)
            outfile.write('areaMaketProductsProperties=model_._areaMaketProductsProperties(\n')
            self.areaMaketProductsProperties.exportLiteral(outfile, level, name_='areaMaketProductsProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.coverRateProductsProperties is not None:
            showIndent(outfile, level)
            outfile.write('coverRateProductsProperties=model_._coverRateProductsProperties(\n')
            self.coverRateProductsProperties.exportLiteral(outfile, level, name_='coverRateProductsProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LaiProductsProperties is not None:
            showIndent(outfile, level)
            outfile.write('LaiProductsProperties=model_._LaiProductsProperties(\n')
            self.LaiProductsProperties.exportLiteral(outfile, level, name_='LaiProductsProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('laiProducts', node)
        if value is not None and 'laiProducts' not in already_processed:
            already_processed.add('laiProducts')
            try:
                self.laiProducts = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('coverRateProducts', node)
        if value is not None and 'coverRateProducts' not in already_processed:
            already_processed.add('coverRateProducts')
            try:
                self.coverRateProducts = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('MNEProducts', node)
        if value is not None and 'MNEProducts' not in already_processed:
            already_processed.add('MNEProducts')
            try:
                self.MNEProducts = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('areaMaketProducts', node)
        if value is not None and 'areaMaketProducts' not in already_processed:
            already_processed.add('areaMaketProducts')
            try:
                self.areaMaketProducts = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('objectGeneration', node)
        if value is not None and 'objectGeneration' not in already_processed:
            already_processed.add('objectGeneration')
            try:
                self.objectGeneration = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'areaMaketProductsProperties':
            obj_ = create_areaMaketProductsProperties.factory()
            obj_.build(child_)
            self.set_areaMaketProductsProperties(obj_)
            obj_.original_tagname_ = 'areaMaketProductsProperties'
        elif nodeName_ == 'coverRateProductsProperties':
            obj_ = create_coverRateProductsProperties.factory()
            obj_.build(child_)
            self.set_coverRateProductsProperties(obj_)
            obj_.original_tagname_ = 'coverRateProductsProperties'
        elif nodeName_ == 'LaiProductsProperties':
            obj_ = create_LaiProductsProperties.factory()
            obj_.build(child_)
            self.set_LaiProductsProperties(obj_)
            obj_.original_tagname_ = 'LaiProductsProperties'
# end class create_maketModuleProducts


class create_areaMaketProductsProperties(GeneratedsSuper):
    """areaMaketProductsProperties areaMaketProductsProperties Scene
    Builder creates 1 file containing total area of triangle for
    each cell. Scene Builder creates 1 file containing total area of
    triangle for each cell. Scene Builder creates 1 file per type
    containing the total area of triangle for each cell. Scene
    Builder creates 1 file per type containing the total area of
    triangle for each cell."""
    subclass = None
    superclass = None
    def __init__(self, totalMaketArea=1, areaMaketPerType=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_areaMaketProductsProperties")
        self.attrib = ['totalMaketArea', 'areaMaketPerType']
        self.children = []
        self.parent = None
        self._totalMaketArea = _cast(int, totalMaketArea)
        self._areaMaketPerType = _cast(int, areaMaketPerType)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_areaMaketProductsProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_areaMaketProductsProperties.subclass:
            return create_areaMaketProductsProperties.subclass(*args_, **kwargs_)
        else:
            return create_areaMaketProductsProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_totalMaketArea(self): return self._totalMaketArea
    def set_totalMaketArea(self, value):
        self._totalMaketArea = value
        update_node(self,self.troot,"phase")
    totalMaketArea = property(get_totalMaketArea, set_totalMaketArea)
    def get_areaMaketPerType(self): return self._areaMaketPerType
    def set_areaMaketPerType(self, value):
        self._areaMaketPerType = value
        update_node(self,self.troot,"phase")
    areaMaketPerType = property(get_areaMaketPerType, set_areaMaketPerType)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_areaMaketProductsProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_areaMaketProductsProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_areaMaketProductsProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_areaMaketProductsProperties', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_areaMaketProductsProperties'):
        if self.totalMaketArea is not None and 'totalMaketArea' not in already_processed:
            already_processed.add('totalMaketArea')
            outfile.write(' totalMaketArea="%s"' % self.gds_format_integer(self.totalMaketArea, input_name='totalMaketArea'))
        if self.areaMaketPerType is not None and 'areaMaketPerType' not in already_processed:
            already_processed.add('areaMaketPerType')
            outfile.write(' areaMaketPerType="%s"' % self.gds_format_integer(self.areaMaketPerType, input_name='areaMaketPerType'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_areaMaketProductsProperties', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_areaMaketProductsProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.totalMaketArea is not None:
            element.set('totalMaketArea', self.gds_format_integer(self.totalMaketArea))
        if self.areaMaketPerType is not None:
            element.set('areaMaketPerType', self.gds_format_integer(self.areaMaketPerType))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_areaMaketProductsProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.totalMaketArea is not None and 'totalMaketArea' not in already_processed:
            already_processed.add('totalMaketArea')
            showIndent(outfile, level)
            outfile.write('totalMaketArea=%d,\n' % (self.totalMaketArea,))
        if self.areaMaketPerType is not None and 'areaMaketPerType' not in already_processed:
            already_processed.add('areaMaketPerType')
            showIndent(outfile, level)
            outfile.write('areaMaketPerType=%d,\n' % (self.areaMaketPerType,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('totalMaketArea', node)
        if value is not None and 'totalMaketArea' not in already_processed:
            already_processed.add('totalMaketArea')
            try:
                self.totalMaketArea = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('areaMaketPerType', node)
        if value is not None and 'areaMaketPerType' not in already_processed:
            already_processed.add('areaMaketPerType')
            try:
                self.areaMaketPerType = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_areaMaketProductsProperties


class create_coverRateProductsProperties(GeneratedsSuper):
    """coverRateProductsProperties coverRateProductsProperties Scene
    Builder stores the total ground cover per type in the
    simulation.properties.txt\n The value is accessible through the
    key [maket.groundCover.triangles.type/N/], where N is the index
    of the type. The list of type are accessible in the dart.typ
    file in the input directory. Scene Builder stores the total
    ground cover per type in the simulation.properties.txt\n The
    value is accessible through the key
    [maket.groundCover.triangles.type/N/], where N is the index of
    the type. The list of type are accessible in the dart.typ file
    in the input directory. "Effective horizontal sample grid"
    "Effective horizontal sample grid" Scene Builder stores the
    total ground cover in the simulation.properties.txt\n The value
    is accessible through the key
    [maket.groundCover.triangles.total] Scene Builder stores the
    total ground cover in the simulation.properties.txt\n The value
    is accessible through the key
    [maket.groundCover.triangles.total]"""
    subclass = None
    superclass = None
    def __init__(self, coverRatePerType=0, coverRatePrecision=0.1, totalMaketCoverRate=1):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_coverRateProductsProperties")
        self.attrib = ['coverRatePerType', 'coverRatePrecision', 'totalMaketCoverRate']
        self.children = []
        self.parent = None
        self._coverRatePerType = _cast(int, coverRatePerType)
        self._coverRatePrecision = _cast(float, coverRatePrecision)
        self._totalMaketCoverRate = _cast(int, totalMaketCoverRate)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_coverRateProductsProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_coverRateProductsProperties.subclass:
            return create_coverRateProductsProperties.subclass(*args_, **kwargs_)
        else:
            return create_coverRateProductsProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_coverRatePerType(self): return self._coverRatePerType
    def set_coverRatePerType(self, value):
        self._coverRatePerType = value
        update_node(self,self.troot,"phase")
    coverRatePerType = property(get_coverRatePerType, set_coverRatePerType)
    def get_coverRatePrecision(self): return self._coverRatePrecision
    def set_coverRatePrecision(self, value):
        self._coverRatePrecision = value
        update_node(self,self.troot,"phase")
    coverRatePrecision = property(get_coverRatePrecision, set_coverRatePrecision)
    def get_totalMaketCoverRate(self): return self._totalMaketCoverRate
    def set_totalMaketCoverRate(self, value):
        self._totalMaketCoverRate = value
        update_node(self,self.troot,"phase")
    totalMaketCoverRate = property(get_totalMaketCoverRate, set_totalMaketCoverRate)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_coverRateProductsProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_coverRateProductsProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_coverRateProductsProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_coverRateProductsProperties', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_coverRateProductsProperties'):
        if self.coverRatePerType is not None and 'coverRatePerType' not in already_processed:
            already_processed.add('coverRatePerType')
            outfile.write(' coverRatePerType="%s"' % self.gds_format_integer(self.coverRatePerType, input_name='coverRatePerType'))
        if self.coverRatePrecision is not None and 'coverRatePrecision' not in already_processed:
            already_processed.add('coverRatePrecision')
            outfile.write(' coverRatePrecision="%s"' % self.gds_format_double(self.coverRatePrecision, input_name='coverRatePrecision'))
        if self.totalMaketCoverRate is not None and 'totalMaketCoverRate' not in already_processed:
            already_processed.add('totalMaketCoverRate')
            outfile.write(' totalMaketCoverRate="%s"' % self.gds_format_integer(self.totalMaketCoverRate, input_name='totalMaketCoverRate'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_coverRateProductsProperties', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_coverRateProductsProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.coverRatePerType is not None:
            element.set('coverRatePerType', self.gds_format_integer(self.coverRatePerType))
        if self.coverRatePrecision is not None:
            element.set('coverRatePrecision', self.gds_format_double(self.coverRatePrecision))
        if self.totalMaketCoverRate is not None:
            element.set('totalMaketCoverRate', self.gds_format_integer(self.totalMaketCoverRate))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_coverRateProductsProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.coverRatePerType is not None and 'coverRatePerType' not in already_processed:
            already_processed.add('coverRatePerType')
            showIndent(outfile, level)
            outfile.write('coverRatePerType=%d,\n' % (self.coverRatePerType,))
        if self.coverRatePrecision is not None and 'coverRatePrecision' not in already_processed:
            already_processed.add('coverRatePrecision')
            showIndent(outfile, level)
            outfile.write('coverRatePrecision=%e,\n' % (self.coverRatePrecision,))
        if self.totalMaketCoverRate is not None and 'totalMaketCoverRate' not in already_processed:
            already_processed.add('totalMaketCoverRate')
            showIndent(outfile, level)
            outfile.write('totalMaketCoverRate=%d,\n' % (self.totalMaketCoverRate,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('coverRatePerType', node)
        if value is not None and 'coverRatePerType' not in already_processed:
            already_processed.add('coverRatePerType')
            try:
                self.coverRatePerType = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('coverRatePrecision', node)
        if value is not None and 'coverRatePrecision' not in already_processed:
            already_processed.add('coverRatePrecision')
            try:
                self.coverRatePrecision = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (coverRatePrecision): %s' % exp)
        value = find_attr_value_('totalMaketCoverRate', node)
        if value is not None and 'totalMaketCoverRate' not in already_processed:
            already_processed.add('totalMaketCoverRate')
            try:
                self.totalMaketCoverRate = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_coverRateProductsProperties


class create_LaiProductsProperties(GeneratedsSuper):
    """LaiProductsProperties LaiProductsProperties nonEmptyCellsLayer
    nonEmptyCellsLayer lai1DProducts lai1DProducts lai3DProducts
    lai3DProducts"""
    subclass = None
    superclass = None
    def __init__(self, nonEmptyCellsLayer=1, lai1DProducts=1, lai3DProducts=1):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_LaiProductsProperties")
        self.attrib = ['nonEmptyCellsLayer', 'lai1DProducts', 'lai3DProducts']
        self.children = []
        self.parent = None
        self._nonEmptyCellsLayer = _cast(int, nonEmptyCellsLayer)
        self._lai1DProducts = _cast(int, lai1DProducts)
        self._lai3DProducts = _cast(int, lai3DProducts)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_LaiProductsProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_LaiProductsProperties.subclass:
            return create_LaiProductsProperties.subclass(*args_, **kwargs_)
        else:
            return create_LaiProductsProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nonEmptyCellsLayer(self): return self._nonEmptyCellsLayer
    def set_nonEmptyCellsLayer(self, value):
        self._nonEmptyCellsLayer = value
        update_node(self,self.troot,"phase")
    nonEmptyCellsLayer = property(get_nonEmptyCellsLayer, set_nonEmptyCellsLayer)
    def get_lai1DProducts(self): return self._lai1DProducts
    def set_lai1DProducts(self, value):
        self._lai1DProducts = value
        update_node(self,self.troot,"phase")
    lai1DProducts = property(get_lai1DProducts, set_lai1DProducts)
    def get_lai3DProducts(self): return self._lai3DProducts
    def set_lai3DProducts(self, value):
        self._lai3DProducts = value
        update_node(self,self.troot,"phase")
    lai3DProducts = property(get_lai3DProducts, set_lai3DProducts)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_LaiProductsProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_LaiProductsProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_LaiProductsProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_LaiProductsProperties', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_LaiProductsProperties'):
        if self.nonEmptyCellsLayer is not None and 'nonEmptyCellsLayer' not in already_processed:
            already_processed.add('nonEmptyCellsLayer')
            outfile.write(' nonEmptyCellsLayer="%s"' % self.gds_format_integer(self.nonEmptyCellsLayer, input_name='nonEmptyCellsLayer'))
        if self.lai1DProducts is not None and 'lai1DProducts' not in already_processed:
            already_processed.add('lai1DProducts')
            outfile.write(' lai1DProducts="%s"' % self.gds_format_integer(self.lai1DProducts, input_name='lai1DProducts'))
        if self.lai3DProducts is not None and 'lai3DProducts' not in already_processed:
            already_processed.add('lai3DProducts')
            outfile.write(' lai3DProducts="%s"' % self.gds_format_integer(self.lai3DProducts, input_name='lai3DProducts'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_LaiProductsProperties', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_LaiProductsProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.nonEmptyCellsLayer is not None:
            element.set('nonEmptyCellsLayer', self.gds_format_integer(self.nonEmptyCellsLayer))
        if self.lai1DProducts is not None:
            element.set('lai1DProducts', self.gds_format_integer(self.lai1DProducts))
        if self.lai3DProducts is not None:
            element.set('lai3DProducts', self.gds_format_integer(self.lai3DProducts))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_LaiProductsProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nonEmptyCellsLayer is not None and 'nonEmptyCellsLayer' not in already_processed:
            already_processed.add('nonEmptyCellsLayer')
            showIndent(outfile, level)
            outfile.write('nonEmptyCellsLayer=%d,\n' % (self.nonEmptyCellsLayer,))
        if self.lai1DProducts is not None and 'lai1DProducts' not in already_processed:
            already_processed.add('lai1DProducts')
            showIndent(outfile, level)
            outfile.write('lai1DProducts=%d,\n' % (self.lai1DProducts,))
        if self.lai3DProducts is not None and 'lai3DProducts' not in already_processed:
            already_processed.add('lai3DProducts')
            showIndent(outfile, level)
            outfile.write('lai3DProducts=%d,\n' % (self.lai3DProducts,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nonEmptyCellsLayer', node)
        if value is not None and 'nonEmptyCellsLayer' not in already_processed:
            already_processed.add('nonEmptyCellsLayer')
            try:
                self.nonEmptyCellsLayer = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('lai1DProducts', node)
        if value is not None and 'lai1DProducts' not in already_processed:
            already_processed.add('lai1DProducts')
            try:
                self.lai1DProducts = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('lai3DProducts', node)
        if value is not None and 'lai3DProducts' not in already_processed:
            already_processed.add('lai3DProducts')
            try:
                self.lai3DProducts = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_LaiProductsProperties


class create_SensorImageSimulation(GeneratedsSuper):
    """Simulating passive sensors looking downward Simulating passive
    sensors looking downward Import multiple-frame-camera sensor
    file Import multiple-frame-camera sensor file"""
    subclass = None
    superclass = None
    def __init__(self, importMultipleSensors=0, SensorsImportation=None, Pinhole=None, Pushbroom=None, InsideSensor=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_SensorImageSimulation")
        self.attrib = ['importMultipleSensors']
        self.children = ['SensorsImportation', 'Pinhole', 'Pushbroom', 'InsideSensor']
        self.parent = None
        self._importMultipleSensors = _cast(int, importMultipleSensors)
        self._SensorsImportation = SensorsImportation
        if Pinhole is None:
            self._Pinhole = []
        else:
            self._Pinhole = Pinhole
        if Pushbroom is None:
            self._Pushbroom = []
        else:
            self._Pushbroom = Pushbroom
        if InsideSensor is None:
            self._InsideSensor = []
        else:
            self._InsideSensor = InsideSensor
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_SensorImageSimulation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_SensorImageSimulation.subclass:
            return create_SensorImageSimulation.subclass(*args_, **kwargs_)
        else:
            return create_SensorImageSimulation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SensorsImportation(self): return self._SensorsImportation
    def set_SensorsImportation(self, value):
        if value is not None:
            checkclass(value, create_SensorsImportation)
            value.parent = self
        self._SensorsImportation = value
    SensorsImportation = property(get_SensorsImportation, set_SensorsImportation)
    def get_Pinhole(self): return self._Pinhole
    def set_Pinhole(self, value):
        if value is not None:
            checkclass(value, create_Pinhole)
            for v in value:
                v.parent = self
        self._Pinhole = value
    def add_Pinhole(self, value):
        value.parent = self
        self._Pinhole.append(value)
    def insert_Pinhole_at(self, index, value):
        value.parent = self
        self.Pinhole.insert(index, value)
    def replace_Pinhole_at(self, index, value):
        value.parent = self
        self.Pinhole[index] = value
    Pinhole = property(get_Pinhole, set_Pinhole)
    def get_Pushbroom(self): return self._Pushbroom
    def set_Pushbroom(self, value):
        if value is not None:
            checkclass(value, create_Pushbroom)
            for v in value:
                v.parent = self
        self._Pushbroom = value
    def add_Pushbroom(self, value):
        value.parent = self
        self._Pushbroom.append(value)
    def insert_Pushbroom_at(self, index, value):
        value.parent = self
        self.Pushbroom.insert(index, value)
    def replace_Pushbroom_at(self, index, value):
        value.parent = self
        self.Pushbroom[index] = value
    Pushbroom = property(get_Pushbroom, set_Pushbroom)
    def get_InsideSensor(self): return self._InsideSensor
    def set_InsideSensor(self, value):
        if value is not None:
            checkclass(value, create_InsideSensor)
            for v in value:
                v.parent = self
        self._InsideSensor = value
    def add_InsideSensor(self, value):
        value.parent = self
        self._InsideSensor.append(value)
    def insert_InsideSensor_at(self, index, value):
        value.parent = self
        self.InsideSensor.insert(index, value)
    def replace_InsideSensor_at(self, index, value):
        value.parent = self
        self.InsideSensor[index] = value
    InsideSensor = property(get_InsideSensor, set_InsideSensor)
    def get_importMultipleSensors(self): return self._importMultipleSensors
    def set_importMultipleSensors(self, value):
        self._importMultipleSensors = value
        update_node(self,self.troot,"phase")
    importMultipleSensors = property(get_importMultipleSensors, set_importMultipleSensors)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.SensorsImportation is not None or
            self.Pinhole or
            self.Pushbroom or
            self.InsideSensor
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_SensorImageSimulation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_SensorImageSimulation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_SensorImageSimulation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_SensorImageSimulation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_SensorImageSimulation'):
        if self.importMultipleSensors is not None and 'importMultipleSensors' not in already_processed:
            already_processed.add('importMultipleSensors')
            outfile.write(' importMultipleSensors="%s"' % self.gds_format_integer(self.importMultipleSensors, input_name='importMultipleSensors'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_SensorImageSimulation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SensorsImportation is not None:
            self.SensorsImportation.export(outfile, level, namespaceprefix_, name_='SensorsImportation', pretty_print=pretty_print)
        for Pinhole_ in self.Pinhole:
            Pinhole_.export(outfile, level, namespaceprefix_, name_='Pinhole', pretty_print=pretty_print)
        for Pushbroom_ in self.Pushbroom:
            Pushbroom_.export(outfile, level, namespaceprefix_, name_='Pushbroom', pretty_print=pretty_print)
        for InsideSensor_ in self.InsideSensor:
            InsideSensor_.export(outfile, level, namespaceprefix_, name_='InsideSensor', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_SensorImageSimulation', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.importMultipleSensors is not None:
            element.set('importMultipleSensors', self.gds_format_integer(self.importMultipleSensors))
        if self.SensorsImportation is not None:
            SensorsImportation_ = self.SensorsImportation
            SensorsImportation_.to_etree(element, name_='SensorsImportation', mapping_=mapping_)
        for Pinhole_ in self.Pinhole:
            Pinhole_.to_etree(element, name_='Pinhole', mapping_=mapping_)
        for Pushbroom_ in self.Pushbroom:
            Pushbroom_.to_etree(element, name_='Pushbroom', mapping_=mapping_)
        for InsideSensor_ in self.InsideSensor:
            InsideSensor_.to_etree(element, name_='InsideSensor', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_SensorImageSimulation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.importMultipleSensors is not None and 'importMultipleSensors' not in already_processed:
            already_processed.add('importMultipleSensors')
            showIndent(outfile, level)
            outfile.write('importMultipleSensors=%d,\n' % (self.importMultipleSensors,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SensorsImportation is not None:
            showIndent(outfile, level)
            outfile.write('SensorsImportation=model_._SensorsImportation(\n')
            self.SensorsImportation.exportLiteral(outfile, level, name_='SensorsImportation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Pinhole=[\n')
        level += 1
        for Pinhole_ in self.Pinhole:
            showIndent(outfile, level)
            outfile.write('model_._Pinhole(\n')
            Pinhole_.exportLiteral(outfile, level, name_='_Pinhole')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Pushbroom=[\n')
        level += 1
        for Pushbroom_ in self.Pushbroom:
            showIndent(outfile, level)
            outfile.write('model_._Pushbroom(\n')
            Pushbroom_.exportLiteral(outfile, level, name_='_Pushbroom')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('InsideSensor=[\n')
        level += 1
        for InsideSensor_ in self.InsideSensor:
            showIndent(outfile, level)
            outfile.write('model_._InsideSensor(\n')
            InsideSensor_.exportLiteral(outfile, level, name_='_InsideSensor')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.Pinhole = []
        self.Pushbroom = []
        self.InsideSensor = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('importMultipleSensors', node)
        if value is not None and 'importMultipleSensors' not in already_processed:
            already_processed.add('importMultipleSensors')
            try:
                self.importMultipleSensors = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SensorsImportation':
            obj_ = create_SensorsImportation.factory()
            obj_.build(child_)
            self.set_SensorsImportation(obj_)
            obj_.original_tagname_ = 'SensorsImportation'
        elif nodeName_ == 'Pinhole':
            obj_ = create_Pinhole.factory()
            obj_.build(child_)
            self.add_Pinhole(obj_)
            obj_.original_tagname_ = 'Pinhole'
        elif nodeName_ == 'Pushbroom':
            obj_ = create_Pushbroom.factory()
            obj_.build(child_)
            self.add_Pushbroom(obj_)
            obj_.original_tagname_ = 'Pushbroom'
        elif nodeName_ == 'InsideSensor':
            obj_ = create_InsideSensor.factory()
            obj_.build(child_)
            self.add_InsideSensor(obj_)
            obj_.original_tagname_ = 'InsideSensor'
# end class create_SensorImageSimulation


class create_SensorsImportation(GeneratedsSuper):
    """Multiple-PH-camera sensor importation Multiple-PH-camera sensor
    importation File name File name"""
    subclass = None
    superclass = None
    def __init__(self, fileN='sensors.txt'):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_SensorsImportation")
        self.attrib = ['fileN']
        self.children = []
        self.parent = None
        self._fileN = _cast(None, fileN)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_SensorsImportation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_SensorsImportation.subclass:
            return create_SensorsImportation.subclass(*args_, **kwargs_)
        else:
            return create_SensorsImportation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fileN(self): return self._fileN
    def set_fileN(self, value):
        self._fileN = value
        update_node(self,self.troot,"phase")
    fileN = property(get_fileN, set_fileN)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_SensorsImportation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_SensorsImportation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_SensorsImportation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_SensorsImportation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_SensorsImportation'):
        if self.fileN is not None and 'fileN' not in already_processed:
            already_processed.add('fileN')
            outfile.write(' fileN=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fileN), input_name='fileN')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_SensorsImportation', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_SensorsImportation', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.fileN is not None:
            element.set('fileN', self.gds_format_string(self.fileN))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_SensorsImportation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.fileN is not None and 'fileN' not in already_processed:
            already_processed.add('fileN')
            showIndent(outfile, level)
            outfile.write('fileN="%s",\n' % (self.fileN,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fileN', node)
        if value is not None and 'fileN' not in already_processed:
            already_processed.add('fileN')
            self.fileN = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_SensorsImportation


class create_Pinhole(GeneratedsSuper):
    """Pinhole Camera (convergence on a single point) Pinhole Camera
    (convergence on a single point) The generated image size is by
    default the minimum area which enclose the whole scene on the
    ground, but it can be defined relative the the center of the
    image. The generated image size is by default the minimum area
    which enclose the whole scene on the ground, but it can be
    defined relative the the center of the image. The camera
    orientation is by default the average of the four corners of the
    scene on the ground, but it can also be defined specifically.
    The camera orientation is by default the average of the four
    corners of the scene on the ground, but it can also be defined
    specifically. If this option is checked, the result will be a
    hemispherical camera image If this option is checked, the result
    will be a hemispherical camera image"""
    subclass = None
    superclass = None
    def __init__(self, setImageSize=0, defCameraOrientation=0, ifFishEye=0, OrientationDef=None, Sensor=None, FishEye=None, CamImageFOV=None, FishEyeFOV=None, Radiometer=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_Pinhole")
        self.attrib = ['setImageSize', 'defCameraOrientation', 'ifFishEye']
        self.children = ['OrientationDef', 'Sensor', 'FishEye', 'CamImageFOV', 'FishEyeFOV', 'Radiometer']
        self.parent = None
        self._setImageSize = _cast(int, setImageSize)
        self._defCameraOrientation = _cast(int, defCameraOrientation)
        self._ifFishEye = _cast(int, ifFishEye)
        self._OrientationDef = OrientationDef
        self._Sensor = Sensor
        self._FishEye = FishEye
        self._CamImageFOV = CamImageFOV
        self._FishEyeFOV = FishEyeFOV
        self._Radiometer = Radiometer
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Pinhole)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Pinhole.subclass:
            return create_Pinhole.subclass(*args_, **kwargs_)
        else:
            return create_Pinhole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OrientationDef(self): return self._OrientationDef
    def set_OrientationDef(self, value):
        if value is not None:
            checkclass(value, create_OrientationDef)
            value.parent = self
        self._OrientationDef = value
    OrientationDef = property(get_OrientationDef, set_OrientationDef)
    def get_Sensor(self): return self._Sensor
    def set_Sensor(self, value):
        if value is not None:
            checkclass(value, create_Sensor)
            value.parent = self
        self._Sensor = value
    Sensor = property(get_Sensor, set_Sensor)
    def get_FishEye(self): return self._FishEye
    def set_FishEye(self, value):
        if value is not None:
            checkclass(value, create_FishEye)
            value.parent = self
        self._FishEye = value
    FishEye = property(get_FishEye, set_FishEye)
    def get_CamImageFOV(self): return self._CamImageFOV
    def set_CamImageFOV(self, value):
        if value is not None:
            checkclass(value, create_CamImageFOV)
            value.parent = self
        self._CamImageFOV = value
    CamImageFOV = property(get_CamImageFOV, set_CamImageFOV)
    def get_FishEyeFOV(self): return self._FishEyeFOV
    def set_FishEyeFOV(self, value):
        if value is not None:
            checkclass(value, create_FishEyeFOV)
            value.parent = self
        self._FishEyeFOV = value
    FishEyeFOV = property(get_FishEyeFOV, set_FishEyeFOV)
    def get_Radiometer(self): return self._Radiometer
    def set_Radiometer(self, value):
        if value is not None:
            checkclass(value, create_Radiometer)
            value.parent = self
        self._Radiometer = value
    Radiometer = property(get_Radiometer, set_Radiometer)
    def get_setImageSize(self): return self._setImageSize
    def set_setImageSize(self, value):
        self._setImageSize = value
        update_node(self,self.troot,"phase")
    setImageSize = property(get_setImageSize, set_setImageSize)
    def get_defCameraOrientation(self): return self._defCameraOrientation
    def set_defCameraOrientation(self, value):
        self._defCameraOrientation = value
        update_node(self,self.troot,"phase")
    defCameraOrientation = property(get_defCameraOrientation, set_defCameraOrientation)
    def get_ifFishEye(self): return self._ifFishEye
    def set_ifFishEye(self, value):
        self._ifFishEye = value
        update_node(self,self.troot,"phase")
    ifFishEye = property(get_ifFishEye, set_ifFishEye)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.OrientationDef is not None or
            self.Sensor is not None or
            self.FishEye is not None or
            self.CamImageFOV is not None or
            self.FishEyeFOV is not None or
            self.Radiometer is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Pinhole', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Pinhole')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Pinhole')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Pinhole', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Pinhole'):
        if self.setImageSize is not None and 'setImageSize' not in already_processed:
            already_processed.add('setImageSize')
            outfile.write(' setImageSize="%s"' % self.gds_format_integer(self.setImageSize, input_name='setImageSize'))
        if self.defCameraOrientation is not None and 'defCameraOrientation' not in already_processed:
            already_processed.add('defCameraOrientation')
            outfile.write(' defCameraOrientation="%s"' % self.gds_format_integer(self.defCameraOrientation, input_name='defCameraOrientation'))
        if self.ifFishEye is not None and 'ifFishEye' not in already_processed:
            already_processed.add('ifFishEye')
            outfile.write(' ifFishEye="%s"' % self.gds_format_integer(self.ifFishEye, input_name='ifFishEye'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Pinhole', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OrientationDef is not None:
            self.OrientationDef.export(outfile, level, namespaceprefix_, name_='OrientationDef', pretty_print=pretty_print)
        if self.Sensor is not None:
            self.Sensor.export(outfile, level, namespaceprefix_, name_='Sensor', pretty_print=pretty_print)
        if self.FishEye is not None:
            self.FishEye.export(outfile, level, namespaceprefix_, name_='FishEye', pretty_print=pretty_print)
        if self.CamImageFOV is not None:
            self.CamImageFOV.export(outfile, level, namespaceprefix_, name_='CamImageFOV', pretty_print=pretty_print)
        if self.FishEyeFOV is not None:
            self.FishEyeFOV.export(outfile, level, namespaceprefix_, name_='FishEyeFOV', pretty_print=pretty_print)
        if self.Radiometer is not None:
            self.Radiometer.export(outfile, level, namespaceprefix_, name_='Radiometer', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Pinhole', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.setImageSize is not None:
            element.set('setImageSize', self.gds_format_integer(self.setImageSize))
        if self.defCameraOrientation is not None:
            element.set('defCameraOrientation', self.gds_format_integer(self.defCameraOrientation))
        if self.ifFishEye is not None:
            element.set('ifFishEye', self.gds_format_integer(self.ifFishEye))
        if self.OrientationDef is not None:
            OrientationDef_ = self.OrientationDef
            OrientationDef_.to_etree(element, name_='OrientationDef', mapping_=mapping_)
        if self.Sensor is not None:
            Sensor_ = self.Sensor
            Sensor_.to_etree(element, name_='Sensor', mapping_=mapping_)
        if self.FishEye is not None:
            FishEye_ = self.FishEye
            FishEye_.to_etree(element, name_='FishEye', mapping_=mapping_)
        if self.CamImageFOV is not None:
            CamImageFOV_ = self.CamImageFOV
            CamImageFOV_.to_etree(element, name_='CamImageFOV', mapping_=mapping_)
        if self.FishEyeFOV is not None:
            FishEyeFOV_ = self.FishEyeFOV
            FishEyeFOV_.to_etree(element, name_='FishEyeFOV', mapping_=mapping_)
        if self.Radiometer is not None:
            Radiometer_ = self.Radiometer
            Radiometer_.to_etree(element, name_='Radiometer', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Pinhole'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.setImageSize is not None and 'setImageSize' not in already_processed:
            already_processed.add('setImageSize')
            showIndent(outfile, level)
            outfile.write('setImageSize=%d,\n' % (self.setImageSize,))
        if self.defCameraOrientation is not None and 'defCameraOrientation' not in already_processed:
            already_processed.add('defCameraOrientation')
            showIndent(outfile, level)
            outfile.write('defCameraOrientation=%d,\n' % (self.defCameraOrientation,))
        if self.ifFishEye is not None and 'ifFishEye' not in already_processed:
            already_processed.add('ifFishEye')
            showIndent(outfile, level)
            outfile.write('ifFishEye=%d,\n' % (self.ifFishEye,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.OrientationDef is not None:
            showIndent(outfile, level)
            outfile.write('OrientationDef=model_._OrientationDef(\n')
            self.OrientationDef.exportLiteral(outfile, level, name_='OrientationDef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Sensor is not None:
            showIndent(outfile, level)
            outfile.write('Sensor=model_._Sensor(\n')
            self.Sensor.exportLiteral(outfile, level, name_='Sensor')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FishEye is not None:
            showIndent(outfile, level)
            outfile.write('FishEye=model_._FishEye(\n')
            self.FishEye.exportLiteral(outfile, level, name_='FishEye')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CamImageFOV is not None:
            showIndent(outfile, level)
            outfile.write('CamImageFOV=model_._CamImageFOV(\n')
            self.CamImageFOV.exportLiteral(outfile, level, name_='CamImageFOV')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FishEyeFOV is not None:
            showIndent(outfile, level)
            outfile.write('FishEyeFOV=model_._FishEyeFOV(\n')
            self.FishEyeFOV.exportLiteral(outfile, level, name_='FishEyeFOV')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Radiometer is not None:
            showIndent(outfile, level)
            outfile.write('Radiometer=model_._Radiometer(\n')
            self.Radiometer.exportLiteral(outfile, level, name_='Radiometer')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('setImageSize', node)
        if value is not None and 'setImageSize' not in already_processed:
            already_processed.add('setImageSize')
            try:
                self.setImageSize = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('defCameraOrientation', node)
        if value is not None and 'defCameraOrientation' not in already_processed:
            already_processed.add('defCameraOrientation')
            try:
                self.defCameraOrientation = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ifFishEye', node)
        if value is not None and 'ifFishEye' not in already_processed:
            already_processed.add('ifFishEye')
            try:
                self.ifFishEye = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OrientationDef':
            obj_ = create_OrientationDef.factory()
            obj_.build(child_)
            self.set_OrientationDef(obj_)
            obj_.original_tagname_ = 'OrientationDef'
        elif nodeName_ == 'Sensor':
            obj_ = create_Sensor.factory()
            obj_.build(child_)
            self.set_Sensor(obj_)
            obj_.original_tagname_ = 'Sensor'
        elif nodeName_ == 'FishEye':
            obj_ = create_FishEye.factory()
            obj_.build(child_)
            self.set_FishEye(obj_)
            obj_.original_tagname_ = 'FishEye'
        elif nodeName_ == 'CamImageFOV':
            obj_ = create_CamImageFOV.factory()
            obj_.build(child_)
            self.set_CamImageFOV(obj_)
            obj_.original_tagname_ = 'CamImageFOV'
        elif nodeName_ == 'FishEyeFOV':
            obj_ = create_FishEyeFOV.factory()
            obj_.build(child_)
            self.set_FishEyeFOV(obj_)
            obj_.original_tagname_ = 'FishEyeFOV'
        elif nodeName_ == 'Radiometer':
            obj_ = create_Radiometer.factory()
            obj_.build(child_)
            self.set_Radiometer(obj_)
            obj_.original_tagname_ = 'Radiometer'
# end class create_Pinhole


class create_OrientationDef(GeneratedsSuper):
    """Orientation definition Orientation definition 2 Types to be selected
    (ZYZ intrinsic rotation, or Tait-Bryan Angles) 2 Types to be
    selected (ZYZ intrinsic rotation, or Tait-Bryan Angles)"""
    subclass = None
    superclass = None
    def __init__(self, orientDefType=0, CameraOrientation=None, CameraOrientYPR=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_OrientationDef")
        self.attrib = ['orientDefType']
        self.children = ['CameraOrientation', 'CameraOrientYPR']
        self.parent = None
        self._orientDefType = _cast(int, orientDefType)
        self._CameraOrientation = CameraOrientation
        self._CameraOrientYPR = CameraOrientYPR
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_OrientationDef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_OrientationDef.subclass:
            return create_OrientationDef.subclass(*args_, **kwargs_)
        else:
            return create_OrientationDef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CameraOrientation(self): return self._CameraOrientation
    def set_CameraOrientation(self, value):
        if value is not None:
            checkclass(value, create_CameraOrientation)
            value.parent = self
        self._CameraOrientation = value
    CameraOrientation = property(get_CameraOrientation, set_CameraOrientation)
    def get_CameraOrientYPR(self): return self._CameraOrientYPR
    def set_CameraOrientYPR(self, value):
        if value is not None:
            checkclass(value, create_CameraOrientYPR)
            value.parent = self
        self._CameraOrientYPR = value
    CameraOrientYPR = property(get_CameraOrientYPR, set_CameraOrientYPR)
    def get_orientDefType(self): return self._orientDefType
    def set_orientDefType(self, value):
        self._orientDefType = value
        update_node(self,self.troot,"phase")
    orientDefType = property(get_orientDefType, set_orientDefType)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.CameraOrientation is not None or
            self.CameraOrientYPR is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_OrientationDef', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_OrientationDef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_OrientationDef')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_OrientationDef', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_OrientationDef'):
        if self.orientDefType is not None and 'orientDefType' not in already_processed:
            already_processed.add('orientDefType')
            outfile.write(' orientDefType="%s"' % self.gds_format_integer(self.orientDefType, input_name='orientDefType'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_OrientationDef', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CameraOrientation is not None:
            self.CameraOrientation.export(outfile, level, namespaceprefix_, name_='CameraOrientation', pretty_print=pretty_print)
        if self.CameraOrientYPR is not None:
            self.CameraOrientYPR.export(outfile, level, namespaceprefix_, name_='CameraOrientYPR', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_OrientationDef', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.orientDefType is not None:
            element.set('orientDefType', self.gds_format_integer(self.orientDefType))
        if self.CameraOrientation is not None:
            CameraOrientation_ = self.CameraOrientation
            CameraOrientation_.to_etree(element, name_='CameraOrientation', mapping_=mapping_)
        if self.CameraOrientYPR is not None:
            CameraOrientYPR_ = self.CameraOrientYPR
            CameraOrientYPR_.to_etree(element, name_='CameraOrientYPR', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_OrientationDef'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.orientDefType is not None and 'orientDefType' not in already_processed:
            already_processed.add('orientDefType')
            showIndent(outfile, level)
            outfile.write('orientDefType=%d,\n' % (self.orientDefType,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CameraOrientation is not None:
            showIndent(outfile, level)
            outfile.write('CameraOrientation=model_._CameraOrientation(\n')
            self.CameraOrientation.exportLiteral(outfile, level, name_='CameraOrientation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CameraOrientYPR is not None:
            showIndent(outfile, level)
            outfile.write('CameraOrientYPR=model_._CameraOrientYPR(\n')
            self.CameraOrientYPR.exportLiteral(outfile, level, name_='CameraOrientYPR')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('orientDefType', node)
        if value is not None and 'orientDefType' not in already_processed:
            already_processed.add('orientDefType')
            try:
                self.orientDefType = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CameraOrientation':
            obj_ = create_CameraOrientation.factory()
            obj_.build(child_)
            self.set_CameraOrientation(obj_)
            obj_.original_tagname_ = 'CameraOrientation'
        elif nodeName_ == 'CameraOrientYPR':
            obj_ = create_CameraOrientYPR.factory()
            obj_.build(child_)
            self.set_CameraOrientYPR(obj_)
            obj_.original_tagname_ = 'CameraOrientYPR'
# end class create_OrientationDef


class create_CameraOrientation(GeneratedsSuper):
    """CameraOrientation (Proper Euler Intrinsic Intrinsic ZYZ)
    CameraOrientation (Proper Euler Intrinsic Intrinsic ZYZ) Zenith
    angle of the camera axis (perpendicular to camera focal plane),
    towards the camera position Zenith angle of the camera axis
    (perpendicular to camera focal plane), towards the camera
    position Rotation along the camera axis (perpendicular to camera
    focal plane) Rotation along the camera axis (perpendicular to
    camera focal plane) Azimuth angle of the camera axis
    (perpendicular to the camera focal plane), towards the camera
    position Azimuth angle of the camera axis (perpendicular to the
    camera focal plane), towards the camera position"""
    subclass = None
    superclass = None
    def __init__(self, cameraTheta=15, cameraRotation=0, cameraPhi=225):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_CameraOrientation")
        self.attrib = ['cameraTheta', 'cameraRotation', 'cameraPhi']
        self.children = []
        self.parent = None
        self._cameraTheta = _cast(float, cameraTheta)
        self._cameraRotation = _cast(float, cameraRotation)
        self._cameraPhi = _cast(float, cameraPhi)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_CameraOrientation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_CameraOrientation.subclass:
            return create_CameraOrientation.subclass(*args_, **kwargs_)
        else:
            return create_CameraOrientation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cameraTheta(self): return self._cameraTheta
    def set_cameraTheta(self, value):
        self._cameraTheta = value
        update_node(self,self.troot,"phase")
    cameraTheta = property(get_cameraTheta, set_cameraTheta)
    def get_cameraRotation(self): return self._cameraRotation
    def set_cameraRotation(self, value):
        self._cameraRotation = value
        update_node(self,self.troot,"phase")
    cameraRotation = property(get_cameraRotation, set_cameraRotation)
    def get_cameraPhi(self): return self._cameraPhi
    def set_cameraPhi(self, value):
        self._cameraPhi = value
        update_node(self,self.troot,"phase")
    cameraPhi = property(get_cameraPhi, set_cameraPhi)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_CameraOrientation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_CameraOrientation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_CameraOrientation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_CameraOrientation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_CameraOrientation'):
        if self.cameraTheta is not None and 'cameraTheta' not in already_processed:
            already_processed.add('cameraTheta')
            outfile.write(' cameraTheta="%s"' % self.gds_format_double(self.cameraTheta, input_name='cameraTheta'))
        if self.cameraRotation is not None and 'cameraRotation' not in already_processed:
            already_processed.add('cameraRotation')
            outfile.write(' cameraRotation="%s"' % self.gds_format_double(self.cameraRotation, input_name='cameraRotation'))
        if self.cameraPhi is not None and 'cameraPhi' not in already_processed:
            already_processed.add('cameraPhi')
            outfile.write(' cameraPhi="%s"' % self.gds_format_double(self.cameraPhi, input_name='cameraPhi'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_CameraOrientation', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_CameraOrientation', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.cameraTheta is not None:
            element.set('cameraTheta', self.gds_format_double(self.cameraTheta))
        if self.cameraRotation is not None:
            element.set('cameraRotation', self.gds_format_double(self.cameraRotation))
        if self.cameraPhi is not None:
            element.set('cameraPhi', self.gds_format_double(self.cameraPhi))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_CameraOrientation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.cameraTheta is not None and 'cameraTheta' not in already_processed:
            already_processed.add('cameraTheta')
            showIndent(outfile, level)
            outfile.write('cameraTheta=%e,\n' % (self.cameraTheta,))
        if self.cameraRotation is not None and 'cameraRotation' not in already_processed:
            already_processed.add('cameraRotation')
            showIndent(outfile, level)
            outfile.write('cameraRotation=%e,\n' % (self.cameraRotation,))
        if self.cameraPhi is not None and 'cameraPhi' not in already_processed:
            already_processed.add('cameraPhi')
            showIndent(outfile, level)
            outfile.write('cameraPhi=%e,\n' % (self.cameraPhi,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cameraTheta', node)
        if value is not None and 'cameraTheta' not in already_processed:
            already_processed.add('cameraTheta')
            try:
                self.cameraTheta = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (cameraTheta): %s' % exp)
        value = find_attr_value_('cameraRotation', node)
        if value is not None and 'cameraRotation' not in already_processed:
            already_processed.add('cameraRotation')
            try:
                self.cameraRotation = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (cameraRotation): %s' % exp)
        value = find_attr_value_('cameraPhi', node)
        if value is not None and 'cameraPhi' not in already_processed:
            already_processed.add('cameraPhi')
            try:
                self.cameraPhi = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (cameraPhi): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_CameraOrientation


class create_CameraOrientYPR(GeneratedsSuper):
    """Camera orientation (Tait-Bryan Angles) Camera orientation (Tait-
    Bryan Angles) Rotation along intrinsic Z axis Rotation along
    intrinsic Z axis Rotation along intrinsic X axis Rotation along
    intrinsic X axis Rotation Order (123) Rotation Order (123)
    Rotation along intrinsic Y axis Rotation along intrinsic Y axis"""
    subclass = None
    superclass = None
    def __init__(self, yaw=0, roll=180, rotDefBT=5, pitch=-90):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_CameraOrientYPR")
        self.attrib = ['yaw', 'roll', 'rotDefBT', 'pitch']
        self.children = []
        self.parent = None
        self._yaw = _cast(float, yaw)
        self._roll = _cast(float, roll)
        self._rotDefBT = _cast(int, rotDefBT)
        self._pitch = _cast(float, pitch)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_CameraOrientYPR)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_CameraOrientYPR.subclass:
            return create_CameraOrientYPR.subclass(*args_, **kwargs_)
        else:
            return create_CameraOrientYPR(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_yaw(self): return self._yaw
    def set_yaw(self, value):
        self._yaw = value
        update_node(self,self.troot,"phase")
    yaw = property(get_yaw, set_yaw)
    def get_roll(self): return self._roll
    def set_roll(self, value):
        self._roll = value
        update_node(self,self.troot,"phase")
    roll = property(get_roll, set_roll)
    def get_rotDefBT(self): return self._rotDefBT
    def set_rotDefBT(self, value):
        self._rotDefBT = value
        update_node(self,self.troot,"phase")
    rotDefBT = property(get_rotDefBT, set_rotDefBT)
    def get_pitch(self): return self._pitch
    def set_pitch(self, value):
        self._pitch = value
        update_node(self,self.troot,"phase")
    pitch = property(get_pitch, set_pitch)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_CameraOrientYPR', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_CameraOrientYPR')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_CameraOrientYPR')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_CameraOrientYPR', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_CameraOrientYPR'):
        if self.yaw is not None and 'yaw' not in already_processed:
            already_processed.add('yaw')
            outfile.write(' yaw="%s"' % self.gds_format_double(self.yaw, input_name='yaw'))
        if self.roll is not None and 'roll' not in already_processed:
            already_processed.add('roll')
            outfile.write(' roll="%s"' % self.gds_format_double(self.roll, input_name='roll'))
        if self.rotDefBT is not None and 'rotDefBT' not in already_processed:
            already_processed.add('rotDefBT')
            outfile.write(' rotDefBT="%s"' % self.gds_format_integer(self.rotDefBT, input_name='rotDefBT'))
        if self.pitch is not None and 'pitch' not in already_processed:
            already_processed.add('pitch')
            outfile.write(' pitch="%s"' % self.gds_format_double(self.pitch, input_name='pitch'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_CameraOrientYPR', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_CameraOrientYPR', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.yaw is not None:
            element.set('yaw', self.gds_format_double(self.yaw))
        if self.roll is not None:
            element.set('roll', self.gds_format_double(self.roll))
        if self.rotDefBT is not None:
            element.set('rotDefBT', self.gds_format_integer(self.rotDefBT))
        if self.pitch is not None:
            element.set('pitch', self.gds_format_double(self.pitch))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_CameraOrientYPR'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.yaw is not None and 'yaw' not in already_processed:
            already_processed.add('yaw')
            showIndent(outfile, level)
            outfile.write('yaw=%e,\n' % (self.yaw,))
        if self.roll is not None and 'roll' not in already_processed:
            already_processed.add('roll')
            showIndent(outfile, level)
            outfile.write('roll=%e,\n' % (self.roll,))
        if self.rotDefBT is not None and 'rotDefBT' not in already_processed:
            already_processed.add('rotDefBT')
            showIndent(outfile, level)
            outfile.write('rotDefBT=%d,\n' % (self.rotDefBT,))
        if self.pitch is not None and 'pitch' not in already_processed:
            already_processed.add('pitch')
            showIndent(outfile, level)
            outfile.write('pitch=%e,\n' % (self.pitch,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('yaw', node)
        if value is not None and 'yaw' not in already_processed:
            already_processed.add('yaw')
            try:
                self.yaw = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (yaw): %s' % exp)
        value = find_attr_value_('roll', node)
        if value is not None and 'roll' not in already_processed:
            already_processed.add('roll')
            try:
                self.roll = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (roll): %s' % exp)
        value = find_attr_value_('rotDefBT', node)
        if value is not None and 'rotDefBT' not in already_processed:
            already_processed.add('rotDefBT')
            try:
                self.rotDefBT = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('pitch', node)
        if value is not None and 'pitch' not in already_processed:
            already_processed.add('pitch')
            try:
                self.pitch = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (pitch): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_CameraOrientYPR


class create_FishEye(GeneratedsSuper):
    """Hemispherical camera Hemispherical camera This defines the offset
    between each pixels in the hemspherical camera image, which is
    defined by zenith angle offset size This defines the offset
    between each pixels in the hemspherical camera image, which is
    defined by zenith angle offset size"""
    subclass = None
    superclass = None
    def __init__(self, resolutionTheta=1):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_FishEye")
        self.attrib = ['resolutionTheta']
        self.children = []
        self.parent = None
        self._resolutionTheta = _cast(float, resolutionTheta)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_FishEye)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_FishEye.subclass:
            return create_FishEye.subclass(*args_, **kwargs_)
        else:
            return create_FishEye(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resolutionTheta(self): return self._resolutionTheta
    def set_resolutionTheta(self, value):
        self._resolutionTheta = value
        update_node(self,self.troot,"phase")
    resolutionTheta = property(get_resolutionTheta, set_resolutionTheta)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_FishEye', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_FishEye')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_FishEye')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_FishEye', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_FishEye'):
        if self.resolutionTheta is not None and 'resolutionTheta' not in already_processed:
            already_processed.add('resolutionTheta')
            outfile.write(' resolutionTheta="%s"' % self.gds_format_double(self.resolutionTheta, input_name='resolutionTheta'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_FishEye', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_FishEye', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.resolutionTheta is not None:
            element.set('resolutionTheta', self.gds_format_double(self.resolutionTheta))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_FishEye'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.resolutionTheta is not None and 'resolutionTheta' not in already_processed:
            already_processed.add('resolutionTheta')
            showIndent(outfile, level)
            outfile.write('resolutionTheta=%e,\n' % (self.resolutionTheta,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('resolutionTheta', node)
        if value is not None and 'resolutionTheta' not in already_processed:
            already_processed.add('resolutionTheta')
            try:
                self.resolutionTheta = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (resolutionTheta): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_FishEye


class create_CamImageFOV(GeneratedsSuper):
    """The camera is viewing a subregion of the scene defined by its field
    of view. The camera is viewing a subregion of the scene defined
    by its field of view. Force the number of pixels within the
    camera field of view Force the number of pixels within the
    camera field of view FOV definition FOV definition"""
    subclass = None
    superclass = None
    def __init__(self, defNbPixels=0, definitionFOV=1, CamImageDim=None, CamImageAOV=None, NbPixels=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_CamImageFOV")
        self.attrib = ['defNbPixels', 'definitionFOV']
        self.children = ['CamImageDim', 'CamImageAOV', 'NbPixels']
        self.parent = None
        self._defNbPixels = _cast(int, defNbPixels)
        self._definitionFOV = _cast(int, definitionFOV)
        self._CamImageDim = CamImageDim
        self._CamImageAOV = CamImageAOV
        self._NbPixels = NbPixels
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_CamImageFOV)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_CamImageFOV.subclass:
            return create_CamImageFOV.subclass(*args_, **kwargs_)
        else:
            return create_CamImageFOV(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CamImageDim(self): return self._CamImageDim
    def set_CamImageDim(self, value):
        if value is not None:
            checkclass(value, create_CamImageDim)
            value.parent = self
        self._CamImageDim = value
    CamImageDim = property(get_CamImageDim, set_CamImageDim)
    def get_CamImageAOV(self): return self._CamImageAOV
    def set_CamImageAOV(self, value):
        if value is not None:
            checkclass(value, create_CamImageAOV)
            value.parent = self
        self._CamImageAOV = value
    CamImageAOV = property(get_CamImageAOV, set_CamImageAOV)
    def get_NbPixels(self): return self._NbPixels
    def set_NbPixels(self, value):
        if value is not None:
            checkclass(value, create_NbPixels)
            value.parent = self
        self._NbPixels = value
    NbPixels = property(get_NbPixels, set_NbPixels)
    def get_defNbPixels(self): return self._defNbPixels
    def set_defNbPixels(self, value):
        self._defNbPixels = value
        update_node(self,self.troot,"phase")
    defNbPixels = property(get_defNbPixels, set_defNbPixels)
    def get_definitionFOV(self): return self._definitionFOV
    def set_definitionFOV(self, value):
        self._definitionFOV = value
        update_node(self,self.troot,"phase")
    definitionFOV = property(get_definitionFOV, set_definitionFOV)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.CamImageDim is not None or
            self.CamImageAOV is not None or
            self.NbPixels is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_CamImageFOV', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_CamImageFOV')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_CamImageFOV')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_CamImageFOV', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_CamImageFOV'):
        if self.defNbPixels is not None and 'defNbPixels' not in already_processed:
            already_processed.add('defNbPixels')
            outfile.write(' defNbPixels="%s"' % self.gds_format_integer(self.defNbPixels, input_name='defNbPixels'))
        if self.definitionFOV is not None and 'definitionFOV' not in already_processed:
            already_processed.add('definitionFOV')
            outfile.write(' definitionFOV="%s"' % self.gds_format_integer(self.definitionFOV, input_name='definitionFOV'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_CamImageFOV', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CamImageDim is not None:
            self.CamImageDim.export(outfile, level, namespaceprefix_, name_='CamImageDim', pretty_print=pretty_print)
        if self.CamImageAOV is not None:
            self.CamImageAOV.export(outfile, level, namespaceprefix_, name_='CamImageAOV', pretty_print=pretty_print)
        if self.NbPixels is not None:
            self.NbPixels.export(outfile, level, namespaceprefix_, name_='NbPixels', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_CamImageFOV', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.defNbPixels is not None:
            element.set('defNbPixels', self.gds_format_integer(self.defNbPixels))
        if self.definitionFOV is not None:
            element.set('definitionFOV', self.gds_format_integer(self.definitionFOV))
        if self.CamImageDim is not None:
            CamImageDim_ = self.CamImageDim
            CamImageDim_.to_etree(element, name_='CamImageDim', mapping_=mapping_)
        if self.CamImageAOV is not None:
            CamImageAOV_ = self.CamImageAOV
            CamImageAOV_.to_etree(element, name_='CamImageAOV', mapping_=mapping_)
        if self.NbPixels is not None:
            NbPixels_ = self.NbPixels
            NbPixels_.to_etree(element, name_='NbPixels', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_CamImageFOV'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.defNbPixels is not None and 'defNbPixels' not in already_processed:
            already_processed.add('defNbPixels')
            showIndent(outfile, level)
            outfile.write('defNbPixels=%d,\n' % (self.defNbPixels,))
        if self.definitionFOV is not None and 'definitionFOV' not in already_processed:
            already_processed.add('definitionFOV')
            showIndent(outfile, level)
            outfile.write('definitionFOV=%d,\n' % (self.definitionFOV,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CamImageDim is not None:
            showIndent(outfile, level)
            outfile.write('CamImageDim=model_._CamImageDim(\n')
            self.CamImageDim.exportLiteral(outfile, level, name_='CamImageDim')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CamImageAOV is not None:
            showIndent(outfile, level)
            outfile.write('CamImageAOV=model_._CamImageAOV(\n')
            self.CamImageAOV.exportLiteral(outfile, level, name_='CamImageAOV')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NbPixels is not None:
            showIndent(outfile, level)
            outfile.write('NbPixels=model_._NbPixels(\n')
            self.NbPixels.exportLiteral(outfile, level, name_='NbPixels')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('defNbPixels', node)
        if value is not None and 'defNbPixels' not in already_processed:
            already_processed.add('defNbPixels')
            try:
                self.defNbPixels = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('definitionFOV', node)
        if value is not None and 'definitionFOV' not in already_processed:
            already_processed.add('definitionFOV')
            try:
                self.definitionFOV = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CamImageDim':
            obj_ = create_CamImageDim.factory()
            obj_.build(child_)
            self.set_CamImageDim(obj_)
            obj_.original_tagname_ = 'CamImageDim'
        elif nodeName_ == 'CamImageAOV':
            obj_ = create_CamImageAOV.factory()
            obj_.build(child_)
            self.set_CamImageAOV(obj_)
            obj_.original_tagname_ = 'CamImageAOV'
        elif nodeName_ == 'NbPixels':
            obj_ = create_NbPixels.factory()
            obj_.build(child_)
            self.set_NbPixels(obj_)
            obj_.original_tagname_ = 'NbPixels'
# end class create_CamImageFOV


class create_CamImageDim(GeneratedsSuper):
    """The dimenstion of the subregion viewed by camera in its local frame.
    The dimenstion of the subregion viewed by camera in its local
    frame. Length of subregion viewed by camera in its local frame
    [m]. Length of subregion viewed by camera in its local frame
    [m]. Width of subregion viewed by camera in its local frame [m].
    Width of subregion viewed by camera in its local frame [m]."""
    subclass = None
    superclass = None
    def __init__(self, sizeImageX=30, sizeImageY=25):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_CamImageDim")
        self.attrib = ['sizeImageX', 'sizeImageY']
        self.children = []
        self.parent = None
        self._sizeImageX = _cast(float, sizeImageX)
        self._sizeImageY = _cast(float, sizeImageY)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_CamImageDim)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_CamImageDim.subclass:
            return create_CamImageDim.subclass(*args_, **kwargs_)
        else:
            return create_CamImageDim(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sizeImageX(self): return self._sizeImageX
    def set_sizeImageX(self, value):
        self._sizeImageX = value
        update_node(self,self.troot,"phase")
    sizeImageX = property(get_sizeImageX, set_sizeImageX)
    def get_sizeImageY(self): return self._sizeImageY
    def set_sizeImageY(self, value):
        self._sizeImageY = value
        update_node(self,self.troot,"phase")
    sizeImageY = property(get_sizeImageY, set_sizeImageY)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_CamImageDim', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_CamImageDim')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_CamImageDim')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_CamImageDim', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_CamImageDim'):
        if self.sizeImageX is not None and 'sizeImageX' not in already_processed:
            already_processed.add('sizeImageX')
            outfile.write(' sizeImageX="%s"' % self.gds_format_double(self.sizeImageX, input_name='sizeImageX'))
        if self.sizeImageY is not None and 'sizeImageY' not in already_processed:
            already_processed.add('sizeImageY')
            outfile.write(' sizeImageY="%s"' % self.gds_format_double(self.sizeImageY, input_name='sizeImageY'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_CamImageDim', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_CamImageDim', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.sizeImageX is not None:
            element.set('sizeImageX', self.gds_format_double(self.sizeImageX))
        if self.sizeImageY is not None:
            element.set('sizeImageY', self.gds_format_double(self.sizeImageY))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_CamImageDim'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sizeImageX is not None and 'sizeImageX' not in already_processed:
            already_processed.add('sizeImageX')
            showIndent(outfile, level)
            outfile.write('sizeImageX=%e,\n' % (self.sizeImageX,))
        if self.sizeImageY is not None and 'sizeImageY' not in already_processed:
            already_processed.add('sizeImageY')
            showIndent(outfile, level)
            outfile.write('sizeImageY=%e,\n' % (self.sizeImageY,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sizeImageX', node)
        if value is not None and 'sizeImageX' not in already_processed:
            already_processed.add('sizeImageX')
            try:
                self.sizeImageX = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sizeImageX): %s' % exp)
        value = find_attr_value_('sizeImageY', node)
        if value is not None and 'sizeImageY' not in already_processed:
            already_processed.add('sizeImageY')
            try:
                self.sizeImageY = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sizeImageY): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_CamImageDim


class create_CamImageAOV(GeneratedsSuper):
    """Define the FOV by angles of view in length and width. Define the FOV
    by angles of view in length and width. Angle of view length
    [\u00B0] Angle of view length [\u00B0] Angle of view width
    [\u00B0] Angle of view width [\u00B0]"""
    subclass = None
    superclass = None
    def __init__(self, aovX=30, aovY=25):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_CamImageAOV")
        self.attrib = ['aovX', 'aovY']
        self.children = []
        self.parent = None
        self._aovX = _cast(float, aovX)
        self._aovY = _cast(float, aovY)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_CamImageAOV)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_CamImageAOV.subclass:
            return create_CamImageAOV.subclass(*args_, **kwargs_)
        else:
            return create_CamImageAOV(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_aovX(self): return self._aovX
    def set_aovX(self, value):
        self._aovX = value
        update_node(self,self.troot,"phase")
    aovX = property(get_aovX, set_aovX)
    def get_aovY(self): return self._aovY
    def set_aovY(self, value):
        self._aovY = value
        update_node(self,self.troot,"phase")
    aovY = property(get_aovY, set_aovY)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_CamImageAOV', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_CamImageAOV')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_CamImageAOV')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_CamImageAOV', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_CamImageAOV'):
        if self.aovX is not None and 'aovX' not in already_processed:
            already_processed.add('aovX')
            outfile.write(' aovX="%s"' % self.gds_format_double(self.aovX, input_name='aovX'))
        if self.aovY is not None and 'aovY' not in already_processed:
            already_processed.add('aovY')
            outfile.write(' aovY="%s"' % self.gds_format_double(self.aovY, input_name='aovY'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_CamImageAOV', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_CamImageAOV', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.aovX is not None:
            element.set('aovX', self.gds_format_double(self.aovX))
        if self.aovY is not None:
            element.set('aovY', self.gds_format_double(self.aovY))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_CamImageAOV'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.aovX is not None and 'aovX' not in already_processed:
            already_processed.add('aovX')
            showIndent(outfile, level)
            outfile.write('aovX=%e,\n' % (self.aovX,))
        if self.aovY is not None and 'aovY' not in already_processed:
            already_processed.add('aovY')
            showIndent(outfile, level)
            outfile.write('aovY=%e,\n' % (self.aovY,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aovX', node)
        if value is not None and 'aovX' not in already_processed:
            already_processed.add('aovX')
            try:
                self.aovX = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (aovX): %s' % exp)
        value = find_attr_value_('aovY', node)
        if value is not None and 'aovY' not in already_processed:
            already_processed.add('aovY')
            try:
                self.aovY = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (aovY): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_CamImageAOV


class create_NbPixels(GeneratedsSuper):
    """Number of pixels (Horizontal) Number of pixels (Horizontal) Number
    of pixels (Vertical) Number of pixels (Vertical)"""
    subclass = None
    superclass = None
    def __init__(self, nbPixelsX=60, nbPixelsY=50):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_NbPixels")
        self.attrib = ['nbPixelsX', 'nbPixelsY']
        self.children = []
        self.parent = None
        self._nbPixelsX = _cast(int, nbPixelsX)
        self._nbPixelsY = _cast(int, nbPixelsY)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_NbPixels)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_NbPixels.subclass:
            return create_NbPixels.subclass(*args_, **kwargs_)
        else:
            return create_NbPixels(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nbPixelsX(self): return self._nbPixelsX
    def set_nbPixelsX(self, value):
        self._nbPixelsX = value
        update_node(self,self.troot,"phase")
    nbPixelsX = property(get_nbPixelsX, set_nbPixelsX)
    def get_nbPixelsY(self): return self._nbPixelsY
    def set_nbPixelsY(self, value):
        self._nbPixelsY = value
        update_node(self,self.troot,"phase")
    nbPixelsY = property(get_nbPixelsY, set_nbPixelsY)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_NbPixels', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_NbPixels')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_NbPixels')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_NbPixels', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_NbPixels'):
        if self.nbPixelsX is not None and 'nbPixelsX' not in already_processed:
            already_processed.add('nbPixelsX')
            outfile.write(' nbPixelsX="%s"' % self.gds_format_integer(self.nbPixelsX, input_name='nbPixelsX'))
        if self.nbPixelsY is not None and 'nbPixelsY' not in already_processed:
            already_processed.add('nbPixelsY')
            outfile.write(' nbPixelsY="%s"' % self.gds_format_integer(self.nbPixelsY, input_name='nbPixelsY'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_NbPixels', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_NbPixels', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.nbPixelsX is not None:
            element.set('nbPixelsX', self.gds_format_integer(self.nbPixelsX))
        if self.nbPixelsY is not None:
            element.set('nbPixelsY', self.gds_format_integer(self.nbPixelsY))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_NbPixels'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nbPixelsX is not None and 'nbPixelsX' not in already_processed:
            already_processed.add('nbPixelsX')
            showIndent(outfile, level)
            outfile.write('nbPixelsX=%d,\n' % (self.nbPixelsX,))
        if self.nbPixelsY is not None and 'nbPixelsY' not in already_processed:
            already_processed.add('nbPixelsY')
            showIndent(outfile, level)
            outfile.write('nbPixelsY=%d,\n' % (self.nbPixelsY,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nbPixelsX', node)
        if value is not None and 'nbPixelsX' not in already_processed:
            already_processed.add('nbPixelsX')
            try:
                self.nbPixelsX = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('nbPixelsY', node)
        if value is not None and 'nbPixelsY' not in already_processed:
            already_processed.add('nbPixelsY')
            try:
                self.nbPixelsY = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_NbPixels


class create_FishEyeFOV(GeneratedsSuper):
    """Hemispherical camera FOV Hemispherical camera FOV This defines the
    maximum zenith angle at the boundaries of the image This defines
    the maximum zenith angle at the boundaries of the image"""
    subclass = None
    superclass = None
    def __init__(self, angleMaxFishEye=90):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_FishEyeFOV")
        self.attrib = ['angleMaxFishEye']
        self.children = []
        self.parent = None
        self._angleMaxFishEye = _cast(float, angleMaxFishEye)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_FishEyeFOV)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_FishEyeFOV.subclass:
            return create_FishEyeFOV.subclass(*args_, **kwargs_)
        else:
            return create_FishEyeFOV(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_angleMaxFishEye(self): return self._angleMaxFishEye
    def set_angleMaxFishEye(self, value):
        self._angleMaxFishEye = value
        update_node(self,self.troot,"phase")
    angleMaxFishEye = property(get_angleMaxFishEye, set_angleMaxFishEye)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_FishEyeFOV', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_FishEyeFOV')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_FishEyeFOV')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_FishEyeFOV', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_FishEyeFOV'):
        if self.angleMaxFishEye is not None and 'angleMaxFishEye' not in already_processed:
            already_processed.add('angleMaxFishEye')
            outfile.write(' angleMaxFishEye="%s"' % self.gds_format_double(self.angleMaxFishEye, input_name='angleMaxFishEye'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_FishEyeFOV', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_FishEyeFOV', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.angleMaxFishEye is not None:
            element.set('angleMaxFishEye', self.gds_format_double(self.angleMaxFishEye))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_FishEyeFOV'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.angleMaxFishEye is not None and 'angleMaxFishEye' not in already_processed:
            already_processed.add('angleMaxFishEye')
            showIndent(outfile, level)
            outfile.write('angleMaxFishEye=%e,\n' % (self.angleMaxFishEye,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('angleMaxFishEye', node)
        if value is not None and 'angleMaxFishEye' not in already_processed:
            already_processed.add('angleMaxFishEye')
            try:
                self.angleMaxFishEye = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (angleMaxFishEye): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_FishEyeFOV


class create_Radiometer(GeneratedsSuper):
    """Radiometer Radiometer Define a radiometer output Define a radiometer
    output"""
    subclass = None
    superclass = None
    def __init__(self, ifRadiometer=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_Radiometer")
        self.attrib = ['ifRadiometer']
        self.children = []
        self.parent = None
        self._ifRadiometer = _cast(int, ifRadiometer)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Radiometer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Radiometer.subclass:
            return create_Radiometer.subclass(*args_, **kwargs_)
        else:
            return create_Radiometer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ifRadiometer(self): return self._ifRadiometer
    def set_ifRadiometer(self, value):
        self._ifRadiometer = value
        update_node(self,self.troot,"phase")
    ifRadiometer = property(get_ifRadiometer, set_ifRadiometer)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Radiometer', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Radiometer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Radiometer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Radiometer', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Radiometer'):
        if self.ifRadiometer is not None and 'ifRadiometer' not in already_processed:
            already_processed.add('ifRadiometer')
            outfile.write(' ifRadiometer="%s"' % self.gds_format_integer(self.ifRadiometer, input_name='ifRadiometer'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Radiometer', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_Radiometer', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ifRadiometer is not None:
            element.set('ifRadiometer', self.gds_format_integer(self.ifRadiometer))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Radiometer'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ifRadiometer is not None and 'ifRadiometer' not in already_processed:
            already_processed.add('ifRadiometer')
            showIndent(outfile, level)
            outfile.write('ifRadiometer=%d,\n' % (self.ifRadiometer,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ifRadiometer', node)
        if value is not None and 'ifRadiometer' not in already_processed:
            already_processed.add('ifRadiometer')
            try:
                self.ifRadiometer = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_Radiometer


class create_Pushbroom(GeneratedsSuper):
    """Pushbroom Pushbroom Importation of files containing the theta/phi
    information Importation of files containing the theta/phi
    information"""
    subclass = None
    superclass = None
    def __init__(self, importThetaPhi=0, Platform=None, Sensor=None, Importation=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_Pushbroom")
        self.attrib = ['importThetaPhi']
        self.children = ['Platform', 'Sensor', 'Importation']
        self.parent = None
        self._importThetaPhi = _cast(int, importThetaPhi)
        self._Platform = Platform
        self._Sensor = Sensor
        self._Importation = Importation
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Pushbroom)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Pushbroom.subclass:
            return create_Pushbroom.subclass(*args_, **kwargs_)
        else:
            return create_Pushbroom(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Platform(self): return self._Platform
    def set_Platform(self, value):
        if value is not None:
            checkclass(value, create_Platform)
            value.parent = self
        self._Platform = value
    Platform = property(get_Platform, set_Platform)
    def get_Sensor(self): return self._Sensor
    def set_Sensor(self, value):
        if value is not None:
            checkclass(value, create_Sensor)
            value.parent = self
        self._Sensor = value
    Sensor = property(get_Sensor, set_Sensor)
    def get_Importation(self): return self._Importation
    def set_Importation(self, value):
        if value is not None:
            checkclass(value, create_Importation)
            value.parent = self
        self._Importation = value
    Importation = property(get_Importation, set_Importation)
    def get_importThetaPhi(self): return self._importThetaPhi
    def set_importThetaPhi(self, value):
        self._importThetaPhi = value
        update_node(self,self.troot,"phase")
    importThetaPhi = property(get_importThetaPhi, set_importThetaPhi)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Platform is not None or
            self.Sensor is not None or
            self.Importation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Pushbroom', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Pushbroom')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Pushbroom')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Pushbroom', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Pushbroom'):
        if self.importThetaPhi is not None and 'importThetaPhi' not in already_processed:
            already_processed.add('importThetaPhi')
            outfile.write(' importThetaPhi="%s"' % self.gds_format_integer(self.importThetaPhi, input_name='importThetaPhi'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Pushbroom', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Platform is not None:
            self.Platform.export(outfile, level, namespaceprefix_, name_='Platform', pretty_print=pretty_print)
        if self.Sensor is not None:
            self.Sensor.export(outfile, level, namespaceprefix_, name_='Sensor', pretty_print=pretty_print)
        if self.Importation is not None:
            self.Importation.export(outfile, level, namespaceprefix_, name_='Importation', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Pushbroom', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.importThetaPhi is not None:
            element.set('importThetaPhi', self.gds_format_integer(self.importThetaPhi))
        if self.Platform is not None:
            Platform_ = self.Platform
            Platform_.to_etree(element, name_='Platform', mapping_=mapping_)
        if self.Sensor is not None:
            Sensor_ = self.Sensor
            Sensor_.to_etree(element, name_='Sensor', mapping_=mapping_)
        if self.Importation is not None:
            Importation_ = self.Importation
            Importation_.to_etree(element, name_='Importation', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Pushbroom'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.importThetaPhi is not None and 'importThetaPhi' not in already_processed:
            already_processed.add('importThetaPhi')
            showIndent(outfile, level)
            outfile.write('importThetaPhi=%d,\n' % (self.importThetaPhi,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Platform is not None:
            showIndent(outfile, level)
            outfile.write('Platform=model_._Platform(\n')
            self.Platform.exportLiteral(outfile, level, name_='Platform')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Sensor is not None:
            showIndent(outfile, level)
            outfile.write('Sensor=model_._Sensor(\n')
            self.Sensor.exportLiteral(outfile, level, name_='Sensor')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Importation is not None:
            showIndent(outfile, level)
            outfile.write('Importation=model_._Importation(\n')
            self.Importation.exportLiteral(outfile, level, name_='Importation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('importThetaPhi', node)
        if value is not None and 'importThetaPhi' not in already_processed:
            already_processed.add('importThetaPhi')
            try:
                self.importThetaPhi = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Platform':
            obj_ = create_Platform.factory()
            obj_.build(child_)
            self.set_Platform(obj_)
            obj_.original_tagname_ = 'Platform'
        elif nodeName_ == 'Sensor':
            obj_ = create_Sensor.factory()
            obj_.build(child_)
            self.set_Sensor(obj_)
            obj_.original_tagname_ = 'Sensor'
        elif nodeName_ == 'Importation':
            obj_ = create_Importation.factory()
            obj_.build(child_)
            self.set_Importation(obj_)
            obj_.original_tagname_ = 'Importation'
# end class create_Pushbroom


class create_Platform(GeneratedsSuper):
    """Platform information Platform information Acquisition azimuth angle
    relative to the plane perpendicular to the flight direction
    Acquisition azimuth angle relative to the plane perpendicular to
    the flight direction The azimuth angle that represent the
    platform moving direction The azimuth angle that represent the
    platform moving direction Pushbroom Camera Orientation (Pitch)
    Pushbroom Camera Orientation (Pitch)"""
    subclass = None
    superclass = None
    def __init__(self, platformAzimuth=0, platformDirection=0, pitchLookAngle=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_Platform")
        self.attrib = ['platformAzimuth', 'platformDirection', 'pitchLookAngle']
        self.children = []
        self.parent = None
        self._platformAzimuth = _cast(float, platformAzimuth)
        self._platformDirection = _cast(float, platformDirection)
        self._pitchLookAngle = _cast(float, pitchLookAngle)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Platform)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Platform.subclass:
            return create_Platform.subclass(*args_, **kwargs_)
        else:
            return create_Platform(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_platformAzimuth(self): return self._platformAzimuth
    def set_platformAzimuth(self, value):
        self._platformAzimuth = value
        update_node(self,self.troot,"phase")
    platformAzimuth = property(get_platformAzimuth, set_platformAzimuth)
    def get_platformDirection(self): return self._platformDirection
    def set_platformDirection(self, value):
        self._platformDirection = value
        update_node(self,self.troot,"phase")
    platformDirection = property(get_platformDirection, set_platformDirection)
    def get_pitchLookAngle(self): return self._pitchLookAngle
    def set_pitchLookAngle(self, value):
        self._pitchLookAngle = value
        update_node(self,self.troot,"phase")
    pitchLookAngle = property(get_pitchLookAngle, set_pitchLookAngle)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Platform', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Platform')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Platform')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Platform', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Platform'):
        if self.platformAzimuth is not None and 'platformAzimuth' not in already_processed:
            already_processed.add('platformAzimuth')
            outfile.write(' platformAzimuth="%s"' % self.gds_format_double(self.platformAzimuth, input_name='platformAzimuth'))
        if self.platformDirection is not None and 'platformDirection' not in already_processed:
            already_processed.add('platformDirection')
            outfile.write(' platformDirection="%s"' % self.gds_format_double(self.platformDirection, input_name='platformDirection'))
        if self.pitchLookAngle is not None and 'pitchLookAngle' not in already_processed:
            already_processed.add('pitchLookAngle')
            outfile.write(' pitchLookAngle="%s"' % self.gds_format_double(self.pitchLookAngle, input_name='pitchLookAngle'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Platform', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_Platform', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.platformAzimuth is not None:
            element.set('platformAzimuth', self.gds_format_double(self.platformAzimuth))
        if self.platformDirection is not None:
            element.set('platformDirection', self.gds_format_double(self.platformDirection))
        if self.pitchLookAngle is not None:
            element.set('pitchLookAngle', self.gds_format_double(self.pitchLookAngle))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Platform'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.platformAzimuth is not None and 'platformAzimuth' not in already_processed:
            already_processed.add('platformAzimuth')
            showIndent(outfile, level)
            outfile.write('platformAzimuth=%e,\n' % (self.platformAzimuth,))
        if self.platformDirection is not None and 'platformDirection' not in already_processed:
            already_processed.add('platformDirection')
            showIndent(outfile, level)
            outfile.write('platformDirection=%e,\n' % (self.platformDirection,))
        if self.pitchLookAngle is not None and 'pitchLookAngle' not in already_processed:
            already_processed.add('pitchLookAngle')
            showIndent(outfile, level)
            outfile.write('pitchLookAngle=%e,\n' % (self.pitchLookAngle,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('platformAzimuth', node)
        if value is not None and 'platformAzimuth' not in already_processed:
            already_processed.add('platformAzimuth')
            try:
                self.platformAzimuth = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (platformAzimuth): %s' % exp)
        value = find_attr_value_('platformDirection', node)
        if value is not None and 'platformDirection' not in already_processed:
            already_processed.add('platformDirection')
            try:
                self.platformDirection = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (platformDirection): %s' % exp)
        value = find_attr_value_('pitchLookAngle', node)
        if value is not None and 'pitchLookAngle' not in already_processed:
            already_processed.add('pitchLookAngle')
            try:
                self.pitchLookAngle = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (pitchLookAngle): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_Platform


class create_Importation(GeneratedsSuper):
    """Importation Importation An ascii file descibe the azimuth
    distribution over the image An ascii file descibe the azimuth
    distribution over the image Resolution of imported angle
    distribution file Resolution of imported angle distribution file
    Altitude of the sensor trajactory Altitude of the sensor
    trajactory Offset X from the beginning of the map relative to
    the origin position of the scene Offset X from the beginning of
    the map relative to the origin position of the scene Offset Y
    from the beginning of the map relative to the origin position of
    the scene Offset Y from the beginning of the map relative to the
    origin position of the scene An ascii file descibe the zenith
    distribution over the image An ascii file descibe the zenith
    distribution over the image"""
    subclass = None
    superclass = None
    def __init__(self, phiFile='phi.txt', resImage=1, sensorAltitude=1000, offsetX=0, offsetY=0, thetaFile='theta.txt'):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_Importation")
        self.attrib = ['phiFile', 'resImage', 'sensorAltitude', 'offsetX', 'offsetY', 'thetaFile']
        self.children = []
        self.parent = None
        self._phiFile = _cast(None, phiFile)
        self._resImage = _cast(float, resImage)
        self._sensorAltitude = _cast(float, sensorAltitude)
        self._offsetX = _cast(float, offsetX)
        self._offsetY = _cast(float, offsetY)
        self._thetaFile = _cast(None, thetaFile)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Importation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Importation.subclass:
            return create_Importation.subclass(*args_, **kwargs_)
        else:
            return create_Importation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_phiFile(self): return self._phiFile
    def set_phiFile(self, value):
        self._phiFile = value
        update_node(self,self.troot,"phase")
    phiFile = property(get_phiFile, set_phiFile)
    def get_resImage(self): return self._resImage
    def set_resImage(self, value):
        self._resImage = value
        update_node(self,self.troot,"phase")
    resImage = property(get_resImage, set_resImage)
    def get_sensorAltitude(self): return self._sensorAltitude
    def set_sensorAltitude(self, value):
        self._sensorAltitude = value
        update_node(self,self.troot,"phase")
    sensorAltitude = property(get_sensorAltitude, set_sensorAltitude)
    def get_offsetX(self): return self._offsetX
    def set_offsetX(self, value):
        self._offsetX = value
        update_node(self,self.troot,"phase")
    offsetX = property(get_offsetX, set_offsetX)
    def get_offsetY(self): return self._offsetY
    def set_offsetY(self, value):
        self._offsetY = value
        update_node(self,self.troot,"phase")
    offsetY = property(get_offsetY, set_offsetY)
    def get_thetaFile(self): return self._thetaFile
    def set_thetaFile(self, value):
        self._thetaFile = value
        update_node(self,self.troot,"phase")
    thetaFile = property(get_thetaFile, set_thetaFile)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Importation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Importation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Importation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Importation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Importation'):
        if self.phiFile is not None and 'phiFile' not in already_processed:
            already_processed.add('phiFile')
            outfile.write(' phiFile=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.phiFile), input_name='phiFile')), ))
        if self.resImage is not None and 'resImage' not in already_processed:
            already_processed.add('resImage')
            outfile.write(' resImage="%s"' % self.gds_format_double(self.resImage, input_name='resImage'))
        if self.sensorAltitude is not None and 'sensorAltitude' not in already_processed:
            already_processed.add('sensorAltitude')
            outfile.write(' sensorAltitude="%s"' % self.gds_format_double(self.sensorAltitude, input_name='sensorAltitude'))
        if self.offsetX is not None and 'offsetX' not in already_processed:
            already_processed.add('offsetX')
            outfile.write(' offsetX="%s"' % self.gds_format_double(self.offsetX, input_name='offsetX'))
        if self.offsetY is not None and 'offsetY' not in already_processed:
            already_processed.add('offsetY')
            outfile.write(' offsetY="%s"' % self.gds_format_double(self.offsetY, input_name='offsetY'))
        if self.thetaFile is not None and 'thetaFile' not in already_processed:
            already_processed.add('thetaFile')
            outfile.write(' thetaFile=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.thetaFile), input_name='thetaFile')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Importation', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_Importation', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.phiFile is not None:
            element.set('phiFile', self.gds_format_string(self.phiFile))
        if self.resImage is not None:
            element.set('resImage', self.gds_format_double(self.resImage))
        if self.sensorAltitude is not None:
            element.set('sensorAltitude', self.gds_format_double(self.sensorAltitude))
        if self.offsetX is not None:
            element.set('offsetX', self.gds_format_double(self.offsetX))
        if self.offsetY is not None:
            element.set('offsetY', self.gds_format_double(self.offsetY))
        if self.thetaFile is not None:
            element.set('thetaFile', self.gds_format_string(self.thetaFile))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Importation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.phiFile is not None and 'phiFile' not in already_processed:
            already_processed.add('phiFile')
            showIndent(outfile, level)
            outfile.write('phiFile="%s",\n' % (self.phiFile,))
        if self.resImage is not None and 'resImage' not in already_processed:
            already_processed.add('resImage')
            showIndent(outfile, level)
            outfile.write('resImage=%e,\n' % (self.resImage,))
        if self.sensorAltitude is not None and 'sensorAltitude' not in already_processed:
            already_processed.add('sensorAltitude')
            showIndent(outfile, level)
            outfile.write('sensorAltitude=%e,\n' % (self.sensorAltitude,))
        if self.offsetX is not None and 'offsetX' not in already_processed:
            already_processed.add('offsetX')
            showIndent(outfile, level)
            outfile.write('offsetX=%e,\n' % (self.offsetX,))
        if self.offsetY is not None and 'offsetY' not in already_processed:
            already_processed.add('offsetY')
            showIndent(outfile, level)
            outfile.write('offsetY=%e,\n' % (self.offsetY,))
        if self.thetaFile is not None and 'thetaFile' not in already_processed:
            already_processed.add('thetaFile')
            showIndent(outfile, level)
            outfile.write('thetaFile="%s",\n' % (self.thetaFile,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('phiFile', node)
        if value is not None and 'phiFile' not in already_processed:
            already_processed.add('phiFile')
            self.phiFile = value
        value = find_attr_value_('resImage', node)
        if value is not None and 'resImage' not in already_processed:
            already_processed.add('resImage')
            try:
                self.resImage = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (resImage): %s' % exp)
        value = find_attr_value_('sensorAltitude', node)
        if value is not None and 'sensorAltitude' not in already_processed:
            already_processed.add('sensorAltitude')
            try:
                self.sensorAltitude = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sensorAltitude): %s' % exp)
        value = find_attr_value_('offsetX', node)
        if value is not None and 'offsetX' not in already_processed:
            already_processed.add('offsetX')
            try:
                self.offsetX = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (offsetX): %s' % exp)
        value = find_attr_value_('offsetY', node)
        if value is not None and 'offsetY' not in already_processed:
            already_processed.add('offsetY')
            try:
                self.offsetY = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (offsetY): %s' % exp)
        value = find_attr_value_('thetaFile', node)
        if value is not None and 'thetaFile' not in already_processed:
            already_processed.add('thetaFile')
            self.thetaFile = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_Importation


class create_InsideSensor(GeneratedsSuper):
    """Mode Mode"""
    subclass = None
    superclass = None
    def __init__(self, sensorConfiguration=0, Sensor=None, Image=None, Hemisphere=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_InsideSensor")
        self.attrib = ['sensorConfiguration']
        self.children = ['Sensor', 'Image', 'Hemisphere']
        self.parent = None
        self._sensorConfiguration = _cast(int, sensorConfiguration)
        self._Sensor = Sensor
        self._Image = Image
        self._Hemisphere = Hemisphere
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_InsideSensor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_InsideSensor.subclass:
            return create_InsideSensor.subclass(*args_, **kwargs_)
        else:
            return create_InsideSensor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Sensor(self): return self._Sensor
    def set_Sensor(self, value):
        if value is not None:
            checkclass(value, create_Sensor)
            value.parent = self
        self._Sensor = value
    Sensor = property(get_Sensor, set_Sensor)
    def get_Image(self): return self._Image
    def set_Image(self, value):
        if value is not None:
            checkclass(value, create_Image)
            value.parent = self
        self._Image = value
    Image = property(get_Image, set_Image)
    def get_Hemisphere(self): return self._Hemisphere
    def set_Hemisphere(self, value):
        if value is not None:
            checkclass(value, create_Hemisphere)
            value.parent = self
        self._Hemisphere = value
    Hemisphere = property(get_Hemisphere, set_Hemisphere)
    def get_sensorConfiguration(self): return self._sensorConfiguration
    def set_sensorConfiguration(self, value):
        self._sensorConfiguration = value
        update_node(self,self.troot,"phase")
    sensorConfiguration = property(get_sensorConfiguration, set_sensorConfiguration)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Sensor is not None or
            self.Image is not None or
            self.Hemisphere is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_InsideSensor', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_InsideSensor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_InsideSensor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_InsideSensor', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_InsideSensor'):
        if self.sensorConfiguration is not None and 'sensorConfiguration' not in already_processed:
            already_processed.add('sensorConfiguration')
            outfile.write(' sensorConfiguration="%s"' % self.gds_format_integer(self.sensorConfiguration, input_name='sensorConfiguration'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_InsideSensor', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Sensor is not None:
            self.Sensor.export(outfile, level, namespaceprefix_, name_='Sensor', pretty_print=pretty_print)
        if self.Image is not None:
            self.Image.export(outfile, level, namespaceprefix_, name_='Image', pretty_print=pretty_print)
        if self.Hemisphere is not None:
            self.Hemisphere.export(outfile, level, namespaceprefix_, name_='Hemisphere', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_InsideSensor', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.sensorConfiguration is not None:
            element.set('sensorConfiguration', self.gds_format_integer(self.sensorConfiguration))
        if self.Sensor is not None:
            Sensor_ = self.Sensor
            Sensor_.to_etree(element, name_='Sensor', mapping_=mapping_)
        if self.Image is not None:
            Image_ = self.Image
            Image_.to_etree(element, name_='Image', mapping_=mapping_)
        if self.Hemisphere is not None:
            Hemisphere_ = self.Hemisphere
            Hemisphere_.to_etree(element, name_='Hemisphere', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_InsideSensor'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sensorConfiguration is not None and 'sensorConfiguration' not in already_processed:
            already_processed.add('sensorConfiguration')
            showIndent(outfile, level)
            outfile.write('sensorConfiguration=%d,\n' % (self.sensorConfiguration,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Sensor is not None:
            showIndent(outfile, level)
            outfile.write('Sensor=model_._Sensor(\n')
            self.Sensor.exportLiteral(outfile, level, name_='Sensor')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Image is not None:
            showIndent(outfile, level)
            outfile.write('Image=model_._Image(\n')
            self.Image.exportLiteral(outfile, level, name_='Image')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Hemisphere is not None:
            showIndent(outfile, level)
            outfile.write('Hemisphere=model_._Hemisphere(\n')
            self.Hemisphere.exportLiteral(outfile, level, name_='Hemisphere')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sensorConfiguration', node)
        if value is not None and 'sensorConfiguration' not in already_processed:
            already_processed.add('sensorConfiguration')
            try:
                self.sensorConfiguration = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Sensor':
            obj_ = create_Sensor.factory()
            obj_.build(child_)
            self.set_Sensor(obj_)
            obj_.original_tagname_ = 'Sensor'
        elif nodeName_ == 'Image':
            obj_ = create_Image.factory()
            obj_.build(child_)
            self.set_Image(obj_)
            obj_.original_tagname_ = 'Image'
        elif nodeName_ == 'Hemisphere':
            obj_ = create_Hemisphere.factory()
            obj_.build(child_)
            self.set_Hemisphere(obj_)
            obj_.original_tagname_ = 'Hemisphere'
# end class create_InsideSensor


class create_SensorCentralPosition(GeneratedsSuper):
    """Z coordinate of sensor Z coordinate of sensor X coordinate of sensor
    X coordinate of sensor Y coordinate of sensor Y coordinate of
    sensor"""
    subclass = None
    superclass = None
    def __init__(self, sensorPosZ=1.6, sensorPosX=36, sensorPosY=36):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_SensorCentralPosition")
        self.attrib = ['sensorPosZ', 'sensorPosX', 'sensorPosY']
        self.children = []
        self.parent = None
        self._sensorPosZ = _cast(float, sensorPosZ)
        self._sensorPosX = _cast(float, sensorPosX)
        self._sensorPosY = _cast(float, sensorPosY)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_SensorCentralPosition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_SensorCentralPosition.subclass:
            return create_SensorCentralPosition.subclass(*args_, **kwargs_)
        else:
            return create_SensorCentralPosition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sensorPosZ(self): return self._sensorPosZ
    def set_sensorPosZ(self, value):
        self._sensorPosZ = value
        update_node(self,self.troot,"phase")
    sensorPosZ = property(get_sensorPosZ, set_sensorPosZ)
    def get_sensorPosX(self): return self._sensorPosX
    def set_sensorPosX(self, value):
        self._sensorPosX = value
        update_node(self,self.troot,"phase")
    sensorPosX = property(get_sensorPosX, set_sensorPosX)
    def get_sensorPosY(self): return self._sensorPosY
    def set_sensorPosY(self, value):
        self._sensorPosY = value
        update_node(self,self.troot,"phase")
    sensorPosY = property(get_sensorPosY, set_sensorPosY)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_SensorCentralPosition', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_SensorCentralPosition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_SensorCentralPosition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_SensorCentralPosition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_SensorCentralPosition'):
        if self.sensorPosZ is not None and 'sensorPosZ' not in already_processed:
            already_processed.add('sensorPosZ')
            outfile.write(' sensorPosZ="%s"' % self.gds_format_double(self.sensorPosZ, input_name='sensorPosZ'))
        if self.sensorPosX is not None and 'sensorPosX' not in already_processed:
            already_processed.add('sensorPosX')
            outfile.write(' sensorPosX="%s"' % self.gds_format_double(self.sensorPosX, input_name='sensorPosX'))
        if self.sensorPosY is not None and 'sensorPosY' not in already_processed:
            already_processed.add('sensorPosY')
            outfile.write(' sensorPosY="%s"' % self.gds_format_double(self.sensorPosY, input_name='sensorPosY'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_SensorCentralPosition', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_SensorCentralPosition', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.sensorPosZ is not None:
            element.set('sensorPosZ', self.gds_format_double(self.sensorPosZ))
        if self.sensorPosX is not None:
            element.set('sensorPosX', self.gds_format_double(self.sensorPosX))
        if self.sensorPosY is not None:
            element.set('sensorPosY', self.gds_format_double(self.sensorPosY))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_SensorCentralPosition'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sensorPosZ is not None and 'sensorPosZ' not in already_processed:
            already_processed.add('sensorPosZ')
            showIndent(outfile, level)
            outfile.write('sensorPosZ=%e,\n' % (self.sensorPosZ,))
        if self.sensorPosX is not None and 'sensorPosX' not in already_processed:
            already_processed.add('sensorPosX')
            showIndent(outfile, level)
            outfile.write('sensorPosX=%e,\n' % (self.sensorPosX,))
        if self.sensorPosY is not None and 'sensorPosY' not in already_processed:
            already_processed.add('sensorPosY')
            showIndent(outfile, level)
            outfile.write('sensorPosY=%e,\n' % (self.sensorPosY,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sensorPosZ', node)
        if value is not None and 'sensorPosZ' not in already_processed:
            already_processed.add('sensorPosZ')
            try:
                self.sensorPosZ = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sensorPosZ): %s' % exp)
        value = find_attr_value_('sensorPosX', node)
        if value is not None and 'sensorPosX' not in already_processed:
            already_processed.add('sensorPosX')
            try:
                self.sensorPosX = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sensorPosX): %s' % exp)
        value = find_attr_value_('sensorPosY', node)
        if value is not None and 'sensorPosY' not in already_processed:
            already_processed.add('sensorPosY')
            try:
                self.sensorPosY = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sensorPosY): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_SensorCentralPosition


class create_SensorView(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, viewDefinition=0, SensorViewDirection=None, SensorAngleDirection=None, CameraOrientYPR=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_SensorView")
        self.attrib = ['viewDefinition']
        self.children = ['SensorViewDirection', 'SensorAngleDirection', 'CameraOrientYPR']
        self.parent = None
        self._viewDefinition = _cast(int, viewDefinition)
        self._SensorViewDirection = SensorViewDirection
        self._SensorAngleDirection = SensorAngleDirection
        self._CameraOrientYPR = CameraOrientYPR
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_SensorView)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_SensorView.subclass:
            return create_SensorView.subclass(*args_, **kwargs_)
        else:
            return create_SensorView(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SensorViewDirection(self): return self._SensorViewDirection
    def set_SensorViewDirection(self, value):
        if value is not None:
            checkclass(value, create_SensorViewDirection)
            value.parent = self
        self._SensorViewDirection = value
    SensorViewDirection = property(get_SensorViewDirection, set_SensorViewDirection)
    def get_SensorAngleDirection(self): return self._SensorAngleDirection
    def set_SensorAngleDirection(self, value):
        if value is not None:
            checkclass(value, create_SensorAngleDirection)
            value.parent = self
        self._SensorAngleDirection = value
    SensorAngleDirection = property(get_SensorAngleDirection, set_SensorAngleDirection)
    def get_CameraOrientYPR(self): return self._CameraOrientYPR
    def set_CameraOrientYPR(self, value):
        if value is not None:
            checkclass(value, create_CameraOrientYPR)
            value.parent = self
        self._CameraOrientYPR = value
    CameraOrientYPR = property(get_CameraOrientYPR, set_CameraOrientYPR)
    def get_viewDefinition(self): return self._viewDefinition
    def set_viewDefinition(self, value):
        self._viewDefinition = value
        update_node(self,self.troot,"phase")
    viewDefinition = property(get_viewDefinition, set_viewDefinition)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.SensorViewDirection is not None or
            self.SensorAngleDirection is not None or
            self.CameraOrientYPR is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_SensorView', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_SensorView')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_SensorView')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_SensorView', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_SensorView'):
        if self.viewDefinition is not None and 'viewDefinition' not in already_processed:
            already_processed.add('viewDefinition')
            outfile.write(' viewDefinition="%s"' % self.gds_format_integer(self.viewDefinition, input_name='viewDefinition'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_SensorView', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SensorViewDirection is not None:
            self.SensorViewDirection.export(outfile, level, namespaceprefix_, name_='SensorViewDirection', pretty_print=pretty_print)
        if self.SensorAngleDirection is not None:
            self.SensorAngleDirection.export(outfile, level, namespaceprefix_, name_='SensorAngleDirection', pretty_print=pretty_print)
        if self.CameraOrientYPR is not None:
            self.CameraOrientYPR.export(outfile, level, namespaceprefix_, name_='CameraOrientYPR', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_SensorView', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.viewDefinition is not None:
            element.set('viewDefinition', self.gds_format_integer(self.viewDefinition))
        if self.SensorViewDirection is not None:
            SensorViewDirection_ = self.SensorViewDirection
            SensorViewDirection_.to_etree(element, name_='SensorViewDirection', mapping_=mapping_)
        if self.SensorAngleDirection is not None:
            SensorAngleDirection_ = self.SensorAngleDirection
            SensorAngleDirection_.to_etree(element, name_='SensorAngleDirection', mapping_=mapping_)
        if self.CameraOrientYPR is not None:
            CameraOrientYPR_ = self.CameraOrientYPR
            CameraOrientYPR_.to_etree(element, name_='CameraOrientYPR', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_SensorView'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.viewDefinition is not None and 'viewDefinition' not in already_processed:
            already_processed.add('viewDefinition')
            showIndent(outfile, level)
            outfile.write('viewDefinition=%d,\n' % (self.viewDefinition,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SensorViewDirection is not None:
            showIndent(outfile, level)
            outfile.write('SensorViewDirection=model_._SensorViewDirection(\n')
            self.SensorViewDirection.exportLiteral(outfile, level, name_='SensorViewDirection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SensorAngleDirection is not None:
            showIndent(outfile, level)
            outfile.write('SensorAngleDirection=model_._SensorAngleDirection(\n')
            self.SensorAngleDirection.exportLiteral(outfile, level, name_='SensorAngleDirection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CameraOrientYPR is not None:
            showIndent(outfile, level)
            outfile.write('CameraOrientYPR=model_._CameraOrientYPR(\n')
            self.CameraOrientYPR.exportLiteral(outfile, level, name_='CameraOrientYPR')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('viewDefinition', node)
        if value is not None and 'viewDefinition' not in already_processed:
            already_processed.add('viewDefinition')
            try:
                self.viewDefinition = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SensorViewDirection':
            obj_ = create_SensorViewDirection.factory()
            obj_.build(child_)
            self.set_SensorViewDirection(obj_)
            obj_.original_tagname_ = 'SensorViewDirection'
        elif nodeName_ == 'SensorAngleDirection':
            obj_ = create_SensorAngleDirection.factory()
            obj_.build(child_)
            self.set_SensorAngleDirection(obj_)
            obj_.original_tagname_ = 'SensorAngleDirection'
        elif nodeName_ == 'CameraOrientYPR':
            obj_ = create_CameraOrientYPR.factory()
            obj_.build(child_)
            self.set_CameraOrientYPR(obj_)
            obj_.original_tagname_ = 'CameraOrientYPR'
# end class create_SensorView


class create_SensorViewDirection(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sensorDirectionZ=0.15, sensorDirectionY=-0.7, sensorDirectionX=-0.7):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_SensorViewDirection")
        self.attrib = ['sensorDirectionZ', 'sensorDirectionY', 'sensorDirectionX']
        self.children = []
        self.parent = None
        self._sensorDirectionZ = _cast(float, sensorDirectionZ)
        self._sensorDirectionY = _cast(float, sensorDirectionY)
        self._sensorDirectionX = _cast(float, sensorDirectionX)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_SensorViewDirection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_SensorViewDirection.subclass:
            return create_SensorViewDirection.subclass(*args_, **kwargs_)
        else:
            return create_SensorViewDirection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sensorDirectionZ(self): return self._sensorDirectionZ
    def set_sensorDirectionZ(self, value):
        self._sensorDirectionZ = value
        update_node(self,self.troot,"phase")
    sensorDirectionZ = property(get_sensorDirectionZ, set_sensorDirectionZ)
    def get_sensorDirectionY(self): return self._sensorDirectionY
    def set_sensorDirectionY(self, value):
        self._sensorDirectionY = value
        update_node(self,self.troot,"phase")
    sensorDirectionY = property(get_sensorDirectionY, set_sensorDirectionY)
    def get_sensorDirectionX(self): return self._sensorDirectionX
    def set_sensorDirectionX(self, value):
        self._sensorDirectionX = value
        update_node(self,self.troot,"phase")
    sensorDirectionX = property(get_sensorDirectionX, set_sensorDirectionX)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_SensorViewDirection', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_SensorViewDirection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_SensorViewDirection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_SensorViewDirection', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_SensorViewDirection'):
        if self.sensorDirectionZ is not None and 'sensorDirectionZ' not in already_processed:
            already_processed.add('sensorDirectionZ')
            outfile.write(' sensorDirectionZ="%s"' % self.gds_format_double(self.sensorDirectionZ, input_name='sensorDirectionZ'))
        if self.sensorDirectionY is not None and 'sensorDirectionY' not in already_processed:
            already_processed.add('sensorDirectionY')
            outfile.write(' sensorDirectionY="%s"' % self.gds_format_double(self.sensorDirectionY, input_name='sensorDirectionY'))
        if self.sensorDirectionX is not None and 'sensorDirectionX' not in already_processed:
            already_processed.add('sensorDirectionX')
            outfile.write(' sensorDirectionX="%s"' % self.gds_format_double(self.sensorDirectionX, input_name='sensorDirectionX'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_SensorViewDirection', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_SensorViewDirection', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.sensorDirectionZ is not None:
            element.set('sensorDirectionZ', self.gds_format_double(self.sensorDirectionZ))
        if self.sensorDirectionY is not None:
            element.set('sensorDirectionY', self.gds_format_double(self.sensorDirectionY))
        if self.sensorDirectionX is not None:
            element.set('sensorDirectionX', self.gds_format_double(self.sensorDirectionX))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_SensorViewDirection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sensorDirectionZ is not None and 'sensorDirectionZ' not in already_processed:
            already_processed.add('sensorDirectionZ')
            showIndent(outfile, level)
            outfile.write('sensorDirectionZ=%e,\n' % (self.sensorDirectionZ,))
        if self.sensorDirectionY is not None and 'sensorDirectionY' not in already_processed:
            already_processed.add('sensorDirectionY')
            showIndent(outfile, level)
            outfile.write('sensorDirectionY=%e,\n' % (self.sensorDirectionY,))
        if self.sensorDirectionX is not None and 'sensorDirectionX' not in already_processed:
            already_processed.add('sensorDirectionX')
            showIndent(outfile, level)
            outfile.write('sensorDirectionX=%e,\n' % (self.sensorDirectionX,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sensorDirectionZ', node)
        if value is not None and 'sensorDirectionZ' not in already_processed:
            already_processed.add('sensorDirectionZ')
            try:
                self.sensorDirectionZ = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sensorDirectionZ): %s' % exp)
        value = find_attr_value_('sensorDirectionY', node)
        if value is not None and 'sensorDirectionY' not in already_processed:
            already_processed.add('sensorDirectionY')
            try:
                self.sensorDirectionY = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sensorDirectionY): %s' % exp)
        value = find_attr_value_('sensorDirectionX', node)
        if value is not None and 'sensorDirectionX' not in already_processed:
            already_processed.add('sensorDirectionX')
            try:
                self.sensorDirectionX = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sensorDirectionX): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_SensorViewDirection


class create_SensorAngleDirection(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sensorDirectionPhi=45, sensorDirectionTetha=98):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_SensorAngleDirection")
        self.attrib = ['sensorDirectionPhi', 'sensorDirectionTetha']
        self.children = []
        self.parent = None
        self._sensorDirectionPhi = _cast(float, sensorDirectionPhi)
        self._sensorDirectionTetha = _cast(float, sensorDirectionTetha)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_SensorAngleDirection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_SensorAngleDirection.subclass:
            return create_SensorAngleDirection.subclass(*args_, **kwargs_)
        else:
            return create_SensorAngleDirection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sensorDirectionPhi(self): return self._sensorDirectionPhi
    def set_sensorDirectionPhi(self, value):
        self._sensorDirectionPhi = value
        update_node(self,self.troot,"phase")
    sensorDirectionPhi = property(get_sensorDirectionPhi, set_sensorDirectionPhi)
    def get_sensorDirectionTetha(self): return self._sensorDirectionTetha
    def set_sensorDirectionTetha(self, value):
        self._sensorDirectionTetha = value
        update_node(self,self.troot,"phase")
    sensorDirectionTetha = property(get_sensorDirectionTetha, set_sensorDirectionTetha)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_SensorAngleDirection', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_SensorAngleDirection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_SensorAngleDirection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_SensorAngleDirection', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_SensorAngleDirection'):
        if self.sensorDirectionPhi is not None and 'sensorDirectionPhi' not in already_processed:
            already_processed.add('sensorDirectionPhi')
            outfile.write(' sensorDirectionPhi="%s"' % self.gds_format_double(self.sensorDirectionPhi, input_name='sensorDirectionPhi'))
        if self.sensorDirectionTetha is not None and 'sensorDirectionTetha' not in already_processed:
            already_processed.add('sensorDirectionTetha')
            outfile.write(' sensorDirectionTetha="%s"' % self.gds_format_double(self.sensorDirectionTetha, input_name='sensorDirectionTetha'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_SensorAngleDirection', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_SensorAngleDirection', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.sensorDirectionPhi is not None:
            element.set('sensorDirectionPhi', self.gds_format_double(self.sensorDirectionPhi))
        if self.sensorDirectionTetha is not None:
            element.set('sensorDirectionTetha', self.gds_format_double(self.sensorDirectionTetha))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_SensorAngleDirection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sensorDirectionPhi is not None and 'sensorDirectionPhi' not in already_processed:
            already_processed.add('sensorDirectionPhi')
            showIndent(outfile, level)
            outfile.write('sensorDirectionPhi=%e,\n' % (self.sensorDirectionPhi,))
        if self.sensorDirectionTetha is not None and 'sensorDirectionTetha' not in already_processed:
            already_processed.add('sensorDirectionTetha')
            showIndent(outfile, level)
            outfile.write('sensorDirectionTetha=%e,\n' % (self.sensorDirectionTetha,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sensorDirectionPhi', node)
        if value is not None and 'sensorDirectionPhi' not in already_processed:
            already_processed.add('sensorDirectionPhi')
            try:
                self.sensorDirectionPhi = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sensorDirectionPhi): %s' % exp)
        value = find_attr_value_('sensorDirectionTetha', node)
        if value is not None and 'sensorDirectionTetha' not in already_processed:
            already_processed.add('sensorDirectionTetha')
            try:
                self.sensorDirectionTetha = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sensorDirectionTetha): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_SensorAngleDirection


class create_Image(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SensorDimensions=None, ImageResolution=None, FocaleDistance=None, SensorOrientation=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_Image")
        self.attrib = ['']
        self.children = ['SensorDimensions', 'ImageResolution', 'FocaleDistance', 'SensorOrientation']
        self.parent = None
        self._SensorDimensions = SensorDimensions
        self._ImageResolution = ImageResolution
        self._FocaleDistance = FocaleDistance
        self._SensorOrientation = SensorOrientation
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Image)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Image.subclass:
            return create_Image.subclass(*args_, **kwargs_)
        else:
            return create_Image(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SensorDimensions(self): return self._SensorDimensions
    def set_SensorDimensions(self, value):
        if value is not None:
            checkclass(value, create_SensorDimensions)
            value.parent = self
        self._SensorDimensions = value
    SensorDimensions = property(get_SensorDimensions, set_SensorDimensions)
    def get_ImageResolution(self): return self._ImageResolution
    def set_ImageResolution(self, value):
        if value is not None:
            checkclass(value, create_ImageResolution)
            value.parent = self
        self._ImageResolution = value
    ImageResolution = property(get_ImageResolution, set_ImageResolution)
    def get_FocaleDistance(self): return self._FocaleDistance
    def set_FocaleDistance(self, value):
        if value is not None:
            checkclass(value, create_FocaleDistance)
            value.parent = self
        self._FocaleDistance = value
    FocaleDistance = property(get_FocaleDistance, set_FocaleDistance)
    def get_SensorOrientation(self): return self._SensorOrientation
    def set_SensorOrientation(self, value):
        if value is not None:
            checkclass(value, create_SensorOrientation)
            value.parent = self
        self._SensorOrientation = value
    SensorOrientation = property(get_SensorOrientation, set_SensorOrientation)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.SensorDimensions is not None or
            self.ImageResolution is not None or
            self.FocaleDistance is not None or
            self.SensorOrientation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Image', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Image')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Image')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Image', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Image'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Image', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SensorDimensions is not None:
            self.SensorDimensions.export(outfile, level, namespaceprefix_, name_='SensorDimensions', pretty_print=pretty_print)
        if self.ImageResolution is not None:
            self.ImageResolution.export(outfile, level, namespaceprefix_, name_='ImageResolution', pretty_print=pretty_print)
        if self.FocaleDistance is not None:
            self.FocaleDistance.export(outfile, level, namespaceprefix_, name_='FocaleDistance', pretty_print=pretty_print)
        if self.SensorOrientation is not None:
            self.SensorOrientation.export(outfile, level, namespaceprefix_, name_='SensorOrientation', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Image', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.SensorDimensions is not None:
            SensorDimensions_ = self.SensorDimensions
            SensorDimensions_.to_etree(element, name_='SensorDimensions', mapping_=mapping_)
        if self.ImageResolution is not None:
            ImageResolution_ = self.ImageResolution
            ImageResolution_.to_etree(element, name_='ImageResolution', mapping_=mapping_)
        if self.FocaleDistance is not None:
            FocaleDistance_ = self.FocaleDistance
            FocaleDistance_.to_etree(element, name_='FocaleDistance', mapping_=mapping_)
        if self.SensorOrientation is not None:
            SensorOrientation_ = self.SensorOrientation
            SensorOrientation_.to_etree(element, name_='SensorOrientation', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Image'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SensorDimensions is not None:
            showIndent(outfile, level)
            outfile.write('SensorDimensions=model_._SensorDimensions(\n')
            self.SensorDimensions.exportLiteral(outfile, level, name_='SensorDimensions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ImageResolution is not None:
            showIndent(outfile, level)
            outfile.write('ImageResolution=model_._ImageResolution(\n')
            self.ImageResolution.exportLiteral(outfile, level, name_='ImageResolution')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FocaleDistance is not None:
            showIndent(outfile, level)
            outfile.write('FocaleDistance=model_._FocaleDistance(\n')
            self.FocaleDistance.exportLiteral(outfile, level, name_='FocaleDistance')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SensorOrientation is not None:
            showIndent(outfile, level)
            outfile.write('SensorOrientation=model_._SensorOrientation(\n')
            self.SensorOrientation.exportLiteral(outfile, level, name_='SensorOrientation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SensorDimensions':
            obj_ = create_SensorDimensions.factory()
            obj_.build(child_)
            self.set_SensorDimensions(obj_)
            obj_.original_tagname_ = 'SensorDimensions'
        elif nodeName_ == 'ImageResolution':
            obj_ = create_ImageResolution.factory()
            obj_.build(child_)
            self.set_ImageResolution(obj_)
            obj_.original_tagname_ = 'ImageResolution'
        elif nodeName_ == 'FocaleDistance':
            obj_ = create_FocaleDistance.factory()
            obj_.build(child_)
            self.set_FocaleDistance(obj_)
            obj_.original_tagname_ = 'FocaleDistance'
        elif nodeName_ == 'SensorOrientation':
            obj_ = create_SensorOrientation.factory()
            obj_.build(child_)
            self.set_SensorOrientation(obj_)
            obj_.original_tagname_ = 'SensorOrientation'
# end class create_Image


class create_SensorDimensions(GeneratedsSuper):
    """Sensor width Sensor width Sensor height Sensor height"""
    subclass = None
    superclass = None
    def __init__(self, width=0.54, height=0.40):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_SensorDimensions")
        self.attrib = ['width', 'height']
        self.children = []
        self.parent = None
        self._width = _cast(float, width)
        self._height = _cast(float, height)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_SensorDimensions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_SensorDimensions.subclass:
            return create_SensorDimensions.subclass(*args_, **kwargs_)
        else:
            return create_SensorDimensions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_width(self): return self._width
    def set_width(self, value):
        self._width = value
        update_node(self,self.troot,"phase")
    width = property(get_width, set_width)
    def get_height(self): return self._height
    def set_height(self, value):
        self._height = value
        update_node(self,self.troot,"phase")
    height = property(get_height, set_height)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_SensorDimensions', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_SensorDimensions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_SensorDimensions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_SensorDimensions', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_SensorDimensions'):
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height="%s"' % self.gds_format_double(self.height, input_name='height'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_SensorDimensions', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_SensorDimensions', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.width is not None:
            element.set('width', self.gds_format_double(self.width))
        if self.height is not None:
            element.set('height', self.gds_format_double(self.height))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_SensorDimensions'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            showIndent(outfile, level)
            outfile.write('width=%e,\n' % (self.width,))
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            showIndent(outfile, level)
            outfile.write('height=%e,\n' % (self.height,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            try:
                self.width = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (width): %s' % exp)
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            try:
                self.height = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (height): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_SensorDimensions


class create_ImageResolution(GeneratedsSuper):
    """Image width Image width Image height Image height"""
    subclass = None
    superclass = None
    def __init__(self, nbPixelsWidth=1000, nbPixelsHeight=1000):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_ImageResolution")
        self.attrib = ['nbPixelsWidth', 'nbPixelsHeight']
        self.children = []
        self.parent = None
        self._nbPixelsWidth = _cast(int, nbPixelsWidth)
        self._nbPixelsHeight = _cast(int, nbPixelsHeight)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ImageResolution)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ImageResolution.subclass:
            return create_ImageResolution.subclass(*args_, **kwargs_)
        else:
            return create_ImageResolution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nbPixelsWidth(self): return self._nbPixelsWidth
    def set_nbPixelsWidth(self, value):
        self._nbPixelsWidth = value
        update_node(self,self.troot,"phase")
    nbPixelsWidth = property(get_nbPixelsWidth, set_nbPixelsWidth)
    def get_nbPixelsHeight(self): return self._nbPixelsHeight
    def set_nbPixelsHeight(self, value):
        self._nbPixelsHeight = value
        update_node(self,self.troot,"phase")
    nbPixelsHeight = property(get_nbPixelsHeight, set_nbPixelsHeight)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ImageResolution', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ImageResolution')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ImageResolution')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ImageResolution', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ImageResolution'):
        if self.nbPixelsWidth is not None and 'nbPixelsWidth' not in already_processed:
            already_processed.add('nbPixelsWidth')
            outfile.write(' nbPixelsWidth="%s"' % self.gds_format_integer(self.nbPixelsWidth, input_name='nbPixelsWidth'))
        if self.nbPixelsHeight is not None and 'nbPixelsHeight' not in already_processed:
            already_processed.add('nbPixelsHeight')
            outfile.write(' nbPixelsHeight="%s"' % self.gds_format_integer(self.nbPixelsHeight, input_name='nbPixelsHeight'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ImageResolution', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_ImageResolution', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.nbPixelsWidth is not None:
            element.set('nbPixelsWidth', self.gds_format_integer(self.nbPixelsWidth))
        if self.nbPixelsHeight is not None:
            element.set('nbPixelsHeight', self.gds_format_integer(self.nbPixelsHeight))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ImageResolution'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nbPixelsWidth is not None and 'nbPixelsWidth' not in already_processed:
            already_processed.add('nbPixelsWidth')
            showIndent(outfile, level)
            outfile.write('nbPixelsWidth=%d,\n' % (self.nbPixelsWidth,))
        if self.nbPixelsHeight is not None and 'nbPixelsHeight' not in already_processed:
            already_processed.add('nbPixelsHeight')
            showIndent(outfile, level)
            outfile.write('nbPixelsHeight=%d,\n' % (self.nbPixelsHeight,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nbPixelsWidth', node)
        if value is not None and 'nbPixelsWidth' not in already_processed:
            already_processed.add('nbPixelsWidth')
            try:
                self.nbPixelsWidth = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('nbPixelsHeight', node)
        if value is not None and 'nbPixelsHeight' not in already_processed:
            already_processed.add('nbPixelsHeight')
            try:
                self.nbPixelsHeight = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_ImageResolution


class create_FocaleDistance(GeneratedsSuper):
    """Focal distance Focal distance"""
    subclass = None
    superclass = None
    def __init__(self, focaleDistance=0.1):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_FocaleDistance")
        self.attrib = ['focaleDistance']
        self.children = []
        self.parent = None
        self._focaleDistance = _cast(float, focaleDistance)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_FocaleDistance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_FocaleDistance.subclass:
            return create_FocaleDistance.subclass(*args_, **kwargs_)
        else:
            return create_FocaleDistance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_focaleDistance(self): return self._focaleDistance
    def set_focaleDistance(self, value):
        self._focaleDistance = value
        update_node(self,self.troot,"phase")
    focaleDistance = property(get_focaleDistance, set_focaleDistance)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_FocaleDistance', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_FocaleDistance')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_FocaleDistance')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_FocaleDistance', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_FocaleDistance'):
        if self.focaleDistance is not None and 'focaleDistance' not in already_processed:
            already_processed.add('focaleDistance')
            outfile.write(' focaleDistance="%s"' % self.gds_format_double(self.focaleDistance, input_name='focaleDistance'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_FocaleDistance', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_FocaleDistance', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.focaleDistance is not None:
            element.set('focaleDistance', self.gds_format_double(self.focaleDistance))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_FocaleDistance'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.focaleDistance is not None and 'focaleDistance' not in already_processed:
            already_processed.add('focaleDistance')
            showIndent(outfile, level)
            outfile.write('focaleDistance=%e,\n' % (self.focaleDistance,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('focaleDistance', node)
        if value is not None and 'focaleDistance' not in already_processed:
            already_processed.add('focaleDistance')
            try:
                self.focaleDistance = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (focaleDistance): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_FocaleDistance


class create_SensorOrientation(GeneratedsSuper):
    """Sensor rotation in the plane that is perpendicular to the central
    view direction Sensor rotation in the plane that is
    perpendicular to the central view direction"""
    subclass = None
    superclass = None
    def __init__(self, tethaOrientation=0.0):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_SensorOrientation")
        self.attrib = ['tethaOrientation']
        self.children = []
        self.parent = None
        self._tethaOrientation = _cast(float, tethaOrientation)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_SensorOrientation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_SensorOrientation.subclass:
            return create_SensorOrientation.subclass(*args_, **kwargs_)
        else:
            return create_SensorOrientation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tethaOrientation(self): return self._tethaOrientation
    def set_tethaOrientation(self, value):
        self._tethaOrientation = value
        update_node(self,self.troot,"phase")
    tethaOrientation = property(get_tethaOrientation, set_tethaOrientation)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_SensorOrientation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_SensorOrientation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_SensorOrientation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_SensorOrientation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_SensorOrientation'):
        if self.tethaOrientation is not None and 'tethaOrientation' not in already_processed:
            already_processed.add('tethaOrientation')
            outfile.write(' tethaOrientation="%s"' % self.gds_format_double(self.tethaOrientation, input_name='tethaOrientation'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_SensorOrientation', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_SensorOrientation', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.tethaOrientation is not None:
            element.set('tethaOrientation', self.gds_format_double(self.tethaOrientation))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_SensorOrientation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.tethaOrientation is not None and 'tethaOrientation' not in already_processed:
            already_processed.add('tethaOrientation')
            showIndent(outfile, level)
            outfile.write('tethaOrientation=%e,\n' % (self.tethaOrientation,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('tethaOrientation', node)
        if value is not None and 'tethaOrientation' not in already_processed:
            already_processed.add('tethaOrientation')
            try:
                self.tethaOrientation = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (tethaOrientation): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_SensorOrientation


class create_Hemisphere(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ZenithalRange=None, HemisphereImageResolution=None, SphereGeometry=None, SensorOrientation=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_Hemisphere")
        self.attrib = ['']
        self.children = ['ZenithalRange', 'HemisphereImageResolution', 'SphereGeometry', 'SensorOrientation']
        self.parent = None
        self._ZenithalRange = ZenithalRange
        self._HemisphereImageResolution = HemisphereImageResolution
        self._SphereGeometry = SphereGeometry
        self._SensorOrientation = SensorOrientation
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Hemisphere)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Hemisphere.subclass:
            return create_Hemisphere.subclass(*args_, **kwargs_)
        else:
            return create_Hemisphere(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ZenithalRange(self): return self._ZenithalRange
    def set_ZenithalRange(self, value):
        if value is not None:
            checkclass(value, create_ZenithalRange)
            value.parent = self
        self._ZenithalRange = value
    ZenithalRange = property(get_ZenithalRange, set_ZenithalRange)
    def get_HemisphereImageResolution(self): return self._HemisphereImageResolution
    def set_HemisphereImageResolution(self, value):
        if value is not None:
            checkclass(value, create_HemisphereImageResolution)
            value.parent = self
        self._HemisphereImageResolution = value
    HemisphereImageResolution = property(get_HemisphereImageResolution, set_HemisphereImageResolution)
    def get_SphereGeometry(self): return self._SphereGeometry
    def set_SphereGeometry(self, value):
        if value is not None:
            checkclass(value, create_SphereGeometry)
            value.parent = self
        self._SphereGeometry = value
    SphereGeometry = property(get_SphereGeometry, set_SphereGeometry)
    def get_SensorOrientation(self): return self._SensorOrientation
    def set_SensorOrientation(self, value):
        if value is not None:
            checkclass(value, create_SensorOrientation)
            value.parent = self
        self._SensorOrientation = value
    SensorOrientation = property(get_SensorOrientation, set_SensorOrientation)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.ZenithalRange is not None or
            self.HemisphereImageResolution is not None or
            self.SphereGeometry is not None or
            self.SensorOrientation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Hemisphere', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Hemisphere')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Hemisphere')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Hemisphere', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Hemisphere'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Hemisphere', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ZenithalRange is not None:
            self.ZenithalRange.export(outfile, level, namespaceprefix_, name_='ZenithalRange', pretty_print=pretty_print)
        if self.HemisphereImageResolution is not None:
            self.HemisphereImageResolution.export(outfile, level, namespaceprefix_, name_='HemisphereImageResolution', pretty_print=pretty_print)
        if self.SphereGeometry is not None:
            self.SphereGeometry.export(outfile, level, namespaceprefix_, name_='SphereGeometry', pretty_print=pretty_print)
        if self.SensorOrientation is not None:
            self.SensorOrientation.export(outfile, level, namespaceprefix_, name_='SensorOrientation', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Hemisphere', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ZenithalRange is not None:
            ZenithalRange_ = self.ZenithalRange
            ZenithalRange_.to_etree(element, name_='ZenithalRange', mapping_=mapping_)
        if self.HemisphereImageResolution is not None:
            HemisphereImageResolution_ = self.HemisphereImageResolution
            HemisphereImageResolution_.to_etree(element, name_='HemisphereImageResolution', mapping_=mapping_)
        if self.SphereGeometry is not None:
            SphereGeometry_ = self.SphereGeometry
            SphereGeometry_.to_etree(element, name_='SphereGeometry', mapping_=mapping_)
        if self.SensorOrientation is not None:
            SensorOrientation_ = self.SensorOrientation
            SensorOrientation_.to_etree(element, name_='SensorOrientation', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Hemisphere'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ZenithalRange is not None:
            showIndent(outfile, level)
            outfile.write('ZenithalRange=model_._ZenithalRange(\n')
            self.ZenithalRange.exportLiteral(outfile, level, name_='ZenithalRange')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HemisphereImageResolution is not None:
            showIndent(outfile, level)
            outfile.write('HemisphereImageResolution=model_._HemisphereImageResolution(\n')
            self.HemisphereImageResolution.exportLiteral(outfile, level, name_='HemisphereImageResolution')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SphereGeometry is not None:
            showIndent(outfile, level)
            outfile.write('SphereGeometry=model_._SphereGeometry(\n')
            self.SphereGeometry.exportLiteral(outfile, level, name_='SphereGeometry')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SensorOrientation is not None:
            showIndent(outfile, level)
            outfile.write('SensorOrientation=model_._SensorOrientation(\n')
            self.SensorOrientation.exportLiteral(outfile, level, name_='SensorOrientation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ZenithalRange':
            obj_ = create_ZenithalRange.factory()
            obj_.build(child_)
            self.set_ZenithalRange(obj_)
            obj_.original_tagname_ = 'ZenithalRange'
        elif nodeName_ == 'HemisphereImageResolution':
            obj_ = create_HemisphereImageResolution.factory()
            obj_.build(child_)
            self.set_HemisphereImageResolution(obj_)
            obj_.original_tagname_ = 'HemisphereImageResolution'
        elif nodeName_ == 'SphereGeometry':
            obj_ = create_SphereGeometry.factory()
            obj_.build(child_)
            self.set_SphereGeometry(obj_)
            obj_.original_tagname_ = 'SphereGeometry'
        elif nodeName_ == 'SensorOrientation':
            obj_ = create_SensorOrientation.factory()
            obj_.build(child_)
            self.set_SensorOrientation(obj_)
            obj_.original_tagname_ = 'SensorOrientation'
# end class create_Hemisphere


class create_ZenithalRange(GeneratedsSuper):
    """Minimum zenith, relative to the sensor central direction, registered
    by the sensor. Minimum zenith, relative to the sensor central
    direction, registered by the sensor. Maximum zenith, relative to
    the sensor central direction, registered by the sensor. Maximum
    zenith, relative to the sensor central direction, registered by
    the sensor."""
    subclass = None
    superclass = None
    def __init__(self, zenithMinimum=0, zenithMaximum=90):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_ZenithalRange")
        self.attrib = ['zenithMinimum', 'zenithMaximum']
        self.children = []
        self.parent = None
        self._zenithMinimum = _cast(float, zenithMinimum)
        self._zenithMaximum = _cast(float, zenithMaximum)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ZenithalRange)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ZenithalRange.subclass:
            return create_ZenithalRange.subclass(*args_, **kwargs_)
        else:
            return create_ZenithalRange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_zenithMinimum(self): return self._zenithMinimum
    def set_zenithMinimum(self, value):
        self._zenithMinimum = value
        update_node(self,self.troot,"phase")
    zenithMinimum = property(get_zenithMinimum, set_zenithMinimum)
    def get_zenithMaximum(self): return self._zenithMaximum
    def set_zenithMaximum(self, value):
        self._zenithMaximum = value
        update_node(self,self.troot,"phase")
    zenithMaximum = property(get_zenithMaximum, set_zenithMaximum)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ZenithalRange', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ZenithalRange')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ZenithalRange')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ZenithalRange', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ZenithalRange'):
        if self.zenithMinimum is not None and 'zenithMinimum' not in already_processed:
            already_processed.add('zenithMinimum')
            outfile.write(' zenithMinimum="%s"' % self.gds_format_double(self.zenithMinimum, input_name='zenithMinimum'))
        if self.zenithMaximum is not None and 'zenithMaximum' not in already_processed:
            already_processed.add('zenithMaximum')
            outfile.write(' zenithMaximum="%s"' % self.gds_format_double(self.zenithMaximum, input_name='zenithMaximum'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ZenithalRange', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_ZenithalRange', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.zenithMinimum is not None:
            element.set('zenithMinimum', self.gds_format_double(self.zenithMinimum))
        if self.zenithMaximum is not None:
            element.set('zenithMaximum', self.gds_format_double(self.zenithMaximum))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ZenithalRange'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.zenithMinimum is not None and 'zenithMinimum' not in already_processed:
            already_processed.add('zenithMinimum')
            showIndent(outfile, level)
            outfile.write('zenithMinimum=%e,\n' % (self.zenithMinimum,))
        if self.zenithMaximum is not None and 'zenithMaximum' not in already_processed:
            already_processed.add('zenithMaximum')
            showIndent(outfile, level)
            outfile.write('zenithMaximum=%e,\n' % (self.zenithMaximum,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('zenithMinimum', node)
        if value is not None and 'zenithMinimum' not in already_processed:
            already_processed.add('zenithMinimum')
            try:
                self.zenithMinimum = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (zenithMinimum): %s' % exp)
        value = find_attr_value_('zenithMaximum', node)
        if value is not None and 'zenithMaximum' not in already_processed:
            already_processed.add('zenithMaximum')
            try:
                self.zenithMaximum = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (zenithMaximum): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_ZenithalRange


class create_HemisphereImageResolution(GeneratedsSuper):
    """The image generated will be a disk incrusted in a square image. This
    parameter defines the number of pixel of said square image.
    Quasi-equivalent to zenithal resolution. The image generated
    will be a disk incrusted in a square image. This parameter
    defines the number of pixel of said square image. Quasi-
    equivalent to zenithal resolution."""
    subclass = None
    superclass = None
    def __init__(self, nbPixelsPerAxis=1000):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_HemisphereImageResolution")
        self.attrib = ['nbPixelsPerAxis']
        self.children = []
        self.parent = None
        self._nbPixelsPerAxis = _cast(int, nbPixelsPerAxis)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_HemisphereImageResolution)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_HemisphereImageResolution.subclass:
            return create_HemisphereImageResolution.subclass(*args_, **kwargs_)
        else:
            return create_HemisphereImageResolution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nbPixelsPerAxis(self): return self._nbPixelsPerAxis
    def set_nbPixelsPerAxis(self, value):
        self._nbPixelsPerAxis = value
        update_node(self,self.troot,"phase")
    nbPixelsPerAxis = property(get_nbPixelsPerAxis, set_nbPixelsPerAxis)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_HemisphereImageResolution', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_HemisphereImageResolution')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_HemisphereImageResolution')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_HemisphereImageResolution', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_HemisphereImageResolution'):
        if self.nbPixelsPerAxis is not None and 'nbPixelsPerAxis' not in already_processed:
            already_processed.add('nbPixelsPerAxis')
            outfile.write(' nbPixelsPerAxis="%s"' % self.gds_format_integer(self.nbPixelsPerAxis, input_name='nbPixelsPerAxis'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_HemisphereImageResolution', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_HemisphereImageResolution', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.nbPixelsPerAxis is not None:
            element.set('nbPixelsPerAxis', self.gds_format_integer(self.nbPixelsPerAxis))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_HemisphereImageResolution'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nbPixelsPerAxis is not None and 'nbPixelsPerAxis' not in already_processed:
            already_processed.add('nbPixelsPerAxis')
            showIndent(outfile, level)
            outfile.write('nbPixelsPerAxis=%d,\n' % (self.nbPixelsPerAxis,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nbPixelsPerAxis', node)
        if value is not None and 'nbPixelsPerAxis' not in already_processed:
            already_processed.add('nbPixelsPerAxis')
            try:
                self.nbPixelsPerAxis = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_HemisphereImageResolution


class create_SphereGeometry(GeneratedsSuper):
    """Radius of the intercepting sphere Radius of the intercepting sphere"""
    subclass = None
    superclass = None
    def __init__(self, radius=0.1):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_SphereGeometry")
        self.attrib = ['radius']
        self.children = []
        self.parent = None
        self._radius = _cast(float, radius)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_SphereGeometry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_SphereGeometry.subclass:
            return create_SphereGeometry.subclass(*args_, **kwargs_)
        else:
            return create_SphereGeometry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_radius(self): return self._radius
    def set_radius(self, value):
        self._radius = value
        update_node(self,self.troot,"phase")
    radius = property(get_radius, set_radius)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_SphereGeometry', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_SphereGeometry')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_SphereGeometry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_SphereGeometry', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_SphereGeometry'):
        if self.radius is not None and 'radius' not in already_processed:
            already_processed.add('radius')
            outfile.write(' radius="%s"' % self.gds_format_double(self.radius, input_name='radius'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_SphereGeometry', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_SphereGeometry', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.radius is not None:
            element.set('radius', self.gds_format_double(self.radius))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_SphereGeometry'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.radius is not None and 'radius' not in already_processed:
            already_processed.add('radius')
            showIndent(outfile, level)
            outfile.write('radius=%e,\n' % (self.radius,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('radius', node)
        if value is not None and 'radius' not in already_processed:
            already_processed.add('radius')
            try:
                self.radius = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (radius): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_SphereGeometry


class create_ExternalScripts(GeneratedsSuper):
    """Python External Scripts Python External Scripts"""
    subclass = None
    superclass = None
    def __init__(self, ExternalScript=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_ExternalScripts")
        self.attrib = ['']
        self.children = ['ExternalScript']
        self.parent = None
        if ExternalScript is None:
            self._ExternalScript = []
        else:
            self._ExternalScript = ExternalScript
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ExternalScripts)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ExternalScripts.subclass:
            return create_ExternalScripts.subclass(*args_, **kwargs_)
        else:
            return create_ExternalScripts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ExternalScript(self): return self._ExternalScript
    def set_ExternalScript(self, value):
        if value is not None:
            checkclass(value, create_ExternalScript)
            for v in value:
                v.parent = self
        self._ExternalScript = value
    def add_ExternalScript(self, value):
        value.parent = self
        self._ExternalScript.append(value)
    def insert_ExternalScript_at(self, index, value):
        value.parent = self
        self.ExternalScript.insert(index, value)
    def replace_ExternalScript_at(self, index, value):
        value.parent = self
        self.ExternalScript[index] = value
    ExternalScript = property(get_ExternalScript, set_ExternalScript)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.ExternalScript
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ExternalScripts', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ExternalScripts')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ExternalScripts')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ExternalScripts', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ExternalScripts'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ExternalScripts', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ExternalScript_ in self.ExternalScript:
            ExternalScript_.export(outfile, level, namespaceprefix_, name_='ExternalScript', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_ExternalScripts', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for ExternalScript_ in self.ExternalScript:
            ExternalScript_.to_etree(element, name_='ExternalScript', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ExternalScripts'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ExternalScript=[\n')
        level += 1
        for ExternalScript_ in self.ExternalScript:
            showIndent(outfile, level)
            outfile.write('model_._ExternalScript(\n')
            ExternalScript_.exportLiteral(outfile, level, name_='_ExternalScript')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.ExternalScript = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExternalScript':
            obj_ = create_ExternalScript.factory()
            obj_.build(child_)
            self.add_ExternalScript(obj_)
            obj_.original_tagname_ = 'ExternalScript'
# end class create_ExternalScripts


class create_ExternalScript(GeneratedsSuper):
    """Python External Script Python External Script"""
    subclass = None
    superclass = None
    def __init__(self, ScriptDefinition=None, ScriptLaunchPosition=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_ExternalScript")
        self.attrib = ['']
        self.children = ['ScriptDefinition', 'ScriptLaunchPosition']
        self.parent = None
        self._ScriptDefinition = ScriptDefinition
        self._ScriptLaunchPosition = ScriptLaunchPosition
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ExternalScript)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ExternalScript.subclass:
            return create_ExternalScript.subclass(*args_, **kwargs_)
        else:
            return create_ExternalScript(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ScriptDefinition(self): return self._ScriptDefinition
    def set_ScriptDefinition(self, value):
        if value is not None:
            checkclass(value, create_ScriptDefinition)
            value.parent = self
        self._ScriptDefinition = value
    ScriptDefinition = property(get_ScriptDefinition, set_ScriptDefinition)
    def get_ScriptLaunchPosition(self): return self._ScriptLaunchPosition
    def set_ScriptLaunchPosition(self, value):
        if value is not None:
            checkclass(value, create_ScriptLaunchPosition)
            value.parent = self
        self._ScriptLaunchPosition = value
    ScriptLaunchPosition = property(get_ScriptLaunchPosition, set_ScriptLaunchPosition)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.ScriptDefinition is not None or
            self.ScriptLaunchPosition is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ExternalScript', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ExternalScript')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ExternalScript')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ExternalScript', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ExternalScript'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ExternalScript', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ScriptDefinition is not None:
            self.ScriptDefinition.export(outfile, level, namespaceprefix_, name_='ScriptDefinition', pretty_print=pretty_print)
        if self.ScriptLaunchPosition is not None:
            self.ScriptLaunchPosition.export(outfile, level, namespaceprefix_, name_='ScriptLaunchPosition', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_ExternalScript', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ScriptDefinition is not None:
            ScriptDefinition_ = self.ScriptDefinition
            ScriptDefinition_.to_etree(element, name_='ScriptDefinition', mapping_=mapping_)
        if self.ScriptLaunchPosition is not None:
            ScriptLaunchPosition_ = self.ScriptLaunchPosition
            ScriptLaunchPosition_.to_etree(element, name_='ScriptLaunchPosition', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ExternalScript'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ScriptDefinition is not None:
            showIndent(outfile, level)
            outfile.write('ScriptDefinition=model_._ScriptDefinition(\n')
            self.ScriptDefinition.exportLiteral(outfile, level, name_='ScriptDefinition')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ScriptLaunchPosition is not None:
            showIndent(outfile, level)
            outfile.write('ScriptLaunchPosition=model_._ScriptLaunchPosition(\n')
            self.ScriptLaunchPosition.exportLiteral(outfile, level, name_='ScriptLaunchPosition')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ScriptDefinition':
            obj_ = create_ScriptDefinition.factory()
            obj_.build(child_)
            self.set_ScriptDefinition(obj_)
            obj_.original_tagname_ = 'ScriptDefinition'
        elif nodeName_ == 'ScriptLaunchPosition':
            obj_ = create_ScriptLaunchPosition.factory()
            obj_.build(child_)
            self.set_ScriptLaunchPosition(obj_)
            obj_.original_tagname_ = 'ScriptLaunchPosition'
# end class create_ExternalScript


class create_ScriptDefinition(GeneratedsSuper):
    """Python Script definition Python Script definition Source script
    (.py) Source script (.py) Script arguments Script arguments"""
    subclass = None
    superclass = None
    def __init__(self, sourceAbsolutePath='script.py', arguments=''):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_ScriptDefinition")
        self.attrib = ['sourceAbsolutePath', 'arguments']
        self.children = []
        self.parent = None
        self._sourceAbsolutePath = _cast(None, sourceAbsolutePath)
        self._arguments = _cast(None, arguments)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ScriptDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ScriptDefinition.subclass:
            return create_ScriptDefinition.subclass(*args_, **kwargs_)
        else:
            return create_ScriptDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sourceAbsolutePath(self): return self._sourceAbsolutePath
    def set_sourceAbsolutePath(self, value):
        self._sourceAbsolutePath = value
        update_node(self,self.troot,"phase")
    sourceAbsolutePath = property(get_sourceAbsolutePath, set_sourceAbsolutePath)
    def get_arguments(self): return self._arguments
    def set_arguments(self, value):
        self._arguments = value
        update_node(self,self.troot,"phase")
    arguments = property(get_arguments, set_arguments)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ScriptDefinition', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ScriptDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ScriptDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ScriptDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ScriptDefinition'):
        if self.sourceAbsolutePath is not None and 'sourceAbsolutePath' not in already_processed:
            already_processed.add('sourceAbsolutePath')
            outfile.write(' sourceAbsolutePath=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sourceAbsolutePath), input_name='sourceAbsolutePath')), ))
        if self.arguments is not None and 'arguments' not in already_processed:
            already_processed.add('arguments')
            outfile.write(' arguments=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.arguments), input_name='arguments')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ScriptDefinition', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_ScriptDefinition', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.sourceAbsolutePath is not None:
            element.set('sourceAbsolutePath', self.gds_format_string(self.sourceAbsolutePath))
        if self.arguments is not None:
            element.set('arguments', self.gds_format_string(self.arguments))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ScriptDefinition'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sourceAbsolutePath is not None and 'sourceAbsolutePath' not in already_processed:
            already_processed.add('sourceAbsolutePath')
            showIndent(outfile, level)
            outfile.write('sourceAbsolutePath="%s",\n' % (self.sourceAbsolutePath,))
        if self.arguments is not None and 'arguments' not in already_processed:
            already_processed.add('arguments')
            showIndent(outfile, level)
            outfile.write('arguments="%s",\n' % (self.arguments,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sourceAbsolutePath', node)
        if value is not None and 'sourceAbsolutePath' not in already_processed:
            already_processed.add('sourceAbsolutePath')
            self.sourceAbsolutePath = value
        value = find_attr_value_('arguments', node)
        if value is not None and 'arguments' not in already_processed:
            already_processed.add('arguments')
            self.arguments = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_ScriptDefinition


class create_ScriptLaunchPosition(GeneratedsSuper):
    """Script location in DART process Script location in DART process
    Script position in DART process Script position in DART process"""
    subclass = None
    superclass = None
    def __init__(self, launchPosition=1, LaunchBetweenDartModules=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_ScriptLaunchPosition")
        self.attrib = ['launchPosition']
        self.children = ['LaunchBetweenDartModules']
        self.parent = None
        self._launchPosition = _cast(int, launchPosition)
        self._LaunchBetweenDartModules = LaunchBetweenDartModules
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ScriptLaunchPosition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ScriptLaunchPosition.subclass:
            return create_ScriptLaunchPosition.subclass(*args_, **kwargs_)
        else:
            return create_ScriptLaunchPosition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LaunchBetweenDartModules(self): return self._LaunchBetweenDartModules
    def set_LaunchBetweenDartModules(self, value):
        if value is not None:
            checkclass(value, create_LaunchBetweenDartModules)
            value.parent = self
        self._LaunchBetweenDartModules = value
    LaunchBetweenDartModules = property(get_LaunchBetweenDartModules, set_LaunchBetweenDartModules)
    def get_launchPosition(self): return self._launchPosition
    def set_launchPosition(self, value):
        self._launchPosition = value
        update_node(self,self.troot,"phase")
    launchPosition = property(get_launchPosition, set_launchPosition)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.LaunchBetweenDartModules is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ScriptLaunchPosition', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ScriptLaunchPosition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ScriptLaunchPosition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ScriptLaunchPosition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ScriptLaunchPosition'):
        if self.launchPosition is not None and 'launchPosition' not in already_processed:
            already_processed.add('launchPosition')
            outfile.write(' launchPosition="%s"' % self.gds_format_integer(self.launchPosition, input_name='launchPosition'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ScriptLaunchPosition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LaunchBetweenDartModules is not None:
            self.LaunchBetweenDartModules.export(outfile, level, namespaceprefix_, name_='LaunchBetweenDartModules', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_ScriptLaunchPosition', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.launchPosition is not None:
            element.set('launchPosition', self.gds_format_integer(self.launchPosition))
        if self.LaunchBetweenDartModules is not None:
            LaunchBetweenDartModules_ = self.LaunchBetweenDartModules
            LaunchBetweenDartModules_.to_etree(element, name_='LaunchBetweenDartModules', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ScriptLaunchPosition'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.launchPosition is not None and 'launchPosition' not in already_processed:
            already_processed.add('launchPosition')
            showIndent(outfile, level)
            outfile.write('launchPosition=%d,\n' % (self.launchPosition,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LaunchBetweenDartModules is not None:
            showIndent(outfile, level)
            outfile.write('LaunchBetweenDartModules=model_._LaunchBetweenDartModules(\n')
            self.LaunchBetweenDartModules.exportLiteral(outfile, level, name_='LaunchBetweenDartModules')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('launchPosition', node)
        if value is not None and 'launchPosition' not in already_processed:
            already_processed.add('launchPosition')
            try:
                self.launchPosition = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LaunchBetweenDartModules':
            obj_ = create_LaunchBetweenDartModules.factory()
            obj_.build(child_)
            self.set_LaunchBetweenDartModules(obj_)
            obj_.original_tagname_ = 'LaunchBetweenDartModules'
# end class create_ScriptLaunchPosition


class create_LaunchBetweenDartModules(GeneratedsSuper):
    """Launch script between DART modules Launch script between DART
    modules Launch script between following DART modules Launch
    script between following DART modules"""
    subclass = None
    superclass = None
    def __init__(self, betweenModules=1):
        self.original_tagname_ = None
        self.troot=get_gs_troot("phase","_LaunchBetweenDartModules")
        self.attrib = ['betweenModules']
        self.children = []
        self.parent = None
        self._betweenModules = _cast(int, betweenModules)
        update_node(self,self.troot,"phase")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_LaunchBetweenDartModules)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_LaunchBetweenDartModules.subclass:
            return create_LaunchBetweenDartModules.subclass(*args_, **kwargs_)
        else:
            return create_LaunchBetweenDartModules(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_betweenModules(self): return self._betweenModules
    def set_betweenModules(self, value):
        self._betweenModules = value
        update_node(self,self.troot,"phase")
    betweenModules = property(get_betweenModules, set_betweenModules)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_LaunchBetweenDartModules', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_LaunchBetweenDartModules')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_LaunchBetweenDartModules')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_LaunchBetweenDartModules', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_LaunchBetweenDartModules'):
        if self.betweenModules is not None and 'betweenModules' not in already_processed:
            already_processed.add('betweenModules')
            outfile.write(' betweenModules="%s"' % self.gds_format_integer(self.betweenModules, input_name='betweenModules'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_LaunchBetweenDartModules', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_LaunchBetweenDartModules', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.betweenModules is not None:
            element.set('betweenModules', self.gds_format_integer(self.betweenModules))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_LaunchBetweenDartModules'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.betweenModules is not None and 'betweenModules' not in already_processed:
            already_processed.add('betweenModules')
            showIndent(outfile, level)
            outfile.write('betweenModules=%d,\n' % (self.betweenModules,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('betweenModules', node)
        if value is not None and 'betweenModules' not in already_processed:
            already_processed.add('betweenModules')
            try:
                self.betweenModules = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_LaunchBetweenDartModules


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <createParser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from phase import *\n\n')
        sys.stdout.write('import phase as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "createDartFile",
    "create_ALS",
    "create_AirConfig",
    "create_ApproximatedTrajectory",
    "create_AtmosphereRadiativeTransfer",
    "create_AtmosphereRadiativeTransferOptions",
    "create_BackSide",
    "create_BottomSide",
    "create_BrfProductsProperties",
    "create_CamImageAOV",
    "create_CamImageDim",
    "create_CamImageFOV",
    "create_CameraOrientYPR",
    "create_CameraOrientation",
    "create_CenterBegin",
    "create_CenterEnd",
    "create_CenterOnGround",
    "create_CommonParameters",
    "create_ControlPoint",
    "create_CorrespondingParameters",
    "create_DartInputParameters",
    "create_DartProduct",
    "create_DiscreteIllumination",
    "create_DiscreteReturnParam",
    "create_ExpertModeZone",
    "create_ExpertModeZone_Etalement",
    "create_ExpertModeZone_PerTypeProduct",
    "create_ExpertModeZone_Projection",
    "create_ExpertModeZone_maskProjection",
    "create_ExternalScript",
    "create_ExternalScripts",
    "create_FishEye",
    "create_FishEyeFOV",
    "create_FluxtrackingSolarNoise",
    "create_FocaleDistance",
    "create_FootPrintAndFOVDispersions",
    "create_FootPrintAndFOVRadiuses",
    "create_FrontSide",
    "create_Hemisphere",
    "create_HemisphereImageResolution",
    "create_Image",
    "create_ImageBinaryProducts",
    "create_ImageParameters",
    "create_ImageResolution",
    "create_ImageSideIllumination",
    "create_Importation",
    "create_ImportedPulse",
    "create_InsideSensor",
    "create_LaiProductsProperties",
    "create_LaunchBetweenDartModules",
    "create_LeftSide",
    "create_Lidar",
    "create_LidarAcquisitionParameters",
    "create_LidarGeometry",
    "create_LidarIlluminationIntensity",
    "create_MonteCarlo",
    "create_NbPixels",
    "create_Order1Options",
    "create_OrientationDef",
    "create_Phase",
    "create_PhotonCounting",
    "create_PhotonCountingParam",
    "create_Pinhole",
    "create_Platform",
    "create_PositionGround",
    "create_PulseDuration",
    "create_Pushbroom",
    "create_Radiometer",
    "create_RightSide",
    "create_RunningMode",
    "create_ScriptDefinition",
    "create_ScriptLaunchPosition",
    "create_Sensor",
    "create_SensorAngleDirection",
    "create_SensorAngles",
    "create_SensorCentralPosition",
    "create_SensorDimensions",
    "create_SensorImageSimulation",
    "create_SensorOrientation",
    "create_SensorView",
    "create_SensorViewDirection",
    "create_SensorsImportation",
    "create_SideIlluminationFile",
    "create_SigmaDefinition",
    "create_SpectralDomainTir",
    "create_SpectralIntervals",
    "create_SpectralIntervalsProperties",
    "create_SpectralIrradiance",
    "create_SpectralIrradianceValue",
    "create_SphereGeometry",
    "create_StWaveHeightRange",
    "create_Swath",
    "create_TLS",
    "create_TLSRegion",
    "create_TemperatureFile",
    "create_TopSide",
    "create_WeightingParameters",
    "create_ZenithalRange",
    "create_ZeroDist",
    "create_areaMaketProductsProperties",
    "create_bandIrradianceFileNode",
    "create_calculatedSwath",
    "create_coverRateProductsProperties",
    "create_dartModuleProducts",
    "create_emissionLawNode",
    "create_ftiImportation",
    "create_illumination",
    "create_importedSwath",
    "create_irradianceDatabaseNode",
    "create_lidarProductsProperties",
    "create_maketModuleProducts",
    "create_nodeIlluminationMode",
    "create_nodefluxtracking",
    "create_overrideBandIrradiance",
    "create_radiativeBudgetProperties",
    "create_skylTemperature",
    "create_temperatureAtmosphere",
    "create_terresScanRange"
]
