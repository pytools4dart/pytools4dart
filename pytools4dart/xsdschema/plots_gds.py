#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Sep 25 22:15:37 2018 by generateDS.py version 2.29.24.
# Python 2.7.12 (default, Dec  4 2017, 14:50:18)  [GCC 5.4.0 20160609]
#
# Command line options:
#   ('--always-export-default', '')
#   ('-o', '/home/boissieu/git/pytools4dartMTD/pytools4dart/xsdschema/plots_gds.py')
#
# Command line arguments:
#   /home/boissieu/git/pytools4dartMTD/pytools4dart/xsdschema/plots.xsd
#
# Command line:
#   generateDS.py --always-export-default -o "/home/boissieu/git/pytools4dartMTD/pytools4dart/xsdschema/plots_gds.py" /home/boissieu/git/pytools4dartMTD/pytools4dart/xsdschema/plots.xsd
#
# Current working directory (os.getcwd()):
#   generateDS-2.29.24
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class DartFile(GeneratedsSuper):
    """Version of the plots.xml file. Depends of the version on DART
    itself. Version of the plots.xml file. Depends of the version on
    DART itself."""
    subclass = None
    superclass = None
    def __init__(self, version='5.7.1', build_='0', Plots=None):
        self.original_tagname_ = None
        self.version = _cast(None, version)
        self.build_ = _cast(None, build_)
        self.Plots = Plots
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DartFile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DartFile.subclass:
            return DartFile.subclass(*args_, **kwargs_)
        else:
            return DartFile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Plots(self): return self.Plots
    def set_Plots(self, Plots): self.Plots = Plots
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_build(self): return self.build_
    def set_build(self, build_): self.build_ = build_
    def hasContent_(self):
        if (
            self.Plots is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='DartFile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DartFile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DartFile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='DartFile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DartFile'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
        if self.build_ is not None and 'build_' not in already_processed:
            already_processed.add('build_')
            outfile.write(' build=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.build_), input_name='build')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='DartFile', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Plots is not None:
            self.Plots.export(outfile, level, namespaceprefix_, name_='Plots', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('build', node)
        if value is not None and 'build' not in already_processed:
            already_processed.add('build')
            self.build_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Plots':
            obj_ = _Plots.factory()
            obj_.build(child_)
            self.Plots = obj_
            obj_.original_tagname_ = 'Plots'
# end class DartFile


class _Plots(GeneratedsSuper):
    """Contains the description of the working environment for the
    Vegetation module. Contains also the list of the plots for the
    simulation and their optical(s) property(ies). Contains the
    description of the working environment for the Vegetation
    module. Contains also the list of the plots for the simulation
    and their optical(s) property(ies). Indicate if there is
    information for the module Vegetation. 1 if the user wants to
    use the Vegetation module, 0 otherwise. Indicate if there is
    information for the module Vegetation. 1 if the user wants to
    use the Vegetation module, 0 otherwise. Choose if you want to
    add an extra plot file Choose if you want to add an extra plot
    file"""
    subclass = None
    superclass = None
    def __init__(self, isVegetation=0, addExtraPlotsTextFile=0, ExtraPlotsTextFileDefinition=None, ImportationFichierRaster=None, Plot=None):
        self.original_tagname_ = None
        self.isVegetation = _cast(int, isVegetation)
        self.addExtraPlotsTextFile = _cast(int, addExtraPlotsTextFile)
        self.ExtraPlotsTextFileDefinition = ExtraPlotsTextFileDefinition
        self.ImportationFichierRaster = ImportationFichierRaster
        if Plot is None:
            self.Plot = []
        else:
            self.Plot = Plot
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, _Plots)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if _Plots.subclass:
            return _Plots.subclass(*args_, **kwargs_)
        else:
            return _Plots(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ExtraPlotsTextFileDefinition(self): return self.ExtraPlotsTextFileDefinition
    def set_ExtraPlotsTextFileDefinition(self, ExtraPlotsTextFileDefinition): self.ExtraPlotsTextFileDefinition = ExtraPlotsTextFileDefinition
    def get_ImportationFichierRaster(self): return self.ImportationFichierRaster
    def set_ImportationFichierRaster(self, ImportationFichierRaster): self.ImportationFichierRaster = ImportationFichierRaster
    def get_Plot(self): return self.Plot
    def set_Plot(self, Plot): self.Plot = Plot
    def add_Plot(self, value): self.Plot.append(value)
    def insert_Plot_at(self, index, value): self.Plot.insert(index, value)
    def replace_Plot_at(self, index, value): self.Plot[index] = value
    def get_isVegetation(self): return self.isVegetation
    def set_isVegetation(self, isVegetation): self.isVegetation = isVegetation
    def get_addExtraPlotsTextFile(self): return self.addExtraPlotsTextFile
    def set_addExtraPlotsTextFile(self, addExtraPlotsTextFile): self.addExtraPlotsTextFile = addExtraPlotsTextFile
    def hasContent_(self):
        if (
            self.ExtraPlotsTextFileDefinition is not None or
            self.ImportationFichierRaster is not None or
            self.Plot
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Plots', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Plots')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Plots')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Plots', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Plots'):
        if self.isVegetation is not None and 'isVegetation' not in already_processed:
            already_processed.add('isVegetation')
            outfile.write(' isVegetation="%s"' % self.gds_format_integer(self.isVegetation, input_name='isVegetation'))
        if self.addExtraPlotsTextFile is not None and 'addExtraPlotsTextFile' not in already_processed:
            already_processed.add('addExtraPlotsTextFile')
            outfile.write(' addExtraPlotsTextFile="%s"' % self.gds_format_integer(self.addExtraPlotsTextFile, input_name='addExtraPlotsTextFile'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Plots', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ExtraPlotsTextFileDefinition is not None:
            self.ExtraPlotsTextFileDefinition.export(outfile, level, namespaceprefix_, name_='ExtraPlotsTextFileDefinition', pretty_print=pretty_print)
        if self.ImportationFichierRaster is not None:
            self.ImportationFichierRaster.export(outfile, level, namespaceprefix_, name_='ImportationFichierRaster', pretty_print=pretty_print)
        for Plot_ in self.Plot:
            Plot_.export(outfile, level, namespaceprefix_, name_='Plot', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isVegetation', node)
        if value is not None and 'isVegetation' not in already_processed:
            already_processed.add('isVegetation')
            try:
                self.isVegetation = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('addExtraPlotsTextFile', node)
        if value is not None and 'addExtraPlotsTextFile' not in already_processed:
            already_processed.add('addExtraPlotsTextFile')
            try:
                self.addExtraPlotsTextFile = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExtraPlotsTextFileDefinition':
            obj_ = _ExtraPlotsTextFileDefinition.factory()
            obj_.build(child_)
            self.ExtraPlotsTextFileDefinition = obj_
            obj_.original_tagname_ = 'ExtraPlotsTextFileDefinition'
        elif nodeName_ == 'ImportationFichierRaster':
            obj_ = _ImportationFichierRaster.factory()
            obj_.build(child_)
            self.ImportationFichierRaster = obj_
            obj_.original_tagname_ = 'ImportationFichierRaster'
        elif nodeName_ == 'Plot':
            obj_ = _Plot.factory()
            obj_.build(child_)
            self.Plot.append(obj_)
            obj_.original_tagname_ = 'Plot'
# end class _Plots


class _ExtraPlotsTextFileDefinition(GeneratedsSuper):
    """Extra plot file definition Extra plot file definition Path to extra
    plot file Path to extra plot file"""
    subclass = None
    superclass = None
    def __init__(self, extraPlotsFileName='plots.txt'):
        self.original_tagname_ = None
        self.extraPlotsFileName = _cast(None, extraPlotsFileName)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, _ExtraPlotsTextFileDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if _ExtraPlotsTextFileDefinition.subclass:
            return _ExtraPlotsTextFileDefinition.subclass(*args_, **kwargs_)
        else:
            return _ExtraPlotsTextFileDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extraPlotsFileName(self): return self.extraPlotsFileName
    def set_extraPlotsFileName(self, extraPlotsFileName): self.extraPlotsFileName = extraPlotsFileName
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ExtraPlotsTextFileDefinition', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ExtraPlotsTextFileDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ExtraPlotsTextFileDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ExtraPlotsTextFileDefinition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ExtraPlotsTextFileDefinition'):
        if self.extraPlotsFileName is not None and 'extraPlotsFileName' not in already_processed:
            already_processed.add('extraPlotsFileName')
            outfile.write(' extraPlotsFileName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.extraPlotsFileName), input_name='extraPlotsFileName')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ExtraPlotsTextFileDefinition', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('extraPlotsFileName', node)
        if value is not None and 'extraPlotsFileName' not in already_processed:
            already_processed.add('extraPlotsFileName')
            self.extraPlotsFileName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class _ExtraPlotsTextFileDefinition


class _ImportationFichierRaster(GeneratedsSuper):
    """Contains the information of the input files for the Vegetation
    module. Contains the information of the input files for the
    Vegetation module."""
    subclass = None
    superclass = None
    def __init__(self, VegetationProperties=None, RasterCOSInformation=None):
        self.original_tagname_ = None
        self.VegetationProperties = VegetationProperties
        self.RasterCOSInformation = RasterCOSInformation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, _ImportationFichierRaster)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if _ImportationFichierRaster.subclass:
            return _ImportationFichierRaster.subclass(*args_, **kwargs_)
        else:
            return _ImportationFichierRaster(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VegetationProperties(self): return self.VegetationProperties
    def set_VegetationProperties(self, VegetationProperties): self.VegetationProperties = VegetationProperties
    def get_RasterCOSInformation(self): return self.RasterCOSInformation
    def set_RasterCOSInformation(self, RasterCOSInformation): self.RasterCOSInformation = RasterCOSInformation
    def hasContent_(self):
        if (
            self.VegetationProperties is not None or
            self.RasterCOSInformation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ImportationFichierRaster', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ImportationFichierRaster')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ImportationFichierRaster')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ImportationFichierRaster', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ImportationFichierRaster'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ImportationFichierRaster', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VegetationProperties is not None:
            self.VegetationProperties.export(outfile, level, namespaceprefix_, name_='VegetationProperties', pretty_print=pretty_print)
        if self.RasterCOSInformation is not None:
            self.RasterCOSInformation.export(outfile, level, namespaceprefix_, name_='RasterCOSInformation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VegetationProperties':
            obj_ = _VegetationProperties.factory()
            obj_.build(child_)
            self.VegetationProperties = obj_
            obj_.original_tagname_ = 'VegetationProperties'
        elif nodeName_ == 'RasterCOSInformation':
            obj_ = _RasterCOSInformation.factory()
            obj_.build(child_)
            self.RasterCOSInformation = obj_
            obj_.original_tagname_ = 'RasterCOSInformation'
# end class _ImportationFichierRaster


class _VegetationProperties(GeneratedsSuper):
    """Properties of the raster image of the Vegetation module (name,
    number of lines/colunms, type of the pixel ...). Properties of
    the raster image of the Vegetation module (name, number of
    lines/colunms, type of the pixel ...). Allows the user to work
    on a subzone of the raster image. 1 for extracting a sub-zone of
    the COS, 0 otherwise. Allows the user to work on a subzone of
    the raster image. 1 for extracting a sub-zone of the COS, 0
    otherwise. Raster file name. It must be in the simulation
    "input" directory of the simulation. Raster file name. It must
    be in the simulation "input" directory of the simulation. Allows
    Vegetation module to keep or crush the current plots. 1, the
    plots are crushed. 0, the plots are kept. Allows Vegetation
    module to keep or crush the current plots. 1, the plots are
    crushed. 0, the plots are kept."""
    subclass = None
    superclass = None
    def __init__(self, selectSubZone=0, coverLandMapFileName='land_cover.mp#', coverLandMapDescFileName='Desc_CoverLandMap.txt', OverwritePlots=1, SelectSubZoneProperties=None):
        self.original_tagname_ = None
        self.selectSubZone = _cast(int, selectSubZone)
        self.coverLandMapFileName = _cast(None, coverLandMapFileName)
        self.coverLandMapDescFileName = _cast(None, coverLandMapDescFileName)
        self.OverwritePlots = _cast(int, OverwritePlots)
        self.SelectSubZoneProperties = SelectSubZoneProperties
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, _VegetationProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if _VegetationProperties.subclass:
            return _VegetationProperties.subclass(*args_, **kwargs_)
        else:
            return _VegetationProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SelectSubZoneProperties(self): return self.SelectSubZoneProperties
    def set_SelectSubZoneProperties(self, SelectSubZoneProperties): self.SelectSubZoneProperties = SelectSubZoneProperties
    def get_selectSubZone(self): return self.selectSubZone
    def set_selectSubZone(self, selectSubZone): self.selectSubZone = selectSubZone
    def get_coverLandMapFileName(self): return self.coverLandMapFileName
    def set_coverLandMapFileName(self, coverLandMapFileName): self.coverLandMapFileName = coverLandMapFileName
    def get_coverLandMapDescFileName(self): return self.coverLandMapDescFileName
    def set_coverLandMapDescFileName(self, coverLandMapDescFileName): self.coverLandMapDescFileName = coverLandMapDescFileName
    def get_OverwritePlots(self): return self.OverwritePlots
    def set_OverwritePlots(self, OverwritePlots): self.OverwritePlots = OverwritePlots
    def hasContent_(self):
        if (
            self.SelectSubZoneProperties is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_VegetationProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_VegetationProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_VegetationProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_VegetationProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_VegetationProperties'):
        if self.selectSubZone is not None and 'selectSubZone' not in already_processed:
            already_processed.add('selectSubZone')
            outfile.write(' selectSubZone="%s"' % self.gds_format_integer(self.selectSubZone, input_name='selectSubZone'))
        if self.coverLandMapFileName is not None and 'coverLandMapFileName' not in already_processed:
            already_processed.add('coverLandMapFileName')
            outfile.write(' coverLandMapFileName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.coverLandMapFileName), input_name='coverLandMapFileName')), ))
        if self.coverLandMapDescFileName is not None and 'coverLandMapDescFileName' not in already_processed:
            already_processed.add('coverLandMapDescFileName')
            outfile.write(' coverLandMapDescFileName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.coverLandMapDescFileName), input_name='coverLandMapDescFileName')), ))
        if self.OverwritePlots is not None and 'OverwritePlots' not in already_processed:
            already_processed.add('OverwritePlots')
            outfile.write(' OverwritePlots="%s"' % self.gds_format_integer(self.OverwritePlots, input_name='OverwritePlots'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_VegetationProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SelectSubZoneProperties is not None:
            self.SelectSubZoneProperties.export(outfile, level, namespaceprefix_, name_='SelectSubZoneProperties', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('selectSubZone', node)
        if value is not None and 'selectSubZone' not in already_processed:
            already_processed.add('selectSubZone')
            try:
                self.selectSubZone = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('coverLandMapFileName', node)
        if value is not None and 'coverLandMapFileName' not in already_processed:
            already_processed.add('coverLandMapFileName')
            self.coverLandMapFileName = value
        value = find_attr_value_('coverLandMapDescFileName', node)
        if value is not None and 'coverLandMapDescFileName' not in already_processed:
            already_processed.add('coverLandMapDescFileName')
            self.coverLandMapDescFileName = value
        value = find_attr_value_('OverwritePlots', node)
        if value is not None and 'OverwritePlots' not in already_processed:
            already_processed.add('OverwritePlots')
            try:
                self.OverwritePlots = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SelectSubZoneProperties':
            obj_ = _SelectSubZoneProperties.factory()
            obj_.build(child_)
            self.SelectSubZoneProperties = obj_
            obj_.original_tagname_ = 'SelectSubZoneProperties'
# end class _VegetationProperties


class _SelectSubZoneProperties(GeneratedsSuper):
    """Properties of the sub zone. It's defined by a starting point and a
    number of lines/colunms. Properties of the sub zone. It's
    defined by a starting point and a number of lines/colunms.
    Number of lines of the subzone. Number of lines of the subzone.
    First column of the sub-zone. First column of the sub-zone.
    Number of columns of the sub-zone. Number of columns of the sub-
    zone. First line of the sub-zone. First line of the sub-zone."""
    subclass = None
    superclass = None
    def __init__(self, lineNbSubZone=5, columnOfTopLeftPixel=0, columnNbSubZone=5, lineOfTopLeftPixel=0):
        self.original_tagname_ = None
        self.lineNbSubZone = _cast(int, lineNbSubZone)
        self.columnOfTopLeftPixel = _cast(int, columnOfTopLeftPixel)
        self.columnNbSubZone = _cast(int, columnNbSubZone)
        self.lineOfTopLeftPixel = _cast(int, lineOfTopLeftPixel)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, _SelectSubZoneProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if _SelectSubZoneProperties.subclass:
            return _SelectSubZoneProperties.subclass(*args_, **kwargs_)
        else:
            return _SelectSubZoneProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lineNbSubZone(self): return self.lineNbSubZone
    def set_lineNbSubZone(self, lineNbSubZone): self.lineNbSubZone = lineNbSubZone
    def get_columnOfTopLeftPixel(self): return self.columnOfTopLeftPixel
    def set_columnOfTopLeftPixel(self, columnOfTopLeftPixel): self.columnOfTopLeftPixel = columnOfTopLeftPixel
    def get_columnNbSubZone(self): return self.columnNbSubZone
    def set_columnNbSubZone(self, columnNbSubZone): self.columnNbSubZone = columnNbSubZone
    def get_lineOfTopLeftPixel(self): return self.lineOfTopLeftPixel
    def set_lineOfTopLeftPixel(self, lineOfTopLeftPixel): self.lineOfTopLeftPixel = lineOfTopLeftPixel
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_SelectSubZoneProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_SelectSubZoneProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_SelectSubZoneProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_SelectSubZoneProperties', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_SelectSubZoneProperties'):
        if self.lineNbSubZone is not None and 'lineNbSubZone' not in already_processed:
            already_processed.add('lineNbSubZone')
            outfile.write(' lineNbSubZone="%s"' % self.gds_format_integer(self.lineNbSubZone, input_name='lineNbSubZone'))
        if self.columnOfTopLeftPixel is not None and 'columnOfTopLeftPixel' not in already_processed:
            already_processed.add('columnOfTopLeftPixel')
            outfile.write(' columnOfTopLeftPixel="%s"' % self.gds_format_integer(self.columnOfTopLeftPixel, input_name='columnOfTopLeftPixel'))
        if self.columnNbSubZone is not None and 'columnNbSubZone' not in already_processed:
            already_processed.add('columnNbSubZone')
            outfile.write(' columnNbSubZone="%s"' % self.gds_format_integer(self.columnNbSubZone, input_name='columnNbSubZone'))
        if self.lineOfTopLeftPixel is not None and 'lineOfTopLeftPixel' not in already_processed:
            already_processed.add('lineOfTopLeftPixel')
            outfile.write(' lineOfTopLeftPixel="%s"' % self.gds_format_integer(self.lineOfTopLeftPixel, input_name='lineOfTopLeftPixel'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_SelectSubZoneProperties', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lineNbSubZone', node)
        if value is not None and 'lineNbSubZone' not in already_processed:
            already_processed.add('lineNbSubZone')
            try:
                self.lineNbSubZone = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('columnOfTopLeftPixel', node)
        if value is not None and 'columnOfTopLeftPixel' not in already_processed:
            already_processed.add('columnOfTopLeftPixel')
            try:
                self.columnOfTopLeftPixel = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('columnNbSubZone', node)
        if value is not None and 'columnNbSubZone' not in already_processed:
            already_processed.add('columnNbSubZone')
            try:
                self.columnNbSubZone = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('lineOfTopLeftPixel', node)
        if value is not None and 'lineOfTopLeftPixel' not in already_processed:
            already_processed.add('lineOfTopLeftPixel')
            try:
                self.lineOfTopLeftPixel = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class _SelectSubZoneProperties


class _RasterCOSInformation(GeneratedsSuper):
    """Properties of the raster image of the Vegetation module (name,
    number of lines/colunms, type of the pixel ...). Properties of
    the raster image of the Vegetation module (name, number of
    lines/colunms, type of the pixel ...). Dimension in meters of a
    pixel of the raster image, along a column. Dimension in meters
    of a pixel of the raster image, along a column. Number of
    columns of the raster image. Number of columns of the raster
    image. Dimension in meters of a pixel of the raster image, along
    a line. Dimension in meters of a pixel of the raster image,
    along a line. double. double. Number of lines of the raster
    image. Number of lines of the raster image."""
    subclass = None
    superclass = None
    def __init__(self, pixelSizeCol=1, nbColCOS=20, pixelSizeLi=1, pixelByteSizeCOS=1, nbLiCOS=20):
        self.original_tagname_ = None
        self.pixelSizeCol = _cast(float, pixelSizeCol)
        self.nbColCOS = _cast(int, nbColCOS)
        self.pixelSizeLi = _cast(float, pixelSizeLi)
        self.pixelByteSizeCOS = _cast(int, pixelByteSizeCOS)
        self.nbLiCOS = _cast(int, nbLiCOS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, _RasterCOSInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if _RasterCOSInformation.subclass:
            return _RasterCOSInformation.subclass(*args_, **kwargs_)
        else:
            return _RasterCOSInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pixelSizeCol(self): return self.pixelSizeCol
    def set_pixelSizeCol(self, pixelSizeCol): self.pixelSizeCol = pixelSizeCol
    def get_nbColCOS(self): return self.nbColCOS
    def set_nbColCOS(self, nbColCOS): self.nbColCOS = nbColCOS
    def get_pixelSizeLi(self): return self.pixelSizeLi
    def set_pixelSizeLi(self, pixelSizeLi): self.pixelSizeLi = pixelSizeLi
    def get_pixelByteSizeCOS(self): return self.pixelByteSizeCOS
    def set_pixelByteSizeCOS(self, pixelByteSizeCOS): self.pixelByteSizeCOS = pixelByteSizeCOS
    def get_nbLiCOS(self): return self.nbLiCOS
    def set_nbLiCOS(self, nbLiCOS): self.nbLiCOS = nbLiCOS
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_RasterCOSInformation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_RasterCOSInformation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_RasterCOSInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_RasterCOSInformation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_RasterCOSInformation'):
        if self.pixelSizeCol is not None and 'pixelSizeCol' not in already_processed:
            already_processed.add('pixelSizeCol')
            outfile.write(' pixelSizeCol="%s"' % self.gds_format_double(self.pixelSizeCol, input_name='pixelSizeCol'))
        if self.nbColCOS is not None and 'nbColCOS' not in already_processed:
            already_processed.add('nbColCOS')
            outfile.write(' nbColCOS="%s"' % self.gds_format_integer(self.nbColCOS, input_name='nbColCOS'))
        if self.pixelSizeLi is not None and 'pixelSizeLi' not in already_processed:
            already_processed.add('pixelSizeLi')
            outfile.write(' pixelSizeLi="%s"' % self.gds_format_double(self.pixelSizeLi, input_name='pixelSizeLi'))
        if self.pixelByteSizeCOS is not None and 'pixelByteSizeCOS' not in already_processed:
            already_processed.add('pixelByteSizeCOS')
            outfile.write(' pixelByteSizeCOS="%s"' % self.gds_format_integer(self.pixelByteSizeCOS, input_name='pixelByteSizeCOS'))
        if self.nbLiCOS is not None and 'nbLiCOS' not in already_processed:
            already_processed.add('nbLiCOS')
            outfile.write(' nbLiCOS="%s"' % self.gds_format_integer(self.nbLiCOS, input_name='nbLiCOS'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_RasterCOSInformation', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pixelSizeCol', node)
        if value is not None and 'pixelSizeCol' not in already_processed:
            already_processed.add('pixelSizeCol')
            try:
                self.pixelSizeCol = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (pixelSizeCol): %s' % exp)
        value = find_attr_value_('nbColCOS', node)
        if value is not None and 'nbColCOS' not in already_processed:
            already_processed.add('nbColCOS')
            try:
                self.nbColCOS = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('pixelSizeLi', node)
        if value is not None and 'pixelSizeLi' not in already_processed:
            already_processed.add('pixelSizeLi')
            try:
                self.pixelSizeLi = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (pixelSizeLi): %s' % exp)
        value = find_attr_value_('pixelByteSizeCOS', node)
        if value is not None and 'pixelByteSizeCOS' not in already_processed:
            already_processed.add('pixelByteSizeCOS')
            try:
                self.pixelByteSizeCOS = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('nbLiCOS', node)
        if value is not None and 'nbLiCOS' not in already_processed:
            already_processed.add('nbLiCOS')
            try:
                self.nbLiCOS = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class _RasterCOSInformation


class _Plot(GeneratedsSuper):
    """Representation of a DART plot. It's defined by its type, a geometric
    property and its optical(s) property(ies). The number of optical
    properties depends of the type of the plot. It can be formed of
    soil, vegetation or a combinaison of soil and vegetation.
    Representation of a DART plot. It's defined by its type, a
    geometric property and its optical(s) property(ies). The number
    of optical properties depends of the type of the plot. It can be
    formed of soil, vegetation or a combinaison of soil and
    vegetation. If you select this option, this plot are not use in
    all DART modules, \n it's useful if you want conserve plot
    properties backup without delete this for tests If you select
    this option, this plot are not use in all DART modules, \n it's
    useful if you want conserve plot properties backup without
    delete this for tests If part of the object goes beyond the
    border of the scene, this part is copied on the other side of
    the scene. If part of the object goes beyond the border of the
    scene, this part is copied on the other side of the scene. Plot:
    "vegetation layer + ground surface over the ground of the
    scene", "ground surface over the ground of the scene" or
    "vegetation layer over the ground of the scene" Plot:
    "vegetation layer + ground surface over the ground of the
    scene", "ground surface over the ground of the scene" or
    "vegetation layer over the ground of the scene" How the plot
    geometry will be defined. This can be done by giving the
    dimension and position of a rectangle, or by directly giving the
    coordinates of the four corners of the the delimiting
    quadrilater. How the plot geometry will be defined. This can be
    done by giving the dimension and position of a rectangle, or by
    directly giving the coordinates of the four corners of the the
    delimiting quadrilater. Objects's positions are taken from the
    position file.\nDesactivate this option if you experience some
    slowdown. Objects's positions are taken from the position
    file.\nDesactivate this option if you experience some slowdown."""
    subclass = None
    superclass = None
    def __init__(self, hidden=0, repeatedOnBorder=1, type_=1, form=0, isDisplayed=1, Polygon2D=None, Rectangle2D=None, GroundOpticalPropertyLink=None, GroundThermalPropertyLink=None, PlotVegetationProperties=None, PlotAirProperties=None, PlotWaterProperties=None):
        self.original_tagname_ = None
        self.hidden = _cast(int, hidden)
        self.repeatedOnBorder = _cast(int, repeatedOnBorder)
        self.type_ = _cast(int, type_)
        self.form = _cast(int, form)
        self.isDisplayed = _cast(int, isDisplayed)
        self.Polygon2D = Polygon2D
        self.Rectangle2D = Rectangle2D
        self.GroundOpticalPropertyLink = GroundOpticalPropertyLink
        self.GroundThermalPropertyLink = GroundThermalPropertyLink
        self.PlotVegetationProperties = PlotVegetationProperties
        self.PlotAirProperties = PlotAirProperties
        self.PlotWaterProperties = PlotWaterProperties
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, _Plot)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if _Plot.subclass:
            return _Plot.subclass(*args_, **kwargs_)
        else:
            return _Plot(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Polygon2D(self): return self.Polygon2D
    def set_Polygon2D(self, Polygon2D): self.Polygon2D = Polygon2D
    def get_Rectangle2D(self): return self.Rectangle2D
    def set_Rectangle2D(self, Rectangle2D): self.Rectangle2D = Rectangle2D
    def get_GroundOpticalPropertyLink(self): return self.GroundOpticalPropertyLink
    def set_GroundOpticalPropertyLink(self, GroundOpticalPropertyLink): self.GroundOpticalPropertyLink = GroundOpticalPropertyLink
    def get_GroundThermalPropertyLink(self): return self.GroundThermalPropertyLink
    def set_GroundThermalPropertyLink(self, GroundThermalPropertyLink): self.GroundThermalPropertyLink = GroundThermalPropertyLink
    def get_PlotVegetationProperties(self): return self.PlotVegetationProperties
    def set_PlotVegetationProperties(self, PlotVegetationProperties): self.PlotVegetationProperties = PlotVegetationProperties
    def get_PlotAirProperties(self): return self.PlotAirProperties
    def set_PlotAirProperties(self, PlotAirProperties): self.PlotAirProperties = PlotAirProperties
    def get_PlotWaterProperties(self): return self.PlotWaterProperties
    def set_PlotWaterProperties(self, PlotWaterProperties): self.PlotWaterProperties = PlotWaterProperties
    def get_hidden(self): return self.hidden
    def set_hidden(self, hidden): self.hidden = hidden
    def get_repeatedOnBorder(self): return self.repeatedOnBorder
    def set_repeatedOnBorder(self, repeatedOnBorder): self.repeatedOnBorder = repeatedOnBorder
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_form(self): return self.form
    def set_form(self, form): self.form = form
    def get_isDisplayed(self): return self.isDisplayed
    def set_isDisplayed(self, isDisplayed): self.isDisplayed = isDisplayed
    def hasContent_(self):
        if (
            self.Polygon2D is not None or
            self.Rectangle2D is not None or
            self.GroundOpticalPropertyLink is not None or
            self.GroundThermalPropertyLink is not None or
            self.PlotVegetationProperties is not None or
            self.PlotAirProperties is not None or
            self.PlotWaterProperties is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Plot', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Plot')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Plot')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Plot', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Plot'):
        if self.hidden is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            outfile.write(' hidden="%s"' % self.gds_format_integer(self.hidden, input_name='hidden'))
        if self.repeatedOnBorder is not None and 'repeatedOnBorder' not in already_processed:
            already_processed.add('repeatedOnBorder')
            outfile.write(' repeatedOnBorder="%s"' % self.gds_format_integer(self.repeatedOnBorder, input_name='repeatedOnBorder'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type="%s"' % self.gds_format_integer(self.type_, input_name='type'))
        if self.form is not None and 'form' not in already_processed:
            already_processed.add('form')
            outfile.write(' form="%s"' % self.gds_format_integer(self.form, input_name='form'))
        if self.isDisplayed is not None and 'isDisplayed' not in already_processed:
            already_processed.add('isDisplayed')
            outfile.write(' isDisplayed="%s"' % self.gds_format_integer(self.isDisplayed, input_name='isDisplayed'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Plot', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Polygon2D is not None:
            self.Polygon2D.export(outfile, level, namespaceprefix_, name_='Polygon2D', pretty_print=pretty_print)
        if self.Rectangle2D is not None:
            self.Rectangle2D.export(outfile, level, namespaceprefix_, name_='Rectangle2D', pretty_print=pretty_print)
        if self.GroundOpticalPropertyLink is not None:
            self.GroundOpticalPropertyLink.export(outfile, level, namespaceprefix_, name_='GroundOpticalPropertyLink', pretty_print=pretty_print)
        if self.GroundThermalPropertyLink is not None:
            self.GroundThermalPropertyLink.export(outfile, level, namespaceprefix_, name_='GroundThermalPropertyLink', pretty_print=pretty_print)
        if self.PlotVegetationProperties is not None:
            self.PlotVegetationProperties.export(outfile, level, namespaceprefix_, name_='PlotVegetationProperties', pretty_print=pretty_print)
        if self.PlotAirProperties is not None:
            self.PlotAirProperties.export(outfile, level, namespaceprefix_, name_='PlotAirProperties', pretty_print=pretty_print)
        if self.PlotWaterProperties is not None:
            self.PlotWaterProperties.export(outfile, level, namespaceprefix_, name_='PlotWaterProperties', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hidden', node)
        if value is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            try:
                self.hidden = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('repeatedOnBorder', node)
        if value is not None and 'repeatedOnBorder' not in already_processed:
            already_processed.add('repeatedOnBorder')
            try:
                self.repeatedOnBorder = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            try:
                self.type_ = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('form', node)
        if value is not None and 'form' not in already_processed:
            already_processed.add('form')
            try:
                self.form = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isDisplayed', node)
        if value is not None and 'isDisplayed' not in already_processed:
            already_processed.add('isDisplayed')
            try:
                self.isDisplayed = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Polygon2D':
            obj_ = _Polygon2D.factory()
            obj_.build(child_)
            self.Polygon2D = obj_
            obj_.original_tagname_ = 'Polygon2D'
        elif nodeName_ == 'Rectangle2D':
            obj_ = _Rectangle2D.factory()
            obj_.build(child_)
            self.Rectangle2D = obj_
            obj_.original_tagname_ = 'Rectangle2D'
        elif nodeName_ == 'GroundOpticalPropertyLink':
            obj_ = _GroundOpticalPropertyLink.factory()
            obj_.build(child_)
            self.GroundOpticalPropertyLink = obj_
            obj_.original_tagname_ = 'GroundOpticalPropertyLink'
        elif nodeName_ == 'GroundThermalPropertyLink':
            obj_ = _GroundThermalPropertyLink.factory()
            obj_.build(child_)
            self.GroundThermalPropertyLink = obj_
            obj_.original_tagname_ = 'GroundThermalPropertyLink'
        elif nodeName_ == 'PlotVegetationProperties':
            obj_ = _PlotVegetationProperties.factory()
            obj_.build(child_)
            self.PlotVegetationProperties = obj_
            obj_.original_tagname_ = 'PlotVegetationProperties'
        elif nodeName_ == 'PlotAirProperties':
            obj_ = _PlotAirProperties.factory()
            obj_.build(child_)
            self.PlotAirProperties = obj_
            obj_.original_tagname_ = 'PlotAirProperties'
        elif nodeName_ == 'PlotWaterProperties':
            obj_ = _PlotWaterProperties.factory()
            obj_.build(child_)
            self.PlotWaterProperties = obj_
            obj_.original_tagname_ = 'PlotWaterProperties'
# end class _Plot


class _Polygon2D(GeneratedsSuper):
    """Representation of a DART polygon. He's defined by his 4 corners,
    starting form the top left one, and turning anticlockwise.
    Representation of a DART polygon. He's defined by his 4 corners,
    starting form the top left one, and turning anticlockwise."""
    subclass = None
    superclass = None
    def __init__(self, Point2D=None):
        self.original_tagname_ = None
        if Point2D is None:
            self.Point2D = []
        else:
            self.Point2D = Point2D
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, _Polygon2D)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if _Polygon2D.subclass:
            return _Polygon2D.subclass(*args_, **kwargs_)
        else:
            return _Polygon2D(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Point2D(self): return self.Point2D
    def set_Point2D(self, Point2D): self.Point2D = Point2D
    def add_Point2D(self, value): self.Point2D.append(value)
    def insert_Point2D_at(self, index, value): self.Point2D.insert(index, value)
    def replace_Point2D_at(self, index, value): self.Point2D[index] = value
    def hasContent_(self):
        if (
            self.Point2D
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Polygon2D', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Polygon2D')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Polygon2D')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Polygon2D', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Polygon2D'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Polygon2D', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Point2D_ in self.Point2D:
            Point2D_.export(outfile, level, namespaceprefix_, name_='Point2D', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Point2D':
            obj_ = _Point2D.factory()
            obj_.build(child_)
            self.Point2D.append(obj_)
            obj_.original_tagname_ = 'Point2D'
# end class _Polygon2D


class _Point2D(GeneratedsSuper):
    """Optical properties for a DART soil phase function. Optical
    properties for a DART soil phase function. y coordinate of a
    corner of the quadrilateral that defines the plot. Points are
    defined anticlockwise y coordinate of a corner of the
    quadrilateral that defines the plot. Points are defined
    anticlockwise x coordinate of a corner of the quadrilateral that
    defines the plot. Points are defined anticlockwise x coordinate
    of a corner of the quadrilateral that defines the plot. Points
    are defined anticlockwise"""
    subclass = None
    superclass = None
    def __init__(self, y=0.00, x=0.00):
        self.original_tagname_ = None
        self.y = _cast(float, y)
        self.x = _cast(float, x)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, _Point2D)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if _Point2D.subclass:
            return _Point2D.subclass(*args_, **kwargs_)
        else:
            return _Point2D(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Point2D', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Point2D')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Point2D')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Point2D', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Point2D'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y="%s"' % self.gds_format_double(self.y, input_name='y'))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name='x'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Point2D', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            try:
                self.y = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (y): %s' % exp)
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            try:
                self.x = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class _Point2D


class _Rectangle2D(GeneratedsSuper):
    """Rectangle2D Rectangle2D Length along X axis (in meters) Length along
    X axis (in meters) Length along Y axis (in meters) Length along
    Y axis (in meters) Rotation around the plot center (in degrees,
    in the range [-180, 180]) Rotation around the plot center (in
    degrees, in the range [-180, 180]) Center along X axis (in
    meters) Center along X axis (in meters) Center along Y axis (in
    meters) Center along Y axis (in meters)"""
    subclass = None
    superclass = None
    def __init__(self, coteX=10, coteY=10, intrinsicRotation=0, centreX=5, centreY=5):
        self.original_tagname_ = None
        self.coteX = _cast(float, coteX)
        self.coteY = _cast(float, coteY)
        self.intrinsicRotation = _cast(float, intrinsicRotation)
        self.centreX = _cast(float, centreX)
        self.centreY = _cast(float, centreY)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, _Rectangle2D)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if _Rectangle2D.subclass:
            return _Rectangle2D.subclass(*args_, **kwargs_)
        else:
            return _Rectangle2D(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_coteX(self): return self.coteX
    def set_coteX(self, coteX): self.coteX = coteX
    def get_coteY(self): return self.coteY
    def set_coteY(self, coteY): self.coteY = coteY
    def get_intrinsicRotation(self): return self.intrinsicRotation
    def set_intrinsicRotation(self, intrinsicRotation): self.intrinsicRotation = intrinsicRotation
    def get_centreX(self): return self.centreX
    def set_centreX(self, centreX): self.centreX = centreX
    def get_centreY(self): return self.centreY
    def set_centreY(self, centreY): self.centreY = centreY
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Rectangle2D', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Rectangle2D')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Rectangle2D')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Rectangle2D', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Rectangle2D'):
        if self.coteX is not None and 'coteX' not in already_processed:
            already_processed.add('coteX')
            outfile.write(' coteX="%s"' % self.gds_format_double(self.coteX, input_name='coteX'))
        if self.coteY is not None and 'coteY' not in already_processed:
            already_processed.add('coteY')
            outfile.write(' coteY="%s"' % self.gds_format_double(self.coteY, input_name='coteY'))
        if self.intrinsicRotation is not None and 'intrinsicRotation' not in already_processed:
            already_processed.add('intrinsicRotation')
            outfile.write(' intrinsicRotation="%s"' % self.gds_format_double(self.intrinsicRotation, input_name='intrinsicRotation'))
        if self.centreX is not None and 'centreX' not in already_processed:
            already_processed.add('centreX')
            outfile.write(' centreX="%s"' % self.gds_format_double(self.centreX, input_name='centreX'))
        if self.centreY is not None and 'centreY' not in already_processed:
            already_processed.add('centreY')
            outfile.write(' centreY="%s"' % self.gds_format_double(self.centreY, input_name='centreY'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Rectangle2D', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('coteX', node)
        if value is not None and 'coteX' not in already_processed:
            already_processed.add('coteX')
            try:
                self.coteX = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (coteX): %s' % exp)
        value = find_attr_value_('coteY', node)
        if value is not None and 'coteY' not in already_processed:
            already_processed.add('coteY')
            try:
                self.coteY = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (coteY): %s' % exp)
        value = find_attr_value_('intrinsicRotation', node)
        if value is not None and 'intrinsicRotation' not in already_processed:
            already_processed.add('intrinsicRotation')
            try:
                self.intrinsicRotation = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (intrinsicRotation): %s' % exp)
        value = find_attr_value_('centreX', node)
        if value is not None and 'centreX' not in already_processed:
            already_processed.add('centreX')
            try:
                self.centreX = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (centreX): %s' % exp)
        value = find_attr_value_('centreY', node)
        if value is not None and 'centreY' not in already_processed:
            already_processed.add('centreY')
            try:
                self.centreY = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (centreY): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class _Rectangle2D


class _GroundOpticalPropertyLink(GeneratedsSuper):
    """Optical properties for a DART soil phase function (name, type and
    index). Optical properties for a DART soil phase function (name,
    type and index). Index of the DART phase function of the ground
    of the plot. Index of the DART phase function of the ground of
    the plot. proportion of photons intercepted along an incident
    direction that are scattered within a solid angle along a given
    direction proportion of photons intercepted along an incident
    direction that are scattered within a solid angle along a given
    direction Type of phase function (lambertian, etc.) Type of
    phase function (lambertian, etc.)"""
    subclass = None
    superclass = None
    def __init__(self, indexFctPhase=0, ident='Lambertian_Phase_Function_1', type_=0):
        self.original_tagname_ = None
        self.indexFctPhase = _cast(int, indexFctPhase)
        self.ident = _cast(None, ident)
        self.type_ = _cast(int, type_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, _GroundOpticalPropertyLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if _GroundOpticalPropertyLink.subclass:
            return _GroundOpticalPropertyLink.subclass(*args_, **kwargs_)
        else:
            return _GroundOpticalPropertyLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexFctPhase(self): return self.indexFctPhase
    def set_indexFctPhase(self, indexFctPhase): self.indexFctPhase = indexFctPhase
    def get_ident(self): return self.ident
    def set_ident(self, ident): self.ident = ident
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_GroundOpticalPropertyLink', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_GroundOpticalPropertyLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_GroundOpticalPropertyLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_GroundOpticalPropertyLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_GroundOpticalPropertyLink'):
        if self.indexFctPhase is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            outfile.write(' indexFctPhase="%s"' % self.gds_format_integer(self.indexFctPhase, input_name='indexFctPhase'))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            outfile.write(' ident=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ident), input_name='ident')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type="%s"' % self.gds_format_integer(self.type_, input_name='type'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_GroundOpticalPropertyLink', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('indexFctPhase', node)
        if value is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            try:
                self.indexFctPhase = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ident', node)
        if value is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            self.ident = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            try:
                self.type_ = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class _GroundOpticalPropertyLink


class _GroundThermalPropertyLink(GeneratedsSuper):
    """GroundThermalPropertyLink GroundThermalPropertyLink indexTemperature
    indexTemperature Thermal Function ID Thermal Function ID"""
    subclass = None
    superclass = None
    def __init__(self, indexTemperature=0, idTemperature='ThermalFunction290_310'):
        self.original_tagname_ = None
        self.indexTemperature = _cast(int, indexTemperature)
        self.idTemperature = _cast(None, idTemperature)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, _GroundThermalPropertyLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if _GroundThermalPropertyLink.subclass:
            return _GroundThermalPropertyLink.subclass(*args_, **kwargs_)
        else:
            return _GroundThermalPropertyLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexTemperature(self): return self.indexTemperature
    def set_indexTemperature(self, indexTemperature): self.indexTemperature = indexTemperature
    def get_idTemperature(self): return self.idTemperature
    def set_idTemperature(self, idTemperature): self.idTemperature = idTemperature
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_GroundThermalPropertyLink', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_GroundThermalPropertyLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_GroundThermalPropertyLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_GroundThermalPropertyLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_GroundThermalPropertyLink'):
        if self.indexTemperature is not None and 'indexTemperature' not in already_processed:
            already_processed.add('indexTemperature')
            outfile.write(' indexTemperature="%s"' % self.gds_format_integer(self.indexTemperature, input_name='indexTemperature'))
        if self.idTemperature is not None and 'idTemperature' not in already_processed:
            already_processed.add('idTemperature')
            outfile.write(' idTemperature=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idTemperature), input_name='idTemperature')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_GroundThermalPropertyLink', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('indexTemperature', node)
        if value is not None and 'indexTemperature' not in already_processed:
            already_processed.add('indexTemperature')
            try:
                self.indexTemperature = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('idTemperature', node)
        if value is not None and 'idTemperature' not in already_processed:
            already_processed.add('idTemperature')
            self.idTemperature = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class _GroundThermalPropertyLink


class _PlotVegetationProperties(GeneratedsSuper):
    """Caracteristics of a plot (height of its vegetation, LAI ...).
    Caracteristics of a plot (height of its vegetation, LAI ...).
    Fill everything in the defined area below a given altitude. Fill
    everything in the defined area below a given altitude. If
    checked, the plot will be represented as a cloud of triangles.
    Otherwise, it will be represented as a juxtaposition of turbid
    cells. If checked, the plot will be represented as a cloud of
    triangles. Otherwise, it will be represented as a juxtaposition
    of turbid cells. Choose if you define vegetation by LAI (foliar
    m2 / m2 of the plot) or Ul (foliar m2 / m3 of the plot) Choose
    if you define vegetation by LAI (foliar m2 / m2 of the plot) or
    Ul (foliar m2 / m3 of the plot)"""
    subclass = None
    superclass = None
    def __init__(self, verticalFillMode=0, trianglePlotRepresentation=0, densityDefinition=0, MeshPlotRepresentation=None, VegetationGeometry=None, VegetationFillGeometry=None, LAIVegetation=None, UFVegetation=None, VegetationOpticalPropertyLink=None, GroundThermalPropertyLink=None):
        self.original_tagname_ = None
        self.verticalFillMode = _cast(int, verticalFillMode)
        self.trianglePlotRepresentation = _cast(int, trianglePlotRepresentation)
        self.densityDefinition = _cast(int, densityDefinition)
        self.MeshPlotRepresentation = MeshPlotRepresentation
        self.VegetationGeometry = VegetationGeometry
        self.VegetationFillGeometry = VegetationFillGeometry
        self.LAIVegetation = LAIVegetation
        self.UFVegetation = UFVegetation
        self.VegetationOpticalPropertyLink = VegetationOpticalPropertyLink
        self.GroundThermalPropertyLink = GroundThermalPropertyLink
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, _PlotVegetationProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if _PlotVegetationProperties.subclass:
            return _PlotVegetationProperties.subclass(*args_, **kwargs_)
        else:
            return _PlotVegetationProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MeshPlotRepresentation(self): return self.MeshPlotRepresentation
    def set_MeshPlotRepresentation(self, MeshPlotRepresentation): self.MeshPlotRepresentation = MeshPlotRepresentation
    def get_VegetationGeometry(self): return self.VegetationGeometry
    def set_VegetationGeometry(self, VegetationGeometry): self.VegetationGeometry = VegetationGeometry
    def get_VegetationFillGeometry(self): return self.VegetationFillGeometry
    def set_VegetationFillGeometry(self, VegetationFillGeometry): self.VegetationFillGeometry = VegetationFillGeometry
    def get_LAIVegetation(self): return self.LAIVegetation
    def set_LAIVegetation(self, LAIVegetation): self.LAIVegetation = LAIVegetation
    def get_UFVegetation(self): return self.UFVegetation
    def set_UFVegetation(self, UFVegetation): self.UFVegetation = UFVegetation
    def get_VegetationOpticalPropertyLink(self): return self.VegetationOpticalPropertyLink
    def set_VegetationOpticalPropertyLink(self, VegetationOpticalPropertyLink): self.VegetationOpticalPropertyLink = VegetationOpticalPropertyLink
    def get_GroundThermalPropertyLink(self): return self.GroundThermalPropertyLink
    def set_GroundThermalPropertyLink(self, GroundThermalPropertyLink): self.GroundThermalPropertyLink = GroundThermalPropertyLink
    def get_verticalFillMode(self): return self.verticalFillMode
    def set_verticalFillMode(self, verticalFillMode): self.verticalFillMode = verticalFillMode
    def get_trianglePlotRepresentation(self): return self.trianglePlotRepresentation
    def set_trianglePlotRepresentation(self, trianglePlotRepresentation): self.trianglePlotRepresentation = trianglePlotRepresentation
    def get_densityDefinition(self): return self.densityDefinition
    def set_densityDefinition(self, densityDefinition): self.densityDefinition = densityDefinition
    def hasContent_(self):
        if (
            self.MeshPlotRepresentation is not None or
            self.VegetationGeometry is not None or
            self.VegetationFillGeometry is not None or
            self.LAIVegetation is not None or
            self.UFVegetation is not None or
            self.VegetationOpticalPropertyLink is not None or
            self.GroundThermalPropertyLink is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_PlotVegetationProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_PlotVegetationProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_PlotVegetationProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_PlotVegetationProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_PlotVegetationProperties'):
        if self.verticalFillMode is not None and 'verticalFillMode' not in already_processed:
            already_processed.add('verticalFillMode')
            outfile.write(' verticalFillMode="%s"' % self.gds_format_integer(self.verticalFillMode, input_name='verticalFillMode'))
        if self.trianglePlotRepresentation is not None and 'trianglePlotRepresentation' not in already_processed:
            already_processed.add('trianglePlotRepresentation')
            outfile.write(' trianglePlotRepresentation="%s"' % self.gds_format_integer(self.trianglePlotRepresentation, input_name='trianglePlotRepresentation'))
        if self.densityDefinition is not None and 'densityDefinition' not in already_processed:
            already_processed.add('densityDefinition')
            outfile.write(' densityDefinition="%s"' % self.gds_format_integer(self.densityDefinition, input_name='densityDefinition'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_PlotVegetationProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MeshPlotRepresentation is not None:
            self.MeshPlotRepresentation.export(outfile, level, namespaceprefix_, name_='MeshPlotRepresentation', pretty_print=pretty_print)
        if self.VegetationGeometry is not None:
            self.VegetationGeometry.export(outfile, level, namespaceprefix_, name_='VegetationGeometry', pretty_print=pretty_print)
        if self.VegetationFillGeometry is not None:
            self.VegetationFillGeometry.export(outfile, level, namespaceprefix_, name_='VegetationFillGeometry', pretty_print=pretty_print)
        if self.LAIVegetation is not None:
            self.LAIVegetation.export(outfile, level, namespaceprefix_, name_='LAIVegetation', pretty_print=pretty_print)
        if self.UFVegetation is not None:
            self.UFVegetation.export(outfile, level, namespaceprefix_, name_='UFVegetation', pretty_print=pretty_print)
        if self.VegetationOpticalPropertyLink is not None:
            self.VegetationOpticalPropertyLink.export(outfile, level, namespaceprefix_, name_='VegetationOpticalPropertyLink', pretty_print=pretty_print)
        if self.GroundThermalPropertyLink is not None:
            self.GroundThermalPropertyLink.export(outfile, level, namespaceprefix_, name_='GroundThermalPropertyLink', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('verticalFillMode', node)
        if value is not None and 'verticalFillMode' not in already_processed:
            already_processed.add('verticalFillMode')
            try:
                self.verticalFillMode = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('trianglePlotRepresentation', node)
        if value is not None and 'trianglePlotRepresentation' not in already_processed:
            already_processed.add('trianglePlotRepresentation')
            try:
                self.trianglePlotRepresentation = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('densityDefinition', node)
        if value is not None and 'densityDefinition' not in already_processed:
            already_processed.add('densityDefinition')
            try:
                self.densityDefinition = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeshPlotRepresentation':
            obj_ = _MeshPlotRepresentation.factory()
            obj_.build(child_)
            self.MeshPlotRepresentation = obj_
            obj_.original_tagname_ = 'MeshPlotRepresentation'
        elif nodeName_ == 'VegetationGeometry':
            obj_ = _VegetationGeometry.factory()
            obj_.build(child_)
            self.VegetationGeometry = obj_
            obj_.original_tagname_ = 'VegetationGeometry'
        elif nodeName_ == 'VegetationFillGeometry':
            obj_ = _VegetationFillGeometry.factory()
            obj_.build(child_)
            self.VegetationFillGeometry = obj_
            obj_.original_tagname_ = 'VegetationFillGeometry'
        elif nodeName_ == 'LAIVegetation':
            obj_ = _LAIVegetation.factory()
            obj_.build(child_)
            self.LAIVegetation = obj_
            obj_.original_tagname_ = 'LAIVegetation'
        elif nodeName_ == 'UFVegetation':
            obj_ = _UFVegetation.factory()
            obj_.build(child_)
            self.UFVegetation = obj_
            obj_.original_tagname_ = 'UFVegetation'
        elif nodeName_ == 'VegetationOpticalPropertyLink':
            obj_ = _VegetationOpticalPropertyLink.factory()
            obj_.build(child_)
            self.VegetationOpticalPropertyLink = obj_
            obj_.original_tagname_ = 'VegetationOpticalPropertyLink'
        elif nodeName_ == 'GroundThermalPropertyLink':
            obj_ = _GroundThermalPropertyLink.factory()
            obj_.build(child_)
            self.GroundThermalPropertyLink = obj_
            obj_.original_tagname_ = 'GroundThermalPropertyLink'
# end class _PlotVegetationProperties


class _MeshPlotRepresentation(GeneratedsSuper):
    """Defines how the leaves are geometrically distributed in the crown.
    Defines how the leaves are geometrically distributed in the
    crown. Definition of the leaves geometry and numbers. Definition
    of the leaves geometry and numbers."""
    subclass = None
    superclass = None
    def __init__(self, distributionMode=0, leafDefinition=1, NumberOfTriangleParameters=None, MeshLeafDimensionParameters=None):
        self.original_tagname_ = None
        self.distributionMode = _cast(int, distributionMode)
        self.leafDefinition = _cast(int, leafDefinition)
        self.NumberOfTriangleParameters = NumberOfTriangleParameters
        self.MeshLeafDimensionParameters = MeshLeafDimensionParameters
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, _MeshPlotRepresentation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if _MeshPlotRepresentation.subclass:
            return _MeshPlotRepresentation.subclass(*args_, **kwargs_)
        else:
            return _MeshPlotRepresentation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NumberOfTriangleParameters(self): return self.NumberOfTriangleParameters
    def set_NumberOfTriangleParameters(self, NumberOfTriangleParameters): self.NumberOfTriangleParameters = NumberOfTriangleParameters
    def get_MeshLeafDimensionParameters(self): return self.MeshLeafDimensionParameters
    def set_MeshLeafDimensionParameters(self, MeshLeafDimensionParameters): self.MeshLeafDimensionParameters = MeshLeafDimensionParameters
    def get_distributionMode(self): return self.distributionMode
    def set_distributionMode(self, distributionMode): self.distributionMode = distributionMode
    def get_leafDefinition(self): return self.leafDefinition
    def set_leafDefinition(self, leafDefinition): self.leafDefinition = leafDefinition
    def hasContent_(self):
        if (
            self.NumberOfTriangleParameters is not None or
            self.MeshLeafDimensionParameters is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_MeshPlotRepresentation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_MeshPlotRepresentation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_MeshPlotRepresentation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_MeshPlotRepresentation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_MeshPlotRepresentation'):
        if self.distributionMode is not None and 'distributionMode' not in already_processed:
            already_processed.add('distributionMode')
            outfile.write(' distributionMode="%s"' % self.gds_format_integer(self.distributionMode, input_name='distributionMode'))
        if self.leafDefinition is not None and 'leafDefinition' not in already_processed:
            already_processed.add('leafDefinition')
            outfile.write(' leafDefinition="%s"' % self.gds_format_integer(self.leafDefinition, input_name='leafDefinition'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_MeshPlotRepresentation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NumberOfTriangleParameters is not None:
            self.NumberOfTriangleParameters.export(outfile, level, namespaceprefix_, name_='NumberOfTriangleParameters', pretty_print=pretty_print)
        if self.MeshLeafDimensionParameters is not None:
            self.MeshLeafDimensionParameters.export(outfile, level, namespaceprefix_, name_='MeshLeafDimensionParameters', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('distributionMode', node)
        if value is not None and 'distributionMode' not in already_processed:
            already_processed.add('distributionMode')
            try:
                self.distributionMode = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('leafDefinition', node)
        if value is not None and 'leafDefinition' not in already_processed:
            already_processed.add('leafDefinition')
            try:
                self.leafDefinition = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NumberOfTriangleParameters':
            obj_ = _NumberOfTriangleParameters.factory()
            obj_.build(child_)
            self.NumberOfTriangleParameters = obj_
            obj_.original_tagname_ = 'NumberOfTriangleParameters'
        elif nodeName_ == 'MeshLeafDimensionParameters':
            obj_ = _MeshLeafDimensionParameters.factory()
            obj_.build(child_)
            self.MeshLeafDimensionParameters = obj_
            obj_.original_tagname_ = 'MeshLeafDimensionParameters'
# end class _MeshPlotRepresentation


class _NumberOfTriangleParameters(GeneratedsSuper):
    """Fix the number of leaves/triangles of the plot. The leaf area will
    then be the total area of leaves in the plot divided by this
    number. The real effective number generated may vary due to
    rounding and distribution errors. Fix the number of
    leaves/triangles of the plot. The leaf area will then be the
    total area of leaves in the plot divided by this number. The
    real effective number generated may vary due to rounding and
    distribution errors."""
    subclass = None
    superclass = None
    def __init__(self, nbTriangles=10000):
        self.original_tagname_ = None
        self.nbTriangles = _cast(int, nbTriangles)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, _NumberOfTriangleParameters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if _NumberOfTriangleParameters.subclass:
            return _NumberOfTriangleParameters.subclass(*args_, **kwargs_)
        else:
            return _NumberOfTriangleParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nbTriangles(self): return self.nbTriangles
    def set_nbTriangles(self, nbTriangles): self.nbTriangles = nbTriangles
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_NumberOfTriangleParameters', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_NumberOfTriangleParameters')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_NumberOfTriangleParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_NumberOfTriangleParameters', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_NumberOfTriangleParameters'):
        if self.nbTriangles is not None and 'nbTriangles' not in already_processed:
            already_processed.add('nbTriangles')
            outfile.write(' nbTriangles="%s"' % self.gds_format_integer(self.nbTriangles, input_name='nbTriangles'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_NumberOfTriangleParameters', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nbTriangles', node)
        if value is not None and 'nbTriangles' not in already_processed:
            already_processed.add('nbTriangles')
            try:
                self.nbTriangles = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class _NumberOfTriangleParameters


class _MeshLeafDimensionParameters(GeneratedsSuper):
    """Area of each individual leaf/triangle. The number of
    leaves/triangles will then be the total area of leaves in the
    plot divided by this number. The real effective number generated
    may vary due to rounding and distribution errors. Area of each
    individual leaf/triangle. The number of leaves/triangles will
    then be the total area of leaves in the plot divided by this
    number. The real effective number generated may vary due to
    rounding and distribution errors."""
    subclass = None
    superclass = None
    def __init__(self, meshLeafDimension=0.003):
        self.original_tagname_ = None
        self.meshLeafDimension = _cast(float, meshLeafDimension)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, _MeshLeafDimensionParameters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if _MeshLeafDimensionParameters.subclass:
            return _MeshLeafDimensionParameters.subclass(*args_, **kwargs_)
        else:
            return _MeshLeafDimensionParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meshLeafDimension(self): return self.meshLeafDimension
    def set_meshLeafDimension(self, meshLeafDimension): self.meshLeafDimension = meshLeafDimension
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_MeshLeafDimensionParameters', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_MeshLeafDimensionParameters')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_MeshLeafDimensionParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_MeshLeafDimensionParameters', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_MeshLeafDimensionParameters'):
        if self.meshLeafDimension is not None and 'meshLeafDimension' not in already_processed:
            already_processed.add('meshLeafDimension')
            outfile.write(' meshLeafDimension="%s"' % self.gds_format_double(self.meshLeafDimension, input_name='meshLeafDimension'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_MeshLeafDimensionParameters', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('meshLeafDimension', node)
        if value is not None and 'meshLeafDimension' not in already_processed:
            already_processed.add('meshLeafDimension')
            try:
                self.meshLeafDimension = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (meshLeafDimension): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class _MeshLeafDimensionParameters


class _VegetationGeometry(GeneratedsSuper):
    """Thickness of the vegetation layer Thickness of the vegetation layer
    Altitude in meter of the base of the vegetation above the ground
    of the plot. Altitude in meter of the base of the vegetation
    above the ground of the plot. Standard deviation of the
    vegetation layer height Standard deviation of the vegetation
    layer height"""
    subclass = None
    superclass = None
    def __init__(self, height=1.0, baseheight=0, stDev=0.0):
        self.original_tagname_ = None
        self.height = _cast(float, height)
        self.baseheight = _cast(float, baseheight)
        self.stDev = _cast(float, stDev)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, _VegetationGeometry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if _VegetationGeometry.subclass:
            return _VegetationGeometry.subclass(*args_, **kwargs_)
        else:
            return _VegetationGeometry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_height(self): return self.height
    def set_height(self, height): self.height = height
    def get_baseheight(self): return self.baseheight
    def set_baseheight(self, baseheight): self.baseheight = baseheight
    def get_stDev(self): return self.stDev
    def set_stDev(self, stDev): self.stDev = stDev
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_VegetationGeometry', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_VegetationGeometry')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_VegetationGeometry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_VegetationGeometry', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_VegetationGeometry'):
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height="%s"' % self.gds_format_double(self.height, input_name='height'))
        if self.baseheight is not None and 'baseheight' not in already_processed:
            already_processed.add('baseheight')
            outfile.write(' baseheight="%s"' % self.gds_format_double(self.baseheight, input_name='baseheight'))
        if self.stDev is not None and 'stDev' not in already_processed:
            already_processed.add('stDev')
            outfile.write(' stDev="%s"' % self.gds_format_double(self.stDev, input_name='stDev'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_VegetationGeometry', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            try:
                self.height = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (height): %s' % exp)
        value = find_attr_value_('baseheight', node)
        if value is not None and 'baseheight' not in already_processed:
            already_processed.add('baseheight')
            try:
                self.baseheight = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (baseheight): %s' % exp)
        value = find_attr_value_('stDev', node)
        if value is not None and 'stDev' not in already_processed:
            already_processed.add('stDev')
            try:
                self.stDev = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (stDev): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class _VegetationGeometry


class _VegetationFillGeometry(GeneratedsSuper):
    """Altitude up to which the plot fill the scene, stating from the
    bottom of the scene Altitude up to which the plot fill the
    scene, stating from the bottom of the scene"""
    subclass = None
    superclass = None
    def __init__(self, topHeight=1.0):
        self.original_tagname_ = None
        self.topHeight = _cast(float, topHeight)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, _VegetationFillGeometry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if _VegetationFillGeometry.subclass:
            return _VegetationFillGeometry.subclass(*args_, **kwargs_)
        else:
            return _VegetationFillGeometry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_topHeight(self): return self.topHeight
    def set_topHeight(self, topHeight): self.topHeight = topHeight
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_VegetationFillGeometry', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_VegetationFillGeometry')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_VegetationFillGeometry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_VegetationFillGeometry', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_VegetationFillGeometry'):
        if self.topHeight is not None and 'topHeight' not in already_processed:
            already_processed.add('topHeight')
            outfile.write(' topHeight="%s"' % self.gds_format_double(self.topHeight, input_name='topHeight'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_VegetationFillGeometry', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('topHeight', node)
        if value is not None and 'topHeight' not in already_processed:
            already_processed.add('topHeight')
            try:
                self.topHeight = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (topHeight): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class _VegetationFillGeometry


class _LAIVegetation(GeneratedsSuper):
    """Leaf Area Index: total leaf area in the plot divided by the scene
    area. Leaf Area Index: total leaf area in the plot divided by
    the scene area."""
    subclass = None
    superclass = None
    def __init__(self, LAI=1.0):
        self.original_tagname_ = None
        self.LAI = _cast(float, LAI)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, _LAIVegetation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if _LAIVegetation.subclass:
            return _LAIVegetation.subclass(*args_, **kwargs_)
        else:
            return _LAIVegetation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LAI(self): return self.LAI
    def set_LAI(self, LAI): self.LAI = LAI
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_LAIVegetation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_LAIVegetation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_LAIVegetation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_LAIVegetation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_LAIVegetation'):
        if self.LAI is not None and 'LAI' not in already_processed:
            already_processed.add('LAI')
            outfile.write(' LAI="%s"' % self.gds_format_double(self.LAI, input_name='LAI'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_LAIVegetation', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('LAI', node)
        if value is not None and 'LAI' not in already_processed:
            already_processed.add('LAI')
            try:
                self.LAI = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (LAI): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class _LAIVegetation


class _UFVegetation(GeneratedsSuper):
    """Ul Ul"""
    subclass = None
    superclass = None
    def __init__(self, UF=1.0):
        self.original_tagname_ = None
        self.UF = _cast(float, UF)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, _UFVegetation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if _UFVegetation.subclass:
            return _UFVegetation.subclass(*args_, **kwargs_)
        else:
            return _UFVegetation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UF(self): return self.UF
    def set_UF(self, UF): self.UF = UF
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_UFVegetation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_UFVegetation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_UFVegetation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_UFVegetation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_UFVegetation'):
        if self.UF is not None and 'UF' not in already_processed:
            already_processed.add('UF')
            outfile.write(' UF="%s"' % self.gds_format_double(self.UF, input_name='UF'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_UFVegetation', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('UF', node)
        if value is not None and 'UF' not in already_processed:
            already_processed.add('UF')
            try:
                self.UF = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (UF): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class _UFVegetation


class _VegetationOpticalPropertyLink(GeneratedsSuper):
    """Optical properties for a DART vegetation phase function (name, type
    and index). Optical properties for a DART vegetation phase
    function (name, type and index). Index of the DART phase
    function of the ground of the plot. Index of the DART phase
    function of the ground of the plot. proportion of photons
    intercepted along an incident direction that are scattered
    within a solid angle along a given direction proportion of
    photons intercepted along an incident direction that are
    scattered within a solid angle along a given direction"""
    subclass = None
    superclass = None
    def __init__(self, indexFctPhase=0, ident='Turbid_Leaf_Deciduous_Phase_Function'):
        self.original_tagname_ = None
        self.indexFctPhase = _cast(int, indexFctPhase)
        self.ident = _cast(None, ident)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, _VegetationOpticalPropertyLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if _VegetationOpticalPropertyLink.subclass:
            return _VegetationOpticalPropertyLink.subclass(*args_, **kwargs_)
        else:
            return _VegetationOpticalPropertyLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexFctPhase(self): return self.indexFctPhase
    def set_indexFctPhase(self, indexFctPhase): self.indexFctPhase = indexFctPhase
    def get_ident(self): return self.ident
    def set_ident(self, ident): self.ident = ident
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_VegetationOpticalPropertyLink', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_VegetationOpticalPropertyLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_VegetationOpticalPropertyLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_VegetationOpticalPropertyLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_VegetationOpticalPropertyLink'):
        if self.indexFctPhase is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            outfile.write(' indexFctPhase="%s"' % self.gds_format_integer(self.indexFctPhase, input_name='indexFctPhase'))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            outfile.write(' ident=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ident), input_name='ident')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_VegetationOpticalPropertyLink', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('indexFctPhase', node)
        if value is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            try:
                self.indexFctPhase = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ident', node)
        if value is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            self.ident = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class _VegetationOpticalPropertyLink


class _PlotAirProperties(GeneratedsSuper):
    """PlotAirProperties PlotAirProperties Fill everything in the defined
    area below a given altitude. Fill everything in the defined area
    below a given altitude. Number of gas/particles in the air plot.
    Number of gas/particles in the air plot."""
    subclass = None
    superclass = None
    def __init__(self, verticalFillMode=0, nbParticule=1, AirGeometry=None, AirFillGeometry=None, AirOpticalProperties=None, GroundThermalPropertyLink=None):
        self.original_tagname_ = None
        self.verticalFillMode = _cast(int, verticalFillMode)
        self.nbParticule = _cast(int, nbParticule)
        self.AirGeometry = AirGeometry
        self.AirFillGeometry = AirFillGeometry
        if AirOpticalProperties is None:
            self.AirOpticalProperties = []
        else:
            self.AirOpticalProperties = AirOpticalProperties
        self.GroundThermalPropertyLink = GroundThermalPropertyLink
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, _PlotAirProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if _PlotAirProperties.subclass:
            return _PlotAirProperties.subclass(*args_, **kwargs_)
        else:
            return _PlotAirProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AirGeometry(self): return self.AirGeometry
    def set_AirGeometry(self, AirGeometry): self.AirGeometry = AirGeometry
    def get_AirFillGeometry(self): return self.AirFillGeometry
    def set_AirFillGeometry(self, AirFillGeometry): self.AirFillGeometry = AirFillGeometry
    def get_AirOpticalProperties(self): return self.AirOpticalProperties
    def set_AirOpticalProperties(self, AirOpticalProperties): self.AirOpticalProperties = AirOpticalProperties
    def add_AirOpticalProperties(self, value): self.AirOpticalProperties.append(value)
    def insert_AirOpticalProperties_at(self, index, value): self.AirOpticalProperties.insert(index, value)
    def replace_AirOpticalProperties_at(self, index, value): self.AirOpticalProperties[index] = value
    def get_GroundThermalPropertyLink(self): return self.GroundThermalPropertyLink
    def set_GroundThermalPropertyLink(self, GroundThermalPropertyLink): self.GroundThermalPropertyLink = GroundThermalPropertyLink
    def get_verticalFillMode(self): return self.verticalFillMode
    def set_verticalFillMode(self, verticalFillMode): self.verticalFillMode = verticalFillMode
    def get_nbParticule(self): return self.nbParticule
    def set_nbParticule(self, nbParticule): self.nbParticule = nbParticule
    def hasContent_(self):
        if (
            self.AirGeometry is not None or
            self.AirFillGeometry is not None or
            self.AirOpticalProperties or
            self.GroundThermalPropertyLink is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_PlotAirProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_PlotAirProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_PlotAirProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_PlotAirProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_PlotAirProperties'):
        if self.verticalFillMode is not None and 'verticalFillMode' not in already_processed:
            already_processed.add('verticalFillMode')
            outfile.write(' verticalFillMode="%s"' % self.gds_format_integer(self.verticalFillMode, input_name='verticalFillMode'))
        if self.nbParticule is not None and 'nbParticule' not in already_processed:
            already_processed.add('nbParticule')
            outfile.write(' nbParticule="%s"' % self.gds_format_integer(self.nbParticule, input_name='nbParticule'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_PlotAirProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AirGeometry is not None:
            self.AirGeometry.export(outfile, level, namespaceprefix_, name_='AirGeometry', pretty_print=pretty_print)
        if self.AirFillGeometry is not None:
            self.AirFillGeometry.export(outfile, level, namespaceprefix_, name_='AirFillGeometry', pretty_print=pretty_print)
        for AirOpticalProperties_ in self.AirOpticalProperties:
            AirOpticalProperties_.export(outfile, level, namespaceprefix_, name_='AirOpticalProperties', pretty_print=pretty_print)
        if self.GroundThermalPropertyLink is not None:
            self.GroundThermalPropertyLink.export(outfile, level, namespaceprefix_, name_='GroundThermalPropertyLink', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('verticalFillMode', node)
        if value is not None and 'verticalFillMode' not in already_processed:
            already_processed.add('verticalFillMode')
            try:
                self.verticalFillMode = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('nbParticule', node)
        if value is not None and 'nbParticule' not in already_processed:
            already_processed.add('nbParticule')
            try:
                self.nbParticule = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AirGeometry':
            obj_ = _AirGeometry.factory()
            obj_.build(child_)
            self.AirGeometry = obj_
            obj_.original_tagname_ = 'AirGeometry'
        elif nodeName_ == 'AirFillGeometry':
            obj_ = _AirFillGeometry.factory()
            obj_.build(child_)
            self.AirFillGeometry = obj_
            obj_.original_tagname_ = 'AirFillGeometry'
        elif nodeName_ == 'AirOpticalProperties':
            obj_ = _AirOpticalProperties.factory()
            obj_.build(child_)
            self.AirOpticalProperties.append(obj_)
            obj_.original_tagname_ = 'AirOpticalProperties'
        elif nodeName_ == 'GroundThermalPropertyLink':
            obj_ = _GroundThermalPropertyLink.factory()
            obj_.build(child_)
            self.GroundThermalPropertyLink = obj_
            obj_.original_tagname_ = 'GroundThermalPropertyLink'
# end class _PlotAirProperties


class _AirGeometry(GeneratedsSuper):
    """Thickness of the air layer Thickness of the air layer Altitude in
    meter of the base of the vegetation above the ground of the
    plot. Altitude in meter of the base of the vegetation above the
    ground of the plot. Standard deviation of the air layer height
    Standard deviation of the air layer height"""
    subclass = None
    superclass = None
    def __init__(self, height=1.0, baseheight=0, stDev=0.0):
        self.original_tagname_ = None
        self.height = _cast(float, height)
        self.baseheight = _cast(float, baseheight)
        self.stDev = _cast(float, stDev)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, _AirGeometry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if _AirGeometry.subclass:
            return _AirGeometry.subclass(*args_, **kwargs_)
        else:
            return _AirGeometry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_height(self): return self.height
    def set_height(self, height): self.height = height
    def get_baseheight(self): return self.baseheight
    def set_baseheight(self, baseheight): self.baseheight = baseheight
    def get_stDev(self): return self.stDev
    def set_stDev(self, stDev): self.stDev = stDev
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_AirGeometry', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_AirGeometry')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_AirGeometry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_AirGeometry', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_AirGeometry'):
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height="%s"' % self.gds_format_double(self.height, input_name='height'))
        if self.baseheight is not None and 'baseheight' not in already_processed:
            already_processed.add('baseheight')
            outfile.write(' baseheight="%s"' % self.gds_format_double(self.baseheight, input_name='baseheight'))
        if self.stDev is not None and 'stDev' not in already_processed:
            already_processed.add('stDev')
            outfile.write(' stDev="%s"' % self.gds_format_double(self.stDev, input_name='stDev'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_AirGeometry', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            try:
                self.height = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (height): %s' % exp)
        value = find_attr_value_('baseheight', node)
        if value is not None and 'baseheight' not in already_processed:
            already_processed.add('baseheight')
            try:
                self.baseheight = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (baseheight): %s' % exp)
        value = find_attr_value_('stDev', node)
        if value is not None and 'stDev' not in already_processed:
            already_processed.add('stDev')
            try:
                self.stDev = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (stDev): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class _AirGeometry


class _AirFillGeometry(GeneratedsSuper):
    """Altitude up to which the plot fill the scene, stating from the
    bottom of the scene Altitude up to which the plot fill the
    scene, stating from the bottom of the scene"""
    subclass = None
    superclass = None
    def __init__(self, topHeight=1.0):
        self.original_tagname_ = None
        self.topHeight = _cast(float, topHeight)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, _AirFillGeometry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if _AirFillGeometry.subclass:
            return _AirFillGeometry.subclass(*args_, **kwargs_)
        else:
            return _AirFillGeometry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_topHeight(self): return self.topHeight
    def set_topHeight(self, topHeight): self.topHeight = topHeight
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_AirFillGeometry', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_AirFillGeometry')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_AirFillGeometry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_AirFillGeometry', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_AirFillGeometry'):
        if self.topHeight is not None and 'topHeight' not in already_processed:
            already_processed.add('topHeight')
            outfile.write(' topHeight="%s"' % self.gds_format_double(self.topHeight, input_name='topHeight'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_AirFillGeometry', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('topHeight', node)
        if value is not None and 'topHeight' not in already_processed:
            already_processed.add('topHeight')
            try:
                self.topHeight = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (topHeight): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class _AirFillGeometry


class _AirOpticalProperties(GeneratedsSuper):
    """AirOpticalProperties AirOpticalProperties Particle Density (Number
    of particle per meter-cube) Particle Density (Number of particle
    per meter-cube)"""
    subclass = None
    superclass = None
    def __init__(self, extinctionCoefficient=5E-16, AirOpticalPropertyLink=None):
        self.original_tagname_ = None
        self.extinctionCoefficient = _cast(float, extinctionCoefficient)
        self.AirOpticalPropertyLink = AirOpticalPropertyLink
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, _AirOpticalProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if _AirOpticalProperties.subclass:
            return _AirOpticalProperties.subclass(*args_, **kwargs_)
        else:
            return _AirOpticalProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AirOpticalPropertyLink(self): return self.AirOpticalPropertyLink
    def set_AirOpticalPropertyLink(self, AirOpticalPropertyLink): self.AirOpticalPropertyLink = AirOpticalPropertyLink
    def get_extinctionCoefficient(self): return self.extinctionCoefficient
    def set_extinctionCoefficient(self, extinctionCoefficient): self.extinctionCoefficient = extinctionCoefficient
    def hasContent_(self):
        if (
            self.AirOpticalPropertyLink is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_AirOpticalProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_AirOpticalProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_AirOpticalProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_AirOpticalProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_AirOpticalProperties'):
        if self.extinctionCoefficient is not None and 'extinctionCoefficient' not in already_processed:
            already_processed.add('extinctionCoefficient')
            outfile.write(' extinctionCoefficient="%s"' % self.gds_format_double(self.extinctionCoefficient, input_name='extinctionCoefficient'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_AirOpticalProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AirOpticalPropertyLink is not None:
            self.AirOpticalPropertyLink.export(outfile, level, namespaceprefix_, name_='AirOpticalPropertyLink', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('extinctionCoefficient', node)
        if value is not None and 'extinctionCoefficient' not in already_processed:
            already_processed.add('extinctionCoefficient')
            try:
                self.extinctionCoefficient = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (extinctionCoefficient): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AirOpticalPropertyLink':
            obj_ = _AirOpticalPropertyLink.factory()
            obj_.build(child_)
            self.AirOpticalPropertyLink = obj_
            obj_.original_tagname_ = 'AirOpticalPropertyLink'
# end class _AirOpticalProperties


class _AirOpticalPropertyLink(GeneratedsSuper):
    """AirOpticalPropertyLink AirOpticalPropertyLink Index of the DART
    phase function of the ground of the plot. Index of the DART
    phase function of the ground of the plot. proportion of photons
    intercepted along an incident direction that are scattered
    within a solid angle along a given direction proportion of
    photons intercepted along an incident direction that are
    scattered within a solid angle along a given direction"""
    subclass = None
    superclass = None
    def __init__(self, indexFctPhase=0, ident='Molecule'):
        self.original_tagname_ = None
        self.indexFctPhase = _cast(int, indexFctPhase)
        self.ident = _cast(None, ident)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, _AirOpticalPropertyLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if _AirOpticalPropertyLink.subclass:
            return _AirOpticalPropertyLink.subclass(*args_, **kwargs_)
        else:
            return _AirOpticalPropertyLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexFctPhase(self): return self.indexFctPhase
    def set_indexFctPhase(self, indexFctPhase): self.indexFctPhase = indexFctPhase
    def get_ident(self): return self.ident
    def set_ident(self, ident): self.ident = ident
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_AirOpticalPropertyLink', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_AirOpticalPropertyLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_AirOpticalPropertyLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_AirOpticalPropertyLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_AirOpticalPropertyLink'):
        if self.indexFctPhase is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            outfile.write(' indexFctPhase="%s"' % self.gds_format_integer(self.indexFctPhase, input_name='indexFctPhase'))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            outfile.write(' ident=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ident), input_name='ident')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_AirOpticalPropertyLink', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('indexFctPhase', node)
        if value is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            try:
                self.indexFctPhase = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ident', node)
        if value is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            self.ident = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class _AirOpticalPropertyLink


class _PlotWaterProperties(GeneratedsSuper):
    """Water properties Water properties Number of components of the water
    volume Number of components of the water volume Water depth
    Water depth Water height level Water height level stDev stDev"""
    subclass = None
    superclass = None
    def __init__(self, nbComponents=1, waterDepth=10.0, waterHeight=0.0, stDev=0.0, WaterOpticalProperties=None, GroundThermalPropertyLink=None):
        self.original_tagname_ = None
        self.nbComponents = _cast(int, nbComponents)
        self.waterDepth = _cast(float, waterDepth)
        self.waterHeight = _cast(float, waterHeight)
        self.stDev = _cast(float, stDev)
        if WaterOpticalProperties is None:
            self.WaterOpticalProperties = []
        else:
            self.WaterOpticalProperties = WaterOpticalProperties
        self.GroundThermalPropertyLink = GroundThermalPropertyLink
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, _PlotWaterProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if _PlotWaterProperties.subclass:
            return _PlotWaterProperties.subclass(*args_, **kwargs_)
        else:
            return _PlotWaterProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WaterOpticalProperties(self): return self.WaterOpticalProperties
    def set_WaterOpticalProperties(self, WaterOpticalProperties): self.WaterOpticalProperties = WaterOpticalProperties
    def add_WaterOpticalProperties(self, value): self.WaterOpticalProperties.append(value)
    def insert_WaterOpticalProperties_at(self, index, value): self.WaterOpticalProperties.insert(index, value)
    def replace_WaterOpticalProperties_at(self, index, value): self.WaterOpticalProperties[index] = value
    def get_GroundThermalPropertyLink(self): return self.GroundThermalPropertyLink
    def set_GroundThermalPropertyLink(self, GroundThermalPropertyLink): self.GroundThermalPropertyLink = GroundThermalPropertyLink
    def get_nbComponents(self): return self.nbComponents
    def set_nbComponents(self, nbComponents): self.nbComponents = nbComponents
    def get_waterDepth(self): return self.waterDepth
    def set_waterDepth(self, waterDepth): self.waterDepth = waterDepth
    def get_waterHeight(self): return self.waterHeight
    def set_waterHeight(self, waterHeight): self.waterHeight = waterHeight
    def get_stDev(self): return self.stDev
    def set_stDev(self, stDev): self.stDev = stDev
    def hasContent_(self):
        if (
            self.WaterOpticalProperties or
            self.GroundThermalPropertyLink is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_PlotWaterProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_PlotWaterProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_PlotWaterProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_PlotWaterProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_PlotWaterProperties'):
        if self.nbComponents is not None and 'nbComponents' not in already_processed:
            already_processed.add('nbComponents')
            outfile.write(' nbComponents="%s"' % self.gds_format_integer(self.nbComponents, input_name='nbComponents'))
        if self.waterDepth is not None and 'waterDepth' not in already_processed:
            already_processed.add('waterDepth')
            outfile.write(' waterDepth="%s"' % self.gds_format_double(self.waterDepth, input_name='waterDepth'))
        if self.waterHeight is not None and 'waterHeight' not in already_processed:
            already_processed.add('waterHeight')
            outfile.write(' waterHeight="%s"' % self.gds_format_double(self.waterHeight, input_name='waterHeight'))
        if self.stDev is not None and 'stDev' not in already_processed:
            already_processed.add('stDev')
            outfile.write(' stDev="%s"' % self.gds_format_double(self.stDev, input_name='stDev'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_PlotWaterProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for WaterOpticalProperties_ in self.WaterOpticalProperties:
            WaterOpticalProperties_.export(outfile, level, namespaceprefix_, name_='WaterOpticalProperties', pretty_print=pretty_print)
        if self.GroundThermalPropertyLink is not None:
            self.GroundThermalPropertyLink.export(outfile, level, namespaceprefix_, name_='GroundThermalPropertyLink', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nbComponents', node)
        if value is not None and 'nbComponents' not in already_processed:
            already_processed.add('nbComponents')
            try:
                self.nbComponents = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('waterDepth', node)
        if value is not None and 'waterDepth' not in already_processed:
            already_processed.add('waterDepth')
            try:
                self.waterDepth = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (waterDepth): %s' % exp)
        value = find_attr_value_('waterHeight', node)
        if value is not None and 'waterHeight' not in already_processed:
            already_processed.add('waterHeight')
            try:
                self.waterHeight = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (waterHeight): %s' % exp)
        value = find_attr_value_('stDev', node)
        if value is not None and 'stDev' not in already_processed:
            already_processed.add('stDev')
            try:
                self.stDev = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (stDev): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WaterOpticalProperties':
            obj_ = _WaterOpticalProperties.factory()
            obj_.build(child_)
            self.WaterOpticalProperties.append(obj_)
            obj_.original_tagname_ = 'WaterOpticalProperties'
        elif nodeName_ == 'GroundThermalPropertyLink':
            obj_ = _GroundThermalPropertyLink.factory()
            obj_.build(child_)
            self.GroundThermalPropertyLink = obj_
            obj_.original_tagname_ = 'GroundThermalPropertyLink'
# end class _PlotWaterProperties


class _WaterOpticalProperties(GeneratedsSuper):
    """Component properties Component properties Extinction coefficient
    Extinction coefficient"""
    subclass = None
    superclass = None
    def __init__(self, extinctionCoefficient=0.5, AirOpticalPropertyLink=None):
        self.original_tagname_ = None
        self.extinctionCoefficient = _cast(float, extinctionCoefficient)
        self.AirOpticalPropertyLink = AirOpticalPropertyLink
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, _WaterOpticalProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if _WaterOpticalProperties.subclass:
            return _WaterOpticalProperties.subclass(*args_, **kwargs_)
        else:
            return _WaterOpticalProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AirOpticalPropertyLink(self): return self.AirOpticalPropertyLink
    def set_AirOpticalPropertyLink(self, AirOpticalPropertyLink): self.AirOpticalPropertyLink = AirOpticalPropertyLink
    def get_extinctionCoefficient(self): return self.extinctionCoefficient
    def set_extinctionCoefficient(self, extinctionCoefficient): self.extinctionCoefficient = extinctionCoefficient
    def hasContent_(self):
        if (
            self.AirOpticalPropertyLink is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_WaterOpticalProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_WaterOpticalProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_WaterOpticalProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_WaterOpticalProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_WaterOpticalProperties'):
        if self.extinctionCoefficient is not None and 'extinctionCoefficient' not in already_processed:
            already_processed.add('extinctionCoefficient')
            outfile.write(' extinctionCoefficient="%s"' % self.gds_format_double(self.extinctionCoefficient, input_name='extinctionCoefficient'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_WaterOpticalProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AirOpticalPropertyLink is not None:
            self.AirOpticalPropertyLink.export(outfile, level, namespaceprefix_, name_='AirOpticalPropertyLink', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('extinctionCoefficient', node)
        if value is not None and 'extinctionCoefficient' not in already_processed:
            already_processed.add('extinctionCoefficient')
            try:
                self.extinctionCoefficient = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (extinctionCoefficient): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AirOpticalPropertyLink':
            obj_ = _AirOpticalPropertyLink.factory()
            obj_.build(child_)
            self.AirOpticalPropertyLink = obj_
            obj_.original_tagname_ = 'AirOpticalPropertyLink'
# end class _WaterOpticalProperties


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = DartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = DartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = DartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = DartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from plots_gds import *\n\n')
        sys.stdout.write('import plots_gds as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "DartFile",
    "_AirFillGeometry",
    "_AirGeometry",
    "_AirOpticalProperties",
    "_AirOpticalPropertyLink",
    "_ExtraPlotsTextFileDefinition",
    "_GroundOpticalPropertyLink",
    "_GroundThermalPropertyLink",
    "_ImportationFichierRaster",
    "_LAIVegetation",
    "_MeshLeafDimensionParameters",
    "_MeshPlotRepresentation",
    "_NumberOfTriangleParameters",
    "_Plot",
    "_PlotAirProperties",
    "_PlotVegetationProperties",
    "_PlotWaterProperties",
    "_Plots",
    "_Point2D",
    "_Polygon2D",
    "_RasterCOSInformation",
    "_Rectangle2D",
    "_SelectSubZoneProperties",
    "_UFVegetation",
    "_VegetationFillGeometry",
    "_VegetationGeometry",
    "_VegetationOpticalPropertyLink",
    "_VegetationProperties",
    "_WaterOpticalProperties"
]
