#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Oct 31 15:06:24 2018 by generateDS.py version 2.29.25.
# Python 2.7.15rc1 (default, Apr 15 2018, 21:51:34)  [GCC 7.3.0]
#
# Command line options:
#   ('-m', '')
#   ('--always-export-default', '')
#   ('--export', 'write literal etree')
#   ('-p', 'create')
#   ('--post-attrib-setter', 'update_node(self,self.troot,"object_3d")')
#   ('--pre-ctor', 'self.troot=get_gs_troot("object_3d","{classname}")')
#   ('--post-ctor', 'update_node(self,self.troot,"object_3d")')
#   ('--imports', 'from pytools4dart.xsdschema.utils import get_gs_troot, update_node')
#   ('-o', '/home/claudia/tmp/object_3d.py')
#
# Command line arguments:
#   /home/claudia/DEV/pytools4dartMTD/pytools4dart/xsdschema/object_3d.xsd
#
# Command line:
#   /home/claudia/DEV/pytools4dartMTD/venv/bin/generateDS.py -m --always-export-default --export="write literal etree" -p "create" --post-attrib-setter="update_node(self,self.troot,"object_3d")" --pre-ctor="self.troot=get_gs_troot("object_3d","{classname}")" --post-ctor="update_node(self,self.troot,"object_3d")" --imports="from pytools4dart.xsdschema.utils import get_gs_troot, update_node" -o "/home/claudia/tmp/object_3d.py" /home/claudia/DEV/pytools4dartMTD/pytools4dart/xsdschema/object_3d.xsd
#
# Current working directory (os.getcwd()):
#   generateds
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_
from pytools4dart.xsdschema.utils import get_gs_troot, update_node


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#

def checkclass(value, cl):
    if isinstance(value, list):
        for v in value:
            if not isinstance(v, cl):
                raise ValueError("invalid class")
    else:
        if not isinstance(value, cl):
            raise ValueError("invalid class")

def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class createDartFile(GeneratedsSuper):
    """Version of the plots.xml file. Depends of the version on DART
    itself. Version of the plots.xml file. Depends of the version on
    DART itself."""
    subclass = None
    superclass = None
    def __init__(self, version='5.7.1', build_='0', object_3d=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","DartFile")
        self.attrib = ['version', 'build_']
        self.children = ['object_3d']
        self.parent = None
        self._version = _cast(None, version)
        self._build_ = _cast(None, build_)
        self._object_3d = object_3d
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, createDartFile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if createDartFile.subclass:
            return createDartFile.subclass(*args_, **kwargs_)
        else:
            return createDartFile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object_3d(self): return self._object_3d
    def set_object_3d(self, value):
        if value is not None:
            checkclass(value, create_object_3d)
            value.parent = self
        self._object_3d = value
    object_3d = property(get_object_3d, set_object_3d)
    def get_version(self): return self._version
    def set_version(self, value):
        self._version = value
        update_node(self,self.troot,"object_3d")
    version = property(get_version, set_version)
    def get_build(self): return self._build_
    def set_build(self, value):
        self._build_ = value
        update_node(self,self.troot,"object_3d")
    build_ = property(get_build, set_build)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.object_3d is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='DartFile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DartFile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DartFile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='DartFile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DartFile'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
        if self.build_ is not None and 'build_' not in already_processed:
            already_processed.add('build_')
            outfile.write(' build=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.build_), input_name='build')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='DartFile', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.object_3d is not None:
            self.object_3d.export(outfile, level, namespaceprefix_, name_='object_3d', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='DartFile', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.version is not None:
            element.set('version', self.gds_format_string(self.version))
        if self.build_ is not None:
            element.set('build', self.gds_format_string(self.build_))
        if self.object_3d is not None:
            object_3d_ = self.object_3d
            object_3d_.to_etree(element, name_='object_3d', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='DartFile'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.build_ is not None and 'build_' not in already_processed:
            already_processed.add('build_')
            showIndent(outfile, level)
            outfile.write('build_="%s",\n' % (self.build_,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.object_3d is not None:
            showIndent(outfile, level)
            outfile.write('object_3d=model_._object_3d(\n')
            self.object_3d.exportLiteral(outfile, level, name_='object_3d')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('build', node)
        if value is not None and 'build' not in already_processed:
            already_processed.add('build')
            self.build_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'object_3d':
            obj_ = create_object_3d.factory()
            obj_.build(child_)
            self.set_object_3d(obj_)
            obj_.original_tagname_ = 'object_3d'
# end class createDartFile


class create_object_3d(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Types=None, ObjectList=None, ObjectFields=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_object_3d")
        self.attrib = ['']
        self.children = ['Types', 'ObjectList', 'ObjectFields']
        self.parent = None
        self._Types = Types
        self._ObjectList = ObjectList
        self._ObjectFields = ObjectFields
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_object_3d)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_object_3d.subclass:
            return create_object_3d.subclass(*args_, **kwargs_)
        else:
            return create_object_3d(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Types(self): return self._Types
    def set_Types(self, value):
        if value is not None:
            checkclass(value, create_Types)
            value.parent = self
        self._Types = value
    Types = property(get_Types, set_Types)
    def get_ObjectList(self): return self._ObjectList
    def set_ObjectList(self, value):
        if value is not None:
            checkclass(value, create_ObjectList)
            value.parent = self
        self._ObjectList = value
    ObjectList = property(get_ObjectList, set_ObjectList)
    def get_ObjectFields(self): return self._ObjectFields
    def set_ObjectFields(self, value):
        if value is not None:
            checkclass(value, create_ObjectFields)
            value.parent = self
        self._ObjectFields = value
    ObjectFields = property(get_ObjectFields, set_ObjectFields)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Types is not None or
            self.ObjectList is not None or
            self.ObjectFields is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_object_3d', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_object_3d')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_object_3d')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_object_3d', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_object_3d'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_object_3d', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Types is not None:
            self.Types.export(outfile, level, namespaceprefix_, name_='Types', pretty_print=pretty_print)
        if self.ObjectList is not None:
            self.ObjectList.export(outfile, level, namespaceprefix_, name_='ObjectList', pretty_print=pretty_print)
        if self.ObjectFields is not None:
            self.ObjectFields.export(outfile, level, namespaceprefix_, name_='ObjectFields', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_object_3d', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.Types is not None:
            Types_ = self.Types
            Types_.to_etree(element, name_='Types', mapping_=mapping_)
        if self.ObjectList is not None:
            ObjectList_ = self.ObjectList
            ObjectList_.to_etree(element, name_='ObjectList', mapping_=mapping_)
        if self.ObjectFields is not None:
            ObjectFields_ = self.ObjectFields
            ObjectFields_.to_etree(element, name_='ObjectFields', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_object_3d'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Types is not None:
            showIndent(outfile, level)
            outfile.write('Types=model_._Types(\n')
            self.Types.exportLiteral(outfile, level, name_='Types')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ObjectList is not None:
            showIndent(outfile, level)
            outfile.write('ObjectList=model_._ObjectList(\n')
            self.ObjectList.exportLiteral(outfile, level, name_='ObjectList')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ObjectFields is not None:
            showIndent(outfile, level)
            outfile.write('ObjectFields=model_._ObjectFields(\n')
            self.ObjectFields.exportLiteral(outfile, level, name_='ObjectFields')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Types':
            obj_ = create_Types.factory()
            obj_.build(child_)
            self.set_Types(obj_)
            obj_.original_tagname_ = 'Types'
        elif nodeName_ == 'ObjectList':
            obj_ = create_ObjectList.factory()
            obj_.build(child_)
            self.set_ObjectList(obj_)
            obj_.original_tagname_ = 'ObjectList'
        elif nodeName_ == 'ObjectFields':
            obj_ = create_ObjectFields.factory()
            obj_.build(child_)
            self.set_ObjectFields(obj_)
            obj_.original_tagname_ = 'ObjectFields'
# end class create_object_3d


class create_Types(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DefaultTypes=None, CustomTypes=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_Types")
        self.attrib = ['']
        self.children = ['DefaultTypes', 'CustomTypes']
        self.parent = None
        self._DefaultTypes = DefaultTypes
        self._CustomTypes = CustomTypes
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Types)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Types.subclass:
            return create_Types.subclass(*args_, **kwargs_)
        else:
            return create_Types(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DefaultTypes(self): return self._DefaultTypes
    def set_DefaultTypes(self, value):
        if value is not None:
            checkclass(value, create_DefaultTypes)
            value.parent = self
        self._DefaultTypes = value
    DefaultTypes = property(get_DefaultTypes, set_DefaultTypes)
    def get_CustomTypes(self): return self._CustomTypes
    def set_CustomTypes(self, value):
        if value is not None:
            checkclass(value, create_CustomTypes)
            value.parent = self
        self._CustomTypes = value
    CustomTypes = property(get_CustomTypes, set_CustomTypes)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.DefaultTypes is not None or
            self.CustomTypes is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Types', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Types')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Types')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Types', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Types'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Types', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DefaultTypes is not None:
            self.DefaultTypes.export(outfile, level, namespaceprefix_, name_='DefaultTypes', pretty_print=pretty_print)
        if self.CustomTypes is not None:
            self.CustomTypes.export(outfile, level, namespaceprefix_, name_='CustomTypes', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Types', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.DefaultTypes is not None:
            DefaultTypes_ = self.DefaultTypes
            DefaultTypes_.to_etree(element, name_='DefaultTypes', mapping_=mapping_)
        if self.CustomTypes is not None:
            CustomTypes_ = self.CustomTypes
            CustomTypes_.to_etree(element, name_='CustomTypes', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Types'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DefaultTypes is not None:
            showIndent(outfile, level)
            outfile.write('DefaultTypes=model_._DefaultTypes(\n')
            self.DefaultTypes.exportLiteral(outfile, level, name_='DefaultTypes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CustomTypes is not None:
            showIndent(outfile, level)
            outfile.write('CustomTypes=model_._CustomTypes(\n')
            self.CustomTypes.exportLiteral(outfile, level, name_='CustomTypes')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DefaultTypes':
            obj_ = create_DefaultTypes.factory()
            obj_.build(child_)
            self.set_DefaultTypes(obj_)
            obj_.original_tagname_ = 'DefaultTypes'
        elif nodeName_ == 'CustomTypes':
            obj_ = create_CustomTypes.factory()
            obj_.build(child_)
            self.set_CustomTypes(obj_)
            obj_.original_tagname_ = 'CustomTypes'
# end class create_Types


class create_DefaultTypes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DefaultType=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_DefaultTypes")
        self.attrib = ['']
        self.children = ['DefaultType']
        self.parent = None
        if DefaultType is None:
            self._DefaultType = []
        else:
            self._DefaultType = DefaultType
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_DefaultTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_DefaultTypes.subclass:
            return create_DefaultTypes.subclass(*args_, **kwargs_)
        else:
            return create_DefaultTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DefaultType(self): return self._DefaultType
    def set_DefaultType(self, value):
        if value is not None:
            checkclass(value, create_DefaultType)
            for v in value:
                v.parent = self
        self._DefaultType = value
    def add_DefaultType(self, value):
        if (value is not None) and (len(self._DefaultType) == 2):
            raise ValueError('Maximum length already reached.')
        value.parent = self
        self._DefaultType.append(value)
    def insert_DefaultType_at(self, index, value):
        if (value is not None) and (len(self._DefaultType) == 2):
            raise ValueError('Maximum length already reached.')
        value.parent = self
        self.DefaultType.insert(index, value)
    def replace_DefaultType_at(self, index, value):
        value.parent = self
        self.DefaultType[index] = value
    DefaultType = property(get_DefaultType, set_DefaultType)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.DefaultType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_DefaultTypes', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_DefaultTypes')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_DefaultTypes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_DefaultTypes', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_DefaultTypes'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_DefaultTypes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DefaultType_ in self.DefaultType:
            DefaultType_.export(outfile, level, namespaceprefix_, name_='DefaultType', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_DefaultTypes', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for DefaultType_ in self.DefaultType:
            DefaultType_.to_etree(element, name_='DefaultType', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_DefaultTypes'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DefaultType=[\n')
        level += 1
        for DefaultType_ in self.DefaultType:
            showIndent(outfile, level)
            outfile.write('model_._DefaultType(\n')
            DefaultType_.exportLiteral(outfile, level, name_='_DefaultType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.DefaultType = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DefaultType':
            obj_ = create_DefaultType.factory()
            obj_.build(child_)
            self.add_DefaultType(obj_)
            obj_.original_tagname_ = 'DefaultType'
# end class create_DefaultTypes


class create_DefaultType(GeneratedsSuper):
    """Color/name Idenfier. Do no modify! Color/name Idenfier. Do no
    modify! Define the element color. Affect the interface and color
    results of Dart. Define the element color. Affect the interface
    and color results of Dart. Name. (optional) Name. (optional)"""
    subclass = None
    superclass = None
    def __init__(self, indexOT=101, typeColor='125 0 125', name='Default_Object'):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_DefaultType")
        self.attrib = ['indexOT', 'typeColor', 'name']
        self.children = []
        self.parent = None
        self._indexOT = _cast(int, indexOT)
        self._typeColor = _cast(None, typeColor)
        self._name = _cast(None, name)
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_DefaultType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_DefaultType.subclass:
            return create_DefaultType.subclass(*args_, **kwargs_)
        else:
            return create_DefaultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexOT(self): return self._indexOT
    def set_indexOT(self, value):
        self._indexOT = value
        update_node(self,self.troot,"object_3d")
    indexOT = property(get_indexOT, set_indexOT)
    def get_typeColor(self): return self._typeColor
    def set_typeColor(self, value):
        self._typeColor = value
        update_node(self,self.troot,"object_3d")
    typeColor = property(get_typeColor, set_typeColor)
    def get_name(self): return self._name
    def set_name(self, value):
        self._name = value
        update_node(self,self.troot,"object_3d")
    name = property(get_name, set_name)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_DefaultType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_DefaultType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_DefaultType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_DefaultType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_DefaultType'):
        if self.indexOT is not None and 'indexOT' not in already_processed:
            already_processed.add('indexOT')
            outfile.write(' indexOT="%s"' % self.gds_format_integer(self.indexOT, input_name='indexOT'))
        if self.typeColor is not None and 'typeColor' not in already_processed:
            already_processed.add('typeColor')
            outfile.write(' typeColor=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.typeColor), input_name='typeColor')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_DefaultType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_DefaultType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.indexOT is not None:
            element.set('indexOT', self.gds_format_integer(self.indexOT))
        if self.typeColor is not None:
            element.set('typeColor', self.gds_format_string(self.typeColor))
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_DefaultType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.indexOT is not None and 'indexOT' not in already_processed:
            already_processed.add('indexOT')
            showIndent(outfile, level)
            outfile.write('indexOT=%d,\n' % (self.indexOT,))
        if self.typeColor is not None and 'typeColor' not in already_processed:
            already_processed.add('typeColor')
            showIndent(outfile, level)
            outfile.write('typeColor="%s",\n' % (self.typeColor,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('indexOT', node)
        if value is not None and 'indexOT' not in already_processed:
            already_processed.add('indexOT')
            try:
                self.indexOT = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('typeColor', node)
        if value is not None and 'typeColor' not in already_processed:
            already_processed.add('typeColor')
            self.typeColor = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_DefaultType


class create_CustomTypes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_CustomTypes")
        self.attrib = ['']
        self.children = ['Type']
        self.parent = None
        if Type is None:
            self._Type = []
        else:
            self._Type = Type
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_CustomTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_CustomTypes.subclass:
            return create_CustomTypes.subclass(*args_, **kwargs_)
        else:
            return create_CustomTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self._Type
    def set_Type(self, value):
        if value is not None:
            checkclass(value, create_Type)
            for v in value:
                v.parent = self
        self._Type = value
    def add_Type(self, value):
        value.parent = self
        self._Type.append(value)
    def insert_Type_at(self, index, value):
        value.parent = self
        self.Type.insert(index, value)
    def replace_Type_at(self, index, value):
        value.parent = self
        self.Type[index] = value
    Type = property(get_Type, set_Type)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Type
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_CustomTypes', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_CustomTypes')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_CustomTypes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_CustomTypes', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_CustomTypes'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_CustomTypes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Type_ in self.Type:
            Type_.export(outfile, level, namespaceprefix_, name_='Type', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_CustomTypes', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for Type_ in self.Type:
            Type_.to_etree(element, name_='Type', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_CustomTypes'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Type=[\n')
        level += 1
        for Type_ in self.Type:
            showIndent(outfile, level)
            outfile.write('model_._Type(\n')
            Type_.exportLiteral(outfile, level, name_='_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.Type = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            obj_ = create_Type.factory()
            obj_.build(child_)
            self.add_Type(obj_)
            obj_.original_tagname_ = 'Type'
# end class create_CustomTypes


class create_Type(GeneratedsSuper):
    """Color/name Idenfier. Do no modify! Color/name Idenfier. Do no
    modify! Define the element color. Affect the interface and color
    results of Dart. Define the element color. Affect the interface
    and color results of Dart. Name. (optional) Name. (optional)"""
    subclass = None
    superclass = None
    def __init__(self, indexOT=-1, typeColor='125 0 125', name='Type'):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_Type")
        self.attrib = ['indexOT', 'typeColor', 'name']
        self.children = []
        self.parent = None
        self._indexOT = _cast(int, indexOT)
        self._typeColor = _cast(None, typeColor)
        self._name = _cast(None, name)
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Type.subclass:
            return create_Type.subclass(*args_, **kwargs_)
        else:
            return create_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexOT(self): return self._indexOT
    def set_indexOT(self, value):
        self._indexOT = value
        update_node(self,self.troot,"object_3d")
    indexOT = property(get_indexOT, set_indexOT)
    def get_typeColor(self): return self._typeColor
    def set_typeColor(self, value):
        self._typeColor = value
        update_node(self,self.troot,"object_3d")
    typeColor = property(get_typeColor, set_typeColor)
    def get_name(self): return self._name
    def set_name(self, value):
        self._name = value
        update_node(self,self.troot,"object_3d")
    name = property(get_name, set_name)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Type'):
        if self.indexOT is not None and 'indexOT' not in already_processed:
            already_processed.add('indexOT')
            outfile.write(' indexOT="%s"' % self.gds_format_integer(self.indexOT, input_name='indexOT'))
        if self.typeColor is not None and 'typeColor' not in already_processed:
            already_processed.add('typeColor')
            outfile.write(' typeColor=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.typeColor), input_name='typeColor')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Type', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_Type', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.indexOT is not None:
            element.set('indexOT', self.gds_format_integer(self.indexOT))
        if self.typeColor is not None:
            element.set('typeColor', self.gds_format_string(self.typeColor))
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.indexOT is not None and 'indexOT' not in already_processed:
            already_processed.add('indexOT')
            showIndent(outfile, level)
            outfile.write('indexOT=%d,\n' % (self.indexOT,))
        if self.typeColor is not None and 'typeColor' not in already_processed:
            already_processed.add('typeColor')
            showIndent(outfile, level)
            outfile.write('typeColor="%s",\n' % (self.typeColor,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('indexOT', node)
        if value is not None and 'indexOT' not in already_processed:
            already_processed.add('indexOT')
            try:
                self.indexOT = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('typeColor', node)
        if value is not None and 'typeColor' not in already_processed:
            already_processed.add('typeColor')
            self.typeColor = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_Type


class create_ObjectList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Object=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_ObjectList")
        self.attrib = ['']
        self.children = ['Object']
        self.parent = None
        if Object is None:
            self._Object = []
        else:
            self._Object = Object
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ObjectList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ObjectList.subclass:
            return create_ObjectList.subclass(*args_, **kwargs_)
        else:
            return create_ObjectList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Object(self): return self._Object
    def set_Object(self, value):
        if value is not None:
            checkclass(value, create_Object)
            for v in value:
                v.parent = self
        self._Object = value
    def add_Object(self, value):
        value.parent = self
        self._Object.append(value)
    def insert_Object_at(self, index, value):
        value.parent = self
        self.Object.insert(index, value)
    def replace_Object_at(self, index, value):
        value.parent = self
        self.Object[index] = value
    Object = property(get_Object, set_Object)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Object
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ObjectList', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ObjectList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ObjectList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ObjectList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ObjectList'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ObjectList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Object_ in self.Object:
            Object_.export(outfile, level, namespaceprefix_, name_='Object', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_ObjectList', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for Object_ in self.Object:
            Object_.to_etree(element, name_='Object', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ObjectList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Object=[\n')
        level += 1
        for Object_ in self.Object:
            showIndent(outfile, level)
            outfile.write('model_._Object(\n')
            Object_.exportLiteral(outfile, level, name_='_Object')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.Object = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Object':
            obj_ = create_Object.factory()
            obj_.build(child_)
            self.add_Object(obj_)
            obj_.original_tagname_ = 'Object'
# end class create_ObjectList


class create_Object(GeneratedsSuper):
    """Defines how this object behaves toward the DEM, including being an
    element of the DEM. Defines how this object behaves toward the
    DEM, including being an element of the DEM. Object's name.
    (optional) Object's name. (optional) Objects's positions are
    taken from the position file.\nDesactivate this option if you
    experience some slowdown. Objects's positions are taken from the
    position file.\nDesactivate this option if you experience some
    slowdown. DO NOT MODIFY! DO NOT MODIFY! Object's source file.
    Contain the object's 3D structure (in either VRML97, X3D, OBJECT
    etc...). Object's source file. Contain the object's 3D structure
    (in either VRML97, X3D, OBJECT etc...). Color of this object in
    the Editor's 2D view. Does not affect the results from the
    software. Color of this object in the Editor's 2D view. Does not
    affect the results from the software. If you select this option,
    this object 3d are not use in all DART modules, \n it's useful
    if you want conserve object 3d properties backup without delete
    this for testsobject_3d.ObjectList.Object.num If you select this
    option, this object 3d are not use in all DART modules, \n it's
    useful if you want conserve object 3d properties backup without
    delete this for testsobject_3d.ObjectList.Object.num If part of
    the object goes beyond the border of the scene, this part is
    copied on the other side of the scene. If part of the object
    goes beyond the border of the scene, this part is copied on the
    other side of the scene."""
    subclass = None
    superclass = None
    def __init__(self, objectDEMMode=0, name='Object', isDisplayed=1, hasGroups=0, num=0, file_src='exemple.wrl', objectColor='125 0 125', hidden=0, repeatedOnBorder=1, GeometricProperties=None, ObjectOpticalProperties=None, ObjectTypeProperties=None, Groups=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_Object")
        self.attrib = ['objectDEMMode', 'name', 'isDisplayed', 'hasGroups', 'num', 'file_src', 'objectColor', 'hidden', 'repeatedOnBorder']
        self.children = ['GeometricProperties', 'ObjectOpticalProperties', 'ObjectTypeProperties', 'Groups']
        self.parent = None
        self._objectDEMMode = _cast(int, objectDEMMode)
        self._name = _cast(None, name)
        self._isDisplayed = _cast(int, isDisplayed)
        self._hasGroups = _cast(int, hasGroups)
        self._num = _cast(int, num)
        self._file_src = _cast(None, file_src)
        self._objectColor = _cast(None, objectColor)
        self._hidden = _cast(int, hidden)
        self._repeatedOnBorder = _cast(int, repeatedOnBorder)
        self._GeometricProperties = GeometricProperties
        self._ObjectOpticalProperties = ObjectOpticalProperties
        self._ObjectTypeProperties = ObjectTypeProperties
        self._Groups = Groups
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Object)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Object.subclass:
            return create_Object.subclass(*args_, **kwargs_)
        else:
            return create_Object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GeometricProperties(self): return self._GeometricProperties
    def set_GeometricProperties(self, value):
        if value is not None:
            checkclass(value, create_GeometricProperties)
            value.parent = self
        self._GeometricProperties = value
    GeometricProperties = property(get_GeometricProperties, set_GeometricProperties)
    def get_ObjectOpticalProperties(self): return self._ObjectOpticalProperties
    def set_ObjectOpticalProperties(self, value):
        if value is not None:
            checkclass(value, create_ObjectOpticalProperties)
            value.parent = self
        self._ObjectOpticalProperties = value
    ObjectOpticalProperties = property(get_ObjectOpticalProperties, set_ObjectOpticalProperties)
    def get_ObjectTypeProperties(self): return self._ObjectTypeProperties
    def set_ObjectTypeProperties(self, value):
        if value is not None:
            checkclass(value, create_ObjectTypeProperties)
            value.parent = self
        self._ObjectTypeProperties = value
    ObjectTypeProperties = property(get_ObjectTypeProperties, set_ObjectTypeProperties)
    def get_Groups(self): return self._Groups
    def set_Groups(self, value):
        if value is not None:
            checkclass(value, create_Groups)
            value.parent = self
        self._Groups = value
    Groups = property(get_Groups, set_Groups)
    def get_objectDEMMode(self): return self._objectDEMMode
    def set_objectDEMMode(self, value):
        self._objectDEMMode = value
        update_node(self,self.troot,"object_3d")
    objectDEMMode = property(get_objectDEMMode, set_objectDEMMode)
    def get_name(self): return self._name
    def set_name(self, value):
        self._name = value
        update_node(self,self.troot,"object_3d")
    name = property(get_name, set_name)
    def get_isDisplayed(self): return self._isDisplayed
    def set_isDisplayed(self, value):
        self._isDisplayed = value
        update_node(self,self.troot,"object_3d")
    isDisplayed = property(get_isDisplayed, set_isDisplayed)
    def get_hasGroups(self): return self._hasGroups
    def set_hasGroups(self, value):
        self._hasGroups = value
        update_node(self,self.troot,"object_3d")
    hasGroups = property(get_hasGroups, set_hasGroups)
    def get_num(self): return self._num
    def set_num(self, value):
        self._num = value
        update_node(self,self.troot,"object_3d")
    num = property(get_num, set_num)
    def get_file_src(self): return self._file_src
    def set_file_src(self, value):
        self._file_src = value
        update_node(self,self.troot,"object_3d")
    file_src = property(get_file_src, set_file_src)
    def get_objectColor(self): return self._objectColor
    def set_objectColor(self, value):
        self._objectColor = value
        update_node(self,self.troot,"object_3d")
    objectColor = property(get_objectColor, set_objectColor)
    def get_hidden(self): return self._hidden
    def set_hidden(self, value):
        self._hidden = value
        update_node(self,self.troot,"object_3d")
    hidden = property(get_hidden, set_hidden)
    def get_repeatedOnBorder(self): return self._repeatedOnBorder
    def set_repeatedOnBorder(self, value):
        self._repeatedOnBorder = value
        update_node(self,self.troot,"object_3d")
    repeatedOnBorder = property(get_repeatedOnBorder, set_repeatedOnBorder)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.GeometricProperties is not None or
            self.ObjectOpticalProperties is not None or
            self.ObjectTypeProperties is not None or
            self.Groups is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Object', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Object')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Object')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Object', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Object'):
        if self.objectDEMMode is not None and 'objectDEMMode' not in already_processed:
            already_processed.add('objectDEMMode')
            outfile.write(' objectDEMMode="%s"' % self.gds_format_integer(self.objectDEMMode, input_name='objectDEMMode'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.isDisplayed is not None and 'isDisplayed' not in already_processed:
            already_processed.add('isDisplayed')
            outfile.write(' isDisplayed="%s"' % self.gds_format_integer(self.isDisplayed, input_name='isDisplayed'))
        if self.hasGroups is not None and 'hasGroups' not in already_processed:
            already_processed.add('hasGroups')
            outfile.write(' hasGroups="%s"' % self.gds_format_integer(self.hasGroups, input_name='hasGroups'))
        if self.num is not None and 'num' not in already_processed:
            already_processed.add('num')
            outfile.write(' num="%s"' % self.gds_format_integer(self.num, input_name='num'))
        if self.file_src is not None and 'file_src' not in already_processed:
            already_processed.add('file_src')
            outfile.write(' file_src=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.file_src), input_name='file_src')), ))
        if self.objectColor is not None and 'objectColor' not in already_processed:
            already_processed.add('objectColor')
            outfile.write(' objectColor=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.objectColor), input_name='objectColor')), ))
        if self.hidden is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            outfile.write(' hidden="%s"' % self.gds_format_integer(self.hidden, input_name='hidden'))
        if self.repeatedOnBorder is not None and 'repeatedOnBorder' not in already_processed:
            already_processed.add('repeatedOnBorder')
            outfile.write(' repeatedOnBorder="%s"' % self.gds_format_integer(self.repeatedOnBorder, input_name='repeatedOnBorder'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Object', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GeometricProperties is not None:
            self.GeometricProperties.export(outfile, level, namespaceprefix_, name_='GeometricProperties', pretty_print=pretty_print)
        if self.ObjectOpticalProperties is not None:
            self.ObjectOpticalProperties.export(outfile, level, namespaceprefix_, name_='ObjectOpticalProperties', pretty_print=pretty_print)
        if self.ObjectTypeProperties is not None:
            self.ObjectTypeProperties.export(outfile, level, namespaceprefix_, name_='ObjectTypeProperties', pretty_print=pretty_print)
        if self.Groups is not None:
            self.Groups.export(outfile, level, namespaceprefix_, name_='Groups', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Object', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.objectDEMMode is not None:
            element.set('objectDEMMode', self.gds_format_integer(self.objectDEMMode))
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.isDisplayed is not None:
            element.set('isDisplayed', self.gds_format_integer(self.isDisplayed))
        if self.hasGroups is not None:
            element.set('hasGroups', self.gds_format_integer(self.hasGroups))
        if self.num is not None:
            element.set('num', self.gds_format_integer(self.num))
        if self.file_src is not None:
            element.set('file_src', self.gds_format_string(self.file_src))
        if self.objectColor is not None:
            element.set('objectColor', self.gds_format_string(self.objectColor))
        if self.hidden is not None:
            element.set('hidden', self.gds_format_integer(self.hidden))
        if self.repeatedOnBorder is not None:
            element.set('repeatedOnBorder', self.gds_format_integer(self.repeatedOnBorder))
        if self.GeometricProperties is not None:
            GeometricProperties_ = self.GeometricProperties
            GeometricProperties_.to_etree(element, name_='GeometricProperties', mapping_=mapping_)
        if self.ObjectOpticalProperties is not None:
            ObjectOpticalProperties_ = self.ObjectOpticalProperties
            ObjectOpticalProperties_.to_etree(element, name_='ObjectOpticalProperties', mapping_=mapping_)
        if self.ObjectTypeProperties is not None:
            ObjectTypeProperties_ = self.ObjectTypeProperties
            ObjectTypeProperties_.to_etree(element, name_='ObjectTypeProperties', mapping_=mapping_)
        if self.Groups is not None:
            Groups_ = self.Groups
            Groups_.to_etree(element, name_='Groups', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Object'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.objectDEMMode is not None and 'objectDEMMode' not in already_processed:
            already_processed.add('objectDEMMode')
            showIndent(outfile, level)
            outfile.write('objectDEMMode=%d,\n' % (self.objectDEMMode,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.isDisplayed is not None and 'isDisplayed' not in already_processed:
            already_processed.add('isDisplayed')
            showIndent(outfile, level)
            outfile.write('isDisplayed=%d,\n' % (self.isDisplayed,))
        if self.hasGroups is not None and 'hasGroups' not in already_processed:
            already_processed.add('hasGroups')
            showIndent(outfile, level)
            outfile.write('hasGroups=%d,\n' % (self.hasGroups,))
        if self.num is not None and 'num' not in already_processed:
            already_processed.add('num')
            showIndent(outfile, level)
            outfile.write('num=%d,\n' % (self.num,))
        if self.file_src is not None and 'file_src' not in already_processed:
            already_processed.add('file_src')
            showIndent(outfile, level)
            outfile.write('file_src="%s",\n' % (self.file_src,))
        if self.objectColor is not None and 'objectColor' not in already_processed:
            already_processed.add('objectColor')
            showIndent(outfile, level)
            outfile.write('objectColor="%s",\n' % (self.objectColor,))
        if self.hidden is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            showIndent(outfile, level)
            outfile.write('hidden=%d,\n' % (self.hidden,))
        if self.repeatedOnBorder is not None and 'repeatedOnBorder' not in already_processed:
            already_processed.add('repeatedOnBorder')
            showIndent(outfile, level)
            outfile.write('repeatedOnBorder=%d,\n' % (self.repeatedOnBorder,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.GeometricProperties is not None:
            showIndent(outfile, level)
            outfile.write('GeometricProperties=model_._GeometricProperties(\n')
            self.GeometricProperties.exportLiteral(outfile, level, name_='GeometricProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ObjectOpticalProperties is not None:
            showIndent(outfile, level)
            outfile.write('ObjectOpticalProperties=model_._ObjectOpticalProperties(\n')
            self.ObjectOpticalProperties.exportLiteral(outfile, level, name_='ObjectOpticalProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ObjectTypeProperties is not None:
            showIndent(outfile, level)
            outfile.write('ObjectTypeProperties=model_._ObjectTypeProperties(\n')
            self.ObjectTypeProperties.exportLiteral(outfile, level, name_='ObjectTypeProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Groups is not None:
            showIndent(outfile, level)
            outfile.write('Groups=model_._Groups(\n')
            self.Groups.exportLiteral(outfile, level, name_='Groups')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('objectDEMMode', node)
        if value is not None and 'objectDEMMode' not in already_processed:
            already_processed.add('objectDEMMode')
            try:
                self.objectDEMMode = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('isDisplayed', node)
        if value is not None and 'isDisplayed' not in already_processed:
            already_processed.add('isDisplayed')
            try:
                self.isDisplayed = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('hasGroups', node)
        if value is not None and 'hasGroups' not in already_processed:
            already_processed.add('hasGroups')
            try:
                self.hasGroups = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('num', node)
        if value is not None and 'num' not in already_processed:
            already_processed.add('num')
            try:
                self.num = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('file_src', node)
        if value is not None and 'file_src' not in already_processed:
            already_processed.add('file_src')
            self.file_src = value
        value = find_attr_value_('objectColor', node)
        if value is not None and 'objectColor' not in already_processed:
            already_processed.add('objectColor')
            self.objectColor = value
        value = find_attr_value_('hidden', node)
        if value is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            try:
                self.hidden = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('repeatedOnBorder', node)
        if value is not None and 'repeatedOnBorder' not in already_processed:
            already_processed.add('repeatedOnBorder')
            try:
                self.repeatedOnBorder = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GeometricProperties':
            obj_ = create_GeometricProperties.factory()
            obj_.build(child_)
            self.set_GeometricProperties(obj_)
            obj_.original_tagname_ = 'GeometricProperties'
        elif nodeName_ == 'ObjectOpticalProperties':
            obj_ = create_ObjectOpticalProperties.factory()
            obj_.build(child_)
            self.set_ObjectOpticalProperties(obj_)
            obj_.original_tagname_ = 'ObjectOpticalProperties'
        elif nodeName_ == 'ObjectTypeProperties':
            obj_ = create_ObjectTypeProperties.factory()
            obj_.build(child_)
            self.set_ObjectTypeProperties(obj_)
            obj_.original_tagname_ = 'ObjectTypeProperties'
        elif nodeName_ == 'Groups':
            obj_ = create_Groups.factory()
            obj_.build(child_)
            self.set_Groups(obj_)
            obj_.original_tagname_ = 'Groups'
# end class create_Object


class create_GeometricProperties(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PositionProperties=None, Dimension3D=None, ScaleProperties=None, RotationProperties=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_GeometricProperties")
        self.attrib = ['']
        self.children = ['PositionProperties', 'Dimension3D', 'ScaleProperties', 'RotationProperties']
        self.parent = None
        self._PositionProperties = PositionProperties
        self._Dimension3D = Dimension3D
        self._ScaleProperties = ScaleProperties
        self._RotationProperties = RotationProperties
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_GeometricProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_GeometricProperties.subclass:
            return create_GeometricProperties.subclass(*args_, **kwargs_)
        else:
            return create_GeometricProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PositionProperties(self): return self._PositionProperties
    def set_PositionProperties(self, value):
        if value is not None:
            checkclass(value, create_PositionProperties)
            value.parent = self
        self._PositionProperties = value
    PositionProperties = property(get_PositionProperties, set_PositionProperties)
    def get_Dimension3D(self): return self._Dimension3D
    def set_Dimension3D(self, value):
        if value is not None:
            checkclass(value, create_Dimension3D)
            value.parent = self
        self._Dimension3D = value
    Dimension3D = property(get_Dimension3D, set_Dimension3D)
    def get_ScaleProperties(self): return self._ScaleProperties
    def set_ScaleProperties(self, value):
        if value is not None:
            checkclass(value, create_ScaleProperties)
            value.parent = self
        self._ScaleProperties = value
    ScaleProperties = property(get_ScaleProperties, set_ScaleProperties)
    def get_RotationProperties(self): return self._RotationProperties
    def set_RotationProperties(self, value):
        if value is not None:
            checkclass(value, create_RotationProperties)
            value.parent = self
        self._RotationProperties = value
    RotationProperties = property(get_RotationProperties, set_RotationProperties)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.PositionProperties is not None or
            self.Dimension3D is not None or
            self.ScaleProperties is not None or
            self.RotationProperties is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_GeometricProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_GeometricProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_GeometricProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_GeometricProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_GeometricProperties'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_GeometricProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PositionProperties is not None:
            self.PositionProperties.export(outfile, level, namespaceprefix_, name_='PositionProperties', pretty_print=pretty_print)
        if self.Dimension3D is not None:
            self.Dimension3D.export(outfile, level, namespaceprefix_, name_='Dimension3D', pretty_print=pretty_print)
        if self.ScaleProperties is not None:
            self.ScaleProperties.export(outfile, level, namespaceprefix_, name_='ScaleProperties', pretty_print=pretty_print)
        if self.RotationProperties is not None:
            self.RotationProperties.export(outfile, level, namespaceprefix_, name_='RotationProperties', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_GeometricProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.PositionProperties is not None:
            PositionProperties_ = self.PositionProperties
            PositionProperties_.to_etree(element, name_='PositionProperties', mapping_=mapping_)
        if self.Dimension3D is not None:
            Dimension3D_ = self.Dimension3D
            Dimension3D_.to_etree(element, name_='Dimension3D', mapping_=mapping_)
        if self.ScaleProperties is not None:
            ScaleProperties_ = self.ScaleProperties
            ScaleProperties_.to_etree(element, name_='ScaleProperties', mapping_=mapping_)
        if self.RotationProperties is not None:
            RotationProperties_ = self.RotationProperties
            RotationProperties_.to_etree(element, name_='RotationProperties', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_GeometricProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PositionProperties is not None:
            showIndent(outfile, level)
            outfile.write('PositionProperties=model_._PositionProperties(\n')
            self.PositionProperties.exportLiteral(outfile, level, name_='PositionProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Dimension3D is not None:
            showIndent(outfile, level)
            outfile.write('Dimension3D=model_._Dimension3D(\n')
            self.Dimension3D.exportLiteral(outfile, level, name_='Dimension3D')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ScaleProperties is not None:
            showIndent(outfile, level)
            outfile.write('ScaleProperties=model_._ScaleProperties(\n')
            self.ScaleProperties.exportLiteral(outfile, level, name_='ScaleProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RotationProperties is not None:
            showIndent(outfile, level)
            outfile.write('RotationProperties=model_._RotationProperties(\n')
            self.RotationProperties.exportLiteral(outfile, level, name_='RotationProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PositionProperties':
            obj_ = create_PositionProperties.factory()
            obj_.build(child_)
            self.set_PositionProperties(obj_)
            obj_.original_tagname_ = 'PositionProperties'
        elif nodeName_ == 'Dimension3D':
            obj_ = create_Dimension3D.factory()
            obj_.build(child_)
            self.set_Dimension3D(obj_)
            obj_.original_tagname_ = 'Dimension3D'
        elif nodeName_ == 'ScaleProperties':
            obj_ = create_ScaleProperties.factory()
            obj_.build(child_)
            self.set_ScaleProperties(obj_)
            obj_.original_tagname_ = 'ScaleProperties'
        elif nodeName_ == 'RotationProperties':
            obj_ = create_RotationProperties.factory()
            obj_.build(child_)
            self.set_RotationProperties(obj_)
            obj_.original_tagname_ = 'RotationProperties'
# end class create_GeometricProperties


class create_PositionProperties(GeneratedsSuper):
    """Object's elevation. Object's elevation. Object's position on the X
    axis. Object's position on the X axis. Object's position on the
    Y axis. Object's position on the Y axis."""
    subclass = None
    superclass = None
    def __init__(self, zpos=0.00, xpos=2.00, ypos=2.00):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_PositionProperties")
        self.attrib = ['zpos', 'xpos', 'ypos']
        self.children = []
        self.parent = None
        self._zpos = _cast(float, zpos)
        self._xpos = _cast(float, xpos)
        self._ypos = _cast(float, ypos)
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_PositionProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_PositionProperties.subclass:
            return create_PositionProperties.subclass(*args_, **kwargs_)
        else:
            return create_PositionProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_zpos(self): return self._zpos
    def set_zpos(self, value):
        self._zpos = value
        update_node(self,self.troot,"object_3d")
    zpos = property(get_zpos, set_zpos)
    def get_xpos(self): return self._xpos
    def set_xpos(self, value):
        self._xpos = value
        update_node(self,self.troot,"object_3d")
    xpos = property(get_xpos, set_xpos)
    def get_ypos(self): return self._ypos
    def set_ypos(self, value):
        self._ypos = value
        update_node(self,self.troot,"object_3d")
    ypos = property(get_ypos, set_ypos)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_PositionProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_PositionProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_PositionProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_PositionProperties', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_PositionProperties'):
        if self.zpos is not None and 'zpos' not in already_processed:
            already_processed.add('zpos')
            outfile.write(' zpos="%s"' % self.gds_format_double(self.zpos, input_name='zpos'))
        if self.xpos is not None and 'xpos' not in already_processed:
            already_processed.add('xpos')
            outfile.write(' xpos="%s"' % self.gds_format_double(self.xpos, input_name='xpos'))
        if self.ypos is not None and 'ypos' not in already_processed:
            already_processed.add('ypos')
            outfile.write(' ypos="%s"' % self.gds_format_double(self.ypos, input_name='ypos'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_PositionProperties', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_PositionProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.zpos is not None:
            element.set('zpos', self.gds_format_double(self.zpos))
        if self.xpos is not None:
            element.set('xpos', self.gds_format_double(self.xpos))
        if self.ypos is not None:
            element.set('ypos', self.gds_format_double(self.ypos))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_PositionProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.zpos is not None and 'zpos' not in already_processed:
            already_processed.add('zpos')
            showIndent(outfile, level)
            outfile.write('zpos=%e,\n' % (self.zpos,))
        if self.xpos is not None and 'xpos' not in already_processed:
            already_processed.add('xpos')
            showIndent(outfile, level)
            outfile.write('xpos=%e,\n' % (self.xpos,))
        if self.ypos is not None and 'ypos' not in already_processed:
            already_processed.add('ypos')
            showIndent(outfile, level)
            outfile.write('ypos=%e,\n' % (self.ypos,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('zpos', node)
        if value is not None and 'zpos' not in already_processed:
            already_processed.add('zpos')
            try:
                self.zpos = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (zpos): %s' % exp)
        value = find_attr_value_('xpos', node)
        if value is not None and 'xpos' not in already_processed:
            already_processed.add('xpos')
            try:
                self.xpos = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (xpos): %s' % exp)
        value = find_attr_value_('ypos', node)
        if value is not None and 'ypos' not in already_processed:
            already_processed.add('ypos')
            try:
                self.ypos = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (ypos): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_PositionProperties


class create_Dimension3D(GeneratedsSuper):
    """Object's original dimension on the Z axis, before scaling.\n To
    multiply by the scaling factor on the Z axis to get the final
    dimension in Maket. Object's original dimension on the Z axis,
    before scaling.\n To multiply by the scaling factor on the Z
    axis to get the final dimension in Maket. Object's original
    dimension on the Y axis, before scaling.\n To multiply by the
    scaling factor on the Y axis to get the final dimension in
    Maket. Object's original dimension on the Y axis, before
    scaling.\n To multiply by the scaling factor on the Y axis to
    get the final dimension in Maket. Object's original dimension on
    the X axis, before scaling.\n To multiply by the scaling factor
    on the X axis to get the final dimension in Maket. Object's
    original dimension on the X axis, before scaling.\n To multiply
    by the scaling factor on the X axis to get the final dimension
    in Maket."""
    subclass = None
    superclass = None
    def __init__(self, zdim=1., ydim=1., xdim=1.):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_Dimension3D")
        self.attrib = ['zdim', 'ydim', 'xdim']
        self.children = []
        self.parent = None
        self._zdim = _cast(float, zdim)
        self._ydim = _cast(float, ydim)
        self._xdim = _cast(float, xdim)
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Dimension3D)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Dimension3D.subclass:
            return create_Dimension3D.subclass(*args_, **kwargs_)
        else:
            return create_Dimension3D(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_zdim(self): return self._zdim
    def set_zdim(self, value):
        self._zdim = value
        update_node(self,self.troot,"object_3d")
    zdim = property(get_zdim, set_zdim)
    def get_ydim(self): return self._ydim
    def set_ydim(self, value):
        self._ydim = value
        update_node(self,self.troot,"object_3d")
    ydim = property(get_ydim, set_ydim)
    def get_xdim(self): return self._xdim
    def set_xdim(self, value):
        self._xdim = value
        update_node(self,self.troot,"object_3d")
    xdim = property(get_xdim, set_xdim)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Dimension3D', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Dimension3D')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Dimension3D')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Dimension3D', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Dimension3D'):
        if self.zdim is not None and 'zdim' not in already_processed:
            already_processed.add('zdim')
            outfile.write(' zdim="%s"' % self.gds_format_double(self.zdim, input_name='zdim'))
        if self.ydim is not None and 'ydim' not in already_processed:
            already_processed.add('ydim')
            outfile.write(' ydim="%s"' % self.gds_format_double(self.ydim, input_name='ydim'))
        if self.xdim is not None and 'xdim' not in already_processed:
            already_processed.add('xdim')
            outfile.write(' xdim="%s"' % self.gds_format_double(self.xdim, input_name='xdim'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Dimension3D', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_Dimension3D', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.zdim is not None:
            element.set('zdim', self.gds_format_double(self.zdim))
        if self.ydim is not None:
            element.set('ydim', self.gds_format_double(self.ydim))
        if self.xdim is not None:
            element.set('xdim', self.gds_format_double(self.xdim))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Dimension3D'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.zdim is not None and 'zdim' not in already_processed:
            already_processed.add('zdim')
            showIndent(outfile, level)
            outfile.write('zdim=%e,\n' % (self.zdim,))
        if self.ydim is not None and 'ydim' not in already_processed:
            already_processed.add('ydim')
            showIndent(outfile, level)
            outfile.write('ydim=%e,\n' % (self.ydim,))
        if self.xdim is not None and 'xdim' not in already_processed:
            already_processed.add('xdim')
            showIndent(outfile, level)
            outfile.write('xdim=%e,\n' % (self.xdim,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('zdim', node)
        if value is not None and 'zdim' not in already_processed:
            already_processed.add('zdim')
            try:
                self.zdim = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (zdim): %s' % exp)
        value = find_attr_value_('ydim', node)
        if value is not None and 'ydim' not in already_processed:
            already_processed.add('ydim')
            try:
                self.ydim = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (ydim): %s' % exp)
        value = find_attr_value_('xdim', node)
        if value is not None and 'xdim' not in already_processed:
            already_processed.add('xdim')
            try:
                self.xdim = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (xdim): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_Dimension3D


class create_ScaleProperties(GeneratedsSuper):
    """Standard deviation used to compute the Gauss probability of the
    object's scale on the Y axis. Standard deviation used to compute
    the Gauss probability of the object's scale on the Y axis.
    Object's scaling factor on the Z axis.\nDefault value: 1
    Object's scaling factor on the Z axis.\nDefault value: 1
    Object's scaling factor on the X axis.\nDefault value: 1
    Object's scaling factor on the X axis.\nDefault value: 1
    Object's scaling factor on the Y axis.\nDefault value: 1
    Object's scaling factor on the Y axis.\nDefault value: 1
    Standard deviation used to compute the Gauss probability of the
    object's scale on the X axis. Standard deviation used to compute
    the Gauss probability of the object's scale on the X axis.
    Standard deviation used to compute the Gauss probability of the
    object's scale on the Z axis. Standard deviation used to compute
    the Gauss probability of the object's scale on the Z axis."""
    subclass = None
    superclass = None
    def __init__(self, yScaleDeviation=0.0, zscale=1.00, xscale=1.00, yscale=1.00, xScaleDeviation=0.0, zScaleDeviation=0.0):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_ScaleProperties")
        self.attrib = ['yScaleDeviation', 'zscale', 'xscale', 'yscale', 'xScaleDeviation', 'zScaleDeviation']
        self.children = []
        self.parent = None
        self._yScaleDeviation = _cast(float, yScaleDeviation)
        self._zscale = _cast(float, zscale)
        self._xscale = _cast(float, xscale)
        self._yscale = _cast(float, yscale)
        self._xScaleDeviation = _cast(float, xScaleDeviation)
        self._zScaleDeviation = _cast(float, zScaleDeviation)
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ScaleProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ScaleProperties.subclass:
            return create_ScaleProperties.subclass(*args_, **kwargs_)
        else:
            return create_ScaleProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_yScaleDeviation(self): return self._yScaleDeviation
    def set_yScaleDeviation(self, value):
        self._yScaleDeviation = value
        update_node(self,self.troot,"object_3d")
    yScaleDeviation = property(get_yScaleDeviation, set_yScaleDeviation)
    def get_zscale(self): return self._zscale
    def set_zscale(self, value):
        self._zscale = value
        update_node(self,self.troot,"object_3d")
    zscale = property(get_zscale, set_zscale)
    def get_xscale(self): return self._xscale
    def set_xscale(self, value):
        self._xscale = value
        update_node(self,self.troot,"object_3d")
    xscale = property(get_xscale, set_xscale)
    def get_yscale(self): return self._yscale
    def set_yscale(self, value):
        self._yscale = value
        update_node(self,self.troot,"object_3d")
    yscale = property(get_yscale, set_yscale)
    def get_xScaleDeviation(self): return self._xScaleDeviation
    def set_xScaleDeviation(self, value):
        self._xScaleDeviation = value
        update_node(self,self.troot,"object_3d")
    xScaleDeviation = property(get_xScaleDeviation, set_xScaleDeviation)
    def get_zScaleDeviation(self): return self._zScaleDeviation
    def set_zScaleDeviation(self, value):
        self._zScaleDeviation = value
        update_node(self,self.troot,"object_3d")
    zScaleDeviation = property(get_zScaleDeviation, set_zScaleDeviation)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ScaleProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ScaleProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ScaleProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ScaleProperties', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ScaleProperties'):
        if self.yScaleDeviation is not None and 'yScaleDeviation' not in already_processed:
            already_processed.add('yScaleDeviation')
            outfile.write(' yScaleDeviation="%s"' % self.gds_format_double(self.yScaleDeviation, input_name='yScaleDeviation'))
        if self.zscale is not None and 'zscale' not in already_processed:
            already_processed.add('zscale')
            outfile.write(' zscale="%s"' % self.gds_format_double(self.zscale, input_name='zscale'))
        if self.xscale is not None and 'xscale' not in already_processed:
            already_processed.add('xscale')
            outfile.write(' xscale="%s"' % self.gds_format_double(self.xscale, input_name='xscale'))
        if self.yscale is not None and 'yscale' not in already_processed:
            already_processed.add('yscale')
            outfile.write(' yscale="%s"' % self.gds_format_double(self.yscale, input_name='yscale'))
        if self.xScaleDeviation is not None and 'xScaleDeviation' not in already_processed:
            already_processed.add('xScaleDeviation')
            outfile.write(' xScaleDeviation="%s"' % self.gds_format_double(self.xScaleDeviation, input_name='xScaleDeviation'))
        if self.zScaleDeviation is not None and 'zScaleDeviation' not in already_processed:
            already_processed.add('zScaleDeviation')
            outfile.write(' zScaleDeviation="%s"' % self.gds_format_double(self.zScaleDeviation, input_name='zScaleDeviation'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ScaleProperties', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_ScaleProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.yScaleDeviation is not None:
            element.set('yScaleDeviation', self.gds_format_double(self.yScaleDeviation))
        if self.zscale is not None:
            element.set('zscale', self.gds_format_double(self.zscale))
        if self.xscale is not None:
            element.set('xscale', self.gds_format_double(self.xscale))
        if self.yscale is not None:
            element.set('yscale', self.gds_format_double(self.yscale))
        if self.xScaleDeviation is not None:
            element.set('xScaleDeviation', self.gds_format_double(self.xScaleDeviation))
        if self.zScaleDeviation is not None:
            element.set('zScaleDeviation', self.gds_format_double(self.zScaleDeviation))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ScaleProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.yScaleDeviation is not None and 'yScaleDeviation' not in already_processed:
            already_processed.add('yScaleDeviation')
            showIndent(outfile, level)
            outfile.write('yScaleDeviation=%e,\n' % (self.yScaleDeviation,))
        if self.zscale is not None and 'zscale' not in already_processed:
            already_processed.add('zscale')
            showIndent(outfile, level)
            outfile.write('zscale=%e,\n' % (self.zscale,))
        if self.xscale is not None and 'xscale' not in already_processed:
            already_processed.add('xscale')
            showIndent(outfile, level)
            outfile.write('xscale=%e,\n' % (self.xscale,))
        if self.yscale is not None and 'yscale' not in already_processed:
            already_processed.add('yscale')
            showIndent(outfile, level)
            outfile.write('yscale=%e,\n' % (self.yscale,))
        if self.xScaleDeviation is not None and 'xScaleDeviation' not in already_processed:
            already_processed.add('xScaleDeviation')
            showIndent(outfile, level)
            outfile.write('xScaleDeviation=%e,\n' % (self.xScaleDeviation,))
        if self.zScaleDeviation is not None and 'zScaleDeviation' not in already_processed:
            already_processed.add('zScaleDeviation')
            showIndent(outfile, level)
            outfile.write('zScaleDeviation=%e,\n' % (self.zScaleDeviation,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('yScaleDeviation', node)
        if value is not None and 'yScaleDeviation' not in already_processed:
            already_processed.add('yScaleDeviation')
            try:
                self.yScaleDeviation = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (yScaleDeviation): %s' % exp)
        value = find_attr_value_('zscale', node)
        if value is not None and 'zscale' not in already_processed:
            already_processed.add('zscale')
            try:
                self.zscale = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (zscale): %s' % exp)
        value = find_attr_value_('xscale', node)
        if value is not None and 'xscale' not in already_processed:
            already_processed.add('xscale')
            try:
                self.xscale = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (xscale): %s' % exp)
        value = find_attr_value_('yscale', node)
        if value is not None and 'yscale' not in already_processed:
            already_processed.add('yscale')
            try:
                self.yscale = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (yscale): %s' % exp)
        value = find_attr_value_('xScaleDeviation', node)
        if value is not None and 'xScaleDeviation' not in already_processed:
            already_processed.add('xScaleDeviation')
            try:
                self.xScaleDeviation = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (xScaleDeviation): %s' % exp)
        value = find_attr_value_('zScaleDeviation', node)
        if value is not None and 'zScaleDeviation' not in already_processed:
            already_processed.add('zScaleDeviation')
            try:
                self.zScaleDeviation = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (zScaleDeviation): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_ScaleProperties


class create_RotationProperties(GeneratedsSuper):
    """Standard deviation used to compute the Gauss probability of the
    object's intrinsic rotation. Standard deviation used to compute
    the Gauss probability of the object's intrinsic rotation.
    Defines the rotation angle of the object on itself.\nAccepted
    angles are in the range [0,360[. Default value: 0.\nYou can use
    the 3D View in the Object/Model node to gauge the effect of the
    field. Defines the rotation angle of the object on
    itself.\nAccepted angles are in the range [0,360[. Default
    value: 0.\nYou can use the 3D View in the Object/Model node to
    gauge the effect of the field. Defines the orientation angle of
    the inclination of the object.\nThe orientation is applied
    counter-clockwise (South(0\u00B0)-East(90\u00B0)-North(180\u00B0
    )-West(270\u00B0))\nAccepted angles are in the range [0,360[.
    Default value: 0.\nYou can use the 3D View in the Object node to
    gauge the effect of the field. Defines the orientation angle of
    the inclination of the object.\nThe orientation is applied
    counter-clockwise (South(0\u00B0)-East(90\u00B0)-North(180\u00B0
    )-West(270\u00B0))\nAccepted angles are in the range [0,360[.
    Default value: 0.\nYou can use the 3D View in the Object node to
    gauge the effect of the field. Defines the inclination angle of
    the object.\nThe tip of the object will point toward the
    South.\nAccepted angles are in the range [0,180]. Default value:
    0.\nYou can use the 3D View in the Object node to gauge the
    effect of the field. Defines the inclination angle of the
    object.\nThe tip of the object will point toward the
    South.\nAccepted angles are in the range [0,180]. Default value:
    0.\nYou can use the 3D View in the Object node to gauge the
    effect of the field. Standard deviation used to compute the
    Gauss probability of the object's precession. Standard deviation
    used to compute the Gauss probability of the object's
    precession. Standard deviation used to compute the Gauss
    probability of the object's nutation. Standard deviation used to
    compute the Gauss probability of the object's nutation."""
    subclass = None
    superclass = None
    def __init__(self, xRotDeviation=0.0, xrot=0.00, zrot=0.00, yrot=0.00, zRotDeviation=0.0, yRotDeviation=0.0):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_RotationProperties")
        self.attrib = ['xRotDeviation', 'xrot', 'zrot', 'yrot', 'zRotDeviation', 'yRotDeviation']
        self.children = []
        self.parent = None
        self._xRotDeviation = _cast(float, xRotDeviation)
        self._xrot = _cast(float, xrot)
        self._zrot = _cast(float, zrot)
        self._yrot = _cast(float, yrot)
        self._zRotDeviation = _cast(float, zRotDeviation)
        self._yRotDeviation = _cast(float, yRotDeviation)
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_RotationProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_RotationProperties.subclass:
            return create_RotationProperties.subclass(*args_, **kwargs_)
        else:
            return create_RotationProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xRotDeviation(self): return self._xRotDeviation
    def set_xRotDeviation(self, value):
        self._xRotDeviation = value
        update_node(self,self.troot,"object_3d")
    xRotDeviation = property(get_xRotDeviation, set_xRotDeviation)
    def get_xrot(self): return self._xrot
    def set_xrot(self, value):
        self._xrot = value
        update_node(self,self.troot,"object_3d")
    xrot = property(get_xrot, set_xrot)
    def get_zrot(self): return self._zrot
    def set_zrot(self, value):
        self._zrot = value
        update_node(self,self.troot,"object_3d")
    zrot = property(get_zrot, set_zrot)
    def get_yrot(self): return self._yrot
    def set_yrot(self, value):
        self._yrot = value
        update_node(self,self.troot,"object_3d")
    yrot = property(get_yrot, set_yrot)
    def get_zRotDeviation(self): return self._zRotDeviation
    def set_zRotDeviation(self, value):
        self._zRotDeviation = value
        update_node(self,self.troot,"object_3d")
    zRotDeviation = property(get_zRotDeviation, set_zRotDeviation)
    def get_yRotDeviation(self): return self._yRotDeviation
    def set_yRotDeviation(self, value):
        self._yRotDeviation = value
        update_node(self,self.troot,"object_3d")
    yRotDeviation = property(get_yRotDeviation, set_yRotDeviation)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_RotationProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_RotationProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_RotationProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_RotationProperties', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_RotationProperties'):
        if self.xRotDeviation is not None and 'xRotDeviation' not in already_processed:
            already_processed.add('xRotDeviation')
            outfile.write(' xRotDeviation="%s"' % self.gds_format_double(self.xRotDeviation, input_name='xRotDeviation'))
        if self.xrot is not None and 'xrot' not in already_processed:
            already_processed.add('xrot')
            outfile.write(' xrot="%s"' % self.gds_format_double(self.xrot, input_name='xrot'))
        if self.zrot is not None and 'zrot' not in already_processed:
            already_processed.add('zrot')
            outfile.write(' zrot="%s"' % self.gds_format_double(self.zrot, input_name='zrot'))
        if self.yrot is not None and 'yrot' not in already_processed:
            already_processed.add('yrot')
            outfile.write(' yrot="%s"' % self.gds_format_double(self.yrot, input_name='yrot'))
        if self.zRotDeviation is not None and 'zRotDeviation' not in already_processed:
            already_processed.add('zRotDeviation')
            outfile.write(' zRotDeviation="%s"' % self.gds_format_double(self.zRotDeviation, input_name='zRotDeviation'))
        if self.yRotDeviation is not None and 'yRotDeviation' not in already_processed:
            already_processed.add('yRotDeviation')
            outfile.write(' yRotDeviation="%s"' % self.gds_format_double(self.yRotDeviation, input_name='yRotDeviation'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_RotationProperties', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_RotationProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.xRotDeviation is not None:
            element.set('xRotDeviation', self.gds_format_double(self.xRotDeviation))
        if self.xrot is not None:
            element.set('xrot', self.gds_format_double(self.xrot))
        if self.zrot is not None:
            element.set('zrot', self.gds_format_double(self.zrot))
        if self.yrot is not None:
            element.set('yrot', self.gds_format_double(self.yrot))
        if self.zRotDeviation is not None:
            element.set('zRotDeviation', self.gds_format_double(self.zRotDeviation))
        if self.yRotDeviation is not None:
            element.set('yRotDeviation', self.gds_format_double(self.yRotDeviation))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_RotationProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.xRotDeviation is not None and 'xRotDeviation' not in already_processed:
            already_processed.add('xRotDeviation')
            showIndent(outfile, level)
            outfile.write('xRotDeviation=%e,\n' % (self.xRotDeviation,))
        if self.xrot is not None and 'xrot' not in already_processed:
            already_processed.add('xrot')
            showIndent(outfile, level)
            outfile.write('xrot=%e,\n' % (self.xrot,))
        if self.zrot is not None and 'zrot' not in already_processed:
            already_processed.add('zrot')
            showIndent(outfile, level)
            outfile.write('zrot=%e,\n' % (self.zrot,))
        if self.yrot is not None and 'yrot' not in already_processed:
            already_processed.add('yrot')
            showIndent(outfile, level)
            outfile.write('yrot=%e,\n' % (self.yrot,))
        if self.zRotDeviation is not None and 'zRotDeviation' not in already_processed:
            already_processed.add('zRotDeviation')
            showIndent(outfile, level)
            outfile.write('zRotDeviation=%e,\n' % (self.zRotDeviation,))
        if self.yRotDeviation is not None and 'yRotDeviation' not in already_processed:
            already_processed.add('yRotDeviation')
            showIndent(outfile, level)
            outfile.write('yRotDeviation=%e,\n' % (self.yRotDeviation,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xRotDeviation', node)
        if value is not None and 'xRotDeviation' not in already_processed:
            already_processed.add('xRotDeviation')
            try:
                self.xRotDeviation = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (xRotDeviation): %s' % exp)
        value = find_attr_value_('xrot', node)
        if value is not None and 'xrot' not in already_processed:
            already_processed.add('xrot')
            try:
                self.xrot = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (xrot): %s' % exp)
        value = find_attr_value_('zrot', node)
        if value is not None and 'zrot' not in already_processed:
            already_processed.add('zrot')
            try:
                self.zrot = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (zrot): %s' % exp)
        value = find_attr_value_('yrot', node)
        if value is not None and 'yrot' not in already_processed:
            already_processed.add('yrot')
            try:
                self.yrot = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (yrot): %s' % exp)
        value = find_attr_value_('zRotDeviation', node)
        if value is not None and 'zRotDeviation' not in already_processed:
            already_processed.add('zRotDeviation')
            try:
                self.zRotDeviation = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (zRotDeviation): %s' % exp)
        value = find_attr_value_('yRotDeviation', node)
        if value is not None and 'yRotDeviation' not in already_processed:
            already_processed.add('yRotDeviation')
            try:
                self.yRotDeviation = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (yRotDeviation): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_RotationProperties


class create_ObjectOpticalProperties(GeneratedsSuper):
    """Use for computing LAI Use for computing LAI Force groups converted
    into turbid volumes to a single combined LAI.\nIf no group is
    converted, the value is ignored. Force groups converted into
    turbid volumes to a single combined LAI.\nIf no group is
    converted, the value is ignored. Apply this optical property to
    all this object's elements.\nReplace any previously defined
    property. Apply this optical property to all this object's
    elements.\nReplace any previously defined property. Check this
    option if you want to apply optical properties on each face of
    the triangles that make up the 3D object.\nIf this option is
    unchecked, a ray incident on the triangle face opposite to the
    triangle normal is stopped/lost, whatever the DART mode (R or
    T). Check this option if you want to apply optical properties on
    each face of the triangles that make up the 3D object.\nIf this
    option is unchecked, a ray incident on the triangle face
    opposite to the triangle normal is stopped/lost, whatever the
    DART mode (R or T)."""
    subclass = None
    superclass = None
    def __init__(self, isLAICalc=0, isSingleGlobalLai=0, sameOPObject=0, doubleFace=0, PropertiesForObject3DTurbidWithLAD=None, PropertiesForObject3DTurbid=None, OpticalPropertyLink=None, ThermalPropertyLink=None, BackFaceOpticalProperty=None, BackFaceThermalProperty=None, SingleGlobalLAIPropertyNode=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_ObjectOpticalProperties")
        self.attrib = ['isLAICalc', 'isSingleGlobalLai', 'sameOPObject', 'doubleFace']
        self.children = ['PropertiesForObject3DTurbidWithLAD', 'PropertiesForObject3DTurbid', 'OpticalPropertyLink', 'ThermalPropertyLink', 'BackFaceOpticalProperty', 'BackFaceThermalProperty', 'SingleGlobalLAIPropertyNode']
        self.parent = None
        self._isLAICalc = _cast(int, isLAICalc)
        self._isSingleGlobalLai = _cast(int, isSingleGlobalLai)
        self._sameOPObject = _cast(int, sameOPObject)
        self._doubleFace = _cast(int, doubleFace)
        self._PropertiesForObject3DTurbidWithLAD = PropertiesForObject3DTurbidWithLAD
        self._PropertiesForObject3DTurbid = PropertiesForObject3DTurbid
        self._OpticalPropertyLink = OpticalPropertyLink
        self._ThermalPropertyLink = ThermalPropertyLink
        self._BackFaceOpticalProperty = BackFaceOpticalProperty
        self._BackFaceThermalProperty = BackFaceThermalProperty
        self._SingleGlobalLAIPropertyNode = SingleGlobalLAIPropertyNode
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ObjectOpticalProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ObjectOpticalProperties.subclass:
            return create_ObjectOpticalProperties.subclass(*args_, **kwargs_)
        else:
            return create_ObjectOpticalProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PropertiesForObject3DTurbidWithLAD(self): return self._PropertiesForObject3DTurbidWithLAD
    def set_PropertiesForObject3DTurbidWithLAD(self, value):
        if value is not None:
            checkclass(value, create_PropertiesForObject3DTurbidWithLAD)
            value.parent = self
        self._PropertiesForObject3DTurbidWithLAD = value
    PropertiesForObject3DTurbidWithLAD = property(get_PropertiesForObject3DTurbidWithLAD, set_PropertiesForObject3DTurbidWithLAD)
    def get_PropertiesForObject3DTurbid(self): return self._PropertiesForObject3DTurbid
    def set_PropertiesForObject3DTurbid(self, value):
        if value is not None:
            checkclass(value, create_PropertiesForObject3DTurbid)
            value.parent = self
        self._PropertiesForObject3DTurbid = value
    PropertiesForObject3DTurbid = property(get_PropertiesForObject3DTurbid, set_PropertiesForObject3DTurbid)
    def get_OpticalPropertyLink(self): return self._OpticalPropertyLink
    def set_OpticalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_OpticalPropertyLink)
            value.parent = self
        self._OpticalPropertyLink = value
    OpticalPropertyLink = property(get_OpticalPropertyLink, set_OpticalPropertyLink)
    def get_ThermalPropertyLink(self): return self._ThermalPropertyLink
    def set_ThermalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_ThermalPropertyLink)
            value.parent = self
        self._ThermalPropertyLink = value
    ThermalPropertyLink = property(get_ThermalPropertyLink, set_ThermalPropertyLink)
    def get_BackFaceOpticalProperty(self): return self._BackFaceOpticalProperty
    def set_BackFaceOpticalProperty(self, value):
        if value is not None:
            checkclass(value, create_BackFaceOpticalProperty)
            value.parent = self
        self._BackFaceOpticalProperty = value
    BackFaceOpticalProperty = property(get_BackFaceOpticalProperty, set_BackFaceOpticalProperty)
    def get_BackFaceThermalProperty(self): return self._BackFaceThermalProperty
    def set_BackFaceThermalProperty(self, value):
        if value is not None:
            checkclass(value, create_BackFaceThermalProperty)
            value.parent = self
        self._BackFaceThermalProperty = value
    BackFaceThermalProperty = property(get_BackFaceThermalProperty, set_BackFaceThermalProperty)
    def get_SingleGlobalLAIPropertyNode(self): return self._SingleGlobalLAIPropertyNode
    def set_SingleGlobalLAIPropertyNode(self, value):
        if value is not None:
            checkclass(value, create_SingleGlobalLAIPropertyNode)
            value.parent = self
        self._SingleGlobalLAIPropertyNode = value
    SingleGlobalLAIPropertyNode = property(get_SingleGlobalLAIPropertyNode, set_SingleGlobalLAIPropertyNode)
    def get_isLAICalc(self): return self._isLAICalc
    def set_isLAICalc(self, value):
        self._isLAICalc = value
        update_node(self,self.troot,"object_3d")
    isLAICalc = property(get_isLAICalc, set_isLAICalc)
    def get_isSingleGlobalLai(self): return self._isSingleGlobalLai
    def set_isSingleGlobalLai(self, value):
        self._isSingleGlobalLai = value
        update_node(self,self.troot,"object_3d")
    isSingleGlobalLai = property(get_isSingleGlobalLai, set_isSingleGlobalLai)
    def get_sameOPObject(self): return self._sameOPObject
    def set_sameOPObject(self, value):
        self._sameOPObject = value
        update_node(self,self.troot,"object_3d")
    sameOPObject = property(get_sameOPObject, set_sameOPObject)
    def get_doubleFace(self): return self._doubleFace
    def set_doubleFace(self, value):
        self._doubleFace = value
        update_node(self,self.troot,"object_3d")
    doubleFace = property(get_doubleFace, set_doubleFace)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.PropertiesForObject3DTurbidWithLAD is not None or
            self.PropertiesForObject3DTurbid is not None or
            self.OpticalPropertyLink is not None or
            self.ThermalPropertyLink is not None or
            self.BackFaceOpticalProperty is not None or
            self.BackFaceThermalProperty is not None or
            self.SingleGlobalLAIPropertyNode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ObjectOpticalProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ObjectOpticalProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ObjectOpticalProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ObjectOpticalProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ObjectOpticalProperties'):
        if self.isLAICalc is not None and 'isLAICalc' not in already_processed:
            already_processed.add('isLAICalc')
            outfile.write(' isLAICalc="%s"' % self.gds_format_integer(self.isLAICalc, input_name='isLAICalc'))
        if self.isSingleGlobalLai is not None and 'isSingleGlobalLai' not in already_processed:
            already_processed.add('isSingleGlobalLai')
            outfile.write(' isSingleGlobalLai="%s"' % self.gds_format_integer(self.isSingleGlobalLai, input_name='isSingleGlobalLai'))
        if self.sameOPObject is not None and 'sameOPObject' not in already_processed:
            already_processed.add('sameOPObject')
            outfile.write(' sameOPObject="%s"' % self.gds_format_integer(self.sameOPObject, input_name='sameOPObject'))
        if self.doubleFace is not None and 'doubleFace' not in already_processed:
            already_processed.add('doubleFace')
            outfile.write(' doubleFace="%s"' % self.gds_format_integer(self.doubleFace, input_name='doubleFace'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ObjectOpticalProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PropertiesForObject3DTurbidWithLAD is not None:
            self.PropertiesForObject3DTurbidWithLAD.export(outfile, level, namespaceprefix_, name_='PropertiesForObject3DTurbidWithLAD', pretty_print=pretty_print)
        if self.PropertiesForObject3DTurbid is not None:
            self.PropertiesForObject3DTurbid.export(outfile, level, namespaceprefix_, name_='PropertiesForObject3DTurbid', pretty_print=pretty_print)
        if self.OpticalPropertyLink is not None:
            self.OpticalPropertyLink.export(outfile, level, namespaceprefix_, name_='OpticalPropertyLink', pretty_print=pretty_print)
        if self.ThermalPropertyLink is not None:
            self.ThermalPropertyLink.export(outfile, level, namespaceprefix_, name_='ThermalPropertyLink', pretty_print=pretty_print)
        if self.BackFaceOpticalProperty is not None:
            self.BackFaceOpticalProperty.export(outfile, level, namespaceprefix_, name_='BackFaceOpticalProperty', pretty_print=pretty_print)
        if self.BackFaceThermalProperty is not None:
            self.BackFaceThermalProperty.export(outfile, level, namespaceprefix_, name_='BackFaceThermalProperty', pretty_print=pretty_print)
        if self.SingleGlobalLAIPropertyNode is not None:
            self.SingleGlobalLAIPropertyNode.export(outfile, level, namespaceprefix_, name_='SingleGlobalLAIPropertyNode', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_ObjectOpticalProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.isLAICalc is not None:
            element.set('isLAICalc', self.gds_format_integer(self.isLAICalc))
        if self.isSingleGlobalLai is not None:
            element.set('isSingleGlobalLai', self.gds_format_integer(self.isSingleGlobalLai))
        if self.sameOPObject is not None:
            element.set('sameOPObject', self.gds_format_integer(self.sameOPObject))
        if self.doubleFace is not None:
            element.set('doubleFace', self.gds_format_integer(self.doubleFace))
        if self.PropertiesForObject3DTurbidWithLAD is not None:
            PropertiesForObject3DTurbidWithLAD_ = self.PropertiesForObject3DTurbidWithLAD
            PropertiesForObject3DTurbidWithLAD_.to_etree(element, name_='PropertiesForObject3DTurbidWithLAD', mapping_=mapping_)
        if self.PropertiesForObject3DTurbid is not None:
            PropertiesForObject3DTurbid_ = self.PropertiesForObject3DTurbid
            PropertiesForObject3DTurbid_.to_etree(element, name_='PropertiesForObject3DTurbid', mapping_=mapping_)
        if self.OpticalPropertyLink is not None:
            OpticalPropertyLink_ = self.OpticalPropertyLink
            OpticalPropertyLink_.to_etree(element, name_='OpticalPropertyLink', mapping_=mapping_)
        if self.ThermalPropertyLink is not None:
            ThermalPropertyLink_ = self.ThermalPropertyLink
            ThermalPropertyLink_.to_etree(element, name_='ThermalPropertyLink', mapping_=mapping_)
        if self.BackFaceOpticalProperty is not None:
            BackFaceOpticalProperty_ = self.BackFaceOpticalProperty
            BackFaceOpticalProperty_.to_etree(element, name_='BackFaceOpticalProperty', mapping_=mapping_)
        if self.BackFaceThermalProperty is not None:
            BackFaceThermalProperty_ = self.BackFaceThermalProperty
            BackFaceThermalProperty_.to_etree(element, name_='BackFaceThermalProperty', mapping_=mapping_)
        if self.SingleGlobalLAIPropertyNode is not None:
            SingleGlobalLAIPropertyNode_ = self.SingleGlobalLAIPropertyNode
            SingleGlobalLAIPropertyNode_.to_etree(element, name_='SingleGlobalLAIPropertyNode', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ObjectOpticalProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isLAICalc is not None and 'isLAICalc' not in already_processed:
            already_processed.add('isLAICalc')
            showIndent(outfile, level)
            outfile.write('isLAICalc=%d,\n' % (self.isLAICalc,))
        if self.isSingleGlobalLai is not None and 'isSingleGlobalLai' not in already_processed:
            already_processed.add('isSingleGlobalLai')
            showIndent(outfile, level)
            outfile.write('isSingleGlobalLai=%d,\n' % (self.isSingleGlobalLai,))
        if self.sameOPObject is not None and 'sameOPObject' not in already_processed:
            already_processed.add('sameOPObject')
            showIndent(outfile, level)
            outfile.write('sameOPObject=%d,\n' % (self.sameOPObject,))
        if self.doubleFace is not None and 'doubleFace' not in already_processed:
            already_processed.add('doubleFace')
            showIndent(outfile, level)
            outfile.write('doubleFace=%d,\n' % (self.doubleFace,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PropertiesForObject3DTurbidWithLAD is not None:
            showIndent(outfile, level)
            outfile.write('PropertiesForObject3DTurbidWithLAD=model_._PropertiesForObject3DTurbidWithLAD(\n')
            self.PropertiesForObject3DTurbidWithLAD.exportLiteral(outfile, level, name_='PropertiesForObject3DTurbidWithLAD')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PropertiesForObject3DTurbid is not None:
            showIndent(outfile, level)
            outfile.write('PropertiesForObject3DTurbid=model_._PropertiesForObject3DTurbid(\n')
            self.PropertiesForObject3DTurbid.exportLiteral(outfile, level, name_='PropertiesForObject3DTurbid')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OpticalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('OpticalPropertyLink=model_._OpticalPropertyLink(\n')
            self.OpticalPropertyLink.exportLiteral(outfile, level, name_='OpticalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ThermalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('ThermalPropertyLink=model_._ThermalPropertyLink(\n')
            self.ThermalPropertyLink.exportLiteral(outfile, level, name_='ThermalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BackFaceOpticalProperty is not None:
            showIndent(outfile, level)
            outfile.write('BackFaceOpticalProperty=model_._BackFaceOpticalProperty(\n')
            self.BackFaceOpticalProperty.exportLiteral(outfile, level, name_='BackFaceOpticalProperty')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BackFaceThermalProperty is not None:
            showIndent(outfile, level)
            outfile.write('BackFaceThermalProperty=model_._BackFaceThermalProperty(\n')
            self.BackFaceThermalProperty.exportLiteral(outfile, level, name_='BackFaceThermalProperty')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SingleGlobalLAIPropertyNode is not None:
            showIndent(outfile, level)
            outfile.write('SingleGlobalLAIPropertyNode=model_._SingleGlobalLAIPropertyNode(\n')
            self.SingleGlobalLAIPropertyNode.exportLiteral(outfile, level, name_='SingleGlobalLAIPropertyNode')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isLAICalc', node)
        if value is not None and 'isLAICalc' not in already_processed:
            already_processed.add('isLAICalc')
            try:
                self.isLAICalc = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isSingleGlobalLai', node)
        if value is not None and 'isSingleGlobalLai' not in already_processed:
            already_processed.add('isSingleGlobalLai')
            try:
                self.isSingleGlobalLai = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('sameOPObject', node)
        if value is not None and 'sameOPObject' not in already_processed:
            already_processed.add('sameOPObject')
            try:
                self.sameOPObject = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('doubleFace', node)
        if value is not None and 'doubleFace' not in already_processed:
            already_processed.add('doubleFace')
            try:
                self.doubleFace = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PropertiesForObject3DTurbidWithLAD':
            obj_ = create_PropertiesForObject3DTurbidWithLAD.factory()
            obj_.build(child_)
            self.set_PropertiesForObject3DTurbidWithLAD(obj_)
            obj_.original_tagname_ = 'PropertiesForObject3DTurbidWithLAD'
        elif nodeName_ == 'PropertiesForObject3DTurbid':
            obj_ = create_PropertiesForObject3DTurbid.factory()
            obj_.build(child_)
            self.set_PropertiesForObject3DTurbid(obj_)
            obj_.original_tagname_ = 'PropertiesForObject3DTurbid'
        elif nodeName_ == 'OpticalPropertyLink':
            obj_ = create_OpticalPropertyLink.factory()
            obj_.build(child_)
            self.set_OpticalPropertyLink(obj_)
            obj_.original_tagname_ = 'OpticalPropertyLink'
        elif nodeName_ == 'ThermalPropertyLink':
            obj_ = create_ThermalPropertyLink.factory()
            obj_.build(child_)
            self.set_ThermalPropertyLink(obj_)
            obj_.original_tagname_ = 'ThermalPropertyLink'
        elif nodeName_ == 'BackFaceOpticalProperty':
            obj_ = create_BackFaceOpticalProperty.factory()
            obj_.build(child_)
            self.set_BackFaceOpticalProperty(obj_)
            obj_.original_tagname_ = 'BackFaceOpticalProperty'
        elif nodeName_ == 'BackFaceThermalProperty':
            obj_ = create_BackFaceThermalProperty.factory()
            obj_.build(child_)
            self.set_BackFaceThermalProperty(obj_)
            obj_.original_tagname_ = 'BackFaceThermalProperty'
        elif nodeName_ == 'SingleGlobalLAIPropertyNode':
            obj_ = create_SingleGlobalLAIPropertyNode.factory()
            obj_.build(child_)
            self.set_SingleGlobalLAIPropertyNode(obj_)
            obj_.original_tagname_ = 'SingleGlobalLAIPropertyNode'
# end class create_ObjectOpticalProperties


class create_PropertiesForObject3DTurbidWithLAD(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VegetationOpticalPropertyLink=None, ThermalPropertyLink=None, LAIPropertyNode=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_PropertiesForObject3DTurbidWithLAD")
        self.attrib = ['']
        self.children = ['VegetationOpticalPropertyLink', 'ThermalPropertyLink', 'LAIPropertyNode']
        self.parent = None
        self._VegetationOpticalPropertyLink = VegetationOpticalPropertyLink
        self._ThermalPropertyLink = ThermalPropertyLink
        self._LAIPropertyNode = LAIPropertyNode
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_PropertiesForObject3DTurbidWithLAD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_PropertiesForObject3DTurbidWithLAD.subclass:
            return create_PropertiesForObject3DTurbidWithLAD.subclass(*args_, **kwargs_)
        else:
            return create_PropertiesForObject3DTurbidWithLAD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VegetationOpticalPropertyLink(self): return self._VegetationOpticalPropertyLink
    def set_VegetationOpticalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_VegetationOpticalPropertyLink)
            value.parent = self
        self._VegetationOpticalPropertyLink = value
    VegetationOpticalPropertyLink = property(get_VegetationOpticalPropertyLink, set_VegetationOpticalPropertyLink)
    def get_ThermalPropertyLink(self): return self._ThermalPropertyLink
    def set_ThermalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_ThermalPropertyLink)
            value.parent = self
        self._ThermalPropertyLink = value
    ThermalPropertyLink = property(get_ThermalPropertyLink, set_ThermalPropertyLink)
    def get_LAIPropertyNode(self): return self._LAIPropertyNode
    def set_LAIPropertyNode(self, value):
        if value is not None:
            checkclass(value, create_LAIPropertyNode)
            value.parent = self
        self._LAIPropertyNode = value
    LAIPropertyNode = property(get_LAIPropertyNode, set_LAIPropertyNode)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.VegetationOpticalPropertyLink is not None or
            self.ThermalPropertyLink is not None or
            self.LAIPropertyNode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_PropertiesForObject3DTurbidWithLAD', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_PropertiesForObject3DTurbidWithLAD')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_PropertiesForObject3DTurbidWithLAD')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_PropertiesForObject3DTurbidWithLAD', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_PropertiesForObject3DTurbidWithLAD'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_PropertiesForObject3DTurbidWithLAD', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VegetationOpticalPropertyLink is not None:
            self.VegetationOpticalPropertyLink.export(outfile, level, namespaceprefix_, name_='VegetationOpticalPropertyLink', pretty_print=pretty_print)
        if self.ThermalPropertyLink is not None:
            self.ThermalPropertyLink.export(outfile, level, namespaceprefix_, name_='ThermalPropertyLink', pretty_print=pretty_print)
        if self.LAIPropertyNode is not None:
            self.LAIPropertyNode.export(outfile, level, namespaceprefix_, name_='LAIPropertyNode', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_PropertiesForObject3DTurbidWithLAD', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.VegetationOpticalPropertyLink is not None:
            VegetationOpticalPropertyLink_ = self.VegetationOpticalPropertyLink
            VegetationOpticalPropertyLink_.to_etree(element, name_='VegetationOpticalPropertyLink', mapping_=mapping_)
        if self.ThermalPropertyLink is not None:
            ThermalPropertyLink_ = self.ThermalPropertyLink
            ThermalPropertyLink_.to_etree(element, name_='ThermalPropertyLink', mapping_=mapping_)
        if self.LAIPropertyNode is not None:
            LAIPropertyNode_ = self.LAIPropertyNode
            LAIPropertyNode_.to_etree(element, name_='LAIPropertyNode', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_PropertiesForObject3DTurbidWithLAD'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.VegetationOpticalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('VegetationOpticalPropertyLink=model_._VegetationOpticalPropertyLink(\n')
            self.VegetationOpticalPropertyLink.exportLiteral(outfile, level, name_='VegetationOpticalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ThermalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('ThermalPropertyLink=model_._ThermalPropertyLink(\n')
            self.ThermalPropertyLink.exportLiteral(outfile, level, name_='ThermalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LAIPropertyNode is not None:
            showIndent(outfile, level)
            outfile.write('LAIPropertyNode=model_._LAIPropertyNode(\n')
            self.LAIPropertyNode.exportLiteral(outfile, level, name_='LAIPropertyNode')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VegetationOpticalPropertyLink':
            obj_ = create_VegetationOpticalPropertyLink.factory()
            obj_.build(child_)
            self.set_VegetationOpticalPropertyLink(obj_)
            obj_.original_tagname_ = 'VegetationOpticalPropertyLink'
        elif nodeName_ == 'ThermalPropertyLink':
            obj_ = create_ThermalPropertyLink.factory()
            obj_.build(child_)
            self.set_ThermalPropertyLink(obj_)
            obj_.original_tagname_ = 'ThermalPropertyLink'
        elif nodeName_ == 'LAIPropertyNode':
            obj_ = create_LAIPropertyNode.factory()
            obj_.build(child_)
            self.set_LAIPropertyNode(obj_)
            obj_.original_tagname_ = 'LAIPropertyNode'
# end class create_PropertiesForObject3DTurbidWithLAD


class create_VegetationOpticalPropertyLink(GeneratedsSuper):
    """Index of the DART phase function of the ground of the plot. Index of
    the DART phase function of the ground of the plot. proportion of
    photons intercepted along an incident direction that are
    scattered within a solid angle along a given direction
    proportion of photons intercepted along an incident direction
    that are scattered within a solid angle along a given direction"""
    subclass = None
    superclass = None
    def __init__(self, indexFctPhase=0, ident='TurbidLeafDeciduous'):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_VegetationOpticalPropertyLink")
        self.attrib = ['indexFctPhase', 'ident']
        self.children = []
        self.parent = None
        self._indexFctPhase = _cast(int, indexFctPhase)
        self._ident = _cast(None, ident)
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_VegetationOpticalPropertyLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_VegetationOpticalPropertyLink.subclass:
            return create_VegetationOpticalPropertyLink.subclass(*args_, **kwargs_)
        else:
            return create_VegetationOpticalPropertyLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexFctPhase(self): return self._indexFctPhase
    def set_indexFctPhase(self, value):
        self._indexFctPhase = value
        update_node(self,self.troot,"object_3d")
    indexFctPhase = property(get_indexFctPhase, set_indexFctPhase)
    def get_ident(self): return self._ident
    def set_ident(self, value):
        self._ident = value
        update_node(self,self.troot,"object_3d")
    ident = property(get_ident, set_ident)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_VegetationOpticalPropertyLink', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_VegetationOpticalPropertyLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_VegetationOpticalPropertyLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_VegetationOpticalPropertyLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_VegetationOpticalPropertyLink'):
        if self.indexFctPhase is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            outfile.write(' indexFctPhase="%s"' % self.gds_format_integer(self.indexFctPhase, input_name='indexFctPhase'))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            outfile.write(' ident=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ident), input_name='ident')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_VegetationOpticalPropertyLink', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_VegetationOpticalPropertyLink', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.indexFctPhase is not None:
            element.set('indexFctPhase', self.gds_format_integer(self.indexFctPhase))
        if self.ident is not None:
            element.set('ident', self.gds_format_string(self.ident))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_VegetationOpticalPropertyLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.indexFctPhase is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            showIndent(outfile, level)
            outfile.write('indexFctPhase=%d,\n' % (self.indexFctPhase,))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            showIndent(outfile, level)
            outfile.write('ident="%s",\n' % (self.ident,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('indexFctPhase', node)
        if value is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            try:
                self.indexFctPhase = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ident', node)
        if value is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            self.ident = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_VegetationOpticalPropertyLink


class create_ThermalPropertyLink(GeneratedsSuper):
    """Thermal Function ID Thermal Function ID"""
    subclass = None
    superclass = None
    def __init__(self, indexTemperature=0, idTemperature='ThermalFunction290_310'):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_ThermalPropertyLink")
        self.attrib = ['indexTemperature', 'idTemperature']
        self.children = []
        self.parent = None
        self._indexTemperature = _cast(int, indexTemperature)
        self._idTemperature = _cast(None, idTemperature)
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ThermalPropertyLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ThermalPropertyLink.subclass:
            return create_ThermalPropertyLink.subclass(*args_, **kwargs_)
        else:
            return create_ThermalPropertyLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexTemperature(self): return self._indexTemperature
    def set_indexTemperature(self, value):
        self._indexTemperature = value
        update_node(self,self.troot,"object_3d")
    indexTemperature = property(get_indexTemperature, set_indexTemperature)
    def get_idTemperature(self): return self._idTemperature
    def set_idTemperature(self, value):
        self._idTemperature = value
        update_node(self,self.troot,"object_3d")
    idTemperature = property(get_idTemperature, set_idTemperature)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ThermalPropertyLink', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ThermalPropertyLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ThermalPropertyLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ThermalPropertyLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ThermalPropertyLink'):
        if self.indexTemperature is not None and 'indexTemperature' not in already_processed:
            already_processed.add('indexTemperature')
            outfile.write(' indexTemperature="%s"' % self.gds_format_integer(self.indexTemperature, input_name='indexTemperature'))
        if self.idTemperature is not None and 'idTemperature' not in already_processed:
            already_processed.add('idTemperature')
            outfile.write(' idTemperature=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idTemperature), input_name='idTemperature')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ThermalPropertyLink', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_ThermalPropertyLink', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.indexTemperature is not None:
            element.set('indexTemperature', self.gds_format_integer(self.indexTemperature))
        if self.idTemperature is not None:
            element.set('idTemperature', self.gds_format_string(self.idTemperature))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ThermalPropertyLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.indexTemperature is not None and 'indexTemperature' not in already_processed:
            already_processed.add('indexTemperature')
            showIndent(outfile, level)
            outfile.write('indexTemperature=%d,\n' % (self.indexTemperature,))
        if self.idTemperature is not None and 'idTemperature' not in already_processed:
            already_processed.add('idTemperature')
            showIndent(outfile, level)
            outfile.write('idTemperature="%s",\n' % (self.idTemperature,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('indexTemperature', node)
        if value is not None and 'indexTemperature' not in already_processed:
            already_processed.add('indexTemperature')
            try:
                self.indexTemperature = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('idTemperature', node)
        if value is not None and 'idTemperature' not in already_processed:
            already_processed.add('idTemperature')
            self.idTemperature = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_ThermalPropertyLink


class create_LAIPropertyNode(GeneratedsSuper):
    """Apply a proportion factor to the calculated LAI of this object in
    order to obtain the desired LAI or total leaf area. Apply a
    proportion factor to the calculated LAI of this object in order
    to obtain the desired LAI or total leaf area."""
    subclass = None
    superclass = None
    def __init__(self, forcedLAI=0, MultiplicativeLAINode=None, ForcedLAINode=None, ForcedTotalSurfaceNode=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_LAIPropertyNode")
        self.attrib = ['forcedLAI']
        self.children = ['MultiplicativeLAINode', 'ForcedLAINode', 'ForcedTotalSurfaceNode']
        self.parent = None
        self._forcedLAI = _cast(int, forcedLAI)
        self._MultiplicativeLAINode = MultiplicativeLAINode
        self._ForcedLAINode = ForcedLAINode
        self._ForcedTotalSurfaceNode = ForcedTotalSurfaceNode
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_LAIPropertyNode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_LAIPropertyNode.subclass:
            return create_LAIPropertyNode.subclass(*args_, **kwargs_)
        else:
            return create_LAIPropertyNode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MultiplicativeLAINode(self): return self._MultiplicativeLAINode
    def set_MultiplicativeLAINode(self, value):
        if value is not None:
            checkclass(value, create_MultiplicativeLAINode)
            value.parent = self
        self._MultiplicativeLAINode = value
    MultiplicativeLAINode = property(get_MultiplicativeLAINode, set_MultiplicativeLAINode)
    def get_ForcedLAINode(self): return self._ForcedLAINode
    def set_ForcedLAINode(self, value):
        if value is not None:
            checkclass(value, create_ForcedLAINode)
            value.parent = self
        self._ForcedLAINode = value
    ForcedLAINode = property(get_ForcedLAINode, set_ForcedLAINode)
    def get_ForcedTotalSurfaceNode(self): return self._ForcedTotalSurfaceNode
    def set_ForcedTotalSurfaceNode(self, value):
        if value is not None:
            checkclass(value, create_ForcedTotalSurfaceNode)
            value.parent = self
        self._ForcedTotalSurfaceNode = value
    ForcedTotalSurfaceNode = property(get_ForcedTotalSurfaceNode, set_ForcedTotalSurfaceNode)
    def get_forcedLAI(self): return self._forcedLAI
    def set_forcedLAI(self, value):
        self._forcedLAI = value
        update_node(self,self.troot,"object_3d")
    forcedLAI = property(get_forcedLAI, set_forcedLAI)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.MultiplicativeLAINode is not None or
            self.ForcedLAINode is not None or
            self.ForcedTotalSurfaceNode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_LAIPropertyNode', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_LAIPropertyNode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_LAIPropertyNode')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_LAIPropertyNode', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_LAIPropertyNode'):
        if self.forcedLAI is not None and 'forcedLAI' not in already_processed:
            already_processed.add('forcedLAI')
            outfile.write(' forcedLAI="%s"' % self.gds_format_integer(self.forcedLAI, input_name='forcedLAI'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_LAIPropertyNode', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MultiplicativeLAINode is not None:
            self.MultiplicativeLAINode.export(outfile, level, namespaceprefix_, name_='MultiplicativeLAINode', pretty_print=pretty_print)
        if self.ForcedLAINode is not None:
            self.ForcedLAINode.export(outfile, level, namespaceprefix_, name_='ForcedLAINode', pretty_print=pretty_print)
        if self.ForcedTotalSurfaceNode is not None:
            self.ForcedTotalSurfaceNode.export(outfile, level, namespaceprefix_, name_='ForcedTotalSurfaceNode', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_LAIPropertyNode', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.forcedLAI is not None:
            element.set('forcedLAI', self.gds_format_integer(self.forcedLAI))
        if self.MultiplicativeLAINode is not None:
            MultiplicativeLAINode_ = self.MultiplicativeLAINode
            MultiplicativeLAINode_.to_etree(element, name_='MultiplicativeLAINode', mapping_=mapping_)
        if self.ForcedLAINode is not None:
            ForcedLAINode_ = self.ForcedLAINode
            ForcedLAINode_.to_etree(element, name_='ForcedLAINode', mapping_=mapping_)
        if self.ForcedTotalSurfaceNode is not None:
            ForcedTotalSurfaceNode_ = self.ForcedTotalSurfaceNode
            ForcedTotalSurfaceNode_.to_etree(element, name_='ForcedTotalSurfaceNode', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_LAIPropertyNode'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.forcedLAI is not None and 'forcedLAI' not in already_processed:
            already_processed.add('forcedLAI')
            showIndent(outfile, level)
            outfile.write('forcedLAI=%d,\n' % (self.forcedLAI,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MultiplicativeLAINode is not None:
            showIndent(outfile, level)
            outfile.write('MultiplicativeLAINode=model_._MultiplicativeLAINode(\n')
            self.MultiplicativeLAINode.exportLiteral(outfile, level, name_='MultiplicativeLAINode')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ForcedLAINode is not None:
            showIndent(outfile, level)
            outfile.write('ForcedLAINode=model_._ForcedLAINode(\n')
            self.ForcedLAINode.exportLiteral(outfile, level, name_='ForcedLAINode')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ForcedTotalSurfaceNode is not None:
            showIndent(outfile, level)
            outfile.write('ForcedTotalSurfaceNode=model_._ForcedTotalSurfaceNode(\n')
            self.ForcedTotalSurfaceNode.exportLiteral(outfile, level, name_='ForcedTotalSurfaceNode')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('forcedLAI', node)
        if value is not None and 'forcedLAI' not in already_processed:
            already_processed.add('forcedLAI')
            try:
                self.forcedLAI = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MultiplicativeLAINode':
            obj_ = create_MultiplicativeLAINode.factory()
            obj_.build(child_)
            self.set_MultiplicativeLAINode(obj_)
            obj_.original_tagname_ = 'MultiplicativeLAINode'
        elif nodeName_ == 'ForcedLAINode':
            obj_ = create_ForcedLAINode.factory()
            obj_.build(child_)
            self.set_ForcedLAINode(obj_)
            obj_.original_tagname_ = 'ForcedLAINode'
        elif nodeName_ == 'ForcedTotalSurfaceNode':
            obj_ = create_ForcedTotalSurfaceNode.factory()
            obj_.build(child_)
            self.set_ForcedTotalSurfaceNode(obj_)
            obj_.original_tagname_ = 'ForcedTotalSurfaceNode'
# end class create_LAIPropertyNode


class create_MultiplicativeLAINode(GeneratedsSuper):
    """Apply the given multiplicative factor to the LAI computed by Maket
    for this group/object.\nFor example, the LAI for needle of pine
    trees is half (so 0.5) the area of the needle divided by the
    projected area on the ground. Apply the given multiplicative
    factor to the LAI computed by Maket for this group/object.\nFor
    example, the LAI for needle of pine trees is half (so 0.5) the
    area of the needle divided by the projected area on the ground."""
    subclass = None
    superclass = None
    def __init__(self, laiMultiplicativeFactor=1.):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_MultiplicativeLAINode")
        self.attrib = ['laiMultiplicativeFactor']
        self.children = []
        self.parent = None
        self._laiMultiplicativeFactor = _cast(float, laiMultiplicativeFactor)
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_MultiplicativeLAINode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_MultiplicativeLAINode.subclass:
            return create_MultiplicativeLAINode.subclass(*args_, **kwargs_)
        else:
            return create_MultiplicativeLAINode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_laiMultiplicativeFactor(self): return self._laiMultiplicativeFactor
    def set_laiMultiplicativeFactor(self, value):
        self._laiMultiplicativeFactor = value
        update_node(self,self.troot,"object_3d")
    laiMultiplicativeFactor = property(get_laiMultiplicativeFactor, set_laiMultiplicativeFactor)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_MultiplicativeLAINode', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_MultiplicativeLAINode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_MultiplicativeLAINode')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_MultiplicativeLAINode', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_MultiplicativeLAINode'):
        if self.laiMultiplicativeFactor is not None and 'laiMultiplicativeFactor' not in already_processed:
            already_processed.add('laiMultiplicativeFactor')
            outfile.write(' laiMultiplicativeFactor="%s"' % self.gds_format_double(self.laiMultiplicativeFactor, input_name='laiMultiplicativeFactor'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_MultiplicativeLAINode', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_MultiplicativeLAINode', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.laiMultiplicativeFactor is not None:
            element.set('laiMultiplicativeFactor', self.gds_format_double(self.laiMultiplicativeFactor))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_MultiplicativeLAINode'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.laiMultiplicativeFactor is not None and 'laiMultiplicativeFactor' not in already_processed:
            already_processed.add('laiMultiplicativeFactor')
            showIndent(outfile, level)
            outfile.write('laiMultiplicativeFactor=%e,\n' % (self.laiMultiplicativeFactor,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('laiMultiplicativeFactor', node)
        if value is not None and 'laiMultiplicativeFactor' not in already_processed:
            already_processed.add('laiMultiplicativeFactor')
            try:
                self.laiMultiplicativeFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (laiMultiplicativeFactor): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_MultiplicativeLAINode


class create_ForcedLAINode(GeneratedsSuper):
    """LAI : total leaf area divided by the projected surface of the object
    on the ground. LAI : total leaf area divided by the projected
    surface of the object on the ground."""
    subclass = None
    superclass = None
    def __init__(self, lai=1.5):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_ForcedLAINode")
        self.attrib = ['lai']
        self.children = []
        self.parent = None
        self._lai = _cast(float, lai)
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ForcedLAINode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ForcedLAINode.subclass:
            return create_ForcedLAINode.subclass(*args_, **kwargs_)
        else:
            return create_ForcedLAINode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lai(self): return self._lai
    def set_lai(self, value):
        self._lai = value
        update_node(self,self.troot,"object_3d")
    lai = property(get_lai, set_lai)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ForcedLAINode', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ForcedLAINode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ForcedLAINode')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ForcedLAINode', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ForcedLAINode'):
        if self.lai is not None and 'lai' not in already_processed:
            already_processed.add('lai')
            outfile.write(' lai="%s"' % self.gds_format_double(self.lai, input_name='lai'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ForcedLAINode', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_ForcedLAINode', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.lai is not None:
            element.set('lai', self.gds_format_double(self.lai))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ForcedLAINode'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lai is not None and 'lai' not in already_processed:
            already_processed.add('lai')
            showIndent(outfile, level)
            outfile.write('lai=%e,\n' % (self.lai,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lai', node)
        if value is not None and 'lai' not in already_processed:
            already_processed.add('lai')
            try:
                self.lai = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (lai): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_ForcedLAINode


class create_ForcedTotalSurfaceNode(GeneratedsSuper):
    """Total area of leaves. Total area of leaves."""
    subclass = None
    superclass = None
    def __init__(self, totalSurface=1.5):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_ForcedTotalSurfaceNode")
        self.attrib = ['totalSurface']
        self.children = []
        self.parent = None
        self._totalSurface = _cast(float, totalSurface)
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ForcedTotalSurfaceNode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ForcedTotalSurfaceNode.subclass:
            return create_ForcedTotalSurfaceNode.subclass(*args_, **kwargs_)
        else:
            return create_ForcedTotalSurfaceNode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_totalSurface(self): return self._totalSurface
    def set_totalSurface(self, value):
        self._totalSurface = value
        update_node(self,self.troot,"object_3d")
    totalSurface = property(get_totalSurface, set_totalSurface)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ForcedTotalSurfaceNode', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ForcedTotalSurfaceNode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ForcedTotalSurfaceNode')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ForcedTotalSurfaceNode', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ForcedTotalSurfaceNode'):
        if self.totalSurface is not None and 'totalSurface' not in already_processed:
            already_processed.add('totalSurface')
            outfile.write(' totalSurface="%s"' % self.gds_format_double(self.totalSurface, input_name='totalSurface'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ForcedTotalSurfaceNode', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_ForcedTotalSurfaceNode', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.totalSurface is not None:
            element.set('totalSurface', self.gds_format_double(self.totalSurface))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ForcedTotalSurfaceNode'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.totalSurface is not None and 'totalSurface' not in already_processed:
            already_processed.add('totalSurface')
            showIndent(outfile, level)
            outfile.write('totalSurface=%e,\n' % (self.totalSurface,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('totalSurface', node)
        if value is not None and 'totalSurface' not in already_processed:
            already_processed.add('totalSurface')
            try:
                self.totalSurface = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (totalSurface): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_ForcedTotalSurfaceNode


class create_PropertiesForObject3DTurbid(GeneratedsSuper):
    """indexPremiereFctPhase indexPremiereFctPhase the 3D object group will
    be transformed into turbid cells with ellipsoidal phase
    functions\n Each phase function is characterized by a ALA value,
    the accuracy of which depends on number of angular sector. the
    3D object group will be transformed into turbid cells with
    ellipsoidal phase functions\n Each phase function is
    characterized by a ALA value, the accuracy of which depends on
    number of angular sector."""
    subclass = None
    superclass = None
    def __init__(self, indexPremiereFctPhase=0, ALAsegmentation=5, VegetationOpticalPropertyLink=None, ThermalPropertyLink=None, LAIPropertyNode=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_PropertiesForObject3DTurbid")
        self.attrib = ['indexPremiereFctPhase', 'ALAsegmentation']
        self.children = ['VegetationOpticalPropertyLink', 'ThermalPropertyLink', 'LAIPropertyNode']
        self.parent = None
        self._indexPremiereFctPhase = _cast(int, indexPremiereFctPhase)
        self._ALAsegmentation = _cast(int, ALAsegmentation)
        self._VegetationOpticalPropertyLink = VegetationOpticalPropertyLink
        self._ThermalPropertyLink = ThermalPropertyLink
        self._LAIPropertyNode = LAIPropertyNode
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_PropertiesForObject3DTurbid)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_PropertiesForObject3DTurbid.subclass:
            return create_PropertiesForObject3DTurbid.subclass(*args_, **kwargs_)
        else:
            return create_PropertiesForObject3DTurbid(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VegetationOpticalPropertyLink(self): return self._VegetationOpticalPropertyLink
    def set_VegetationOpticalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_VegetationOpticalPropertyLink)
            value.parent = self
        self._VegetationOpticalPropertyLink = value
    VegetationOpticalPropertyLink = property(get_VegetationOpticalPropertyLink, set_VegetationOpticalPropertyLink)
    def get_ThermalPropertyLink(self): return self._ThermalPropertyLink
    def set_ThermalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_ThermalPropertyLink)
            value.parent = self
        self._ThermalPropertyLink = value
    ThermalPropertyLink = property(get_ThermalPropertyLink, set_ThermalPropertyLink)
    def get_LAIPropertyNode(self): return self._LAIPropertyNode
    def set_LAIPropertyNode(self, value):
        if value is not None:
            checkclass(value, create_LAIPropertyNode)
            value.parent = self
        self._LAIPropertyNode = value
    LAIPropertyNode = property(get_LAIPropertyNode, set_LAIPropertyNode)
    def get_indexPremiereFctPhase(self): return self._indexPremiereFctPhase
    def set_indexPremiereFctPhase(self, value):
        self._indexPremiereFctPhase = value
        update_node(self,self.troot,"object_3d")
    indexPremiereFctPhase = property(get_indexPremiereFctPhase, set_indexPremiereFctPhase)
    def get_ALAsegmentation(self): return self._ALAsegmentation
    def set_ALAsegmentation(self, value):
        self._ALAsegmentation = value
        update_node(self,self.troot,"object_3d")
    ALAsegmentation = property(get_ALAsegmentation, set_ALAsegmentation)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.VegetationOpticalPropertyLink is not None or
            self.ThermalPropertyLink is not None or
            self.LAIPropertyNode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_PropertiesForObject3DTurbid', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_PropertiesForObject3DTurbid')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_PropertiesForObject3DTurbid')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_PropertiesForObject3DTurbid', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_PropertiesForObject3DTurbid'):
        if self.indexPremiereFctPhase is not None and 'indexPremiereFctPhase' not in already_processed:
            already_processed.add('indexPremiereFctPhase')
            outfile.write(' indexPremiereFctPhase="%s"' % self.gds_format_integer(self.indexPremiereFctPhase, input_name='indexPremiereFctPhase'))
        if self.ALAsegmentation is not None and 'ALAsegmentation' not in already_processed:
            already_processed.add('ALAsegmentation')
            outfile.write(' ALAsegmentation="%s"' % self.gds_format_integer(self.ALAsegmentation, input_name='ALAsegmentation'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_PropertiesForObject3DTurbid', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VegetationOpticalPropertyLink is not None:
            self.VegetationOpticalPropertyLink.export(outfile, level, namespaceprefix_, name_='VegetationOpticalPropertyLink', pretty_print=pretty_print)
        if self.ThermalPropertyLink is not None:
            self.ThermalPropertyLink.export(outfile, level, namespaceprefix_, name_='ThermalPropertyLink', pretty_print=pretty_print)
        if self.LAIPropertyNode is not None:
            self.LAIPropertyNode.export(outfile, level, namespaceprefix_, name_='LAIPropertyNode', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_PropertiesForObject3DTurbid', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.indexPremiereFctPhase is not None:
            element.set('indexPremiereFctPhase', self.gds_format_integer(self.indexPremiereFctPhase))
        if self.ALAsegmentation is not None:
            element.set('ALAsegmentation', self.gds_format_integer(self.ALAsegmentation))
        if self.VegetationOpticalPropertyLink is not None:
            VegetationOpticalPropertyLink_ = self.VegetationOpticalPropertyLink
            VegetationOpticalPropertyLink_.to_etree(element, name_='VegetationOpticalPropertyLink', mapping_=mapping_)
        if self.ThermalPropertyLink is not None:
            ThermalPropertyLink_ = self.ThermalPropertyLink
            ThermalPropertyLink_.to_etree(element, name_='ThermalPropertyLink', mapping_=mapping_)
        if self.LAIPropertyNode is not None:
            LAIPropertyNode_ = self.LAIPropertyNode
            LAIPropertyNode_.to_etree(element, name_='LAIPropertyNode', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_PropertiesForObject3DTurbid'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.indexPremiereFctPhase is not None and 'indexPremiereFctPhase' not in already_processed:
            already_processed.add('indexPremiereFctPhase')
            showIndent(outfile, level)
            outfile.write('indexPremiereFctPhase=%d,\n' % (self.indexPremiereFctPhase,))
        if self.ALAsegmentation is not None and 'ALAsegmentation' not in already_processed:
            already_processed.add('ALAsegmentation')
            showIndent(outfile, level)
            outfile.write('ALAsegmentation=%d,\n' % (self.ALAsegmentation,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.VegetationOpticalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('VegetationOpticalPropertyLink=model_._VegetationOpticalPropertyLink(\n')
            self.VegetationOpticalPropertyLink.exportLiteral(outfile, level, name_='VegetationOpticalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ThermalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('ThermalPropertyLink=model_._ThermalPropertyLink(\n')
            self.ThermalPropertyLink.exportLiteral(outfile, level, name_='ThermalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LAIPropertyNode is not None:
            showIndent(outfile, level)
            outfile.write('LAIPropertyNode=model_._LAIPropertyNode(\n')
            self.LAIPropertyNode.exportLiteral(outfile, level, name_='LAIPropertyNode')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('indexPremiereFctPhase', node)
        if value is not None and 'indexPremiereFctPhase' not in already_processed:
            already_processed.add('indexPremiereFctPhase')
            try:
                self.indexPremiereFctPhase = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ALAsegmentation', node)
        if value is not None and 'ALAsegmentation' not in already_processed:
            already_processed.add('ALAsegmentation')
            try:
                self.ALAsegmentation = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VegetationOpticalPropertyLink':
            obj_ = create_VegetationOpticalPropertyLink.factory()
            obj_.build(child_)
            self.set_VegetationOpticalPropertyLink(obj_)
            obj_.original_tagname_ = 'VegetationOpticalPropertyLink'
        elif nodeName_ == 'ThermalPropertyLink':
            obj_ = create_ThermalPropertyLink.factory()
            obj_.build(child_)
            self.set_ThermalPropertyLink(obj_)
            obj_.original_tagname_ = 'ThermalPropertyLink'
        elif nodeName_ == 'LAIPropertyNode':
            obj_ = create_LAIPropertyNode.factory()
            obj_.build(child_)
            self.set_LAIPropertyNode(obj_)
            obj_.original_tagname_ = 'LAIPropertyNode'
# end class create_PropertiesForObject3DTurbid


class create_OpticalPropertyLink(GeneratedsSuper):
    """Index of the DART phase function of the ground of the plot. Index of
    the DART phase function of the ground of the plot. proportion of
    photons intercepted along an incident direction that are
    scattered within a solid angle along a given direction
    proportion of photons intercepted along an incident direction
    that are scattered within a solid angle along a given direction
    Type of phase function (lambertian, etc.) Type of phase function
    (lambertian, etc.)"""
    subclass = None
    superclass = None
    def __init__(self, indexFctPhase=0, ident='OpticalProperty', type_=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_OpticalPropertyLink")
        self.attrib = ['indexFctPhase', 'ident', 'type_']
        self.children = []
        self.parent = None
        self._indexFctPhase = _cast(int, indexFctPhase)
        self._ident = _cast(None, ident)
        self._type_ = _cast(int, type_)
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_OpticalPropertyLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_OpticalPropertyLink.subclass:
            return create_OpticalPropertyLink.subclass(*args_, **kwargs_)
        else:
            return create_OpticalPropertyLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexFctPhase(self): return self._indexFctPhase
    def set_indexFctPhase(self, value):
        self._indexFctPhase = value
        update_node(self,self.troot,"object_3d")
    indexFctPhase = property(get_indexFctPhase, set_indexFctPhase)
    def get_ident(self): return self._ident
    def set_ident(self, value):
        self._ident = value
        update_node(self,self.troot,"object_3d")
    ident = property(get_ident, set_ident)
    def get_type(self): return self._type_
    def set_type(self, value):
        self._type_ = value
        update_node(self,self.troot,"object_3d")
    type_ = property(get_type, set_type)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_OpticalPropertyLink', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_OpticalPropertyLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_OpticalPropertyLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_OpticalPropertyLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_OpticalPropertyLink'):
        if self.indexFctPhase is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            outfile.write(' indexFctPhase="%s"' % self.gds_format_integer(self.indexFctPhase, input_name='indexFctPhase'))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            outfile.write(' ident=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ident), input_name='ident')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type="%s"' % self.gds_format_integer(self.type_, input_name='type'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_OpticalPropertyLink', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_OpticalPropertyLink', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.indexFctPhase is not None:
            element.set('indexFctPhase', self.gds_format_integer(self.indexFctPhase))
        if self.ident is not None:
            element.set('ident', self.gds_format_string(self.ident))
        if self.type_ is not None:
            element.set('type', self.gds_format_integer(self.type_))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_OpticalPropertyLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.indexFctPhase is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            showIndent(outfile, level)
            outfile.write('indexFctPhase=%d,\n' % (self.indexFctPhase,))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            showIndent(outfile, level)
            outfile.write('ident="%s",\n' % (self.ident,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_=%d,\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('indexFctPhase', node)
        if value is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            try:
                self.indexFctPhase = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ident', node)
        if value is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            self.ident = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            try:
                self.type_ = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_OpticalPropertyLink


class create_BackFaceOpticalProperty(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OpticalPropertyLink=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_BackFaceOpticalProperty")
        self.attrib = ['']
        self.children = ['OpticalPropertyLink']
        self.parent = None
        self._OpticalPropertyLink = OpticalPropertyLink
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_BackFaceOpticalProperty)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_BackFaceOpticalProperty.subclass:
            return create_BackFaceOpticalProperty.subclass(*args_, **kwargs_)
        else:
            return create_BackFaceOpticalProperty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OpticalPropertyLink(self): return self._OpticalPropertyLink
    def set_OpticalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_OpticalPropertyLink)
            value.parent = self
        self._OpticalPropertyLink = value
    OpticalPropertyLink = property(get_OpticalPropertyLink, set_OpticalPropertyLink)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.OpticalPropertyLink is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_BackFaceOpticalProperty', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_BackFaceOpticalProperty')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_BackFaceOpticalProperty')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_BackFaceOpticalProperty', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_BackFaceOpticalProperty'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_BackFaceOpticalProperty', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OpticalPropertyLink is not None:
            self.OpticalPropertyLink.export(outfile, level, namespaceprefix_, name_='OpticalPropertyLink', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_BackFaceOpticalProperty', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.OpticalPropertyLink is not None:
            OpticalPropertyLink_ = self.OpticalPropertyLink
            OpticalPropertyLink_.to_etree(element, name_='OpticalPropertyLink', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_BackFaceOpticalProperty'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.OpticalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('OpticalPropertyLink=model_._OpticalPropertyLink(\n')
            self.OpticalPropertyLink.exportLiteral(outfile, level, name_='OpticalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OpticalPropertyLink':
            obj_ = create_OpticalPropertyLink.factory()
            obj_.build(child_)
            self.set_OpticalPropertyLink(obj_)
            obj_.original_tagname_ = 'OpticalPropertyLink'
# end class create_BackFaceOpticalProperty


class create_BackFaceThermalProperty(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ThermalPropertyLink=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_BackFaceThermalProperty")
        self.attrib = ['']
        self.children = ['ThermalPropertyLink']
        self.parent = None
        self._ThermalPropertyLink = ThermalPropertyLink
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_BackFaceThermalProperty)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_BackFaceThermalProperty.subclass:
            return create_BackFaceThermalProperty.subclass(*args_, **kwargs_)
        else:
            return create_BackFaceThermalProperty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ThermalPropertyLink(self): return self._ThermalPropertyLink
    def set_ThermalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_ThermalPropertyLink)
            value.parent = self
        self._ThermalPropertyLink = value
    ThermalPropertyLink = property(get_ThermalPropertyLink, set_ThermalPropertyLink)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.ThermalPropertyLink is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_BackFaceThermalProperty', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_BackFaceThermalProperty')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_BackFaceThermalProperty')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_BackFaceThermalProperty', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_BackFaceThermalProperty'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_BackFaceThermalProperty', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ThermalPropertyLink is not None:
            self.ThermalPropertyLink.export(outfile, level, namespaceprefix_, name_='ThermalPropertyLink', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_BackFaceThermalProperty', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.ThermalPropertyLink is not None:
            ThermalPropertyLink_ = self.ThermalPropertyLink
            ThermalPropertyLink_.to_etree(element, name_='ThermalPropertyLink', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_BackFaceThermalProperty'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ThermalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('ThermalPropertyLink=model_._ThermalPropertyLink(\n')
            self.ThermalPropertyLink.exportLiteral(outfile, level, name_='ThermalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ThermalPropertyLink':
            obj_ = create_ThermalPropertyLink.factory()
            obj_.build(child_)
            self.set_ThermalPropertyLink(obj_)
            obj_.original_tagname_ = 'ThermalPropertyLink'
# end class create_BackFaceThermalProperty


class create_SingleGlobalLAIPropertyNode(GeneratedsSuper):
    """LAI Definition LAI Definition"""
    subclass = None
    superclass = None
    def __init__(self, laiDefinition=1, ForcedLAINode=None, ForcedTotalSurfaceNode=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_SingleGlobalLAIPropertyNode")
        self.attrib = ['laiDefinition']
        self.children = ['ForcedLAINode', 'ForcedTotalSurfaceNode']
        self.parent = None
        self._laiDefinition = _cast(int, laiDefinition)
        self._ForcedLAINode = ForcedLAINode
        self._ForcedTotalSurfaceNode = ForcedTotalSurfaceNode
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_SingleGlobalLAIPropertyNode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_SingleGlobalLAIPropertyNode.subclass:
            return create_SingleGlobalLAIPropertyNode.subclass(*args_, **kwargs_)
        else:
            return create_SingleGlobalLAIPropertyNode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ForcedLAINode(self): return self._ForcedLAINode
    def set_ForcedLAINode(self, value):
        if value is not None:
            checkclass(value, create_ForcedLAINode)
            value.parent = self
        self._ForcedLAINode = value
    ForcedLAINode = property(get_ForcedLAINode, set_ForcedLAINode)
    def get_ForcedTotalSurfaceNode(self): return self._ForcedTotalSurfaceNode
    def set_ForcedTotalSurfaceNode(self, value):
        if value is not None:
            checkclass(value, create_ForcedTotalSurfaceNode)
            value.parent = self
        self._ForcedTotalSurfaceNode = value
    ForcedTotalSurfaceNode = property(get_ForcedTotalSurfaceNode, set_ForcedTotalSurfaceNode)
    def get_laiDefinition(self): return self._laiDefinition
    def set_laiDefinition(self, value):
        self._laiDefinition = value
        update_node(self,self.troot,"object_3d")
    laiDefinition = property(get_laiDefinition, set_laiDefinition)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.ForcedLAINode is not None or
            self.ForcedTotalSurfaceNode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_SingleGlobalLAIPropertyNode', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_SingleGlobalLAIPropertyNode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_SingleGlobalLAIPropertyNode')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_SingleGlobalLAIPropertyNode', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_SingleGlobalLAIPropertyNode'):
        if self.laiDefinition is not None and 'laiDefinition' not in already_processed:
            already_processed.add('laiDefinition')
            outfile.write(' laiDefinition="%s"' % self.gds_format_integer(self.laiDefinition, input_name='laiDefinition'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_SingleGlobalLAIPropertyNode', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ForcedLAINode is not None:
            self.ForcedLAINode.export(outfile, level, namespaceprefix_, name_='ForcedLAINode', pretty_print=pretty_print)
        if self.ForcedTotalSurfaceNode is not None:
            self.ForcedTotalSurfaceNode.export(outfile, level, namespaceprefix_, name_='ForcedTotalSurfaceNode', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_SingleGlobalLAIPropertyNode', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.laiDefinition is not None:
            element.set('laiDefinition', self.gds_format_integer(self.laiDefinition))
        if self.ForcedLAINode is not None:
            ForcedLAINode_ = self.ForcedLAINode
            ForcedLAINode_.to_etree(element, name_='ForcedLAINode', mapping_=mapping_)
        if self.ForcedTotalSurfaceNode is not None:
            ForcedTotalSurfaceNode_ = self.ForcedTotalSurfaceNode
            ForcedTotalSurfaceNode_.to_etree(element, name_='ForcedTotalSurfaceNode', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_SingleGlobalLAIPropertyNode'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.laiDefinition is not None and 'laiDefinition' not in already_processed:
            already_processed.add('laiDefinition')
            showIndent(outfile, level)
            outfile.write('laiDefinition=%d,\n' % (self.laiDefinition,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ForcedLAINode is not None:
            showIndent(outfile, level)
            outfile.write('ForcedLAINode=model_._ForcedLAINode(\n')
            self.ForcedLAINode.exportLiteral(outfile, level, name_='ForcedLAINode')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ForcedTotalSurfaceNode is not None:
            showIndent(outfile, level)
            outfile.write('ForcedTotalSurfaceNode=model_._ForcedTotalSurfaceNode(\n')
            self.ForcedTotalSurfaceNode.exportLiteral(outfile, level, name_='ForcedTotalSurfaceNode')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('laiDefinition', node)
        if value is not None and 'laiDefinition' not in already_processed:
            already_processed.add('laiDefinition')
            try:
                self.laiDefinition = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ForcedLAINode':
            obj_ = create_ForcedLAINode.factory()
            obj_.build(child_)
            self.set_ForcedLAINode(obj_)
            obj_.original_tagname_ = 'ForcedLAINode'
        elif nodeName_ == 'ForcedTotalSurfaceNode':
            obj_ = create_ForcedTotalSurfaceNode.factory()
            obj_.build(child_)
            self.set_ForcedTotalSurfaceNode(obj_)
            obj_.original_tagname_ = 'ForcedTotalSurfaceNode'
# end class create_SingleGlobalLAIPropertyNode


class create_ObjectTypeProperties(GeneratedsSuper):
    """Define the color/name at the object's level, to all its
    groups.\nReplace any previously defined type. Define the
    color/name at the object's level, to all its groups.\nReplace
    any previously defined type."""
    subclass = None
    superclass = None
    def __init__(self, sameOTObject=0, ObjectTypeLink=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_ObjectTypeProperties")
        self.attrib = ['sameOTObject']
        self.children = ['ObjectTypeLink']
        self.parent = None
        self._sameOTObject = _cast(int, sameOTObject)
        self._ObjectTypeLink = ObjectTypeLink
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ObjectTypeProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ObjectTypeProperties.subclass:
            return create_ObjectTypeProperties.subclass(*args_, **kwargs_)
        else:
            return create_ObjectTypeProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ObjectTypeLink(self): return self._ObjectTypeLink
    def set_ObjectTypeLink(self, value):
        if value is not None:
            checkclass(value, create_ObjectTypeLink)
            value.parent = self
        self._ObjectTypeLink = value
    ObjectTypeLink = property(get_ObjectTypeLink, set_ObjectTypeLink)
    def get_sameOTObject(self): return self._sameOTObject
    def set_sameOTObject(self, value):
        self._sameOTObject = value
        update_node(self,self.troot,"object_3d")
    sameOTObject = property(get_sameOTObject, set_sameOTObject)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.ObjectTypeLink is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ObjectTypeProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ObjectTypeProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ObjectTypeProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ObjectTypeProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ObjectTypeProperties'):
        if self.sameOTObject is not None and 'sameOTObject' not in already_processed:
            already_processed.add('sameOTObject')
            outfile.write(' sameOTObject="%s"' % self.gds_format_integer(self.sameOTObject, input_name='sameOTObject'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ObjectTypeProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ObjectTypeLink is not None:
            self.ObjectTypeLink.export(outfile, level, namespaceprefix_, name_='ObjectTypeLink', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_ObjectTypeProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.sameOTObject is not None:
            element.set('sameOTObject', self.gds_format_integer(self.sameOTObject))
        if self.ObjectTypeLink is not None:
            ObjectTypeLink_ = self.ObjectTypeLink
            ObjectTypeLink_.to_etree(element, name_='ObjectTypeLink', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ObjectTypeProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sameOTObject is not None and 'sameOTObject' not in already_processed:
            already_processed.add('sameOTObject')
            showIndent(outfile, level)
            outfile.write('sameOTObject=%d,\n' % (self.sameOTObject,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ObjectTypeLink is not None:
            showIndent(outfile, level)
            outfile.write('ObjectTypeLink=model_._ObjectTypeLink(\n')
            self.ObjectTypeLink.exportLiteral(outfile, level, name_='ObjectTypeLink')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sameOTObject', node)
        if value is not None and 'sameOTObject' not in already_processed:
            already_processed.add('sameOTObject')
            try:
                self.sameOTObject = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ObjectTypeLink':
            obj_ = create_ObjectTypeLink.factory()
            obj_.build(child_)
            self.set_ObjectTypeLink(obj_)
            obj_.original_tagname_ = 'ObjectTypeLink'
# end class create_ObjectTypeProperties


class create_ObjectTypeLink(GeneratedsSuper):
    """Color/name Idenfier. Do no modify! Color/name Idenfier. Do no
    modify! Color/name. Color/name."""
    subclass = None
    superclass = None
    def __init__(self, indexOT=101, identOType='Default_Object'):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_ObjectTypeLink")
        self.attrib = ['indexOT', 'identOType']
        self.children = []
        self.parent = None
        self._indexOT = _cast(int, indexOT)
        self._identOType = _cast(None, identOType)
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ObjectTypeLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ObjectTypeLink.subclass:
            return create_ObjectTypeLink.subclass(*args_, **kwargs_)
        else:
            return create_ObjectTypeLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexOT(self): return self._indexOT
    def set_indexOT(self, value):
        self._indexOT = value
        update_node(self,self.troot,"object_3d")
    indexOT = property(get_indexOT, set_indexOT)
    def get_identOType(self): return self._identOType
    def set_identOType(self, value):
        self._identOType = value
        update_node(self,self.troot,"object_3d")
    identOType = property(get_identOType, set_identOType)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ObjectTypeLink', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ObjectTypeLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ObjectTypeLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ObjectTypeLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ObjectTypeLink'):
        if self.indexOT is not None and 'indexOT' not in already_processed:
            already_processed.add('indexOT')
            outfile.write(' indexOT="%s"' % self.gds_format_integer(self.indexOT, input_name='indexOT'))
        if self.identOType is not None and 'identOType' not in already_processed:
            already_processed.add('identOType')
            outfile.write(' identOType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.identOType), input_name='identOType')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ObjectTypeLink', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_ObjectTypeLink', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.indexOT is not None:
            element.set('indexOT', self.gds_format_integer(self.indexOT))
        if self.identOType is not None:
            element.set('identOType', self.gds_format_string(self.identOType))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ObjectTypeLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.indexOT is not None and 'indexOT' not in already_processed:
            already_processed.add('indexOT')
            showIndent(outfile, level)
            outfile.write('indexOT=%d,\n' % (self.indexOT,))
        if self.identOType is not None and 'identOType' not in already_processed:
            already_processed.add('identOType')
            showIndent(outfile, level)
            outfile.write('identOType="%s",\n' % (self.identOType,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('indexOT', node)
        if value is not None and 'indexOT' not in already_processed:
            already_processed.add('indexOT')
            try:
                self.indexOT = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('identOType', node)
        if value is not None and 'identOType' not in already_processed:
            already_processed.add('identOType')
            self.identOType = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_ObjectTypeLink


class create_Groups(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Group=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_Groups")
        self.attrib = ['']
        self.children = ['Group']
        self.parent = None
        if Group is None:
            self._Group = []
        else:
            self._Group = Group
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Groups)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Groups.subclass:
            return create_Groups.subclass(*args_, **kwargs_)
        else:
            return create_Groups(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Group(self): return self._Group
    def set_Group(self, value):
        if value is not None:
            checkclass(value, create_Group)
            for v in value:
                v.parent = self
        self._Group = value
    def add_Group(self, value):
        value.parent = self
        self._Group.append(value)
    def insert_Group_at(self, index, value):
        value.parent = self
        self.Group.insert(index, value)
    def replace_Group_at(self, index, value):
        value.parent = self
        self.Group[index] = value
    Group = property(get_Group, set_Group)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Group
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Groups', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Groups')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Groups')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Groups', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Groups'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Groups', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Group_ in self.Group:
            Group_.export(outfile, level, namespaceprefix_, name_='Group', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Groups', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for Group_ in self.Group:
            Group_.to_etree(element, name_='Group', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Groups'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Group=[\n')
        level += 1
        for Group_ in self.Group:
            showIndent(outfile, level)
            outfile.write('model_._Group(\n')
            Group_.exportLiteral(outfile, level, name_='_Group')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.Group = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Group':
            obj_ = create_Group.factory()
            obj_.build(child_)
            self.add_Group(obj_)
            obj_.original_tagname_ = 'Group'
# end class create_Groups


class create_Group(GeneratedsSuper):
    """Name. (optional) Name. (optional) DO NOT MODIFY! DO NOT MODIFY!
    Defines how this group behaves toward the DEM, including being
    an element of the DEM. Defines how this group behaves toward the
    DEM, including being an element of the DEM. Hidden object/groups
    Hidden object/groups Use for computing LAI Use for computing LAI"""
    subclass = None
    superclass = None
    def __init__(self, num=1, name='Group', hasElements=0, groupDEMMode=0, hidden=0, isLAICalc=0, PropertiesForObject3DTurbidWithLAD=None, PropertiesForObject3DTurbid=None, GroupOpticalProperties=None, GroupTypeProperties=None, Elements=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_Group")
        self.attrib = ['num', 'name', 'hasElements', 'groupDEMMode', 'hidden', 'isLAICalc']
        self.children = ['PropertiesForObject3DTurbidWithLAD', 'PropertiesForObject3DTurbid', 'GroupOpticalProperties', 'GroupTypeProperties', 'Elements']
        self.parent = None
        self._num = _cast(int, num)
        self._name = _cast(None, name)
        self._hasElements = _cast(int, hasElements)
        self._groupDEMMode = _cast(int, groupDEMMode)
        self._hidden = _cast(int, hidden)
        self._isLAICalc = _cast(int, isLAICalc)
        self._PropertiesForObject3DTurbidWithLAD = PropertiesForObject3DTurbidWithLAD
        self._PropertiesForObject3DTurbid = PropertiesForObject3DTurbid
        self._GroupOpticalProperties = GroupOpticalProperties
        self._GroupTypeProperties = GroupTypeProperties
        self._Elements = Elements
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Group)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Group.subclass:
            return create_Group.subclass(*args_, **kwargs_)
        else:
            return create_Group(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PropertiesForObject3DTurbidWithLAD(self): return self._PropertiesForObject3DTurbidWithLAD
    def set_PropertiesForObject3DTurbidWithLAD(self, value):
        if value is not None:
            checkclass(value, create_PropertiesForObject3DTurbidWithLAD)
            value.parent = self
        self._PropertiesForObject3DTurbidWithLAD = value
    PropertiesForObject3DTurbidWithLAD = property(get_PropertiesForObject3DTurbidWithLAD, set_PropertiesForObject3DTurbidWithLAD)
    def get_PropertiesForObject3DTurbid(self): return self._PropertiesForObject3DTurbid
    def set_PropertiesForObject3DTurbid(self, value):
        if value is not None:
            checkclass(value, create_PropertiesForObject3DTurbid)
            value.parent = self
        self._PropertiesForObject3DTurbid = value
    PropertiesForObject3DTurbid = property(get_PropertiesForObject3DTurbid, set_PropertiesForObject3DTurbid)
    def get_GroupOpticalProperties(self): return self._GroupOpticalProperties
    def set_GroupOpticalProperties(self, value):
        if value is not None:
            checkclass(value, create_GroupOpticalProperties)
            value.parent = self
        self._GroupOpticalProperties = value
    GroupOpticalProperties = property(get_GroupOpticalProperties, set_GroupOpticalProperties)
    def get_GroupTypeProperties(self): return self._GroupTypeProperties
    def set_GroupTypeProperties(self, value):
        if value is not None:
            checkclass(value, create_GroupTypeProperties)
            value.parent = self
        self._GroupTypeProperties = value
    GroupTypeProperties = property(get_GroupTypeProperties, set_GroupTypeProperties)
    def get_Elements(self): return self._Elements
    def set_Elements(self, value):
        if value is not None:
            checkclass(value, create_Elements)
            value.parent = self
        self._Elements = value
    Elements = property(get_Elements, set_Elements)
    def get_num(self): return self._num
    def set_num(self, value):
        self._num = value
        update_node(self,self.troot,"object_3d")
    num = property(get_num, set_num)
    def get_name(self): return self._name
    def set_name(self, value):
        self._name = value
        update_node(self,self.troot,"object_3d")
    name = property(get_name, set_name)
    def get_hasElements(self): return self._hasElements
    def set_hasElements(self, value):
        self._hasElements = value
        update_node(self,self.troot,"object_3d")
    hasElements = property(get_hasElements, set_hasElements)
    def get_groupDEMMode(self): return self._groupDEMMode
    def set_groupDEMMode(self, value):
        self._groupDEMMode = value
        update_node(self,self.troot,"object_3d")
    groupDEMMode = property(get_groupDEMMode, set_groupDEMMode)
    def get_hidden(self): return self._hidden
    def set_hidden(self, value):
        self._hidden = value
        update_node(self,self.troot,"object_3d")
    hidden = property(get_hidden, set_hidden)
    def get_isLAICalc(self): return self._isLAICalc
    def set_isLAICalc(self, value):
        self._isLAICalc = value
        update_node(self,self.troot,"object_3d")
    isLAICalc = property(get_isLAICalc, set_isLAICalc)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.PropertiesForObject3DTurbidWithLAD is not None or
            self.PropertiesForObject3DTurbid is not None or
            self.GroupOpticalProperties is not None or
            self.GroupTypeProperties is not None or
            self.Elements is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Group', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Group')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Group')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Group', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Group'):
        if self.num is not None and 'num' not in already_processed:
            already_processed.add('num')
            outfile.write(' num="%s"' % self.gds_format_integer(self.num, input_name='num'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.hasElements is not None and 'hasElements' not in already_processed:
            already_processed.add('hasElements')
            outfile.write(' hasElements="%s"' % self.gds_format_integer(self.hasElements, input_name='hasElements'))
        if self.groupDEMMode is not None and 'groupDEMMode' not in already_processed:
            already_processed.add('groupDEMMode')
            outfile.write(' groupDEMMode="%s"' % self.gds_format_integer(self.groupDEMMode, input_name='groupDEMMode'))
        if self.hidden is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            outfile.write(' hidden="%s"' % self.gds_format_integer(self.hidden, input_name='hidden'))
        if self.isLAICalc is not None and 'isLAICalc' not in already_processed:
            already_processed.add('isLAICalc')
            outfile.write(' isLAICalc="%s"' % self.gds_format_integer(self.isLAICalc, input_name='isLAICalc'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Group', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PropertiesForObject3DTurbidWithLAD is not None:
            self.PropertiesForObject3DTurbidWithLAD.export(outfile, level, namespaceprefix_, name_='PropertiesForObject3DTurbidWithLAD', pretty_print=pretty_print)
        if self.PropertiesForObject3DTurbid is not None:
            self.PropertiesForObject3DTurbid.export(outfile, level, namespaceprefix_, name_='PropertiesForObject3DTurbid', pretty_print=pretty_print)
        if self.GroupOpticalProperties is not None:
            self.GroupOpticalProperties.export(outfile, level, namespaceprefix_, name_='GroupOpticalProperties', pretty_print=pretty_print)
        if self.GroupTypeProperties is not None:
            self.GroupTypeProperties.export(outfile, level, namespaceprefix_, name_='GroupTypeProperties', pretty_print=pretty_print)
        if self.Elements is not None:
            self.Elements.export(outfile, level, namespaceprefix_, name_='Elements', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Group', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.num is not None:
            element.set('num', self.gds_format_integer(self.num))
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.hasElements is not None:
            element.set('hasElements', self.gds_format_integer(self.hasElements))
        if self.groupDEMMode is not None:
            element.set('groupDEMMode', self.gds_format_integer(self.groupDEMMode))
        if self.hidden is not None:
            element.set('hidden', self.gds_format_integer(self.hidden))
        if self.isLAICalc is not None:
            element.set('isLAICalc', self.gds_format_integer(self.isLAICalc))
        if self.PropertiesForObject3DTurbidWithLAD is not None:
            PropertiesForObject3DTurbidWithLAD_ = self.PropertiesForObject3DTurbidWithLAD
            PropertiesForObject3DTurbidWithLAD_.to_etree(element, name_='PropertiesForObject3DTurbidWithLAD', mapping_=mapping_)
        if self.PropertiesForObject3DTurbid is not None:
            PropertiesForObject3DTurbid_ = self.PropertiesForObject3DTurbid
            PropertiesForObject3DTurbid_.to_etree(element, name_='PropertiesForObject3DTurbid', mapping_=mapping_)
        if self.GroupOpticalProperties is not None:
            GroupOpticalProperties_ = self.GroupOpticalProperties
            GroupOpticalProperties_.to_etree(element, name_='GroupOpticalProperties', mapping_=mapping_)
        if self.GroupTypeProperties is not None:
            GroupTypeProperties_ = self.GroupTypeProperties
            GroupTypeProperties_.to_etree(element, name_='GroupTypeProperties', mapping_=mapping_)
        if self.Elements is not None:
            Elements_ = self.Elements
            Elements_.to_etree(element, name_='Elements', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Group'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.num is not None and 'num' not in already_processed:
            already_processed.add('num')
            showIndent(outfile, level)
            outfile.write('num=%d,\n' % (self.num,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.hasElements is not None and 'hasElements' not in already_processed:
            already_processed.add('hasElements')
            showIndent(outfile, level)
            outfile.write('hasElements=%d,\n' % (self.hasElements,))
        if self.groupDEMMode is not None and 'groupDEMMode' not in already_processed:
            already_processed.add('groupDEMMode')
            showIndent(outfile, level)
            outfile.write('groupDEMMode=%d,\n' % (self.groupDEMMode,))
        if self.hidden is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            showIndent(outfile, level)
            outfile.write('hidden=%d,\n' % (self.hidden,))
        if self.isLAICalc is not None and 'isLAICalc' not in already_processed:
            already_processed.add('isLAICalc')
            showIndent(outfile, level)
            outfile.write('isLAICalc=%d,\n' % (self.isLAICalc,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PropertiesForObject3DTurbidWithLAD is not None:
            showIndent(outfile, level)
            outfile.write('PropertiesForObject3DTurbidWithLAD=model_._PropertiesForObject3DTurbidWithLAD(\n')
            self.PropertiesForObject3DTurbidWithLAD.exportLiteral(outfile, level, name_='PropertiesForObject3DTurbidWithLAD')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PropertiesForObject3DTurbid is not None:
            showIndent(outfile, level)
            outfile.write('PropertiesForObject3DTurbid=model_._PropertiesForObject3DTurbid(\n')
            self.PropertiesForObject3DTurbid.exportLiteral(outfile, level, name_='PropertiesForObject3DTurbid')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GroupOpticalProperties is not None:
            showIndent(outfile, level)
            outfile.write('GroupOpticalProperties=model_._GroupOpticalProperties(\n')
            self.GroupOpticalProperties.exportLiteral(outfile, level, name_='GroupOpticalProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GroupTypeProperties is not None:
            showIndent(outfile, level)
            outfile.write('GroupTypeProperties=model_._GroupTypeProperties(\n')
            self.GroupTypeProperties.exportLiteral(outfile, level, name_='GroupTypeProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Elements is not None:
            showIndent(outfile, level)
            outfile.write('Elements=model_._Elements(\n')
            self.Elements.exportLiteral(outfile, level, name_='Elements')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('num', node)
        if value is not None and 'num' not in already_processed:
            already_processed.add('num')
            try:
                self.num = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('hasElements', node)
        if value is not None and 'hasElements' not in already_processed:
            already_processed.add('hasElements')
            try:
                self.hasElements = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('groupDEMMode', node)
        if value is not None and 'groupDEMMode' not in already_processed:
            already_processed.add('groupDEMMode')
            try:
                self.groupDEMMode = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('hidden', node)
        if value is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            try:
                self.hidden = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isLAICalc', node)
        if value is not None and 'isLAICalc' not in already_processed:
            already_processed.add('isLAICalc')
            try:
                self.isLAICalc = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PropertiesForObject3DTurbidWithLAD':
            obj_ = create_PropertiesForObject3DTurbidWithLAD.factory()
            obj_.build(child_)
            self.set_PropertiesForObject3DTurbidWithLAD(obj_)
            obj_.original_tagname_ = 'PropertiesForObject3DTurbidWithLAD'
        elif nodeName_ == 'PropertiesForObject3DTurbid':
            obj_ = create_PropertiesForObject3DTurbid.factory()
            obj_.build(child_)
            self.set_PropertiesForObject3DTurbid(obj_)
            obj_.original_tagname_ = 'PropertiesForObject3DTurbid'
        elif nodeName_ == 'GroupOpticalProperties':
            obj_ = create_GroupOpticalProperties.factory()
            obj_.build(child_)
            self.set_GroupOpticalProperties(obj_)
            obj_.original_tagname_ = 'GroupOpticalProperties'
        elif nodeName_ == 'GroupTypeProperties':
            obj_ = create_GroupTypeProperties.factory()
            obj_.build(child_)
            self.set_GroupTypeProperties(obj_)
            obj_.original_tagname_ = 'GroupTypeProperties'
        elif nodeName_ == 'Elements':
            obj_ = create_Elements.factory()
            obj_.build(child_)
            self.set_Elements(obj_)
            obj_.original_tagname_ = 'Elements'
# end class create_Group


class create_GroupOpticalProperties(GeneratedsSuper):
    """Apply this optical property to all this group's elements.\nReplace
    any previously defined property. Apply this optical property to
    all this group's elements.\nReplace any previously defined
    property. Check this option if you want to apply optical
    properties on each face of the triangles that make up the 3D
    object.\nIf this option is unchecked, a ray incident on the
    triangle face opposite to the triangle normal is stopped/lost,
    whatever the DART mode (R or T). Check this option if you want
    to apply optical properties on each face of the triangles that
    make up the 3D object.\nIf this option is unchecked, a ray
    incident on the triangle face opposite to the triangle normal is
    stopped/lost, whatever the DART mode (R or T)."""
    subclass = None
    superclass = None
    def __init__(self, sameOPGroup=1, doubleFace=1, OpticalPropertyLink=None, ThermalPropertyLink=None, BackFaceOpticalProperty=None, BackFaceThermalProperty=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_GroupOpticalProperties")
        self.attrib = ['sameOPGroup', 'doubleFace']
        self.children = ['OpticalPropertyLink', 'ThermalPropertyLink', 'BackFaceOpticalProperty', 'BackFaceThermalProperty']
        self.parent = None
        self._sameOPGroup = _cast(int, sameOPGroup)
        self._doubleFace = _cast(int, doubleFace)
        self._OpticalPropertyLink = OpticalPropertyLink
        self._ThermalPropertyLink = ThermalPropertyLink
        self._BackFaceOpticalProperty = BackFaceOpticalProperty
        self._BackFaceThermalProperty = BackFaceThermalProperty
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_GroupOpticalProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_GroupOpticalProperties.subclass:
            return create_GroupOpticalProperties.subclass(*args_, **kwargs_)
        else:
            return create_GroupOpticalProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OpticalPropertyLink(self): return self._OpticalPropertyLink
    def set_OpticalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_OpticalPropertyLink)
            value.parent = self
        self._OpticalPropertyLink = value
    OpticalPropertyLink = property(get_OpticalPropertyLink, set_OpticalPropertyLink)
    def get_ThermalPropertyLink(self): return self._ThermalPropertyLink
    def set_ThermalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_ThermalPropertyLink)
            value.parent = self
        self._ThermalPropertyLink = value
    ThermalPropertyLink = property(get_ThermalPropertyLink, set_ThermalPropertyLink)
    def get_BackFaceOpticalProperty(self): return self._BackFaceOpticalProperty
    def set_BackFaceOpticalProperty(self, value):
        if value is not None:
            checkclass(value, create_BackFaceOpticalProperty)
            value.parent = self
        self._BackFaceOpticalProperty = value
    BackFaceOpticalProperty = property(get_BackFaceOpticalProperty, set_BackFaceOpticalProperty)
    def get_BackFaceThermalProperty(self): return self._BackFaceThermalProperty
    def set_BackFaceThermalProperty(self, value):
        if value is not None:
            checkclass(value, create_BackFaceThermalProperty)
            value.parent = self
        self._BackFaceThermalProperty = value
    BackFaceThermalProperty = property(get_BackFaceThermalProperty, set_BackFaceThermalProperty)
    def get_sameOPGroup(self): return self._sameOPGroup
    def set_sameOPGroup(self, value):
        self._sameOPGroup = value
        update_node(self,self.troot,"object_3d")
    sameOPGroup = property(get_sameOPGroup, set_sameOPGroup)
    def get_doubleFace(self): return self._doubleFace
    def set_doubleFace(self, value):
        self._doubleFace = value
        update_node(self,self.troot,"object_3d")
    doubleFace = property(get_doubleFace, set_doubleFace)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.OpticalPropertyLink is not None or
            self.ThermalPropertyLink is not None or
            self.BackFaceOpticalProperty is not None or
            self.BackFaceThermalProperty is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_GroupOpticalProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_GroupOpticalProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_GroupOpticalProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_GroupOpticalProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_GroupOpticalProperties'):
        if self.sameOPGroup is not None and 'sameOPGroup' not in already_processed:
            already_processed.add('sameOPGroup')
            outfile.write(' sameOPGroup="%s"' % self.gds_format_integer(self.sameOPGroup, input_name='sameOPGroup'))
        if self.doubleFace is not None and 'doubleFace' not in already_processed:
            already_processed.add('doubleFace')
            outfile.write(' doubleFace="%s"' % self.gds_format_integer(self.doubleFace, input_name='doubleFace'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_GroupOpticalProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OpticalPropertyLink is not None:
            self.OpticalPropertyLink.export(outfile, level, namespaceprefix_, name_='OpticalPropertyLink', pretty_print=pretty_print)
        if self.ThermalPropertyLink is not None:
            self.ThermalPropertyLink.export(outfile, level, namespaceprefix_, name_='ThermalPropertyLink', pretty_print=pretty_print)
        if self.BackFaceOpticalProperty is not None:
            self.BackFaceOpticalProperty.export(outfile, level, namespaceprefix_, name_='BackFaceOpticalProperty', pretty_print=pretty_print)
        if self.BackFaceThermalProperty is not None:
            self.BackFaceThermalProperty.export(outfile, level, namespaceprefix_, name_='BackFaceThermalProperty', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_GroupOpticalProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.sameOPGroup is not None:
            element.set('sameOPGroup', self.gds_format_integer(self.sameOPGroup))
        if self.doubleFace is not None:
            element.set('doubleFace', self.gds_format_integer(self.doubleFace))
        if self.OpticalPropertyLink is not None:
            OpticalPropertyLink_ = self.OpticalPropertyLink
            OpticalPropertyLink_.to_etree(element, name_='OpticalPropertyLink', mapping_=mapping_)
        if self.ThermalPropertyLink is not None:
            ThermalPropertyLink_ = self.ThermalPropertyLink
            ThermalPropertyLink_.to_etree(element, name_='ThermalPropertyLink', mapping_=mapping_)
        if self.BackFaceOpticalProperty is not None:
            BackFaceOpticalProperty_ = self.BackFaceOpticalProperty
            BackFaceOpticalProperty_.to_etree(element, name_='BackFaceOpticalProperty', mapping_=mapping_)
        if self.BackFaceThermalProperty is not None:
            BackFaceThermalProperty_ = self.BackFaceThermalProperty
            BackFaceThermalProperty_.to_etree(element, name_='BackFaceThermalProperty', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_GroupOpticalProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sameOPGroup is not None and 'sameOPGroup' not in already_processed:
            already_processed.add('sameOPGroup')
            showIndent(outfile, level)
            outfile.write('sameOPGroup=%d,\n' % (self.sameOPGroup,))
        if self.doubleFace is not None and 'doubleFace' not in already_processed:
            already_processed.add('doubleFace')
            showIndent(outfile, level)
            outfile.write('doubleFace=%d,\n' % (self.doubleFace,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.OpticalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('OpticalPropertyLink=model_._OpticalPropertyLink(\n')
            self.OpticalPropertyLink.exportLiteral(outfile, level, name_='OpticalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ThermalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('ThermalPropertyLink=model_._ThermalPropertyLink(\n')
            self.ThermalPropertyLink.exportLiteral(outfile, level, name_='ThermalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BackFaceOpticalProperty is not None:
            showIndent(outfile, level)
            outfile.write('BackFaceOpticalProperty=model_._BackFaceOpticalProperty(\n')
            self.BackFaceOpticalProperty.exportLiteral(outfile, level, name_='BackFaceOpticalProperty')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BackFaceThermalProperty is not None:
            showIndent(outfile, level)
            outfile.write('BackFaceThermalProperty=model_._BackFaceThermalProperty(\n')
            self.BackFaceThermalProperty.exportLiteral(outfile, level, name_='BackFaceThermalProperty')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sameOPGroup', node)
        if value is not None and 'sameOPGroup' not in already_processed:
            already_processed.add('sameOPGroup')
            try:
                self.sameOPGroup = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('doubleFace', node)
        if value is not None and 'doubleFace' not in already_processed:
            already_processed.add('doubleFace')
            try:
                self.doubleFace = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OpticalPropertyLink':
            obj_ = create_OpticalPropertyLink.factory()
            obj_.build(child_)
            self.set_OpticalPropertyLink(obj_)
            obj_.original_tagname_ = 'OpticalPropertyLink'
        elif nodeName_ == 'ThermalPropertyLink':
            obj_ = create_ThermalPropertyLink.factory()
            obj_.build(child_)
            self.set_ThermalPropertyLink(obj_)
            obj_.original_tagname_ = 'ThermalPropertyLink'
        elif nodeName_ == 'BackFaceOpticalProperty':
            obj_ = create_BackFaceOpticalProperty.factory()
            obj_.build(child_)
            self.set_BackFaceOpticalProperty(obj_)
            obj_.original_tagname_ = 'BackFaceOpticalProperty'
        elif nodeName_ == 'BackFaceThermalProperty':
            obj_ = create_BackFaceThermalProperty.factory()
            obj_.build(child_)
            self.set_BackFaceThermalProperty(obj_)
            obj_.original_tagname_ = 'BackFaceThermalProperty'
# end class create_GroupOpticalProperties


class create_GroupTypeProperties(GeneratedsSuper):
    """Define the color/name at the group's level, to all its
    elements.\nReplace any previously defined type. Define the
    color/name at the group's level, to all its elements.\nReplace
    any previously defined type."""
    subclass = None
    superclass = None
    def __init__(self, sameOTGroup=1, ObjectTypeLink=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_GroupTypeProperties")
        self.attrib = ['sameOTGroup']
        self.children = ['ObjectTypeLink']
        self.parent = None
        self._sameOTGroup = _cast(int, sameOTGroup)
        self._ObjectTypeLink = ObjectTypeLink
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_GroupTypeProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_GroupTypeProperties.subclass:
            return create_GroupTypeProperties.subclass(*args_, **kwargs_)
        else:
            return create_GroupTypeProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ObjectTypeLink(self): return self._ObjectTypeLink
    def set_ObjectTypeLink(self, value):
        if value is not None:
            checkclass(value, create_ObjectTypeLink)
            value.parent = self
        self._ObjectTypeLink = value
    ObjectTypeLink = property(get_ObjectTypeLink, set_ObjectTypeLink)
    def get_sameOTGroup(self): return self._sameOTGroup
    def set_sameOTGroup(self, value):
        self._sameOTGroup = value
        update_node(self,self.troot,"object_3d")
    sameOTGroup = property(get_sameOTGroup, set_sameOTGroup)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.ObjectTypeLink is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_GroupTypeProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_GroupTypeProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_GroupTypeProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_GroupTypeProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_GroupTypeProperties'):
        if self.sameOTGroup is not None and 'sameOTGroup' not in already_processed:
            already_processed.add('sameOTGroup')
            outfile.write(' sameOTGroup="%s"' % self.gds_format_integer(self.sameOTGroup, input_name='sameOTGroup'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_GroupTypeProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ObjectTypeLink is not None:
            self.ObjectTypeLink.export(outfile, level, namespaceprefix_, name_='ObjectTypeLink', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_GroupTypeProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.sameOTGroup is not None:
            element.set('sameOTGroup', self.gds_format_integer(self.sameOTGroup))
        if self.ObjectTypeLink is not None:
            ObjectTypeLink_ = self.ObjectTypeLink
            ObjectTypeLink_.to_etree(element, name_='ObjectTypeLink', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_GroupTypeProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sameOTGroup is not None and 'sameOTGroup' not in already_processed:
            already_processed.add('sameOTGroup')
            showIndent(outfile, level)
            outfile.write('sameOTGroup=%d,\n' % (self.sameOTGroup,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ObjectTypeLink is not None:
            showIndent(outfile, level)
            outfile.write('ObjectTypeLink=model_._ObjectTypeLink(\n')
            self.ObjectTypeLink.exportLiteral(outfile, level, name_='ObjectTypeLink')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sameOTGroup', node)
        if value is not None and 'sameOTGroup' not in already_processed:
            already_processed.add('sameOTGroup')
            try:
                self.sameOTGroup = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ObjectTypeLink':
            obj_ = create_ObjectTypeLink.factory()
            obj_.build(child_)
            self.set_ObjectTypeLink(obj_)
            obj_.original_tagname_ = 'ObjectTypeLink'
# end class create_GroupTypeProperties


class create_Elements(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Element=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_Elements")
        self.attrib = ['']
        self.children = ['Element']
        self.parent = None
        if Element is None:
            self._Element = []
        else:
            self._Element = Element
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Elements)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Elements.subclass:
            return create_Elements.subclass(*args_, **kwargs_)
        else:
            return create_Elements(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Element(self): return self._Element
    def set_Element(self, value):
        if value is not None:
            checkclass(value, create_Element)
            for v in value:
                v.parent = self
        self._Element = value
    def add_Element(self, value):
        value.parent = self
        self._Element.append(value)
    def insert_Element_at(self, index, value):
        value.parent = self
        self.Element.insert(index, value)
    def replace_Element_at(self, index, value):
        value.parent = self
        self.Element[index] = value
    Element = property(get_Element, set_Element)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Elements', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Elements')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Elements')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Elements', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Elements'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Elements', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Element_ in self.Element:
            Element_.export(outfile, level, namespaceprefix_, name_='Element', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Elements', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for Element_ in self.Element:
            Element_.to_etree(element, name_='Element', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Elements'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Element=[\n')
        level += 1
        for Element_ in self.Element:
            showIndent(outfile, level)
            outfile.write('model_._Element(\n')
            Element_.exportLiteral(outfile, level, name_='_Element')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.Element = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Element':
            obj_ = create_Element.factory()
            obj_.build(child_)
            self.add_Element(obj_)
            obj_.original_tagname_ = 'Element'
# end class create_Elements


class create_Element(GeneratedsSuper):
    """Name. (optional) Name. (optional) Check this option if you want to
    apply optical properties on each face of the triangles that make
    up the 3D object.\nIf this option is unchecked, a ray incident
    on the triangle face opposite to the triangle normal is
    stopped/lost, whatever the DART mode (R or T). Check this option
    if you want to apply optical properties on each face of the
    triangles that make up the 3D object.\nIf this option is
    unchecked, a ray incident on the triangle face opposite to the
    triangle normal is stopped/lost, whatever the DART mode (R or
    T)."""
    subclass = None
    superclass = None
    def __init__(self, num=2, name='Element', doubleFace=1, ObjectTypeLink=None, OpticalPropertyLink=None, ThermalPropertyLink=None, BackFaceOpticalProperty=None, BackFaceThermalProperty=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_Element")
        self.attrib = ['num', 'name', 'doubleFace']
        self.children = ['ObjectTypeLink', 'OpticalPropertyLink', 'ThermalPropertyLink', 'BackFaceOpticalProperty', 'BackFaceThermalProperty']
        self.parent = None
        self._num = _cast(int, num)
        self._name = _cast(None, name)
        self._doubleFace = _cast(int, doubleFace)
        self._ObjectTypeLink = ObjectTypeLink
        self._OpticalPropertyLink = OpticalPropertyLink
        self._ThermalPropertyLink = ThermalPropertyLink
        self._BackFaceOpticalProperty = BackFaceOpticalProperty
        self._BackFaceThermalProperty = BackFaceThermalProperty
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Element)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Element.subclass:
            return create_Element.subclass(*args_, **kwargs_)
        else:
            return create_Element(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ObjectTypeLink(self): return self._ObjectTypeLink
    def set_ObjectTypeLink(self, value):
        if value is not None:
            checkclass(value, create_ObjectTypeLink)
            value.parent = self
        self._ObjectTypeLink = value
    ObjectTypeLink = property(get_ObjectTypeLink, set_ObjectTypeLink)
    def get_OpticalPropertyLink(self): return self._OpticalPropertyLink
    def set_OpticalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_OpticalPropertyLink)
            value.parent = self
        self._OpticalPropertyLink = value
    OpticalPropertyLink = property(get_OpticalPropertyLink, set_OpticalPropertyLink)
    def get_ThermalPropertyLink(self): return self._ThermalPropertyLink
    def set_ThermalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_ThermalPropertyLink)
            value.parent = self
        self._ThermalPropertyLink = value
    ThermalPropertyLink = property(get_ThermalPropertyLink, set_ThermalPropertyLink)
    def get_BackFaceOpticalProperty(self): return self._BackFaceOpticalProperty
    def set_BackFaceOpticalProperty(self, value):
        if value is not None:
            checkclass(value, create_BackFaceOpticalProperty)
            value.parent = self
        self._BackFaceOpticalProperty = value
    BackFaceOpticalProperty = property(get_BackFaceOpticalProperty, set_BackFaceOpticalProperty)
    def get_BackFaceThermalProperty(self): return self._BackFaceThermalProperty
    def set_BackFaceThermalProperty(self, value):
        if value is not None:
            checkclass(value, create_BackFaceThermalProperty)
            value.parent = self
        self._BackFaceThermalProperty = value
    BackFaceThermalProperty = property(get_BackFaceThermalProperty, set_BackFaceThermalProperty)
    def get_num(self): return self._num
    def set_num(self, value):
        self._num = value
        update_node(self,self.troot,"object_3d")
    num = property(get_num, set_num)
    def get_name(self): return self._name
    def set_name(self, value):
        self._name = value
        update_node(self,self.troot,"object_3d")
    name = property(get_name, set_name)
    def get_doubleFace(self): return self._doubleFace
    def set_doubleFace(self, value):
        self._doubleFace = value
        update_node(self,self.troot,"object_3d")
    doubleFace = property(get_doubleFace, set_doubleFace)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.ObjectTypeLink is not None or
            self.OpticalPropertyLink is not None or
            self.ThermalPropertyLink is not None or
            self.BackFaceOpticalProperty is not None or
            self.BackFaceThermalProperty is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Element', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Element')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Element')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Element', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Element'):
        if self.num is not None and 'num' not in already_processed:
            already_processed.add('num')
            outfile.write(' num="%s"' % self.gds_format_integer(self.num, input_name='num'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.doubleFace is not None and 'doubleFace' not in already_processed:
            already_processed.add('doubleFace')
            outfile.write(' doubleFace="%s"' % self.gds_format_integer(self.doubleFace, input_name='doubleFace'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Element', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ObjectTypeLink is not None:
            self.ObjectTypeLink.export(outfile, level, namespaceprefix_, name_='ObjectTypeLink', pretty_print=pretty_print)
        if self.OpticalPropertyLink is not None:
            self.OpticalPropertyLink.export(outfile, level, namespaceprefix_, name_='OpticalPropertyLink', pretty_print=pretty_print)
        if self.ThermalPropertyLink is not None:
            self.ThermalPropertyLink.export(outfile, level, namespaceprefix_, name_='ThermalPropertyLink', pretty_print=pretty_print)
        if self.BackFaceOpticalProperty is not None:
            self.BackFaceOpticalProperty.export(outfile, level, namespaceprefix_, name_='BackFaceOpticalProperty', pretty_print=pretty_print)
        if self.BackFaceThermalProperty is not None:
            self.BackFaceThermalProperty.export(outfile, level, namespaceprefix_, name_='BackFaceThermalProperty', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Element', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.num is not None:
            element.set('num', self.gds_format_integer(self.num))
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.doubleFace is not None:
            element.set('doubleFace', self.gds_format_integer(self.doubleFace))
        if self.ObjectTypeLink is not None:
            ObjectTypeLink_ = self.ObjectTypeLink
            ObjectTypeLink_.to_etree(element, name_='ObjectTypeLink', mapping_=mapping_)
        if self.OpticalPropertyLink is not None:
            OpticalPropertyLink_ = self.OpticalPropertyLink
            OpticalPropertyLink_.to_etree(element, name_='OpticalPropertyLink', mapping_=mapping_)
        if self.ThermalPropertyLink is not None:
            ThermalPropertyLink_ = self.ThermalPropertyLink
            ThermalPropertyLink_.to_etree(element, name_='ThermalPropertyLink', mapping_=mapping_)
        if self.BackFaceOpticalProperty is not None:
            BackFaceOpticalProperty_ = self.BackFaceOpticalProperty
            BackFaceOpticalProperty_.to_etree(element, name_='BackFaceOpticalProperty', mapping_=mapping_)
        if self.BackFaceThermalProperty is not None:
            BackFaceThermalProperty_ = self.BackFaceThermalProperty
            BackFaceThermalProperty_.to_etree(element, name_='BackFaceThermalProperty', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Element'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.num is not None and 'num' not in already_processed:
            already_processed.add('num')
            showIndent(outfile, level)
            outfile.write('num=%d,\n' % (self.num,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.doubleFace is not None and 'doubleFace' not in already_processed:
            already_processed.add('doubleFace')
            showIndent(outfile, level)
            outfile.write('doubleFace=%d,\n' % (self.doubleFace,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ObjectTypeLink is not None:
            showIndent(outfile, level)
            outfile.write('ObjectTypeLink=model_._ObjectTypeLink(\n')
            self.ObjectTypeLink.exportLiteral(outfile, level, name_='ObjectTypeLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OpticalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('OpticalPropertyLink=model_._OpticalPropertyLink(\n')
            self.OpticalPropertyLink.exportLiteral(outfile, level, name_='OpticalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ThermalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('ThermalPropertyLink=model_._ThermalPropertyLink(\n')
            self.ThermalPropertyLink.exportLiteral(outfile, level, name_='ThermalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BackFaceOpticalProperty is not None:
            showIndent(outfile, level)
            outfile.write('BackFaceOpticalProperty=model_._BackFaceOpticalProperty(\n')
            self.BackFaceOpticalProperty.exportLiteral(outfile, level, name_='BackFaceOpticalProperty')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BackFaceThermalProperty is not None:
            showIndent(outfile, level)
            outfile.write('BackFaceThermalProperty=model_._BackFaceThermalProperty(\n')
            self.BackFaceThermalProperty.exportLiteral(outfile, level, name_='BackFaceThermalProperty')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('num', node)
        if value is not None and 'num' not in already_processed:
            already_processed.add('num')
            try:
                self.num = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('doubleFace', node)
        if value is not None and 'doubleFace' not in already_processed:
            already_processed.add('doubleFace')
            try:
                self.doubleFace = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ObjectTypeLink':
            obj_ = create_ObjectTypeLink.factory()
            obj_.build(child_)
            self.set_ObjectTypeLink(obj_)
            obj_.original_tagname_ = 'ObjectTypeLink'
        elif nodeName_ == 'OpticalPropertyLink':
            obj_ = create_OpticalPropertyLink.factory()
            obj_.build(child_)
            self.set_OpticalPropertyLink(obj_)
            obj_.original_tagname_ = 'OpticalPropertyLink'
        elif nodeName_ == 'ThermalPropertyLink':
            obj_ = create_ThermalPropertyLink.factory()
            obj_.build(child_)
            self.set_ThermalPropertyLink(obj_)
            obj_.original_tagname_ = 'ThermalPropertyLink'
        elif nodeName_ == 'BackFaceOpticalProperty':
            obj_ = create_BackFaceOpticalProperty.factory()
            obj_.build(child_)
            self.set_BackFaceOpticalProperty(obj_)
            obj_.original_tagname_ = 'BackFaceOpticalProperty'
        elif nodeName_ == 'BackFaceThermalProperty':
            obj_ = create_BackFaceThermalProperty.factory()
            obj_.build(child_)
            self.set_BackFaceThermalProperty(obj_)
            obj_.original_tagname_ = 'BackFaceThermalProperty'
# end class create_Element


class create_ObjectFields(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Field=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_ObjectFields")
        self.attrib = ['']
        self.children = ['Field']
        self.parent = None
        if Field is None:
            self._Field = []
        else:
            self._Field = Field
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ObjectFields)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ObjectFields.subclass:
            return create_ObjectFields.subclass(*args_, **kwargs_)
        else:
            return create_ObjectFields(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Field(self): return self._Field
    def set_Field(self, value):
        if value is not None:
            checkclass(value, create_Field)
            for v in value:
                v.parent = self
        self._Field = value
    def add_Field(self, value):
        value.parent = self
        self._Field.append(value)
    def insert_Field_at(self, index, value):
        value.parent = self
        self.Field.insert(index, value)
    def replace_Field_at(self, index, value):
        value.parent = self
        self.Field[index] = value
    Field = property(get_Field, set_Field)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Field
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ObjectFields', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ObjectFields')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ObjectFields')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ObjectFields', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ObjectFields'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ObjectFields', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Field_ in self.Field:
            Field_.export(outfile, level, namespaceprefix_, name_='Field', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_ObjectFields', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for Field_ in self.Field:
            Field_.to_etree(element, name_='Field', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ObjectFields'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Field=[\n')
        level += 1
        for Field_ in self.Field:
            showIndent(outfile, level)
            outfile.write('model_._Field(\n')
            Field_.exportLiteral(outfile, level, name_='_Field')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.Field = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Field':
            obj_ = create_Field.factory()
            obj_.build(child_)
            self.add_Field(obj_)
            obj_.original_tagname_ = 'Field'
# end class create_ObjectFields


class create_Field(GeneratedsSuper):
    """The file must contain : Object number, X position, Y position. The
    file must contain : Object number, X position, Y position. Name.
    (optional) Name. (optional) Objects's positions are taken from
    the position file.\nDesactivate this option if you experience
    some slowdown. Objects's positions are taken from the position
    file.\nDesactivate this option if you experience some slowdown."""
    subclass = None
    superclass = None
    def __init__(self, fieldDescriptionFileName='ObjectField.txt', name='Field', showObjectPositions=0, ModelList=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_Field")
        self.attrib = ['fieldDescriptionFileName', 'name', 'showObjectPositions']
        self.children = ['ModelList']
        self.parent = None
        self._fieldDescriptionFileName = _cast(None, fieldDescriptionFileName)
        self._name = _cast(None, name)
        self._showObjectPositions = _cast(int, showObjectPositions)
        self._ModelList = ModelList
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Field)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Field.subclass:
            return create_Field.subclass(*args_, **kwargs_)
        else:
            return create_Field(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ModelList(self): return self._ModelList
    def set_ModelList(self, value):
        if value is not None:
            checkclass(value, create_ModelList)
            value.parent = self
        self._ModelList = value
    ModelList = property(get_ModelList, set_ModelList)
    def get_fieldDescriptionFileName(self): return self._fieldDescriptionFileName
    def set_fieldDescriptionFileName(self, value):
        self._fieldDescriptionFileName = value
        update_node(self,self.troot,"object_3d")
    fieldDescriptionFileName = property(get_fieldDescriptionFileName, set_fieldDescriptionFileName)
    def get_name(self): return self._name
    def set_name(self, value):
        self._name = value
        update_node(self,self.troot,"object_3d")
    name = property(get_name, set_name)
    def get_showObjectPositions(self): return self._showObjectPositions
    def set_showObjectPositions(self, value):
        self._showObjectPositions = value
        update_node(self,self.troot,"object_3d")
    showObjectPositions = property(get_showObjectPositions, set_showObjectPositions)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.ModelList is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Field', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Field')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Field')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Field', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Field'):
        if self.fieldDescriptionFileName is not None and 'fieldDescriptionFileName' not in already_processed:
            already_processed.add('fieldDescriptionFileName')
            outfile.write(' fieldDescriptionFileName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fieldDescriptionFileName), input_name='fieldDescriptionFileName')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.showObjectPositions is not None and 'showObjectPositions' not in already_processed:
            already_processed.add('showObjectPositions')
            outfile.write(' showObjectPositions="%s"' % self.gds_format_integer(self.showObjectPositions, input_name='showObjectPositions'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Field', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ModelList is not None:
            self.ModelList.export(outfile, level, namespaceprefix_, name_='ModelList', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Field', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.fieldDescriptionFileName is not None:
            element.set('fieldDescriptionFileName', self.gds_format_string(self.fieldDescriptionFileName))
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.showObjectPositions is not None:
            element.set('showObjectPositions', self.gds_format_integer(self.showObjectPositions))
        if self.ModelList is not None:
            ModelList_ = self.ModelList
            ModelList_.to_etree(element, name_='ModelList', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Field'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.fieldDescriptionFileName is not None and 'fieldDescriptionFileName' not in already_processed:
            already_processed.add('fieldDescriptionFileName')
            showIndent(outfile, level)
            outfile.write('fieldDescriptionFileName="%s",\n' % (self.fieldDescriptionFileName,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.showObjectPositions is not None and 'showObjectPositions' not in already_processed:
            already_processed.add('showObjectPositions')
            showIndent(outfile, level)
            outfile.write('showObjectPositions=%d,\n' % (self.showObjectPositions,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ModelList is not None:
            showIndent(outfile, level)
            outfile.write('ModelList=model_._ModelList(\n')
            self.ModelList.exportLiteral(outfile, level, name_='ModelList')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fieldDescriptionFileName', node)
        if value is not None and 'fieldDescriptionFileName' not in already_processed:
            already_processed.add('fieldDescriptionFileName')
            self.fieldDescriptionFileName = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('showObjectPositions', node)
        if value is not None and 'showObjectPositions' not in already_processed:
            already_processed.add('showObjectPositions')
            try:
                self.showObjectPositions = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ModelList':
            obj_ = create_ModelList.factory()
            obj_.build(child_)
            self.set_ModelList(obj_)
            obj_.original_tagname_ = 'ModelList'
# end class create_Field


class create_ModelList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Object=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("object_3d","_ModelList")
        self.attrib = ['']
        self.children = ['Object']
        self.parent = None
        if Object is None:
            self._Object = []
        else:
            self._Object = Object
        update_node(self,self.troot,"object_3d")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ModelList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ModelList.subclass:
            return create_ModelList.subclass(*args_, **kwargs_)
        else:
            return create_ModelList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Object(self): return self._Object
    def set_Object(self, value):
        if value is not None:
            checkclass(value, create_Object)
            for v in value:
                v.parent = self
        self._Object = value
    def add_Object(self, value):
        value.parent = self
        self._Object.append(value)
    def insert_Object_at(self, index, value):
        value.parent = self
        self.Object.insert(index, value)
    def replace_Object_at(self, index, value):
        value.parent = self
        self.Object[index] = value
    Object = property(get_Object, set_Object)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Object
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ModelList', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ModelList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ModelList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ModelList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ModelList'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ModelList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Object_ in self.Object:
            Object_.export(outfile, level, namespaceprefix_, name_='Object', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_ModelList', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for Object_ in self.Object:
            Object_.to_etree(element, name_='Object', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ModelList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Object=[\n')
        level += 1
        for Object_ in self.Object:
            showIndent(outfile, level)
            outfile.write('model_._Object(\n')
            Object_.exportLiteral(outfile, level, name_='_Object')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.Object = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Object':
            obj_ = create_Object.factory()
            obj_.build(child_)
            self.add_Object(obj_)
            obj_.original_tagname_ = 'Object'
# end class create_ModelList


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <createParser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from object_3d import *\n\n')
        sys.stdout.write('import object_3d as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "createDartFile",
    "create_BackFaceOpticalProperty",
    "create_BackFaceThermalProperty",
    "create_CustomTypes",
    "create_DefaultType",
    "create_DefaultTypes",
    "create_Dimension3D",
    "create_Element",
    "create_Elements",
    "create_Field",
    "create_ForcedLAINode",
    "create_ForcedTotalSurfaceNode",
    "create_GeometricProperties",
    "create_Group",
    "create_GroupOpticalProperties",
    "create_GroupTypeProperties",
    "create_Groups",
    "create_LAIPropertyNode",
    "create_ModelList",
    "create_MultiplicativeLAINode",
    "create_Object",
    "create_ObjectFields",
    "create_ObjectList",
    "create_ObjectOpticalProperties",
    "create_ObjectTypeLink",
    "create_ObjectTypeProperties",
    "create_OpticalPropertyLink",
    "create_PositionProperties",
    "create_PropertiesForObject3DTurbid",
    "create_PropertiesForObject3DTurbidWithLAD",
    "create_RotationProperties",
    "create_ScaleProperties",
    "create_SingleGlobalLAIPropertyNode",
    "create_ThermalPropertyLink",
    "create_Type",
    "create_Types",
    "create_VegetationOpticalPropertyLink",
    "create_object_3d"
]
