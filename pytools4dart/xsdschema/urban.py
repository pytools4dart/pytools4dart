#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Oct 31 15:06:24 2018 by generateDS.py version 2.29.25.
# Python 2.7.15rc1 (default, Apr 15 2018, 21:51:34)  [GCC 7.3.0]
#
# Command line options:
#   ('-m', '')
#   ('--always-export-default', '')
#   ('--export', 'write literal etree')
#   ('-p', 'create')
#   ('--post-attrib-setter', 'update_node(self,self.troot,"urban")')
#   ('--pre-ctor', 'self.troot=get_gs_troot("urban","{classname}")')
#   ('--post-ctor', 'update_node(self,self.troot,"urban")')
#   ('--imports', 'from pytools4dart.xsdschema.utils import get_gs_troot, update_node')
#   ('-o', '/home/claudia/tmp/urban.py')
#
# Command line arguments:
#   /home/claudia/DEV/pytools4dartMTD/pytools4dart/xsdschema/urban.xsd
#
# Command line:
#   /home/claudia/DEV/pytools4dartMTD/venv/bin/generateDS.py -m --always-export-default --export="write literal etree" -p "create" --post-attrib-setter="update_node(self,self.troot,"urban")" --pre-ctor="self.troot=get_gs_troot("urban","{classname}")" --post-ctor="update_node(self,self.troot,"urban")" --imports="from pytools4dart.xsdschema.utils import get_gs_troot, update_node" -o "/home/claudia/tmp/urban.py" /home/claudia/DEV/pytools4dartMTD/pytools4dart/xsdschema/urban.xsd
#
# Current working directory (os.getcwd()):
#   generateds
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_
from pytools4dart.xsdschema.utils import get_gs_troot, update_node


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#

def checkclass(value, cl):
    if isinstance(value, list):
        for v in value:
            if not isinstance(v, cl):
                raise ValueError("invalid class")
    else:
        if not isinstance(value, cl):
            raise ValueError("invalid class")

def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class createDartFile(GeneratedsSuper):
    """Version of the plots.xml file. Depends of the version on DART
    itself. Version of the plots.xml file. Depends of the version on
    DART itself."""
    subclass = None
    superclass = None
    def __init__(self, version='5.7.1', build_='0', Urban=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("urban","DartFile")
        self.attrib = ['version', 'build_']
        self.children = ['Urban']
        self.parent = None
        self._version = _cast(None, version)
        self._build_ = _cast(None, build_)
        self._Urban = Urban
        update_node(self,self.troot,"urban")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, createDartFile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if createDartFile.subclass:
            return createDartFile.subclass(*args_, **kwargs_)
        else:
            return createDartFile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Urban(self): return self._Urban
    def set_Urban(self, value):
        if value is not None:
            checkclass(value, create_Urban)
            value.parent = self
        self._Urban = value
    Urban = property(get_Urban, set_Urban)
    def get_version(self): return self._version
    def set_version(self, value):
        self._version = value
        update_node(self,self.troot,"urban")
    version = property(get_version, set_version)
    def get_build(self): return self._build_
    def set_build(self, value):
        self._build_ = value
        update_node(self,self.troot,"urban")
    build_ = property(get_build, set_build)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Urban is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='DartFile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DartFile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DartFile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='DartFile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DartFile'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
        if self.build_ is not None and 'build_' not in already_processed:
            already_processed.add('build_')
            outfile.write(' build=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.build_), input_name='build')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='DartFile', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Urban is not None:
            self.Urban.export(outfile, level, namespaceprefix_, name_='Urban', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='DartFile', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.version is not None:
            element.set('version', self.gds_format_string(self.version))
        if self.build_ is not None:
            element.set('build', self.gds_format_string(self.build_))
        if self.Urban is not None:
            Urban_ = self.Urban
            Urban_.to_etree(element, name_='Urban', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='DartFile'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.build_ is not None and 'build_' not in already_processed:
            already_processed.add('build_')
            showIndent(outfile, level)
            outfile.write('build_="%s",\n' % (self.build_,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Urban is not None:
            showIndent(outfile, level)
            outfile.write('Urban=model_._Urban(\n')
            self.Urban.exportLiteral(outfile, level, name_='Urban')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('build', node)
        if value is not None and 'build' not in already_processed:
            already_processed.add('build')
            self.build_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Urban':
            obj_ = create_Urban.factory()
            obj_.build(child_)
            self.set_Urban(obj_)
            obj_.original_tagname_ = 'Urban'
# end class createDartFile


class create_Urban(GeneratedsSuper):
    """Urban Urban"""
    subclass = None
    superclass = None
    def __init__(self, Buildings=None, Roads=None, SmallWalls=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("urban","_Urban")
        self.attrib = ['']
        self.children = ['Buildings', 'Roads', 'SmallWalls']
        self.parent = None
        self._Buildings = Buildings
        self._Roads = Roads
        self._SmallWalls = SmallWalls
        update_node(self,self.troot,"urban")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Urban)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Urban.subclass:
            return create_Urban.subclass(*args_, **kwargs_)
        else:
            return create_Urban(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Buildings(self): return self._Buildings
    def set_Buildings(self, value):
        if value is not None:
            checkclass(value, create_Buildings)
            value.parent = self
        self._Buildings = value
    Buildings = property(get_Buildings, set_Buildings)
    def get_Roads(self): return self._Roads
    def set_Roads(self, value):
        if value is not None:
            checkclass(value, create_Roads)
            value.parent = self
        self._Roads = value
    Roads = property(get_Roads, set_Roads)
    def get_SmallWalls(self): return self._SmallWalls
    def set_SmallWalls(self, value):
        if value is not None:
            checkclass(value, create_SmallWalls)
            value.parent = self
        self._SmallWalls = value
    SmallWalls = property(get_SmallWalls, set_SmallWalls)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Buildings is not None or
            self.Roads is not None or
            self.SmallWalls is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Urban', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Urban')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Urban')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Urban', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Urban'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Urban', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Buildings is not None:
            self.Buildings.export(outfile, level, namespaceprefix_, name_='Buildings', pretty_print=pretty_print)
        if self.Roads is not None:
            self.Roads.export(outfile, level, namespaceprefix_, name_='Roads', pretty_print=pretty_print)
        if self.SmallWalls is not None:
            self.SmallWalls.export(outfile, level, namespaceprefix_, name_='SmallWalls', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Urban', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.Buildings is not None:
            Buildings_ = self.Buildings
            Buildings_.to_etree(element, name_='Buildings', mapping_=mapping_)
        if self.Roads is not None:
            Roads_ = self.Roads
            Roads_.to_etree(element, name_='Roads', mapping_=mapping_)
        if self.SmallWalls is not None:
            SmallWalls_ = self.SmallWalls
            SmallWalls_.to_etree(element, name_='SmallWalls', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Urban'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Buildings is not None:
            showIndent(outfile, level)
            outfile.write('Buildings=model_._Buildings(\n')
            self.Buildings.exportLiteral(outfile, level, name_='Buildings')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Roads is not None:
            showIndent(outfile, level)
            outfile.write('Roads=model_._Roads(\n')
            self.Roads.exportLiteral(outfile, level, name_='Roads')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SmallWalls is not None:
            showIndent(outfile, level)
            outfile.write('SmallWalls=model_._SmallWalls(\n')
            self.SmallWalls.exportLiteral(outfile, level, name_='SmallWalls')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Buildings':
            obj_ = create_Buildings.factory()
            obj_.build(child_)
            self.set_Buildings(obj_)
            obj_.original_tagname_ = 'Buildings'
        elif nodeName_ == 'Roads':
            obj_ = create_Roads.factory()
            obj_.build(child_)
            self.set_Roads(obj_)
            obj_.original_tagname_ = 'Roads'
        elif nodeName_ == 'SmallWalls':
            obj_ = create_SmallWalls.factory()
            obj_.build(child_)
            self.set_SmallWalls(obj_)
            obj_.original_tagname_ = 'SmallWalls'
# end class create_Urban


class create_Buildings(GeneratedsSuper):
    """Buildings Buildings"""
    subclass = None
    superclass = None
    def __init__(self, Building=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("urban","_Buildings")
        self.attrib = ['']
        self.children = ['Building']
        self.parent = None
        if Building is None:
            self._Building = []
        else:
            self._Building = Building
        update_node(self,self.troot,"urban")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Buildings)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Buildings.subclass:
            return create_Buildings.subclass(*args_, **kwargs_)
        else:
            return create_Buildings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Building(self): return self._Building
    def set_Building(self, value):
        if value is not None:
            checkclass(value, create_Building)
            for v in value:
                v.parent = self
        self._Building = value
    def add_Building(self, value):
        value.parent = self
        self._Building.append(value)
    def insert_Building_at(self, index, value):
        value.parent = self
        self.Building.insert(index, value)
    def replace_Building_at(self, index, value):
        value.parent = self
        self.Building[index] = value
    Building = property(get_Building, set_Building)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Building
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Buildings', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Buildings')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Buildings')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Buildings', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Buildings'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Buildings', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Building_ in self.Building:
            Building_.export(outfile, level, namespaceprefix_, name_='Building', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Buildings', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for Building_ in self.Building:
            Building_.to_etree(element, name_='Building', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Buildings'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Building=[\n')
        level += 1
        for Building_ in self.Building:
            showIndent(outfile, level)
            outfile.write('model_._Building(\n')
            Building_.exportLiteral(outfile, level, name_='_Building')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.Building = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Building':
            obj_ = create_Building.factory()
            obj_.build(child_)
            self.add_Building(obj_)
            obj_.original_tagname_ = 'Building'
# end class create_Buildings


class create_Building(GeneratedsSuper):
    """Building Building If you select this option, this entire building
    are not use in all DART modules, \n it's useful if you want
    conserve building properties backup without delete this for
    tests If you select this option, this entire building are not
    use in all DART modules, \n it's useful if you want conserve
    building properties backup without delete this for tests -
    Double faces : \ninternal and external faces \n -Simple face :
    \nonly external faces - Double faces : \ninternal and external
    faces \n -Simple face : \nonly external faces Objects's
    positions are taken from the position file.\nDesactivate this
    option if you experience some slowdown. Objects's positions are
    taken from the position file.\nDesactivate this option if you
    experience some slowdown."""
    subclass = None
    superclass = None
    def __init__(self, hidden=0, doubleFaceBuilding=1, isDisplayed=1, WallProperties=None, RoofProperties=None, House=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("urban","_Building")
        self.attrib = ['hidden', 'doubleFaceBuilding', 'isDisplayed']
        self.children = ['WallProperties', 'RoofProperties', 'House']
        self.parent = None
        self._hidden = _cast(int, hidden)
        self._doubleFaceBuilding = _cast(int, doubleFaceBuilding)
        self._isDisplayed = _cast(int, isDisplayed)
        self._WallProperties = WallProperties
        self._RoofProperties = RoofProperties
        if House is None:
            self._House = []
        else:
            self._House = House
        update_node(self,self.troot,"urban")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Building)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Building.subclass:
            return create_Building.subclass(*args_, **kwargs_)
        else:
            return create_Building(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WallProperties(self): return self._WallProperties
    def set_WallProperties(self, value):
        if value is not None:
            checkclass(value, create_WallProperties)
            value.parent = self
        self._WallProperties = value
    WallProperties = property(get_WallProperties, set_WallProperties)
    def get_RoofProperties(self): return self._RoofProperties
    def set_RoofProperties(self, value):
        if value is not None:
            checkclass(value, create_RoofProperties)
            value.parent = self
        self._RoofProperties = value
    RoofProperties = property(get_RoofProperties, set_RoofProperties)
    def get_House(self): return self._House
    def set_House(self, value):
        if value is not None:
            checkclass(value, create_House)
            for v in value:
                v.parent = self
        self._House = value
    def add_House(self, value):
        value.parent = self
        self._House.append(value)
    def insert_House_at(self, index, value):
        value.parent = self
        self.House.insert(index, value)
    def replace_House_at(self, index, value):
        value.parent = self
        self.House[index] = value
    House = property(get_House, set_House)
    def get_hidden(self): return self._hidden
    def set_hidden(self, value):
        self._hidden = value
        update_node(self,self.troot,"urban")
    hidden = property(get_hidden, set_hidden)
    def get_doubleFaceBuilding(self): return self._doubleFaceBuilding
    def set_doubleFaceBuilding(self, value):
        self._doubleFaceBuilding = value
        update_node(self,self.troot,"urban")
    doubleFaceBuilding = property(get_doubleFaceBuilding, set_doubleFaceBuilding)
    def get_isDisplayed(self): return self._isDisplayed
    def set_isDisplayed(self, value):
        self._isDisplayed = value
        update_node(self,self.troot,"urban")
    isDisplayed = property(get_isDisplayed, set_isDisplayed)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.WallProperties is not None or
            self.RoofProperties is not None or
            self.House
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Building', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Building')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Building')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Building', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Building'):
        if self.hidden is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            outfile.write(' hidden="%s"' % self.gds_format_integer(self.hidden, input_name='hidden'))
        if self.doubleFaceBuilding is not None and 'doubleFaceBuilding' not in already_processed:
            already_processed.add('doubleFaceBuilding')
            outfile.write(' doubleFaceBuilding="%s"' % self.gds_format_integer(self.doubleFaceBuilding, input_name='doubleFaceBuilding'))
        if self.isDisplayed is not None and 'isDisplayed' not in already_processed:
            already_processed.add('isDisplayed')
            outfile.write(' isDisplayed="%s"' % self.gds_format_integer(self.isDisplayed, input_name='isDisplayed'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Building', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.WallProperties is not None:
            self.WallProperties.export(outfile, level, namespaceprefix_, name_='WallProperties', pretty_print=pretty_print)
        if self.RoofProperties is not None:
            self.RoofProperties.export(outfile, level, namespaceprefix_, name_='RoofProperties', pretty_print=pretty_print)
        for House_ in self.House:
            House_.export(outfile, level, namespaceprefix_, name_='House', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Building', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.hidden is not None:
            element.set('hidden', self.gds_format_integer(self.hidden))
        if self.doubleFaceBuilding is not None:
            element.set('doubleFaceBuilding', self.gds_format_integer(self.doubleFaceBuilding))
        if self.isDisplayed is not None:
            element.set('isDisplayed', self.gds_format_integer(self.isDisplayed))
        if self.WallProperties is not None:
            WallProperties_ = self.WallProperties
            WallProperties_.to_etree(element, name_='WallProperties', mapping_=mapping_)
        if self.RoofProperties is not None:
            RoofProperties_ = self.RoofProperties
            RoofProperties_.to_etree(element, name_='RoofProperties', mapping_=mapping_)
        for House_ in self.House:
            House_.to_etree(element, name_='House', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Building'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.hidden is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            showIndent(outfile, level)
            outfile.write('hidden=%d,\n' % (self.hidden,))
        if self.doubleFaceBuilding is not None and 'doubleFaceBuilding' not in already_processed:
            already_processed.add('doubleFaceBuilding')
            showIndent(outfile, level)
            outfile.write('doubleFaceBuilding=%d,\n' % (self.doubleFaceBuilding,))
        if self.isDisplayed is not None and 'isDisplayed' not in already_processed:
            already_processed.add('isDisplayed')
            showIndent(outfile, level)
            outfile.write('isDisplayed=%d,\n' % (self.isDisplayed,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.WallProperties is not None:
            showIndent(outfile, level)
            outfile.write('WallProperties=model_._WallProperties(\n')
            self.WallProperties.exportLiteral(outfile, level, name_='WallProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RoofProperties is not None:
            showIndent(outfile, level)
            outfile.write('RoofProperties=model_._RoofProperties(\n')
            self.RoofProperties.exportLiteral(outfile, level, name_='RoofProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('House=[\n')
        level += 1
        for House_ in self.House:
            showIndent(outfile, level)
            outfile.write('model_._House(\n')
            House_.exportLiteral(outfile, level, name_='_House')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.House = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hidden', node)
        if value is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            try:
                self.hidden = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('doubleFaceBuilding', node)
        if value is not None and 'doubleFaceBuilding' not in already_processed:
            already_processed.add('doubleFaceBuilding')
            try:
                self.doubleFaceBuilding = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isDisplayed', node)
        if value is not None and 'isDisplayed' not in already_processed:
            already_processed.add('isDisplayed')
            try:
                self.isDisplayed = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WallProperties':
            obj_ = create_WallProperties.factory()
            obj_.build(child_)
            self.set_WallProperties(obj_)
            obj_.original_tagname_ = 'WallProperties'
        elif nodeName_ == 'RoofProperties':
            obj_ = create_RoofProperties.factory()
            obj_.build(child_)
            self.set_RoofProperties(obj_)
            obj_.original_tagname_ = 'RoofProperties'
        elif nodeName_ == 'House':
            obj_ = create_House.factory()
            obj_.build(child_)
            self.add_House(obj_)
            obj_.original_tagname_ = 'House'
# end class create_Building


class create_WallProperties(GeneratedsSuper):
    """WallProperties WallProperties The walls of all the houses of this
    building have the same optical properties The walls of all the
    houses of this building have the same optical properties"""
    subclass = None
    superclass = None
    def __init__(self, sameWall=1, ExternalFacesOpticalPropertyLink=None, ExternalFacesThermalPropertyLink=None, InternalFacesOpticalPropertyLink=None, InternalFacesThermalPropertyLink=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("urban","_WallProperties")
        self.attrib = ['sameWall']
        self.children = ['ExternalFacesOpticalPropertyLink', 'ExternalFacesThermalPropertyLink', 'InternalFacesOpticalPropertyLink', 'InternalFacesThermalPropertyLink']
        self.parent = None
        self._sameWall = _cast(int, sameWall)
        self._ExternalFacesOpticalPropertyLink = ExternalFacesOpticalPropertyLink
        self._ExternalFacesThermalPropertyLink = ExternalFacesThermalPropertyLink
        self._InternalFacesOpticalPropertyLink = InternalFacesOpticalPropertyLink
        self._InternalFacesThermalPropertyLink = InternalFacesThermalPropertyLink
        update_node(self,self.troot,"urban")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_WallProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_WallProperties.subclass:
            return create_WallProperties.subclass(*args_, **kwargs_)
        else:
            return create_WallProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ExternalFacesOpticalPropertyLink(self): return self._ExternalFacesOpticalPropertyLink
    def set_ExternalFacesOpticalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_ExternalFacesOpticalPropertyLink)
            value.parent = self
        self._ExternalFacesOpticalPropertyLink = value
    ExternalFacesOpticalPropertyLink = property(get_ExternalFacesOpticalPropertyLink, set_ExternalFacesOpticalPropertyLink)
    def get_ExternalFacesThermalPropertyLink(self): return self._ExternalFacesThermalPropertyLink
    def set_ExternalFacesThermalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_ExternalFacesThermalPropertyLink)
            value.parent = self
        self._ExternalFacesThermalPropertyLink = value
    ExternalFacesThermalPropertyLink = property(get_ExternalFacesThermalPropertyLink, set_ExternalFacesThermalPropertyLink)
    def get_InternalFacesOpticalPropertyLink(self): return self._InternalFacesOpticalPropertyLink
    def set_InternalFacesOpticalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_InternalFacesOpticalPropertyLink)
            value.parent = self
        self._InternalFacesOpticalPropertyLink = value
    InternalFacesOpticalPropertyLink = property(get_InternalFacesOpticalPropertyLink, set_InternalFacesOpticalPropertyLink)
    def get_InternalFacesThermalPropertyLink(self): return self._InternalFacesThermalPropertyLink
    def set_InternalFacesThermalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_InternalFacesThermalPropertyLink)
            value.parent = self
        self._InternalFacesThermalPropertyLink = value
    InternalFacesThermalPropertyLink = property(get_InternalFacesThermalPropertyLink, set_InternalFacesThermalPropertyLink)
    def get_sameWall(self): return self._sameWall
    def set_sameWall(self, value):
        self._sameWall = value
        update_node(self,self.troot,"urban")
    sameWall = property(get_sameWall, set_sameWall)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.ExternalFacesOpticalPropertyLink is not None or
            self.ExternalFacesThermalPropertyLink is not None or
            self.InternalFacesOpticalPropertyLink is not None or
            self.InternalFacesThermalPropertyLink is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_WallProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_WallProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_WallProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_WallProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_WallProperties'):
        if self.sameWall is not None and 'sameWall' not in already_processed:
            already_processed.add('sameWall')
            outfile.write(' sameWall="%s"' % self.gds_format_integer(self.sameWall, input_name='sameWall'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_WallProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ExternalFacesOpticalPropertyLink is not None:
            self.ExternalFacesOpticalPropertyLink.export(outfile, level, namespaceprefix_, name_='ExternalFacesOpticalPropertyLink', pretty_print=pretty_print)
        if self.ExternalFacesThermalPropertyLink is not None:
            self.ExternalFacesThermalPropertyLink.export(outfile, level, namespaceprefix_, name_='ExternalFacesThermalPropertyLink', pretty_print=pretty_print)
        if self.InternalFacesOpticalPropertyLink is not None:
            self.InternalFacesOpticalPropertyLink.export(outfile, level, namespaceprefix_, name_='InternalFacesOpticalPropertyLink', pretty_print=pretty_print)
        if self.InternalFacesThermalPropertyLink is not None:
            self.InternalFacesThermalPropertyLink.export(outfile, level, namespaceprefix_, name_='InternalFacesThermalPropertyLink', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_WallProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.sameWall is not None:
            element.set('sameWall', self.gds_format_integer(self.sameWall))
        if self.ExternalFacesOpticalPropertyLink is not None:
            ExternalFacesOpticalPropertyLink_ = self.ExternalFacesOpticalPropertyLink
            ExternalFacesOpticalPropertyLink_.to_etree(element, name_='ExternalFacesOpticalPropertyLink', mapping_=mapping_)
        if self.ExternalFacesThermalPropertyLink is not None:
            ExternalFacesThermalPropertyLink_ = self.ExternalFacesThermalPropertyLink
            ExternalFacesThermalPropertyLink_.to_etree(element, name_='ExternalFacesThermalPropertyLink', mapping_=mapping_)
        if self.InternalFacesOpticalPropertyLink is not None:
            InternalFacesOpticalPropertyLink_ = self.InternalFacesOpticalPropertyLink
            InternalFacesOpticalPropertyLink_.to_etree(element, name_='InternalFacesOpticalPropertyLink', mapping_=mapping_)
        if self.InternalFacesThermalPropertyLink is not None:
            InternalFacesThermalPropertyLink_ = self.InternalFacesThermalPropertyLink
            InternalFacesThermalPropertyLink_.to_etree(element, name_='InternalFacesThermalPropertyLink', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_WallProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sameWall is not None and 'sameWall' not in already_processed:
            already_processed.add('sameWall')
            showIndent(outfile, level)
            outfile.write('sameWall=%d,\n' % (self.sameWall,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ExternalFacesOpticalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('ExternalFacesOpticalPropertyLink=model_._ExternalFacesOpticalPropertyLink(\n')
            self.ExternalFacesOpticalPropertyLink.exportLiteral(outfile, level, name_='ExternalFacesOpticalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ExternalFacesThermalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('ExternalFacesThermalPropertyLink=model_._ExternalFacesThermalPropertyLink(\n')
            self.ExternalFacesThermalPropertyLink.exportLiteral(outfile, level, name_='ExternalFacesThermalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InternalFacesOpticalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('InternalFacesOpticalPropertyLink=model_._InternalFacesOpticalPropertyLink(\n')
            self.InternalFacesOpticalPropertyLink.exportLiteral(outfile, level, name_='InternalFacesOpticalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InternalFacesThermalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('InternalFacesThermalPropertyLink=model_._InternalFacesThermalPropertyLink(\n')
            self.InternalFacesThermalPropertyLink.exportLiteral(outfile, level, name_='InternalFacesThermalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sameWall', node)
        if value is not None and 'sameWall' not in already_processed:
            already_processed.add('sameWall')
            try:
                self.sameWall = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExternalFacesOpticalPropertyLink':
            obj_ = create_ExternalFacesOpticalPropertyLink.factory()
            obj_.build(child_)
            self.set_ExternalFacesOpticalPropertyLink(obj_)
            obj_.original_tagname_ = 'ExternalFacesOpticalPropertyLink'
        elif nodeName_ == 'ExternalFacesThermalPropertyLink':
            obj_ = create_ExternalFacesThermalPropertyLink.factory()
            obj_.build(child_)
            self.set_ExternalFacesThermalPropertyLink(obj_)
            obj_.original_tagname_ = 'ExternalFacesThermalPropertyLink'
        elif nodeName_ == 'InternalFacesOpticalPropertyLink':
            obj_ = create_InternalFacesOpticalPropertyLink.factory()
            obj_.build(child_)
            self.set_InternalFacesOpticalPropertyLink(obj_)
            obj_.original_tagname_ = 'InternalFacesOpticalPropertyLink'
        elif nodeName_ == 'InternalFacesThermalPropertyLink':
            obj_ = create_InternalFacesThermalPropertyLink.factory()
            obj_.build(child_)
            self.set_InternalFacesThermalPropertyLink(obj_)
            obj_.original_tagname_ = 'InternalFacesThermalPropertyLink'
# end class create_WallProperties


class create_ExternalFacesOpticalPropertyLink(GeneratedsSuper):
    """ExternalFacesOpticalPropertyLink ExternalFacesOpticalPropertyLink
    Index of the DART phase function of the ground of the plot.
    Index of the DART phase function of the ground of the plot.
    proportion of photons intercepted along an incident direction
    that are scattered within a solid angle along a given direction
    proportion of photons intercepted along an incident direction
    that are scattered within a solid angle along a given direction
    Type of phase function (lambertian, etc.) Type of phase function
    (lambertian, etc.)"""
    subclass = None
    superclass = None
    def __init__(self, indexFctPhase=0, ident='Lambertian_Phase_Function_1', type_=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot("urban","_ExternalFacesOpticalPropertyLink")
        self.attrib = ['indexFctPhase', 'ident', 'type_']
        self.children = []
        self.parent = None
        self._indexFctPhase = _cast(int, indexFctPhase)
        self._ident = _cast(None, ident)
        self._type_ = _cast(int, type_)
        update_node(self,self.troot,"urban")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ExternalFacesOpticalPropertyLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ExternalFacesOpticalPropertyLink.subclass:
            return create_ExternalFacesOpticalPropertyLink.subclass(*args_, **kwargs_)
        else:
            return create_ExternalFacesOpticalPropertyLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexFctPhase(self): return self._indexFctPhase
    def set_indexFctPhase(self, value):
        self._indexFctPhase = value
        update_node(self,self.troot,"urban")
    indexFctPhase = property(get_indexFctPhase, set_indexFctPhase)
    def get_ident(self): return self._ident
    def set_ident(self, value):
        self._ident = value
        update_node(self,self.troot,"urban")
    ident = property(get_ident, set_ident)
    def get_type(self): return self._type_
    def set_type(self, value):
        self._type_ = value
        update_node(self,self.troot,"urban")
    type_ = property(get_type, set_type)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ExternalFacesOpticalPropertyLink', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ExternalFacesOpticalPropertyLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ExternalFacesOpticalPropertyLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ExternalFacesOpticalPropertyLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ExternalFacesOpticalPropertyLink'):
        if self.indexFctPhase is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            outfile.write(' indexFctPhase="%s"' % self.gds_format_integer(self.indexFctPhase, input_name='indexFctPhase'))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            outfile.write(' ident=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ident), input_name='ident')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type="%s"' % self.gds_format_integer(self.type_, input_name='type'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ExternalFacesOpticalPropertyLink', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_ExternalFacesOpticalPropertyLink', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.indexFctPhase is not None:
            element.set('indexFctPhase', self.gds_format_integer(self.indexFctPhase))
        if self.ident is not None:
            element.set('ident', self.gds_format_string(self.ident))
        if self.type_ is not None:
            element.set('type', self.gds_format_integer(self.type_))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ExternalFacesOpticalPropertyLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.indexFctPhase is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            showIndent(outfile, level)
            outfile.write('indexFctPhase=%d,\n' % (self.indexFctPhase,))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            showIndent(outfile, level)
            outfile.write('ident="%s",\n' % (self.ident,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_=%d,\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('indexFctPhase', node)
        if value is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            try:
                self.indexFctPhase = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ident', node)
        if value is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            self.ident = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            try:
                self.type_ = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_ExternalFacesOpticalPropertyLink


class create_ExternalFacesThermalPropertyLink(GeneratedsSuper):
    """ExternalFacesThermalPropertyLink ExternalFacesThermalPropertyLink
    indexTemperature indexTemperature Thermal Function ID Thermal
    Function ID"""
    subclass = None
    superclass = None
    def __init__(self, indexTemperature=0, idTemperature='ThermalFunction290_310'):
        self.original_tagname_ = None
        self.troot=get_gs_troot("urban","_ExternalFacesThermalPropertyLink")
        self.attrib = ['indexTemperature', 'idTemperature']
        self.children = []
        self.parent = None
        self._indexTemperature = _cast(int, indexTemperature)
        self._idTemperature = _cast(None, idTemperature)
        update_node(self,self.troot,"urban")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ExternalFacesThermalPropertyLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ExternalFacesThermalPropertyLink.subclass:
            return create_ExternalFacesThermalPropertyLink.subclass(*args_, **kwargs_)
        else:
            return create_ExternalFacesThermalPropertyLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexTemperature(self): return self._indexTemperature
    def set_indexTemperature(self, value):
        self._indexTemperature = value
        update_node(self,self.troot,"urban")
    indexTemperature = property(get_indexTemperature, set_indexTemperature)
    def get_idTemperature(self): return self._idTemperature
    def set_idTemperature(self, value):
        self._idTemperature = value
        update_node(self,self.troot,"urban")
    idTemperature = property(get_idTemperature, set_idTemperature)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ExternalFacesThermalPropertyLink', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ExternalFacesThermalPropertyLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ExternalFacesThermalPropertyLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ExternalFacesThermalPropertyLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ExternalFacesThermalPropertyLink'):
        if self.indexTemperature is not None and 'indexTemperature' not in already_processed:
            already_processed.add('indexTemperature')
            outfile.write(' indexTemperature="%s"' % self.gds_format_integer(self.indexTemperature, input_name='indexTemperature'))
        if self.idTemperature is not None and 'idTemperature' not in already_processed:
            already_processed.add('idTemperature')
            outfile.write(' idTemperature=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idTemperature), input_name='idTemperature')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ExternalFacesThermalPropertyLink', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_ExternalFacesThermalPropertyLink', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.indexTemperature is not None:
            element.set('indexTemperature', self.gds_format_integer(self.indexTemperature))
        if self.idTemperature is not None:
            element.set('idTemperature', self.gds_format_string(self.idTemperature))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ExternalFacesThermalPropertyLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.indexTemperature is not None and 'indexTemperature' not in already_processed:
            already_processed.add('indexTemperature')
            showIndent(outfile, level)
            outfile.write('indexTemperature=%d,\n' % (self.indexTemperature,))
        if self.idTemperature is not None and 'idTemperature' not in already_processed:
            already_processed.add('idTemperature')
            showIndent(outfile, level)
            outfile.write('idTemperature="%s",\n' % (self.idTemperature,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('indexTemperature', node)
        if value is not None and 'indexTemperature' not in already_processed:
            already_processed.add('indexTemperature')
            try:
                self.indexTemperature = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('idTemperature', node)
        if value is not None and 'idTemperature' not in already_processed:
            already_processed.add('idTemperature')
            self.idTemperature = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_ExternalFacesThermalPropertyLink


class create_InternalFacesOpticalPropertyLink(GeneratedsSuper):
    """InternalFacesOpticalPropertyLink InternalFacesOpticalPropertyLink
    Index of the DART phase function of the ground of the plot.
    Index of the DART phase function of the ground of the plot.
    proportion of photons intercepted along an incident direction
    that are scattered within a solid angle along a given direction
    proportion of photons intercepted along an incident direction
    that are scattered within a solid angle along a given direction
    Type of phase function (lambertian, etc.) Type of phase function
    (lambertian, etc.)"""
    subclass = None
    superclass = None
    def __init__(self, indexFctPhase=0, ident='Lambertian_Phase_Function_1', type_=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot("urban","_InternalFacesOpticalPropertyLink")
        self.attrib = ['indexFctPhase', 'ident', 'type_']
        self.children = []
        self.parent = None
        self._indexFctPhase = _cast(int, indexFctPhase)
        self._ident = _cast(None, ident)
        self._type_ = _cast(int, type_)
        update_node(self,self.troot,"urban")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_InternalFacesOpticalPropertyLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_InternalFacesOpticalPropertyLink.subclass:
            return create_InternalFacesOpticalPropertyLink.subclass(*args_, **kwargs_)
        else:
            return create_InternalFacesOpticalPropertyLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexFctPhase(self): return self._indexFctPhase
    def set_indexFctPhase(self, value):
        self._indexFctPhase = value
        update_node(self,self.troot,"urban")
    indexFctPhase = property(get_indexFctPhase, set_indexFctPhase)
    def get_ident(self): return self._ident
    def set_ident(self, value):
        self._ident = value
        update_node(self,self.troot,"urban")
    ident = property(get_ident, set_ident)
    def get_type(self): return self._type_
    def set_type(self, value):
        self._type_ = value
        update_node(self,self.troot,"urban")
    type_ = property(get_type, set_type)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_InternalFacesOpticalPropertyLink', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_InternalFacesOpticalPropertyLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_InternalFacesOpticalPropertyLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_InternalFacesOpticalPropertyLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_InternalFacesOpticalPropertyLink'):
        if self.indexFctPhase is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            outfile.write(' indexFctPhase="%s"' % self.gds_format_integer(self.indexFctPhase, input_name='indexFctPhase'))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            outfile.write(' ident=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ident), input_name='ident')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type="%s"' % self.gds_format_integer(self.type_, input_name='type'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_InternalFacesOpticalPropertyLink', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_InternalFacesOpticalPropertyLink', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.indexFctPhase is not None:
            element.set('indexFctPhase', self.gds_format_integer(self.indexFctPhase))
        if self.ident is not None:
            element.set('ident', self.gds_format_string(self.ident))
        if self.type_ is not None:
            element.set('type', self.gds_format_integer(self.type_))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_InternalFacesOpticalPropertyLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.indexFctPhase is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            showIndent(outfile, level)
            outfile.write('indexFctPhase=%d,\n' % (self.indexFctPhase,))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            showIndent(outfile, level)
            outfile.write('ident="%s",\n' % (self.ident,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_=%d,\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('indexFctPhase', node)
        if value is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            try:
                self.indexFctPhase = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ident', node)
        if value is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            self.ident = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            try:
                self.type_ = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_InternalFacesOpticalPropertyLink


class create_InternalFacesThermalPropertyLink(GeneratedsSuper):
    """InternalFacesThermalPropertyLink InternalFacesThermalPropertyLink
    indexTemperature indexTemperature Thermal Function ID Thermal
    Function ID"""
    subclass = None
    superclass = None
    def __init__(self, indexTemperature=0, idTemperature='ThermalFunction290_310'):
        self.original_tagname_ = None
        self.troot=get_gs_troot("urban","_InternalFacesThermalPropertyLink")
        self.attrib = ['indexTemperature', 'idTemperature']
        self.children = []
        self.parent = None
        self._indexTemperature = _cast(int, indexTemperature)
        self._idTemperature = _cast(None, idTemperature)
        update_node(self,self.troot,"urban")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_InternalFacesThermalPropertyLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_InternalFacesThermalPropertyLink.subclass:
            return create_InternalFacesThermalPropertyLink.subclass(*args_, **kwargs_)
        else:
            return create_InternalFacesThermalPropertyLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexTemperature(self): return self._indexTemperature
    def set_indexTemperature(self, value):
        self._indexTemperature = value
        update_node(self,self.troot,"urban")
    indexTemperature = property(get_indexTemperature, set_indexTemperature)
    def get_idTemperature(self): return self._idTemperature
    def set_idTemperature(self, value):
        self._idTemperature = value
        update_node(self,self.troot,"urban")
    idTemperature = property(get_idTemperature, set_idTemperature)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_InternalFacesThermalPropertyLink', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_InternalFacesThermalPropertyLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_InternalFacesThermalPropertyLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_InternalFacesThermalPropertyLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_InternalFacesThermalPropertyLink'):
        if self.indexTemperature is not None and 'indexTemperature' not in already_processed:
            already_processed.add('indexTemperature')
            outfile.write(' indexTemperature="%s"' % self.gds_format_integer(self.indexTemperature, input_name='indexTemperature'))
        if self.idTemperature is not None and 'idTemperature' not in already_processed:
            already_processed.add('idTemperature')
            outfile.write(' idTemperature=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idTemperature), input_name='idTemperature')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_InternalFacesThermalPropertyLink', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_InternalFacesThermalPropertyLink', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.indexTemperature is not None:
            element.set('indexTemperature', self.gds_format_integer(self.indexTemperature))
        if self.idTemperature is not None:
            element.set('idTemperature', self.gds_format_string(self.idTemperature))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_InternalFacesThermalPropertyLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.indexTemperature is not None and 'indexTemperature' not in already_processed:
            already_processed.add('indexTemperature')
            showIndent(outfile, level)
            outfile.write('indexTemperature=%d,\n' % (self.indexTemperature,))
        if self.idTemperature is not None and 'idTemperature' not in already_processed:
            already_processed.add('idTemperature')
            showIndent(outfile, level)
            outfile.write('idTemperature="%s",\n' % (self.idTemperature,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('indexTemperature', node)
        if value is not None and 'indexTemperature' not in already_processed:
            already_processed.add('indexTemperature')
            try:
                self.indexTemperature = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('idTemperature', node)
        if value is not None and 'idTemperature' not in already_processed:
            already_processed.add('idTemperature')
            self.idTemperature = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_InternalFacesThermalPropertyLink


class create_RoofProperties(GeneratedsSuper):
    """RoofProperties RoofProperties The roofs of all the houses of this
    building have the same optical properties The roofs of all the
    houses of this building have the same optical properties"""
    subclass = None
    superclass = None
    def __init__(self, sameRoof=1, ExternalFacesOpticalPropertyLink=None, ExternalFacesThermalPropertyLink=None, InternalFacesOpticalPropertyLink=None, InternalFacesThermalPropertyLink=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("urban","_RoofProperties")
        self.attrib = ['sameRoof']
        self.children = ['ExternalFacesOpticalPropertyLink', 'ExternalFacesThermalPropertyLink', 'InternalFacesOpticalPropertyLink', 'InternalFacesThermalPropertyLink']
        self.parent = None
        self._sameRoof = _cast(int, sameRoof)
        self._ExternalFacesOpticalPropertyLink = ExternalFacesOpticalPropertyLink
        self._ExternalFacesThermalPropertyLink = ExternalFacesThermalPropertyLink
        self._InternalFacesOpticalPropertyLink = InternalFacesOpticalPropertyLink
        self._InternalFacesThermalPropertyLink = InternalFacesThermalPropertyLink
        update_node(self,self.troot,"urban")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_RoofProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_RoofProperties.subclass:
            return create_RoofProperties.subclass(*args_, **kwargs_)
        else:
            return create_RoofProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ExternalFacesOpticalPropertyLink(self): return self._ExternalFacesOpticalPropertyLink
    def set_ExternalFacesOpticalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_ExternalFacesOpticalPropertyLink)
            value.parent = self
        self._ExternalFacesOpticalPropertyLink = value
    ExternalFacesOpticalPropertyLink = property(get_ExternalFacesOpticalPropertyLink, set_ExternalFacesOpticalPropertyLink)
    def get_ExternalFacesThermalPropertyLink(self): return self._ExternalFacesThermalPropertyLink
    def set_ExternalFacesThermalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_ExternalFacesThermalPropertyLink)
            value.parent = self
        self._ExternalFacesThermalPropertyLink = value
    ExternalFacesThermalPropertyLink = property(get_ExternalFacesThermalPropertyLink, set_ExternalFacesThermalPropertyLink)
    def get_InternalFacesOpticalPropertyLink(self): return self._InternalFacesOpticalPropertyLink
    def set_InternalFacesOpticalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_InternalFacesOpticalPropertyLink)
            value.parent = self
        self._InternalFacesOpticalPropertyLink = value
    InternalFacesOpticalPropertyLink = property(get_InternalFacesOpticalPropertyLink, set_InternalFacesOpticalPropertyLink)
    def get_InternalFacesThermalPropertyLink(self): return self._InternalFacesThermalPropertyLink
    def set_InternalFacesThermalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_InternalFacesThermalPropertyLink)
            value.parent = self
        self._InternalFacesThermalPropertyLink = value
    InternalFacesThermalPropertyLink = property(get_InternalFacesThermalPropertyLink, set_InternalFacesThermalPropertyLink)
    def get_sameRoof(self): return self._sameRoof
    def set_sameRoof(self, value):
        self._sameRoof = value
        update_node(self,self.troot,"urban")
    sameRoof = property(get_sameRoof, set_sameRoof)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.ExternalFacesOpticalPropertyLink is not None or
            self.ExternalFacesThermalPropertyLink is not None or
            self.InternalFacesOpticalPropertyLink is not None or
            self.InternalFacesThermalPropertyLink is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_RoofProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_RoofProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_RoofProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_RoofProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_RoofProperties'):
        if self.sameRoof is not None and 'sameRoof' not in already_processed:
            already_processed.add('sameRoof')
            outfile.write(' sameRoof="%s"' % self.gds_format_integer(self.sameRoof, input_name='sameRoof'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_RoofProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ExternalFacesOpticalPropertyLink is not None:
            self.ExternalFacesOpticalPropertyLink.export(outfile, level, namespaceprefix_, name_='ExternalFacesOpticalPropertyLink', pretty_print=pretty_print)
        if self.ExternalFacesThermalPropertyLink is not None:
            self.ExternalFacesThermalPropertyLink.export(outfile, level, namespaceprefix_, name_='ExternalFacesThermalPropertyLink', pretty_print=pretty_print)
        if self.InternalFacesOpticalPropertyLink is not None:
            self.InternalFacesOpticalPropertyLink.export(outfile, level, namespaceprefix_, name_='InternalFacesOpticalPropertyLink', pretty_print=pretty_print)
        if self.InternalFacesThermalPropertyLink is not None:
            self.InternalFacesThermalPropertyLink.export(outfile, level, namespaceprefix_, name_='InternalFacesThermalPropertyLink', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_RoofProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.sameRoof is not None:
            element.set('sameRoof', self.gds_format_integer(self.sameRoof))
        if self.ExternalFacesOpticalPropertyLink is not None:
            ExternalFacesOpticalPropertyLink_ = self.ExternalFacesOpticalPropertyLink
            ExternalFacesOpticalPropertyLink_.to_etree(element, name_='ExternalFacesOpticalPropertyLink', mapping_=mapping_)
        if self.ExternalFacesThermalPropertyLink is not None:
            ExternalFacesThermalPropertyLink_ = self.ExternalFacesThermalPropertyLink
            ExternalFacesThermalPropertyLink_.to_etree(element, name_='ExternalFacesThermalPropertyLink', mapping_=mapping_)
        if self.InternalFacesOpticalPropertyLink is not None:
            InternalFacesOpticalPropertyLink_ = self.InternalFacesOpticalPropertyLink
            InternalFacesOpticalPropertyLink_.to_etree(element, name_='InternalFacesOpticalPropertyLink', mapping_=mapping_)
        if self.InternalFacesThermalPropertyLink is not None:
            InternalFacesThermalPropertyLink_ = self.InternalFacesThermalPropertyLink
            InternalFacesThermalPropertyLink_.to_etree(element, name_='InternalFacesThermalPropertyLink', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_RoofProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sameRoof is not None and 'sameRoof' not in already_processed:
            already_processed.add('sameRoof')
            showIndent(outfile, level)
            outfile.write('sameRoof=%d,\n' % (self.sameRoof,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ExternalFacesOpticalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('ExternalFacesOpticalPropertyLink=model_._ExternalFacesOpticalPropertyLink(\n')
            self.ExternalFacesOpticalPropertyLink.exportLiteral(outfile, level, name_='ExternalFacesOpticalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ExternalFacesThermalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('ExternalFacesThermalPropertyLink=model_._ExternalFacesThermalPropertyLink(\n')
            self.ExternalFacesThermalPropertyLink.exportLiteral(outfile, level, name_='ExternalFacesThermalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InternalFacesOpticalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('InternalFacesOpticalPropertyLink=model_._InternalFacesOpticalPropertyLink(\n')
            self.InternalFacesOpticalPropertyLink.exportLiteral(outfile, level, name_='InternalFacesOpticalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InternalFacesThermalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('InternalFacesThermalPropertyLink=model_._InternalFacesThermalPropertyLink(\n')
            self.InternalFacesThermalPropertyLink.exportLiteral(outfile, level, name_='InternalFacesThermalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sameRoof', node)
        if value is not None and 'sameRoof' not in already_processed:
            already_processed.add('sameRoof')
            try:
                self.sameRoof = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExternalFacesOpticalPropertyLink':
            obj_ = create_ExternalFacesOpticalPropertyLink.factory()
            obj_.build(child_)
            self.set_ExternalFacesOpticalPropertyLink(obj_)
            obj_.original_tagname_ = 'ExternalFacesOpticalPropertyLink'
        elif nodeName_ == 'ExternalFacesThermalPropertyLink':
            obj_ = create_ExternalFacesThermalPropertyLink.factory()
            obj_.build(child_)
            self.set_ExternalFacesThermalPropertyLink(obj_)
            obj_.original_tagname_ = 'ExternalFacesThermalPropertyLink'
        elif nodeName_ == 'InternalFacesOpticalPropertyLink':
            obj_ = create_InternalFacesOpticalPropertyLink.factory()
            obj_.build(child_)
            self.set_InternalFacesOpticalPropertyLink(obj_)
            obj_.original_tagname_ = 'InternalFacesOpticalPropertyLink'
        elif nodeName_ == 'InternalFacesThermalPropertyLink':
            obj_ = create_InternalFacesThermalPropertyLink.factory()
            obj_.build(child_)
            self.set_InternalFacesThermalPropertyLink(obj_)
            obj_.original_tagname_ = 'InternalFacesThermalPropertyLink'
# end class create_RoofProperties


class create_House(GeneratedsSuper):
    """House House The house has a roof defined by:\n- the 4 corners of the
    house walls are simply connected together to generate the roof
    (option "Basic without thickness"), or\n- the 4 corners of the
    house walls are simply connected together to generate the roof
    with an added thickness (option "Basic with thickness"), or\n- 2
    additional points (option "Classic"), or\n- 4 additional points
    (option "Complex"). The house has a roof defined by:\n- the 4
    corners of the house walls are simply connected together to
    generate the roof (option "Basic without thickness"), or\n- the
    4 corners of the house walls are simply connected together to
    generate the roof with an added thickness (option "Basic with
    thickness"), or\n- 2 additional points (option "Classic"), or\n-
    4 additional points (option "Complex"). If you select this
    option, this house are not use in all DART modules, \n it's
    useful if you want conserve house properties backup without
    delete this for tests If you select this option, this house are
    not use in all DART modules, \n it's useful if you want conserve
    house properties backup without delete this for tests"""
    subclass = None
    superclass = None
    def __init__(self, typeRoof=2, hidden=0, Wall=None, RoofNone=None, RoofClassic=None, RoofPlate=None, RoofComplex=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("urban","_House")
        self.attrib = ['typeRoof', 'hidden']
        self.children = ['Wall', 'RoofNone', 'RoofClassic', 'RoofPlate', 'RoofComplex']
        self.parent = None
        self._typeRoof = _cast(int, typeRoof)
        self._hidden = _cast(int, hidden)
        self._Wall = Wall
        self._RoofNone = RoofNone
        self._RoofClassic = RoofClassic
        self._RoofPlate = RoofPlate
        self._RoofComplex = RoofComplex
        update_node(self,self.troot,"urban")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_House)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_House.subclass:
            return create_House.subclass(*args_, **kwargs_)
        else:
            return create_House(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Wall(self): return self._Wall
    def set_Wall(self, value):
        if value is not None:
            checkclass(value, create_Wall)
            value.parent = self
        self._Wall = value
    Wall = property(get_Wall, set_Wall)
    def get_RoofNone(self): return self._RoofNone
    def set_RoofNone(self, value):
        if value is not None:
            checkclass(value, create_RoofNone)
            value.parent = self
        self._RoofNone = value
    RoofNone = property(get_RoofNone, set_RoofNone)
    def get_RoofClassic(self): return self._RoofClassic
    def set_RoofClassic(self, value):
        if value is not None:
            checkclass(value, create_RoofClassic)
            value.parent = self
        self._RoofClassic = value
    RoofClassic = property(get_RoofClassic, set_RoofClassic)
    def get_RoofPlate(self): return self._RoofPlate
    def set_RoofPlate(self, value):
        if value is not None:
            checkclass(value, create_RoofPlate)
            value.parent = self
        self._RoofPlate = value
    RoofPlate = property(get_RoofPlate, set_RoofPlate)
    def get_RoofComplex(self): return self._RoofComplex
    def set_RoofComplex(self, value):
        if value is not None:
            checkclass(value, create_RoofComplex)
            value.parent = self
        self._RoofComplex = value
    RoofComplex = property(get_RoofComplex, set_RoofComplex)
    def get_typeRoof(self): return self._typeRoof
    def set_typeRoof(self, value):
        self._typeRoof = value
        update_node(self,self.troot,"urban")
    typeRoof = property(get_typeRoof, set_typeRoof)
    def get_hidden(self): return self._hidden
    def set_hidden(self, value):
        self._hidden = value
        update_node(self,self.troot,"urban")
    hidden = property(get_hidden, set_hidden)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Wall is not None or
            self.RoofNone is not None or
            self.RoofClassic is not None or
            self.RoofPlate is not None or
            self.RoofComplex is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_House', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_House')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_House')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_House', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_House'):
        if self.typeRoof is not None and 'typeRoof' not in already_processed:
            already_processed.add('typeRoof')
            outfile.write(' typeRoof="%s"' % self.gds_format_integer(self.typeRoof, input_name='typeRoof'))
        if self.hidden is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            outfile.write(' hidden="%s"' % self.gds_format_integer(self.hidden, input_name='hidden'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_House', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Wall is not None:
            self.Wall.export(outfile, level, namespaceprefix_, name_='Wall', pretty_print=pretty_print)
        if self.RoofNone is not None:
            self.RoofNone.export(outfile, level, namespaceprefix_, name_='RoofNone', pretty_print=pretty_print)
        if self.RoofClassic is not None:
            self.RoofClassic.export(outfile, level, namespaceprefix_, name_='RoofClassic', pretty_print=pretty_print)
        if self.RoofPlate is not None:
            self.RoofPlate.export(outfile, level, namespaceprefix_, name_='RoofPlate', pretty_print=pretty_print)
        if self.RoofComplex is not None:
            self.RoofComplex.export(outfile, level, namespaceprefix_, name_='RoofComplex', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_House', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.typeRoof is not None:
            element.set('typeRoof', self.gds_format_integer(self.typeRoof))
        if self.hidden is not None:
            element.set('hidden', self.gds_format_integer(self.hidden))
        if self.Wall is not None:
            Wall_ = self.Wall
            Wall_.to_etree(element, name_='Wall', mapping_=mapping_)
        if self.RoofNone is not None:
            RoofNone_ = self.RoofNone
            RoofNone_.to_etree(element, name_='RoofNone', mapping_=mapping_)
        if self.RoofClassic is not None:
            RoofClassic_ = self.RoofClassic
            RoofClassic_.to_etree(element, name_='RoofClassic', mapping_=mapping_)
        if self.RoofPlate is not None:
            RoofPlate_ = self.RoofPlate
            RoofPlate_.to_etree(element, name_='RoofPlate', mapping_=mapping_)
        if self.RoofComplex is not None:
            RoofComplex_ = self.RoofComplex
            RoofComplex_.to_etree(element, name_='RoofComplex', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_House'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.typeRoof is not None and 'typeRoof' not in already_processed:
            already_processed.add('typeRoof')
            showIndent(outfile, level)
            outfile.write('typeRoof=%d,\n' % (self.typeRoof,))
        if self.hidden is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            showIndent(outfile, level)
            outfile.write('hidden=%d,\n' % (self.hidden,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Wall is not None:
            showIndent(outfile, level)
            outfile.write('Wall=model_._Wall(\n')
            self.Wall.exportLiteral(outfile, level, name_='Wall')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RoofNone is not None:
            showIndent(outfile, level)
            outfile.write('RoofNone=model_._RoofNone(\n')
            self.RoofNone.exportLiteral(outfile, level, name_='RoofNone')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RoofClassic is not None:
            showIndent(outfile, level)
            outfile.write('RoofClassic=model_._RoofClassic(\n')
            self.RoofClassic.exportLiteral(outfile, level, name_='RoofClassic')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RoofPlate is not None:
            showIndent(outfile, level)
            outfile.write('RoofPlate=model_._RoofPlate(\n')
            self.RoofPlate.exportLiteral(outfile, level, name_='RoofPlate')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RoofComplex is not None:
            showIndent(outfile, level)
            outfile.write('RoofComplex=model_._RoofComplex(\n')
            self.RoofComplex.exportLiteral(outfile, level, name_='RoofComplex')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('typeRoof', node)
        if value is not None and 'typeRoof' not in already_processed:
            already_processed.add('typeRoof')
            try:
                self.typeRoof = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('hidden', node)
        if value is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            try:
                self.hidden = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Wall':
            obj_ = create_Wall.factory()
            obj_.build(child_)
            self.set_Wall(obj_)
            obj_.original_tagname_ = 'Wall'
        elif nodeName_ == 'RoofNone':
            obj_ = create_RoofNone.factory()
            obj_.build(child_)
            self.set_RoofNone(obj_)
            obj_.original_tagname_ = 'RoofNone'
        elif nodeName_ == 'RoofClassic':
            obj_ = create_RoofClassic.factory()
            obj_.build(child_)
            self.set_RoofClassic(obj_)
            obj_.original_tagname_ = 'RoofClassic'
        elif nodeName_ == 'RoofPlate':
            obj_ = create_RoofPlate.factory()
            obj_.build(child_)
            self.set_RoofPlate(obj_)
            obj_.original_tagname_ = 'RoofPlate'
        elif nodeName_ == 'RoofComplex':
            obj_ = create_RoofComplex.factory()
            obj_.build(child_)
            self.set_RoofComplex(obj_)
            obj_.original_tagname_ = 'RoofComplex'
# end class create_House


class create_Wall(GeneratedsSuper):
    """Wall Wall"""
    subclass = None
    superclass = None
    def __init__(self, Polygon3D=None, OpticalProperties=None, ThermalProperties=None, InnerOpticalProperties=None, InnerThermalProperties=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("urban","_Wall")
        self.attrib = ['']
        self.children = ['Polygon3D', 'OpticalProperties', 'ThermalProperties', 'InnerOpticalProperties', 'InnerThermalProperties']
        self.parent = None
        self._Polygon3D = Polygon3D
        self._OpticalProperties = OpticalProperties
        self._ThermalProperties = ThermalProperties
        self._InnerOpticalProperties = InnerOpticalProperties
        self._InnerThermalProperties = InnerThermalProperties
        update_node(self,self.troot,"urban")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Wall)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Wall.subclass:
            return create_Wall.subclass(*args_, **kwargs_)
        else:
            return create_Wall(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Polygon3D(self): return self._Polygon3D
    def set_Polygon3D(self, value):
        if value is not None:
            checkclass(value, create_Polygon3D)
            value.parent = self
        self._Polygon3D = value
    Polygon3D = property(get_Polygon3D, set_Polygon3D)
    def get_OpticalProperties(self): return self._OpticalProperties
    def set_OpticalProperties(self, value):
        if value is not None:
            checkclass(value, create_OpticalProperties)
            value.parent = self
        self._OpticalProperties = value
    OpticalProperties = property(get_OpticalProperties, set_OpticalProperties)
    def get_ThermalProperties(self): return self._ThermalProperties
    def set_ThermalProperties(self, value):
        if value is not None:
            checkclass(value, create_ThermalProperties)
            value.parent = self
        self._ThermalProperties = value
    ThermalProperties = property(get_ThermalProperties, set_ThermalProperties)
    def get_InnerOpticalProperties(self): return self._InnerOpticalProperties
    def set_InnerOpticalProperties(self, value):
        if value is not None:
            checkclass(value, create_InnerOpticalProperties)
            value.parent = self
        self._InnerOpticalProperties = value
    InnerOpticalProperties = property(get_InnerOpticalProperties, set_InnerOpticalProperties)
    def get_InnerThermalProperties(self): return self._InnerThermalProperties
    def set_InnerThermalProperties(self, value):
        if value is not None:
            checkclass(value, create_InnerThermalProperties)
            value.parent = self
        self._InnerThermalProperties = value
    InnerThermalProperties = property(get_InnerThermalProperties, set_InnerThermalProperties)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Polygon3D is not None or
            self.OpticalProperties is not None or
            self.ThermalProperties is not None or
            self.InnerOpticalProperties is not None or
            self.InnerThermalProperties is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Wall', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Wall')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Wall')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Wall', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Wall'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Wall', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Polygon3D is not None:
            self.Polygon3D.export(outfile, level, namespaceprefix_, name_='Polygon3D', pretty_print=pretty_print)
        if self.OpticalProperties is not None:
            self.OpticalProperties.export(outfile, level, namespaceprefix_, name_='OpticalProperties', pretty_print=pretty_print)
        if self.ThermalProperties is not None:
            self.ThermalProperties.export(outfile, level, namespaceprefix_, name_='ThermalProperties', pretty_print=pretty_print)
        if self.InnerOpticalProperties is not None:
            self.InnerOpticalProperties.export(outfile, level, namespaceprefix_, name_='InnerOpticalProperties', pretty_print=pretty_print)
        if self.InnerThermalProperties is not None:
            self.InnerThermalProperties.export(outfile, level, namespaceprefix_, name_='InnerThermalProperties', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Wall', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.Polygon3D is not None:
            Polygon3D_ = self.Polygon3D
            Polygon3D_.to_etree(element, name_='Polygon3D', mapping_=mapping_)
        if self.OpticalProperties is not None:
            OpticalProperties_ = self.OpticalProperties
            OpticalProperties_.to_etree(element, name_='OpticalProperties', mapping_=mapping_)
        if self.ThermalProperties is not None:
            ThermalProperties_ = self.ThermalProperties
            ThermalProperties_.to_etree(element, name_='ThermalProperties', mapping_=mapping_)
        if self.InnerOpticalProperties is not None:
            InnerOpticalProperties_ = self.InnerOpticalProperties
            InnerOpticalProperties_.to_etree(element, name_='InnerOpticalProperties', mapping_=mapping_)
        if self.InnerThermalProperties is not None:
            InnerThermalProperties_ = self.InnerThermalProperties
            InnerThermalProperties_.to_etree(element, name_='InnerThermalProperties', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Wall'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Polygon3D is not None:
            showIndent(outfile, level)
            outfile.write('Polygon3D=model_._Polygon3D(\n')
            self.Polygon3D.exportLiteral(outfile, level, name_='Polygon3D')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OpticalProperties is not None:
            showIndent(outfile, level)
            outfile.write('OpticalProperties=model_._OpticalProperties(\n')
            self.OpticalProperties.exportLiteral(outfile, level, name_='OpticalProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ThermalProperties is not None:
            showIndent(outfile, level)
            outfile.write('ThermalProperties=model_._ThermalProperties(\n')
            self.ThermalProperties.exportLiteral(outfile, level, name_='ThermalProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InnerOpticalProperties is not None:
            showIndent(outfile, level)
            outfile.write('InnerOpticalProperties=model_._InnerOpticalProperties(\n')
            self.InnerOpticalProperties.exportLiteral(outfile, level, name_='InnerOpticalProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InnerThermalProperties is not None:
            showIndent(outfile, level)
            outfile.write('InnerThermalProperties=model_._InnerThermalProperties(\n')
            self.InnerThermalProperties.exportLiteral(outfile, level, name_='InnerThermalProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Polygon3D':
            obj_ = create_Polygon3D.factory()
            obj_.build(child_)
            self.set_Polygon3D(obj_)
            obj_.original_tagname_ = 'Polygon3D'
        elif nodeName_ == 'OpticalProperties':
            obj_ = create_OpticalProperties.factory()
            obj_.build(child_)
            self.set_OpticalProperties(obj_)
            obj_.original_tagname_ = 'OpticalProperties'
        elif nodeName_ == 'ThermalProperties':
            obj_ = create_ThermalProperties.factory()
            obj_.build(child_)
            self.set_ThermalProperties(obj_)
            obj_.original_tagname_ = 'ThermalProperties'
        elif nodeName_ == 'InnerOpticalProperties':
            obj_ = create_InnerOpticalProperties.factory()
            obj_.build(child_)
            self.set_InnerOpticalProperties(obj_)
            obj_.original_tagname_ = 'InnerOpticalProperties'
        elif nodeName_ == 'InnerThermalProperties':
            obj_ = create_InnerThermalProperties.factory()
            obj_.build(child_)
            self.set_InnerThermalProperties(obj_)
            obj_.original_tagname_ = 'InnerThermalProperties'
# end class create_Wall


class create_Polygon3D(GeneratedsSuper):
    """Polygon3D Polygon3D"""
    subclass = None
    superclass = None
    def __init__(self, Point3D=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("urban","_Polygon3D")
        self.attrib = ['']
        self.children = ['Point3D']
        self.parent = None
        if Point3D is None:
            self._Point3D = []
        else:
            self._Point3D = Point3D
        update_node(self,self.troot,"urban")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Polygon3D)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Polygon3D.subclass:
            return create_Polygon3D.subclass(*args_, **kwargs_)
        else:
            return create_Polygon3D(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Point3D(self): return self._Point3D
    def set_Point3D(self, value):
        if value is not None:
            checkclass(value, create_Point3D)
            for v in value:
                v.parent = self
        self._Point3D = value
    def add_Point3D(self, value):
        if (value is not None) and (len(self._Point3D) == 4):
            raise ValueError('Maximum length already reached.')
        value.parent = self
        self._Point3D.append(value)
    def insert_Point3D_at(self, index, value):
        if (value is not None) and (len(self._Point3D) == 4):
            raise ValueError('Maximum length already reached.')
        value.parent = self
        self.Point3D.insert(index, value)
    def replace_Point3D_at(self, index, value):
        value.parent = self
        self.Point3D[index] = value
    Point3D = property(get_Point3D, set_Point3D)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Point3D
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Polygon3D', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Polygon3D')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Polygon3D')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Polygon3D', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Polygon3D'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Polygon3D', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Point3D_ in self.Point3D:
            Point3D_.export(outfile, level, namespaceprefix_, name_='Point3D', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Polygon3D', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for Point3D_ in self.Point3D:
            Point3D_.to_etree(element, name_='Point3D', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Polygon3D'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Point3D=[\n')
        level += 1
        for Point3D_ in self.Point3D:
            showIndent(outfile, level)
            outfile.write('model_._Point3D(\n')
            Point3D_.exportLiteral(outfile, level, name_='_Point3D')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.Point3D = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Point3D':
            obj_ = create_Point3D.factory()
            obj_.build(child_)
            self.add_Point3D(obj_)
            obj_.original_tagname_ = 'Point3D'
# end class create_Polygon3D


class create_Point3D(GeneratedsSuper):
    """Point3D Point3D y coordinate of a top corner of a wall of the house.
    Counter-clockwise input y coordinate of a top corner of a wall
    of the house. Counter-clockwise input x coordinate of a top
    corner of a wall of the house. Counter-clockwise input x
    coordinate of a top corner of a wall of the house. Counter-
    clockwise input z coordinate of a top corner of a wall of the
    house. Counter-clockwise input z coordinate of a top corner of a
    wall of the house. Counter-clockwise input"""
    subclass = None
    superclass = None
    def __init__(self, y=10.00, x=10.00, z=2.50):
        self.original_tagname_ = None
        self.troot=get_gs_troot("urban","_Point3D")
        self.attrib = ['y', 'x', 'z']
        self.children = []
        self.parent = None
        self._y = _cast(float, y)
        self._x = _cast(float, x)
        self._z = _cast(float, z)
        update_node(self,self.troot,"urban")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Point3D)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Point3D.subclass:
            return create_Point3D.subclass(*args_, **kwargs_)
        else:
            return create_Point3D(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_y(self): return self._y
    def set_y(self, value):
        self._y = value
        update_node(self,self.troot,"urban")
    y = property(get_y, set_y)
    def get_x(self): return self._x
    def set_x(self, value):
        self._x = value
        update_node(self,self.troot,"urban")
    x = property(get_x, set_x)
    def get_z(self): return self._z
    def set_z(self, value):
        self._z = value
        update_node(self,self.troot,"urban")
    z = property(get_z, set_z)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Point3D', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Point3D')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Point3D')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Point3D', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Point3D'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y="%s"' % self.gds_format_double(self.y, input_name='y'))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name='x'))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z="%s"' % self.gds_format_double(self.z, input_name='z'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Point3D', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_Point3D', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.y is not None:
            element.set('y', self.gds_format_double(self.y))
        if self.x is not None:
            element.set('x', self.gds_format_double(self.x))
        if self.z is not None:
            element.set('z', self.gds_format_double(self.z))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Point3D'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            showIndent(outfile, level)
            outfile.write('y=%e,\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            showIndent(outfile, level)
            outfile.write('x=%e,\n' % (self.x,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            showIndent(outfile, level)
            outfile.write('z=%e,\n' % (self.z,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            try:
                self.y = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (y): %s' % exp)
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            try:
                self.x = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            try:
                self.z = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (z): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_Point3D


class create_OpticalProperties(GeneratedsSuper):
    """OpticalProperties OpticalProperties"""
    subclass = None
    superclass = None
    def __init__(self, OpticalPropertyLink=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("urban","_OpticalProperties")
        self.attrib = ['']
        self.children = ['OpticalPropertyLink']
        self.parent = None
        if OpticalPropertyLink is None:
            self._OpticalPropertyLink = []
        else:
            self._OpticalPropertyLink = OpticalPropertyLink
        update_node(self,self.troot,"urban")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_OpticalProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_OpticalProperties.subclass:
            return create_OpticalProperties.subclass(*args_, **kwargs_)
        else:
            return create_OpticalProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OpticalPropertyLink(self): return self._OpticalPropertyLink
    def set_OpticalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_OpticalPropertyLink)
            for v in value:
                v.parent = self
        self._OpticalPropertyLink = value
    def add_OpticalPropertyLink(self, value):
        if (value is not None) and (len(self._OpticalPropertyLink) == 4):
            raise ValueError('Maximum length already reached.')
        value.parent = self
        self._OpticalPropertyLink.append(value)
    def insert_OpticalPropertyLink_at(self, index, value):
        if (value is not None) and (len(self._OpticalPropertyLink) == 4):
            raise ValueError('Maximum length already reached.')
        value.parent = self
        self.OpticalPropertyLink.insert(index, value)
    def replace_OpticalPropertyLink_at(self, index, value):
        value.parent = self
        self.OpticalPropertyLink[index] = value
    OpticalPropertyLink = property(get_OpticalPropertyLink, set_OpticalPropertyLink)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.OpticalPropertyLink
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_OpticalProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_OpticalProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_OpticalProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_OpticalProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_OpticalProperties'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_OpticalProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for OpticalPropertyLink_ in self.OpticalPropertyLink:
            OpticalPropertyLink_.export(outfile, level, namespaceprefix_, name_='OpticalPropertyLink', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_OpticalProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for OpticalPropertyLink_ in self.OpticalPropertyLink:
            OpticalPropertyLink_.to_etree(element, name_='OpticalPropertyLink', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_OpticalProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('OpticalPropertyLink=[\n')
        level += 1
        for OpticalPropertyLink_ in self.OpticalPropertyLink:
            showIndent(outfile, level)
            outfile.write('model_._OpticalPropertyLink(\n')
            OpticalPropertyLink_.exportLiteral(outfile, level, name_='_OpticalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.OpticalPropertyLink = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OpticalPropertyLink':
            obj_ = create_OpticalPropertyLink.factory()
            obj_.build(child_)
            self.add_OpticalPropertyLink(obj_)
            obj_.original_tagname_ = 'OpticalPropertyLink'
# end class create_OpticalProperties


class create_OpticalPropertyLink(GeneratedsSuper):
    """OpticalPropertyLink OpticalPropertyLink Index of the DART phase
    function of the ground of the plot. Index of the DART phase
    function of the ground of the plot. wall from ground to Point3D
    4 and 1 wall from ground to Point3D 4 and 1 Type of phase
    function (lambertian, etc.) Type of phase function (lambertian,
    etc.)"""
    subclass = None
    superclass = None
    def __init__(self, indexFctPhase=0, ident='Lambertian_Phase_Function_1', type_=0):
        self.original_tagname_ = None
        self.troot=get_gs_troot("urban","_OpticalPropertyLink")
        self.attrib = ['indexFctPhase', 'ident', 'type_']
        self.children = []
        self.parent = None
        self._indexFctPhase = _cast(int, indexFctPhase)
        self._ident = _cast(None, ident)
        self._type_ = _cast(int, type_)
        update_node(self,self.troot,"urban")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_OpticalPropertyLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_OpticalPropertyLink.subclass:
            return create_OpticalPropertyLink.subclass(*args_, **kwargs_)
        else:
            return create_OpticalPropertyLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexFctPhase(self): return self._indexFctPhase
    def set_indexFctPhase(self, value):
        self._indexFctPhase = value
        update_node(self,self.troot,"urban")
    indexFctPhase = property(get_indexFctPhase, set_indexFctPhase)
    def get_ident(self): return self._ident
    def set_ident(self, value):
        self._ident = value
        update_node(self,self.troot,"urban")
    ident = property(get_ident, set_ident)
    def get_type(self): return self._type_
    def set_type(self, value):
        self._type_ = value
        update_node(self,self.troot,"urban")
    type_ = property(get_type, set_type)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_OpticalPropertyLink', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_OpticalPropertyLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_OpticalPropertyLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_OpticalPropertyLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_OpticalPropertyLink'):
        if self.indexFctPhase is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            outfile.write(' indexFctPhase="%s"' % self.gds_format_integer(self.indexFctPhase, input_name='indexFctPhase'))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            outfile.write(' ident=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ident), input_name='ident')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type="%s"' % self.gds_format_integer(self.type_, input_name='type'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_OpticalPropertyLink', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_OpticalPropertyLink', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.indexFctPhase is not None:
            element.set('indexFctPhase', self.gds_format_integer(self.indexFctPhase))
        if self.ident is not None:
            element.set('ident', self.gds_format_string(self.ident))
        if self.type_ is not None:
            element.set('type', self.gds_format_integer(self.type_))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_OpticalPropertyLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.indexFctPhase is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            showIndent(outfile, level)
            outfile.write('indexFctPhase=%d,\n' % (self.indexFctPhase,))
        if self.ident is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            showIndent(outfile, level)
            outfile.write('ident="%s",\n' % (self.ident,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_=%d,\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('indexFctPhase', node)
        if value is not None and 'indexFctPhase' not in already_processed:
            already_processed.add('indexFctPhase')
            try:
                self.indexFctPhase = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ident', node)
        if value is not None and 'ident' not in already_processed:
            already_processed.add('ident')
            self.ident = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            try:
                self.type_ = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_OpticalPropertyLink


class create_ThermalProperties(GeneratedsSuper):
    """ThermalProperties ThermalProperties"""
    subclass = None
    superclass = None
    def __init__(self, ThermalPropertyLink=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("urban","_ThermalProperties")
        self.attrib = ['']
        self.children = ['ThermalPropertyLink']
        self.parent = None
        if ThermalPropertyLink is None:
            self._ThermalPropertyLink = []
        else:
            self._ThermalPropertyLink = ThermalPropertyLink
        update_node(self,self.troot,"urban")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ThermalProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ThermalProperties.subclass:
            return create_ThermalProperties.subclass(*args_, **kwargs_)
        else:
            return create_ThermalProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ThermalPropertyLink(self): return self._ThermalPropertyLink
    def set_ThermalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_ThermalPropertyLink)
            for v in value:
                v.parent = self
        self._ThermalPropertyLink = value
    def add_ThermalPropertyLink(self, value):
        if (value is not None) and (len(self._ThermalPropertyLink) == 4):
            raise ValueError('Maximum length already reached.')
        value.parent = self
        self._ThermalPropertyLink.append(value)
    def insert_ThermalPropertyLink_at(self, index, value):
        if (value is not None) and (len(self._ThermalPropertyLink) == 4):
            raise ValueError('Maximum length already reached.')
        value.parent = self
        self.ThermalPropertyLink.insert(index, value)
    def replace_ThermalPropertyLink_at(self, index, value):
        value.parent = self
        self.ThermalPropertyLink[index] = value
    ThermalPropertyLink = property(get_ThermalPropertyLink, set_ThermalPropertyLink)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.ThermalPropertyLink
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ThermalProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ThermalProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ThermalProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ThermalProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ThermalProperties'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ThermalProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ThermalPropertyLink_ in self.ThermalPropertyLink:
            ThermalPropertyLink_.export(outfile, level, namespaceprefix_, name_='ThermalPropertyLink', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_ThermalProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for ThermalPropertyLink_ in self.ThermalPropertyLink:
            ThermalPropertyLink_.to_etree(element, name_='ThermalPropertyLink', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ThermalProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ThermalPropertyLink=[\n')
        level += 1
        for ThermalPropertyLink_ in self.ThermalPropertyLink:
            showIndent(outfile, level)
            outfile.write('model_._ThermalPropertyLink(\n')
            ThermalPropertyLink_.exportLiteral(outfile, level, name_='_ThermalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.ThermalPropertyLink = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ThermalPropertyLink':
            obj_ = create_ThermalPropertyLink.factory()
            obj_.build(child_)
            self.add_ThermalPropertyLink(obj_)
            obj_.original_tagname_ = 'ThermalPropertyLink'
# end class create_ThermalProperties


class create_ThermalPropertyLink(GeneratedsSuper):
    """ThermalPropertyLink ThermalPropertyLink indexTemperature
    indexTemperature Thermal Function ID Thermal Function ID"""
    subclass = None
    superclass = None
    def __init__(self, indexTemperature=0, idTemperature='ThermalFunction290_310'):
        self.original_tagname_ = None
        self.troot=get_gs_troot("urban","_ThermalPropertyLink")
        self.attrib = ['indexTemperature', 'idTemperature']
        self.children = []
        self.parent = None
        self._indexTemperature = _cast(int, indexTemperature)
        self._idTemperature = _cast(None, idTemperature)
        update_node(self,self.troot,"urban")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_ThermalPropertyLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_ThermalPropertyLink.subclass:
            return create_ThermalPropertyLink.subclass(*args_, **kwargs_)
        else:
            return create_ThermalPropertyLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexTemperature(self): return self._indexTemperature
    def set_indexTemperature(self, value):
        self._indexTemperature = value
        update_node(self,self.troot,"urban")
    indexTemperature = property(get_indexTemperature, set_indexTemperature)
    def get_idTemperature(self): return self._idTemperature
    def set_idTemperature(self, value):
        self._idTemperature = value
        update_node(self,self.troot,"urban")
    idTemperature = property(get_idTemperature, set_idTemperature)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_ThermalPropertyLink', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_ThermalPropertyLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_ThermalPropertyLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_ThermalPropertyLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_ThermalPropertyLink'):
        if self.indexTemperature is not None and 'indexTemperature' not in already_processed:
            already_processed.add('indexTemperature')
            outfile.write(' indexTemperature="%s"' % self.gds_format_integer(self.indexTemperature, input_name='indexTemperature'))
        if self.idTemperature is not None and 'idTemperature' not in already_processed:
            already_processed.add('idTemperature')
            outfile.write(' idTemperature=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idTemperature), input_name='idTemperature')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_ThermalPropertyLink', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_ThermalPropertyLink', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.indexTemperature is not None:
            element.set('indexTemperature', self.gds_format_integer(self.indexTemperature))
        if self.idTemperature is not None:
            element.set('idTemperature', self.gds_format_string(self.idTemperature))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_ThermalPropertyLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.indexTemperature is not None and 'indexTemperature' not in already_processed:
            already_processed.add('indexTemperature')
            showIndent(outfile, level)
            outfile.write('indexTemperature=%d,\n' % (self.indexTemperature,))
        if self.idTemperature is not None and 'idTemperature' not in already_processed:
            already_processed.add('idTemperature')
            showIndent(outfile, level)
            outfile.write('idTemperature="%s",\n' % (self.idTemperature,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('indexTemperature', node)
        if value is not None and 'indexTemperature' not in already_processed:
            already_processed.add('indexTemperature')
            try:
                self.indexTemperature = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('idTemperature', node)
        if value is not None and 'idTemperature' not in already_processed:
            already_processed.add('idTemperature')
            self.idTemperature = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_ThermalPropertyLink


class create_InnerOpticalProperties(GeneratedsSuper):
    """InnerOpticalProperties InnerOpticalProperties"""
    subclass = None
    superclass = None
    def __init__(self, OpticalPropertyLink=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("urban","_InnerOpticalProperties")
        self.attrib = ['']
        self.children = ['OpticalPropertyLink']
        self.parent = None
        if OpticalPropertyLink is None:
            self._OpticalPropertyLink = []
        else:
            self._OpticalPropertyLink = OpticalPropertyLink
        update_node(self,self.troot,"urban")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_InnerOpticalProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_InnerOpticalProperties.subclass:
            return create_InnerOpticalProperties.subclass(*args_, **kwargs_)
        else:
            return create_InnerOpticalProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OpticalPropertyLink(self): return self._OpticalPropertyLink
    def set_OpticalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_OpticalPropertyLink)
            for v in value:
                v.parent = self
        self._OpticalPropertyLink = value
    def add_OpticalPropertyLink(self, value):
        if (value is not None) and (len(self._OpticalPropertyLink) == 4):
            raise ValueError('Maximum length already reached.')
        value.parent = self
        self._OpticalPropertyLink.append(value)
    def insert_OpticalPropertyLink_at(self, index, value):
        if (value is not None) and (len(self._OpticalPropertyLink) == 4):
            raise ValueError('Maximum length already reached.')
        value.parent = self
        self.OpticalPropertyLink.insert(index, value)
    def replace_OpticalPropertyLink_at(self, index, value):
        value.parent = self
        self.OpticalPropertyLink[index] = value
    OpticalPropertyLink = property(get_OpticalPropertyLink, set_OpticalPropertyLink)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.OpticalPropertyLink
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_InnerOpticalProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_InnerOpticalProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_InnerOpticalProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_InnerOpticalProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_InnerOpticalProperties'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_InnerOpticalProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for OpticalPropertyLink_ in self.OpticalPropertyLink:
            OpticalPropertyLink_.export(outfile, level, namespaceprefix_, name_='OpticalPropertyLink', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_InnerOpticalProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for OpticalPropertyLink_ in self.OpticalPropertyLink:
            OpticalPropertyLink_.to_etree(element, name_='OpticalPropertyLink', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_InnerOpticalProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('OpticalPropertyLink=[\n')
        level += 1
        for OpticalPropertyLink_ in self.OpticalPropertyLink:
            showIndent(outfile, level)
            outfile.write('model_._OpticalPropertyLink(\n')
            OpticalPropertyLink_.exportLiteral(outfile, level, name_='_OpticalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.OpticalPropertyLink = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OpticalPropertyLink':
            obj_ = create_OpticalPropertyLink.factory()
            obj_.build(child_)
            self.add_OpticalPropertyLink(obj_)
            obj_.original_tagname_ = 'OpticalPropertyLink'
# end class create_InnerOpticalProperties


class create_InnerThermalProperties(GeneratedsSuper):
    """InnerThermalProperties InnerThermalProperties"""
    subclass = None
    superclass = None
    def __init__(self, ThermalPropertyLink=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("urban","_InnerThermalProperties")
        self.attrib = ['']
        self.children = ['ThermalPropertyLink']
        self.parent = None
        if ThermalPropertyLink is None:
            self._ThermalPropertyLink = []
        else:
            self._ThermalPropertyLink = ThermalPropertyLink
        update_node(self,self.troot,"urban")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_InnerThermalProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_InnerThermalProperties.subclass:
            return create_InnerThermalProperties.subclass(*args_, **kwargs_)
        else:
            return create_InnerThermalProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ThermalPropertyLink(self): return self._ThermalPropertyLink
    def set_ThermalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_ThermalPropertyLink)
            for v in value:
                v.parent = self
        self._ThermalPropertyLink = value
    def add_ThermalPropertyLink(self, value):
        if (value is not None) and (len(self._ThermalPropertyLink) == 4):
            raise ValueError('Maximum length already reached.')
        value.parent = self
        self._ThermalPropertyLink.append(value)
    def insert_ThermalPropertyLink_at(self, index, value):
        if (value is not None) and (len(self._ThermalPropertyLink) == 4):
            raise ValueError('Maximum length already reached.')
        value.parent = self
        self.ThermalPropertyLink.insert(index, value)
    def replace_ThermalPropertyLink_at(self, index, value):
        value.parent = self
        self.ThermalPropertyLink[index] = value
    ThermalPropertyLink = property(get_ThermalPropertyLink, set_ThermalPropertyLink)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.ThermalPropertyLink
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_InnerThermalProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_InnerThermalProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_InnerThermalProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_InnerThermalProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_InnerThermalProperties'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_InnerThermalProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ThermalPropertyLink_ in self.ThermalPropertyLink:
            ThermalPropertyLink_.export(outfile, level, namespaceprefix_, name_='ThermalPropertyLink', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_InnerThermalProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for ThermalPropertyLink_ in self.ThermalPropertyLink:
            ThermalPropertyLink_.to_etree(element, name_='ThermalPropertyLink', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_InnerThermalProperties'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ThermalPropertyLink=[\n')
        level += 1
        for ThermalPropertyLink_ in self.ThermalPropertyLink:
            showIndent(outfile, level)
            outfile.write('model_._ThermalPropertyLink(\n')
            ThermalPropertyLink_.exportLiteral(outfile, level, name_='_ThermalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.ThermalPropertyLink = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ThermalPropertyLink':
            obj_ = create_ThermalPropertyLink.factory()
            obj_.build(child_)
            self.add_ThermalPropertyLink(obj_)
            obj_.original_tagname_ = 'ThermalPropertyLink'
# end class create_InnerThermalProperties


class create_RoofNone(GeneratedsSuper):
    """RoofNone RoofNone"""
    subclass = None
    superclass = None
    def __init__(self, OpticalProperties=None, ThermalProperties=None, InnerOpticalProperties=None, InnerThermalProperties=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("urban","_RoofNone")
        self.attrib = ['']
        self.children = ['OpticalProperties', 'ThermalProperties', 'InnerOpticalProperties', 'InnerThermalProperties']
        self.parent = None
        self._OpticalProperties = OpticalProperties
        self._ThermalProperties = ThermalProperties
        self._InnerOpticalProperties = InnerOpticalProperties
        self._InnerThermalProperties = InnerThermalProperties
        update_node(self,self.troot,"urban")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_RoofNone)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_RoofNone.subclass:
            return create_RoofNone.subclass(*args_, **kwargs_)
        else:
            return create_RoofNone(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OpticalProperties(self): return self._OpticalProperties
    def set_OpticalProperties(self, value):
        if value is not None:
            checkclass(value, create_OpticalProperties)
            value.parent = self
        self._OpticalProperties = value
    OpticalProperties = property(get_OpticalProperties, set_OpticalProperties)
    def get_ThermalProperties(self): return self._ThermalProperties
    def set_ThermalProperties(self, value):
        if value is not None:
            checkclass(value, create_ThermalProperties)
            value.parent = self
        self._ThermalProperties = value
    ThermalProperties = property(get_ThermalProperties, set_ThermalProperties)
    def get_InnerOpticalProperties(self): return self._InnerOpticalProperties
    def set_InnerOpticalProperties(self, value):
        if value is not None:
            checkclass(value, create_InnerOpticalProperties)
            value.parent = self
        self._InnerOpticalProperties = value
    InnerOpticalProperties = property(get_InnerOpticalProperties, set_InnerOpticalProperties)
    def get_InnerThermalProperties(self): return self._InnerThermalProperties
    def set_InnerThermalProperties(self, value):
        if value is not None:
            checkclass(value, create_InnerThermalProperties)
            value.parent = self
        self._InnerThermalProperties = value
    InnerThermalProperties = property(get_InnerThermalProperties, set_InnerThermalProperties)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.OpticalProperties is not None or
            self.ThermalProperties is not None or
            self.InnerOpticalProperties is not None or
            self.InnerThermalProperties is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_RoofNone', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_RoofNone')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_RoofNone')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_RoofNone', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_RoofNone'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_RoofNone', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OpticalProperties is not None:
            self.OpticalProperties.export(outfile, level, namespaceprefix_, name_='OpticalProperties', pretty_print=pretty_print)
        if self.ThermalProperties is not None:
            self.ThermalProperties.export(outfile, level, namespaceprefix_, name_='ThermalProperties', pretty_print=pretty_print)
        if self.InnerOpticalProperties is not None:
            self.InnerOpticalProperties.export(outfile, level, namespaceprefix_, name_='InnerOpticalProperties', pretty_print=pretty_print)
        if self.InnerThermalProperties is not None:
            self.InnerThermalProperties.export(outfile, level, namespaceprefix_, name_='InnerThermalProperties', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_RoofNone', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.OpticalProperties is not None:
            OpticalProperties_ = self.OpticalProperties
            OpticalProperties_.to_etree(element, name_='OpticalProperties', mapping_=mapping_)
        if self.ThermalProperties is not None:
            ThermalProperties_ = self.ThermalProperties
            ThermalProperties_.to_etree(element, name_='ThermalProperties', mapping_=mapping_)
        if self.InnerOpticalProperties is not None:
            InnerOpticalProperties_ = self.InnerOpticalProperties
            InnerOpticalProperties_.to_etree(element, name_='InnerOpticalProperties', mapping_=mapping_)
        if self.InnerThermalProperties is not None:
            InnerThermalProperties_ = self.InnerThermalProperties
            InnerThermalProperties_.to_etree(element, name_='InnerThermalProperties', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_RoofNone'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.OpticalProperties is not None:
            showIndent(outfile, level)
            outfile.write('OpticalProperties=model_._OpticalProperties(\n')
            self.OpticalProperties.exportLiteral(outfile, level, name_='OpticalProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ThermalProperties is not None:
            showIndent(outfile, level)
            outfile.write('ThermalProperties=model_._ThermalProperties(\n')
            self.ThermalProperties.exportLiteral(outfile, level, name_='ThermalProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InnerOpticalProperties is not None:
            showIndent(outfile, level)
            outfile.write('InnerOpticalProperties=model_._InnerOpticalProperties(\n')
            self.InnerOpticalProperties.exportLiteral(outfile, level, name_='InnerOpticalProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InnerThermalProperties is not None:
            showIndent(outfile, level)
            outfile.write('InnerThermalProperties=model_._InnerThermalProperties(\n')
            self.InnerThermalProperties.exportLiteral(outfile, level, name_='InnerThermalProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OpticalProperties':
            obj_ = create_OpticalProperties.factory()
            obj_.build(child_)
            self.set_OpticalProperties(obj_)
            obj_.original_tagname_ = 'OpticalProperties'
        elif nodeName_ == 'ThermalProperties':
            obj_ = create_ThermalProperties.factory()
            obj_.build(child_)
            self.set_ThermalProperties(obj_)
            obj_.original_tagname_ = 'ThermalProperties'
        elif nodeName_ == 'InnerOpticalProperties':
            obj_ = create_InnerOpticalProperties.factory()
            obj_.build(child_)
            self.set_InnerOpticalProperties(obj_)
            obj_.original_tagname_ = 'InnerOpticalProperties'
        elif nodeName_ == 'InnerThermalProperties':
            obj_ = create_InnerThermalProperties.factory()
            obj_.build(child_)
            self.set_InnerThermalProperties(obj_)
            obj_.original_tagname_ = 'InnerThermalProperties'
# end class create_RoofNone


class create_RoofClassic(GeneratedsSuper):
    """RoofClassic RoofClassic"""
    subclass = None
    superclass = None
    def __init__(self, Polygon3D=None, OpticalProperties=None, ThermalProperties=None, InnerOpticalProperties=None, InnerThermalProperties=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("urban","_RoofClassic")
        self.attrib = ['']
        self.children = ['Polygon3D', 'OpticalProperties', 'ThermalProperties', 'InnerOpticalProperties', 'InnerThermalProperties']
        self.parent = None
        self._Polygon3D = Polygon3D
        self._OpticalProperties = OpticalProperties
        self._ThermalProperties = ThermalProperties
        self._InnerOpticalProperties = InnerOpticalProperties
        self._InnerThermalProperties = InnerThermalProperties
        update_node(self,self.troot,"urban")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_RoofClassic)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_RoofClassic.subclass:
            return create_RoofClassic.subclass(*args_, **kwargs_)
        else:
            return create_RoofClassic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Polygon3D(self): return self._Polygon3D
    def set_Polygon3D(self, value):
        if value is not None:
            checkclass(value, create_Polygon3D)
            value.parent = self
        self._Polygon3D = value
    Polygon3D = property(get_Polygon3D, set_Polygon3D)
    def get_OpticalProperties(self): return self._OpticalProperties
    def set_OpticalProperties(self, value):
        if value is not None:
            checkclass(value, create_OpticalProperties)
            value.parent = self
        self._OpticalProperties = value
    OpticalProperties = property(get_OpticalProperties, set_OpticalProperties)
    def get_ThermalProperties(self): return self._ThermalProperties
    def set_ThermalProperties(self, value):
        if value is not None:
            checkclass(value, create_ThermalProperties)
            value.parent = self
        self._ThermalProperties = value
    ThermalProperties = property(get_ThermalProperties, set_ThermalProperties)
    def get_InnerOpticalProperties(self): return self._InnerOpticalProperties
    def set_InnerOpticalProperties(self, value):
        if value is not None:
            checkclass(value, create_InnerOpticalProperties)
            value.parent = self
        self._InnerOpticalProperties = value
    InnerOpticalProperties = property(get_InnerOpticalProperties, set_InnerOpticalProperties)
    def get_InnerThermalProperties(self): return self._InnerThermalProperties
    def set_InnerThermalProperties(self, value):
        if value is not None:
            checkclass(value, create_InnerThermalProperties)
            value.parent = self
        self._InnerThermalProperties = value
    InnerThermalProperties = property(get_InnerThermalProperties, set_InnerThermalProperties)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Polygon3D is not None or
            self.OpticalProperties is not None or
            self.ThermalProperties is not None or
            self.InnerOpticalProperties is not None or
            self.InnerThermalProperties is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_RoofClassic', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_RoofClassic')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_RoofClassic')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_RoofClassic', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_RoofClassic'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_RoofClassic', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Polygon3D is not None:
            self.Polygon3D.export(outfile, level, namespaceprefix_, name_='Polygon3D', pretty_print=pretty_print)
        if self.OpticalProperties is not None:
            self.OpticalProperties.export(outfile, level, namespaceprefix_, name_='OpticalProperties', pretty_print=pretty_print)
        if self.ThermalProperties is not None:
            self.ThermalProperties.export(outfile, level, namespaceprefix_, name_='ThermalProperties', pretty_print=pretty_print)
        if self.InnerOpticalProperties is not None:
            self.InnerOpticalProperties.export(outfile, level, namespaceprefix_, name_='InnerOpticalProperties', pretty_print=pretty_print)
        if self.InnerThermalProperties is not None:
            self.InnerThermalProperties.export(outfile, level, namespaceprefix_, name_='InnerThermalProperties', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_RoofClassic', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.Polygon3D is not None:
            Polygon3D_ = self.Polygon3D
            Polygon3D_.to_etree(element, name_='Polygon3D', mapping_=mapping_)
        if self.OpticalProperties is not None:
            OpticalProperties_ = self.OpticalProperties
            OpticalProperties_.to_etree(element, name_='OpticalProperties', mapping_=mapping_)
        if self.ThermalProperties is not None:
            ThermalProperties_ = self.ThermalProperties
            ThermalProperties_.to_etree(element, name_='ThermalProperties', mapping_=mapping_)
        if self.InnerOpticalProperties is not None:
            InnerOpticalProperties_ = self.InnerOpticalProperties
            InnerOpticalProperties_.to_etree(element, name_='InnerOpticalProperties', mapping_=mapping_)
        if self.InnerThermalProperties is not None:
            InnerThermalProperties_ = self.InnerThermalProperties
            InnerThermalProperties_.to_etree(element, name_='InnerThermalProperties', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_RoofClassic'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Polygon3D is not None:
            showIndent(outfile, level)
            outfile.write('Polygon3D=model_._Polygon3D(\n')
            self.Polygon3D.exportLiteral(outfile, level, name_='Polygon3D')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OpticalProperties is not None:
            showIndent(outfile, level)
            outfile.write('OpticalProperties=model_._OpticalProperties(\n')
            self.OpticalProperties.exportLiteral(outfile, level, name_='OpticalProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ThermalProperties is not None:
            showIndent(outfile, level)
            outfile.write('ThermalProperties=model_._ThermalProperties(\n')
            self.ThermalProperties.exportLiteral(outfile, level, name_='ThermalProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InnerOpticalProperties is not None:
            showIndent(outfile, level)
            outfile.write('InnerOpticalProperties=model_._InnerOpticalProperties(\n')
            self.InnerOpticalProperties.exportLiteral(outfile, level, name_='InnerOpticalProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InnerThermalProperties is not None:
            showIndent(outfile, level)
            outfile.write('InnerThermalProperties=model_._InnerThermalProperties(\n')
            self.InnerThermalProperties.exportLiteral(outfile, level, name_='InnerThermalProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Polygon3D':
            obj_ = create_Polygon3D.factory()
            obj_.build(child_)
            self.set_Polygon3D(obj_)
            obj_.original_tagname_ = 'Polygon3D'
        elif nodeName_ == 'OpticalProperties':
            obj_ = create_OpticalProperties.factory()
            obj_.build(child_)
            self.set_OpticalProperties(obj_)
            obj_.original_tagname_ = 'OpticalProperties'
        elif nodeName_ == 'ThermalProperties':
            obj_ = create_ThermalProperties.factory()
            obj_.build(child_)
            self.set_ThermalProperties(obj_)
            obj_.original_tagname_ = 'ThermalProperties'
        elif nodeName_ == 'InnerOpticalProperties':
            obj_ = create_InnerOpticalProperties.factory()
            obj_.build(child_)
            self.set_InnerOpticalProperties(obj_)
            obj_.original_tagname_ = 'InnerOpticalProperties'
        elif nodeName_ == 'InnerThermalProperties':
            obj_ = create_InnerThermalProperties.factory()
            obj_.build(child_)
            self.set_InnerThermalProperties(obj_)
            obj_.original_tagname_ = 'InnerThermalProperties'
# end class create_RoofClassic


class create_RoofPlate(GeneratedsSuper):
    """RoofPlate RoofPlate Vertical translation applied to the 4 corners of
    the walls for obtaining the 4 points that define the roof
    Vertical translation applied to the 4 corners of the walls for
    obtaining the 4 points that define the roof"""
    subclass = None
    superclass = None
    def __init__(self, height=0.05, OpticalProperties=None, ThermalProperties=None, InnerOpticalProperties=None, InnerThermalProperties=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("urban","_RoofPlate")
        self.attrib = ['height']
        self.children = ['OpticalProperties', 'ThermalProperties', 'InnerOpticalProperties', 'InnerThermalProperties']
        self.parent = None
        self._height = _cast(float, height)
        self._OpticalProperties = OpticalProperties
        self._ThermalProperties = ThermalProperties
        self._InnerOpticalProperties = InnerOpticalProperties
        self._InnerThermalProperties = InnerThermalProperties
        update_node(self,self.troot,"urban")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_RoofPlate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_RoofPlate.subclass:
            return create_RoofPlate.subclass(*args_, **kwargs_)
        else:
            return create_RoofPlate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OpticalProperties(self): return self._OpticalProperties
    def set_OpticalProperties(self, value):
        if value is not None:
            checkclass(value, create_OpticalProperties)
            value.parent = self
        self._OpticalProperties = value
    OpticalProperties = property(get_OpticalProperties, set_OpticalProperties)
    def get_ThermalProperties(self): return self._ThermalProperties
    def set_ThermalProperties(self, value):
        if value is not None:
            checkclass(value, create_ThermalProperties)
            value.parent = self
        self._ThermalProperties = value
    ThermalProperties = property(get_ThermalProperties, set_ThermalProperties)
    def get_InnerOpticalProperties(self): return self._InnerOpticalProperties
    def set_InnerOpticalProperties(self, value):
        if value is not None:
            checkclass(value, create_InnerOpticalProperties)
            value.parent = self
        self._InnerOpticalProperties = value
    InnerOpticalProperties = property(get_InnerOpticalProperties, set_InnerOpticalProperties)
    def get_InnerThermalProperties(self): return self._InnerThermalProperties
    def set_InnerThermalProperties(self, value):
        if value is not None:
            checkclass(value, create_InnerThermalProperties)
            value.parent = self
        self._InnerThermalProperties = value
    InnerThermalProperties = property(get_InnerThermalProperties, set_InnerThermalProperties)
    def get_height(self): return self._height
    def set_height(self, value):
        self._height = value
        update_node(self,self.troot,"urban")
    height = property(get_height, set_height)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.OpticalProperties is not None or
            self.ThermalProperties is not None or
            self.InnerOpticalProperties is not None or
            self.InnerThermalProperties is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_RoofPlate', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_RoofPlate')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_RoofPlate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_RoofPlate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_RoofPlate'):
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height="%s"' % self.gds_format_double(self.height, input_name='height'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_RoofPlate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OpticalProperties is not None:
            self.OpticalProperties.export(outfile, level, namespaceprefix_, name_='OpticalProperties', pretty_print=pretty_print)
        if self.ThermalProperties is not None:
            self.ThermalProperties.export(outfile, level, namespaceprefix_, name_='ThermalProperties', pretty_print=pretty_print)
        if self.InnerOpticalProperties is not None:
            self.InnerOpticalProperties.export(outfile, level, namespaceprefix_, name_='InnerOpticalProperties', pretty_print=pretty_print)
        if self.InnerThermalProperties is not None:
            self.InnerThermalProperties.export(outfile, level, namespaceprefix_, name_='InnerThermalProperties', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_RoofPlate', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.height is not None:
            element.set('height', self.gds_format_double(self.height))
        if self.OpticalProperties is not None:
            OpticalProperties_ = self.OpticalProperties
            OpticalProperties_.to_etree(element, name_='OpticalProperties', mapping_=mapping_)
        if self.ThermalProperties is not None:
            ThermalProperties_ = self.ThermalProperties
            ThermalProperties_.to_etree(element, name_='ThermalProperties', mapping_=mapping_)
        if self.InnerOpticalProperties is not None:
            InnerOpticalProperties_ = self.InnerOpticalProperties
            InnerOpticalProperties_.to_etree(element, name_='InnerOpticalProperties', mapping_=mapping_)
        if self.InnerThermalProperties is not None:
            InnerThermalProperties_ = self.InnerThermalProperties
            InnerThermalProperties_.to_etree(element, name_='InnerThermalProperties', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_RoofPlate'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            showIndent(outfile, level)
            outfile.write('height=%e,\n' % (self.height,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.OpticalProperties is not None:
            showIndent(outfile, level)
            outfile.write('OpticalProperties=model_._OpticalProperties(\n')
            self.OpticalProperties.exportLiteral(outfile, level, name_='OpticalProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ThermalProperties is not None:
            showIndent(outfile, level)
            outfile.write('ThermalProperties=model_._ThermalProperties(\n')
            self.ThermalProperties.exportLiteral(outfile, level, name_='ThermalProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InnerOpticalProperties is not None:
            showIndent(outfile, level)
            outfile.write('InnerOpticalProperties=model_._InnerOpticalProperties(\n')
            self.InnerOpticalProperties.exportLiteral(outfile, level, name_='InnerOpticalProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InnerThermalProperties is not None:
            showIndent(outfile, level)
            outfile.write('InnerThermalProperties=model_._InnerThermalProperties(\n')
            self.InnerThermalProperties.exportLiteral(outfile, level, name_='InnerThermalProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            try:
                self.height = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (height): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OpticalProperties':
            obj_ = create_OpticalProperties.factory()
            obj_.build(child_)
            self.set_OpticalProperties(obj_)
            obj_.original_tagname_ = 'OpticalProperties'
        elif nodeName_ == 'ThermalProperties':
            obj_ = create_ThermalProperties.factory()
            obj_.build(child_)
            self.set_ThermalProperties(obj_)
            obj_.original_tagname_ = 'ThermalProperties'
        elif nodeName_ == 'InnerOpticalProperties':
            obj_ = create_InnerOpticalProperties.factory()
            obj_.build(child_)
            self.set_InnerOpticalProperties(obj_)
            obj_.original_tagname_ = 'InnerOpticalProperties'
        elif nodeName_ == 'InnerThermalProperties':
            obj_ = create_InnerThermalProperties.factory()
            obj_.build(child_)
            self.set_InnerThermalProperties(obj_)
            obj_.original_tagname_ = 'InnerThermalProperties'
# end class create_RoofPlate


class create_RoofComplex(GeneratedsSuper):
    """RoofComplex RoofComplex"""
    subclass = None
    superclass = None
    def __init__(self, Polygon3D=None, OpticalProperties=None, ThermalProperties=None, InnerOpticalProperties=None, InnerThermalProperties=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("urban","_RoofComplex")
        self.attrib = ['']
        self.children = ['Polygon3D', 'OpticalProperties', 'ThermalProperties', 'InnerOpticalProperties', 'InnerThermalProperties']
        self.parent = None
        self._Polygon3D = Polygon3D
        self._OpticalProperties = OpticalProperties
        self._ThermalProperties = ThermalProperties
        self._InnerOpticalProperties = InnerOpticalProperties
        self._InnerThermalProperties = InnerThermalProperties
        update_node(self,self.troot,"urban")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_RoofComplex)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_RoofComplex.subclass:
            return create_RoofComplex.subclass(*args_, **kwargs_)
        else:
            return create_RoofComplex(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Polygon3D(self): return self._Polygon3D
    def set_Polygon3D(self, value):
        if value is not None:
            checkclass(value, create_Polygon3D)
            value.parent = self
        self._Polygon3D = value
    Polygon3D = property(get_Polygon3D, set_Polygon3D)
    def get_OpticalProperties(self): return self._OpticalProperties
    def set_OpticalProperties(self, value):
        if value is not None:
            checkclass(value, create_OpticalProperties)
            value.parent = self
        self._OpticalProperties = value
    OpticalProperties = property(get_OpticalProperties, set_OpticalProperties)
    def get_ThermalProperties(self): return self._ThermalProperties
    def set_ThermalProperties(self, value):
        if value is not None:
            checkclass(value, create_ThermalProperties)
            value.parent = self
        self._ThermalProperties = value
    ThermalProperties = property(get_ThermalProperties, set_ThermalProperties)
    def get_InnerOpticalProperties(self): return self._InnerOpticalProperties
    def set_InnerOpticalProperties(self, value):
        if value is not None:
            checkclass(value, create_InnerOpticalProperties)
            value.parent = self
        self._InnerOpticalProperties = value
    InnerOpticalProperties = property(get_InnerOpticalProperties, set_InnerOpticalProperties)
    def get_InnerThermalProperties(self): return self._InnerThermalProperties
    def set_InnerThermalProperties(self, value):
        if value is not None:
            checkclass(value, create_InnerThermalProperties)
            value.parent = self
        self._InnerThermalProperties = value
    InnerThermalProperties = property(get_InnerThermalProperties, set_InnerThermalProperties)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Polygon3D is not None or
            self.OpticalProperties is not None or
            self.ThermalProperties is not None or
            self.InnerOpticalProperties is not None or
            self.InnerThermalProperties is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_RoofComplex', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_RoofComplex')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_RoofComplex')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_RoofComplex', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_RoofComplex'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_RoofComplex', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Polygon3D is not None:
            self.Polygon3D.export(outfile, level, namespaceprefix_, name_='Polygon3D', pretty_print=pretty_print)
        if self.OpticalProperties is not None:
            self.OpticalProperties.export(outfile, level, namespaceprefix_, name_='OpticalProperties', pretty_print=pretty_print)
        if self.ThermalProperties is not None:
            self.ThermalProperties.export(outfile, level, namespaceprefix_, name_='ThermalProperties', pretty_print=pretty_print)
        if self.InnerOpticalProperties is not None:
            self.InnerOpticalProperties.export(outfile, level, namespaceprefix_, name_='InnerOpticalProperties', pretty_print=pretty_print)
        if self.InnerThermalProperties is not None:
            self.InnerThermalProperties.export(outfile, level, namespaceprefix_, name_='InnerThermalProperties', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_RoofComplex', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.Polygon3D is not None:
            Polygon3D_ = self.Polygon3D
            Polygon3D_.to_etree(element, name_='Polygon3D', mapping_=mapping_)
        if self.OpticalProperties is not None:
            OpticalProperties_ = self.OpticalProperties
            OpticalProperties_.to_etree(element, name_='OpticalProperties', mapping_=mapping_)
        if self.ThermalProperties is not None:
            ThermalProperties_ = self.ThermalProperties
            ThermalProperties_.to_etree(element, name_='ThermalProperties', mapping_=mapping_)
        if self.InnerOpticalProperties is not None:
            InnerOpticalProperties_ = self.InnerOpticalProperties
            InnerOpticalProperties_.to_etree(element, name_='InnerOpticalProperties', mapping_=mapping_)
        if self.InnerThermalProperties is not None:
            InnerThermalProperties_ = self.InnerThermalProperties
            InnerThermalProperties_.to_etree(element, name_='InnerThermalProperties', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_RoofComplex'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Polygon3D is not None:
            showIndent(outfile, level)
            outfile.write('Polygon3D=model_._Polygon3D(\n')
            self.Polygon3D.exportLiteral(outfile, level, name_='Polygon3D')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OpticalProperties is not None:
            showIndent(outfile, level)
            outfile.write('OpticalProperties=model_._OpticalProperties(\n')
            self.OpticalProperties.exportLiteral(outfile, level, name_='OpticalProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ThermalProperties is not None:
            showIndent(outfile, level)
            outfile.write('ThermalProperties=model_._ThermalProperties(\n')
            self.ThermalProperties.exportLiteral(outfile, level, name_='ThermalProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InnerOpticalProperties is not None:
            showIndent(outfile, level)
            outfile.write('InnerOpticalProperties=model_._InnerOpticalProperties(\n')
            self.InnerOpticalProperties.exportLiteral(outfile, level, name_='InnerOpticalProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InnerThermalProperties is not None:
            showIndent(outfile, level)
            outfile.write('InnerThermalProperties=model_._InnerThermalProperties(\n')
            self.InnerThermalProperties.exportLiteral(outfile, level, name_='InnerThermalProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Polygon3D':
            obj_ = create_Polygon3D.factory()
            obj_.build(child_)
            self.set_Polygon3D(obj_)
            obj_.original_tagname_ = 'Polygon3D'
        elif nodeName_ == 'OpticalProperties':
            obj_ = create_OpticalProperties.factory()
            obj_.build(child_)
            self.set_OpticalProperties(obj_)
            obj_.original_tagname_ = 'OpticalProperties'
        elif nodeName_ == 'ThermalProperties':
            obj_ = create_ThermalProperties.factory()
            obj_.build(child_)
            self.set_ThermalProperties(obj_)
            obj_.original_tagname_ = 'ThermalProperties'
        elif nodeName_ == 'InnerOpticalProperties':
            obj_ = create_InnerOpticalProperties.factory()
            obj_.build(child_)
            self.set_InnerOpticalProperties(obj_)
            obj_.original_tagname_ = 'InnerOpticalProperties'
        elif nodeName_ == 'InnerThermalProperties':
            obj_ = create_InnerThermalProperties.factory()
            obj_.build(child_)
            self.set_InnerThermalProperties(obj_)
            obj_.original_tagname_ = 'InnerThermalProperties'
# end class create_RoofComplex


class create_Roads(GeneratedsSuper):
    """Roads Roads"""
    subclass = None
    superclass = None
    def __init__(self, Road=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("urban","_Roads")
        self.attrib = ['']
        self.children = ['Road']
        self.parent = None
        if Road is None:
            self._Road = []
        else:
            self._Road = Road
        update_node(self,self.troot,"urban")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Roads)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Roads.subclass:
            return create_Roads.subclass(*args_, **kwargs_)
        else:
            return create_Roads(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Road(self): return self._Road
    def set_Road(self, value):
        if value is not None:
            checkclass(value, create_Road)
            for v in value:
                v.parent = self
        self._Road = value
    def add_Road(self, value):
        value.parent = self
        self._Road.append(value)
    def insert_Road_at(self, index, value):
        value.parent = self
        self.Road.insert(index, value)
    def replace_Road_at(self, index, value):
        value.parent = self
        self.Road[index] = value
    Road = property(get_Road, set_Road)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Road
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Roads', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Roads')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Roads')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Roads', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Roads'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Roads', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Road_ in self.Road:
            Road_.export(outfile, level, namespaceprefix_, name_='Road', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Roads', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for Road_ in self.Road:
            Road_.to_etree(element, name_='Road', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Roads'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Road=[\n')
        level += 1
        for Road_ in self.Road:
            showIndent(outfile, level)
            outfile.write('model_._Road(\n')
            Road_.exportLiteral(outfile, level, name_='_Road')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.Road = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Road':
            obj_ = create_Road.factory()
            obj_.build(child_)
            self.add_Road(obj_)
            obj_.original_tagname_ = 'Road'
# end class create_Roads


class create_Road(GeneratedsSuper):
    """Road Road If you select this option, this road are not use in all
    DART modules, \n it's useful if you want conserve road
    properties backup without delete this for tests If you select
    this option, this road are not use in all DART modules, \n it's
    useful if you want conserve road properties backup without
    delete this for tests Objects's positions are taken from the
    position file.\nDesactivate this option if you experience some
    slowdown. Objects's positions are taken from the position
    file.\nDesactivate this option if you experience some slowdown."""
    subclass = None
    superclass = None
    def __init__(self, hidden=0, isDisplayed=1, Path2D=None, OpticalPropertyLink=None, ThermalPropertyLink=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("urban","_Road")
        self.attrib = ['hidden', 'isDisplayed']
        self.children = ['Path2D', 'OpticalPropertyLink', 'ThermalPropertyLink']
        self.parent = None
        self._hidden = _cast(int, hidden)
        self._isDisplayed = _cast(int, isDisplayed)
        self._Path2D = Path2D
        self._OpticalPropertyLink = OpticalPropertyLink
        self._ThermalPropertyLink = ThermalPropertyLink
        update_node(self,self.troot,"urban")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Road)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Road.subclass:
            return create_Road.subclass(*args_, **kwargs_)
        else:
            return create_Road(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Path2D(self): return self._Path2D
    def set_Path2D(self, value):
        if value is not None:
            checkclass(value, create_Path2D)
            value.parent = self
        self._Path2D = value
    Path2D = property(get_Path2D, set_Path2D)
    def get_OpticalPropertyLink(self): return self._OpticalPropertyLink
    def set_OpticalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_OpticalPropertyLink)
            value.parent = self
        self._OpticalPropertyLink = value
    OpticalPropertyLink = property(get_OpticalPropertyLink, set_OpticalPropertyLink)
    def get_ThermalPropertyLink(self): return self._ThermalPropertyLink
    def set_ThermalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_ThermalPropertyLink)
            value.parent = self
        self._ThermalPropertyLink = value
    ThermalPropertyLink = property(get_ThermalPropertyLink, set_ThermalPropertyLink)
    def get_hidden(self): return self._hidden
    def set_hidden(self, value):
        self._hidden = value
        update_node(self,self.troot,"urban")
    hidden = property(get_hidden, set_hidden)
    def get_isDisplayed(self): return self._isDisplayed
    def set_isDisplayed(self, value):
        self._isDisplayed = value
        update_node(self,self.troot,"urban")
    isDisplayed = property(get_isDisplayed, set_isDisplayed)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Path2D is not None or
            self.OpticalPropertyLink is not None or
            self.ThermalPropertyLink is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Road', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Road')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Road')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Road', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Road'):
        if self.hidden is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            outfile.write(' hidden="%s"' % self.gds_format_integer(self.hidden, input_name='hidden'))
        if self.isDisplayed is not None and 'isDisplayed' not in already_processed:
            already_processed.add('isDisplayed')
            outfile.write(' isDisplayed="%s"' % self.gds_format_integer(self.isDisplayed, input_name='isDisplayed'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Road', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Path2D is not None:
            self.Path2D.export(outfile, level, namespaceprefix_, name_='Path2D', pretty_print=pretty_print)
        if self.OpticalPropertyLink is not None:
            self.OpticalPropertyLink.export(outfile, level, namespaceprefix_, name_='OpticalPropertyLink', pretty_print=pretty_print)
        if self.ThermalPropertyLink is not None:
            self.ThermalPropertyLink.export(outfile, level, namespaceprefix_, name_='ThermalPropertyLink', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Road', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.hidden is not None:
            element.set('hidden', self.gds_format_integer(self.hidden))
        if self.isDisplayed is not None:
            element.set('isDisplayed', self.gds_format_integer(self.isDisplayed))
        if self.Path2D is not None:
            Path2D_ = self.Path2D
            Path2D_.to_etree(element, name_='Path2D', mapping_=mapping_)
        if self.OpticalPropertyLink is not None:
            OpticalPropertyLink_ = self.OpticalPropertyLink
            OpticalPropertyLink_.to_etree(element, name_='OpticalPropertyLink', mapping_=mapping_)
        if self.ThermalPropertyLink is not None:
            ThermalPropertyLink_ = self.ThermalPropertyLink
            ThermalPropertyLink_.to_etree(element, name_='ThermalPropertyLink', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Road'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.hidden is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            showIndent(outfile, level)
            outfile.write('hidden=%d,\n' % (self.hidden,))
        if self.isDisplayed is not None and 'isDisplayed' not in already_processed:
            already_processed.add('isDisplayed')
            showIndent(outfile, level)
            outfile.write('isDisplayed=%d,\n' % (self.isDisplayed,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Path2D is not None:
            showIndent(outfile, level)
            outfile.write('Path2D=model_._Path2D(\n')
            self.Path2D.exportLiteral(outfile, level, name_='Path2D')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OpticalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('OpticalPropertyLink=model_._OpticalPropertyLink(\n')
            self.OpticalPropertyLink.exportLiteral(outfile, level, name_='OpticalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ThermalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('ThermalPropertyLink=model_._ThermalPropertyLink(\n')
            self.ThermalPropertyLink.exportLiteral(outfile, level, name_='ThermalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hidden', node)
        if value is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            try:
                self.hidden = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isDisplayed', node)
        if value is not None and 'isDisplayed' not in already_processed:
            already_processed.add('isDisplayed')
            try:
                self.isDisplayed = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Path2D':
            obj_ = create_Path2D.factory()
            obj_.build(child_)
            self.set_Path2D(obj_)
            obj_.original_tagname_ = 'Path2D'
        elif nodeName_ == 'OpticalPropertyLink':
            obj_ = create_OpticalPropertyLink.factory()
            obj_.build(child_)
            self.set_OpticalPropertyLink(obj_)
            obj_.original_tagname_ = 'OpticalPropertyLink'
        elif nodeName_ == 'ThermalPropertyLink':
            obj_ = create_ThermalPropertyLink.factory()
            obj_.build(child_)
            self.set_ThermalPropertyLink(obj_)
            obj_.original_tagname_ = 'ThermalPropertyLink'
# end class create_Road


class create_Path2D(GeneratedsSuper):
    """Path2D Path2D interpolation). interpolation)."""
    subclass = None
    superclass = None
    def __init__(self, width=3.000000, Point2D=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("urban","_Path2D")
        self.attrib = ['width']
        self.children = ['Point2D']
        self.parent = None
        self._width = _cast(float, width)
        if Point2D is None:
            self._Point2D = []
        else:
            self._Point2D = Point2D
        update_node(self,self.troot,"urban")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Path2D)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Path2D.subclass:
            return create_Path2D.subclass(*args_, **kwargs_)
        else:
            return create_Path2D(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Point2D(self): return self._Point2D
    def set_Point2D(self, value):
        if value is not None:
            checkclass(value, create_Point2D)
            for v in value:
                v.parent = self
        self._Point2D = value
    def add_Point2D(self, value):
        value.parent = self
        self._Point2D.append(value)
    def insert_Point2D_at(self, index, value):
        value.parent = self
        self.Point2D.insert(index, value)
    def replace_Point2D_at(self, index, value):
        value.parent = self
        self.Point2D[index] = value
    Point2D = property(get_Point2D, set_Point2D)
    def get_width(self): return self._width
    def set_width(self, value):
        self._width = value
        update_node(self,self.troot,"urban")
    width = property(get_width, set_width)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Point2D
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Path2D', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Path2D')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Path2D')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Path2D', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Path2D'):
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Path2D', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Point2D_ in self.Point2D:
            Point2D_.export(outfile, level, namespaceprefix_, name_='Point2D', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_Path2D', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.width is not None:
            element.set('width', self.gds_format_double(self.width))
        for Point2D_ in self.Point2D:
            Point2D_.to_etree(element, name_='Point2D', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Path2D'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            showIndent(outfile, level)
            outfile.write('width=%e,\n' % (self.width,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Point2D=[\n')
        level += 1
        for Point2D_ in self.Point2D:
            showIndent(outfile, level)
            outfile.write('model_._Point2D(\n')
            Point2D_.exportLiteral(outfile, level, name_='_Point2D')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.Point2D = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            try:
                self.width = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (width): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Point2D':
            obj_ = create_Point2D.factory()
            obj_.build(child_)
            self.add_Point2D(obj_)
            obj_.original_tagname_ = 'Point2D'
# end class create_Path2D


class create_Point2D(GeneratedsSuper):
    """Point2D Point2D y coordinate of a point of the road y coordinate of
    a point of the road x coordinate of a point of the road x
    coordinate of a point of the road"""
    subclass = None
    superclass = None
    def __init__(self, y=22.00, x=22.00):
        self.original_tagname_ = None
        self.troot=get_gs_troot("urban","_Point2D")
        self.attrib = ['y', 'x']
        self.children = []
        self.parent = None
        self._y = _cast(float, y)
        self._x = _cast(float, x)
        update_node(self,self.troot,"urban")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_Point2D)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_Point2D.subclass:
            return create_Point2D.subclass(*args_, **kwargs_)
        else:
            return create_Point2D(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_y(self): return self._y
    def set_y(self, value):
        self._y = value
        update_node(self,self.troot,"urban")
    y = property(get_y, set_y)
    def get_x(self): return self._x
    def set_x(self, value):
        self._x = value
        update_node(self,self.troot,"urban")
    x = property(get_x, set_x)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_Point2D', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_Point2D')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_Point2D')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_Point2D', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_Point2D'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y="%s"' % self.gds_format_double(self.y, input_name='y'))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name='x'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_Point2D', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='_Point2D', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.y is not None:
            element.set('y', self.gds_format_double(self.y))
        if self.x is not None:
            element.set('x', self.gds_format_double(self.x))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_Point2D'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            showIndent(outfile, level)
            outfile.write('y=%e,\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            showIndent(outfile, level)
            outfile.write('x=%e,\n' % (self.x,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            try:
                self.y = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (y): %s' % exp)
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            try:
                self.x = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class create_Point2D


class create_SmallWalls(GeneratedsSuper):
    """SmallWalls SmallWalls"""
    subclass = None
    superclass = None
    def __init__(self, SmallWall=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("urban","_SmallWalls")
        self.attrib = ['']
        self.children = ['SmallWall']
        self.parent = None
        if SmallWall is None:
            self._SmallWall = []
        else:
            self._SmallWall = SmallWall
        update_node(self,self.troot,"urban")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_SmallWalls)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_SmallWalls.subclass:
            return create_SmallWalls.subclass(*args_, **kwargs_)
        else:
            return create_SmallWalls(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SmallWall(self): return self._SmallWall
    def set_SmallWall(self, value):
        if value is not None:
            checkclass(value, create_SmallWall)
            for v in value:
                v.parent = self
        self._SmallWall = value
    def add_SmallWall(self, value):
        value.parent = self
        self._SmallWall.append(value)
    def insert_SmallWall_at(self, index, value):
        value.parent = self
        self.SmallWall.insert(index, value)
    def replace_SmallWall_at(self, index, value):
        value.parent = self
        self.SmallWall[index] = value
    SmallWall = property(get_SmallWall, set_SmallWall)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.SmallWall
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_SmallWalls', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_SmallWalls')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_SmallWalls')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_SmallWalls', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_SmallWalls'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_SmallWalls', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SmallWall_ in self.SmallWall:
            SmallWall_.export(outfile, level, namespaceprefix_, name_='SmallWall', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_SmallWalls', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        for SmallWall_ in self.SmallWall:
            SmallWall_.to_etree(element, name_='SmallWall', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_SmallWalls'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('SmallWall=[\n')
        level += 1
        for SmallWall_ in self.SmallWall:
            showIndent(outfile, level)
            outfile.write('model_._SmallWall(\n')
            SmallWall_.exportLiteral(outfile, level, name_='_SmallWall')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.SmallWall = []
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SmallWall':
            obj_ = create_SmallWall.factory()
            obj_.build(child_)
            self.add_SmallWall(obj_)
            obj_.original_tagname_ = 'SmallWall'
# end class create_SmallWalls


class create_SmallWall(GeneratedsSuper):
    """SmallWall SmallWall If you select this option, this wall are not use
    in all DART modules, \n it's useful if you want conserve wall
    properties backup without delete this for tests If you select
    this option, this wall are not use in all DART modules, \n it's
    useful if you want conserve wall properties backup without
    delete this for tests - Double faces : \ninternal and external
    faces \n -Simple face : \nonly external faces - Double faces :
    \ninternal and external faces \n -Simple face : \nonly external
    faces Objects's positions are taken from the position
    file.\nDesactivate this option if you experience some slowdown.
    Objects's positions are taken from the position
    file.\nDesactivate this option if you experience some slowdown."""
    subclass = None
    superclass = None
    def __init__(self, hidden=0, doubleFaceBuilding=1, isDisplayed=1, Polygon3D=None, ExternalFacesOpticalPropertyLink=None, ExternalFacesThermalPropertyLink=None, InternalFacesOpticalPropertyLink=None, InternalFacesThermalPropertyLink=None):
        self.original_tagname_ = None
        self.troot=get_gs_troot("urban","_SmallWall")
        self.attrib = ['hidden', 'doubleFaceBuilding', 'isDisplayed']
        self.children = ['Polygon3D', 'ExternalFacesOpticalPropertyLink', 'ExternalFacesThermalPropertyLink', 'InternalFacesOpticalPropertyLink', 'InternalFacesThermalPropertyLink']
        self.parent = None
        self._hidden = _cast(int, hidden)
        self._doubleFaceBuilding = _cast(int, doubleFaceBuilding)
        self._isDisplayed = _cast(int, isDisplayed)
        self._Polygon3D = Polygon3D
        self._ExternalFacesOpticalPropertyLink = ExternalFacesOpticalPropertyLink
        self._ExternalFacesThermalPropertyLink = ExternalFacesThermalPropertyLink
        self._InternalFacesOpticalPropertyLink = InternalFacesOpticalPropertyLink
        self._InternalFacesThermalPropertyLink = InternalFacesThermalPropertyLink
        update_node(self,self.troot,"urban")
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, create_SmallWall)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if create_SmallWall.subclass:
            return create_SmallWall.subclass(*args_, **kwargs_)
        else:
            return create_SmallWall(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Polygon3D(self): return self._Polygon3D
    def set_Polygon3D(self, value):
        if value is not None:
            checkclass(value, create_Polygon3D)
            value.parent = self
        self._Polygon3D = value
    Polygon3D = property(get_Polygon3D, set_Polygon3D)
    def get_ExternalFacesOpticalPropertyLink(self): return self._ExternalFacesOpticalPropertyLink
    def set_ExternalFacesOpticalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_ExternalFacesOpticalPropertyLink)
            value.parent = self
        self._ExternalFacesOpticalPropertyLink = value
    ExternalFacesOpticalPropertyLink = property(get_ExternalFacesOpticalPropertyLink, set_ExternalFacesOpticalPropertyLink)
    def get_ExternalFacesThermalPropertyLink(self): return self._ExternalFacesThermalPropertyLink
    def set_ExternalFacesThermalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_ExternalFacesThermalPropertyLink)
            value.parent = self
        self._ExternalFacesThermalPropertyLink = value
    ExternalFacesThermalPropertyLink = property(get_ExternalFacesThermalPropertyLink, set_ExternalFacesThermalPropertyLink)
    def get_InternalFacesOpticalPropertyLink(self): return self._InternalFacesOpticalPropertyLink
    def set_InternalFacesOpticalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_InternalFacesOpticalPropertyLink)
            value.parent = self
        self._InternalFacesOpticalPropertyLink = value
    InternalFacesOpticalPropertyLink = property(get_InternalFacesOpticalPropertyLink, set_InternalFacesOpticalPropertyLink)
    def get_InternalFacesThermalPropertyLink(self): return self._InternalFacesThermalPropertyLink
    def set_InternalFacesThermalPropertyLink(self, value):
        if value is not None:
            checkclass(value, create_InternalFacesThermalPropertyLink)
            value.parent = self
        self._InternalFacesThermalPropertyLink = value
    InternalFacesThermalPropertyLink = property(get_InternalFacesThermalPropertyLink, set_InternalFacesThermalPropertyLink)
    def get_hidden(self): return self._hidden
    def set_hidden(self, value):
        self._hidden = value
        update_node(self,self.troot,"urban")
    hidden = property(get_hidden, set_hidden)
    def get_doubleFaceBuilding(self): return self._doubleFaceBuilding
    def set_doubleFaceBuilding(self, value):
        self._doubleFaceBuilding = value
        update_node(self,self.troot,"urban")
    doubleFaceBuilding = property(get_doubleFaceBuilding, set_doubleFaceBuilding)
    def get_isDisplayed(self): return self._isDisplayed
    def set_isDisplayed(self, value):
        self._isDisplayed = value
        update_node(self,self.troot,"urban")
    isDisplayed = property(get_isDisplayed, set_isDisplayed)
    def copy(self):
        obj_ = self.factory()
        return(obj_.build(self.to_etree()))
    def hasContent_(self):
        if (
            self.Polygon3D is not None or
            self.ExternalFacesOpticalPropertyLink is not None or
            self.ExternalFacesThermalPropertyLink is not None or
            self.InternalFacesOpticalPropertyLink is not None or
            self.InternalFacesThermalPropertyLink is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='_SmallWall', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('_SmallWall')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='_SmallWall')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='_SmallWall', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='_SmallWall'):
        if self.hidden is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            outfile.write(' hidden="%s"' % self.gds_format_integer(self.hidden, input_name='hidden'))
        if self.doubleFaceBuilding is not None and 'doubleFaceBuilding' not in already_processed:
            already_processed.add('doubleFaceBuilding')
            outfile.write(' doubleFaceBuilding="%s"' % self.gds_format_integer(self.doubleFaceBuilding, input_name='doubleFaceBuilding'))
        if self.isDisplayed is not None and 'isDisplayed' not in already_processed:
            already_processed.add('isDisplayed')
            outfile.write(' isDisplayed="%s"' % self.gds_format_integer(self.isDisplayed, input_name='isDisplayed'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='_SmallWall', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Polygon3D is not None:
            self.Polygon3D.export(outfile, level, namespaceprefix_, name_='Polygon3D', pretty_print=pretty_print)
        if self.ExternalFacesOpticalPropertyLink is not None:
            self.ExternalFacesOpticalPropertyLink.export(outfile, level, namespaceprefix_, name_='ExternalFacesOpticalPropertyLink', pretty_print=pretty_print)
        if self.ExternalFacesThermalPropertyLink is not None:
            self.ExternalFacesThermalPropertyLink.export(outfile, level, namespaceprefix_, name_='ExternalFacesThermalPropertyLink', pretty_print=pretty_print)
        if self.InternalFacesOpticalPropertyLink is not None:
            self.InternalFacesOpticalPropertyLink.export(outfile, level, namespaceprefix_, name_='InternalFacesOpticalPropertyLink', pretty_print=pretty_print)
        if self.InternalFacesThermalPropertyLink is not None:
            self.InternalFacesThermalPropertyLink.export(outfile, level, namespaceprefix_, name_='InternalFacesThermalPropertyLink', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='_SmallWall', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_)
        if self.hidden is not None:
            element.set('hidden', self.gds_format_integer(self.hidden))
        if self.doubleFaceBuilding is not None:
            element.set('doubleFaceBuilding', self.gds_format_integer(self.doubleFaceBuilding))
        if self.isDisplayed is not None:
            element.set('isDisplayed', self.gds_format_integer(self.isDisplayed))
        if self.Polygon3D is not None:
            Polygon3D_ = self.Polygon3D
            Polygon3D_.to_etree(element, name_='Polygon3D', mapping_=mapping_)
        if self.ExternalFacesOpticalPropertyLink is not None:
            ExternalFacesOpticalPropertyLink_ = self.ExternalFacesOpticalPropertyLink
            ExternalFacesOpticalPropertyLink_.to_etree(element, name_='ExternalFacesOpticalPropertyLink', mapping_=mapping_)
        if self.ExternalFacesThermalPropertyLink is not None:
            ExternalFacesThermalPropertyLink_ = self.ExternalFacesThermalPropertyLink
            ExternalFacesThermalPropertyLink_.to_etree(element, name_='ExternalFacesThermalPropertyLink', mapping_=mapping_)
        if self.InternalFacesOpticalPropertyLink is not None:
            InternalFacesOpticalPropertyLink_ = self.InternalFacesOpticalPropertyLink
            InternalFacesOpticalPropertyLink_.to_etree(element, name_='InternalFacesOpticalPropertyLink', mapping_=mapping_)
        if self.InternalFacesThermalPropertyLink is not None:
            InternalFacesThermalPropertyLink_ = self.InternalFacesThermalPropertyLink
            InternalFacesThermalPropertyLink_.to_etree(element, name_='InternalFacesThermalPropertyLink', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='_SmallWall'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.hidden is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            showIndent(outfile, level)
            outfile.write('hidden=%d,\n' % (self.hidden,))
        if self.doubleFaceBuilding is not None and 'doubleFaceBuilding' not in already_processed:
            already_processed.add('doubleFaceBuilding')
            showIndent(outfile, level)
            outfile.write('doubleFaceBuilding=%d,\n' % (self.doubleFaceBuilding,))
        if self.isDisplayed is not None and 'isDisplayed' not in already_processed:
            already_processed.add('isDisplayed')
            showIndent(outfile, level)
            outfile.write('isDisplayed=%d,\n' % (self.isDisplayed,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Polygon3D is not None:
            showIndent(outfile, level)
            outfile.write('Polygon3D=model_._Polygon3D(\n')
            self.Polygon3D.exportLiteral(outfile, level, name_='Polygon3D')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ExternalFacesOpticalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('ExternalFacesOpticalPropertyLink=model_._ExternalFacesOpticalPropertyLink(\n')
            self.ExternalFacesOpticalPropertyLink.exportLiteral(outfile, level, name_='ExternalFacesOpticalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ExternalFacesThermalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('ExternalFacesThermalPropertyLink=model_._ExternalFacesThermalPropertyLink(\n')
            self.ExternalFacesThermalPropertyLink.exportLiteral(outfile, level, name_='ExternalFacesThermalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InternalFacesOpticalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('InternalFacesOpticalPropertyLink=model_._InternalFacesOpticalPropertyLink(\n')
            self.InternalFacesOpticalPropertyLink.exportLiteral(outfile, level, name_='InternalFacesOpticalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InternalFacesThermalPropertyLink is not None:
            showIndent(outfile, level)
            outfile.write('InternalFacesThermalPropertyLink=model_._InternalFacesThermalPropertyLink(\n')
            self.InternalFacesThermalPropertyLink.exportLiteral(outfile, level, name_='InternalFacesThermalPropertyLink')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hidden', node)
        if value is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            try:
                self.hidden = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('doubleFaceBuilding', node)
        if value is not None and 'doubleFaceBuilding' not in already_processed:
            already_processed.add('doubleFaceBuilding')
            try:
                self.doubleFaceBuilding = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isDisplayed', node)
        if value is not None and 'isDisplayed' not in already_processed:
            already_processed.add('isDisplayed')
            try:
                self.isDisplayed = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Polygon3D':
            obj_ = create_Polygon3D.factory()
            obj_.build(child_)
            self.set_Polygon3D(obj_)
            obj_.original_tagname_ = 'Polygon3D'
        elif nodeName_ == 'ExternalFacesOpticalPropertyLink':
            obj_ = create_ExternalFacesOpticalPropertyLink.factory()
            obj_.build(child_)
            self.set_ExternalFacesOpticalPropertyLink(obj_)
            obj_.original_tagname_ = 'ExternalFacesOpticalPropertyLink'
        elif nodeName_ == 'ExternalFacesThermalPropertyLink':
            obj_ = create_ExternalFacesThermalPropertyLink.factory()
            obj_.build(child_)
            self.set_ExternalFacesThermalPropertyLink(obj_)
            obj_.original_tagname_ = 'ExternalFacesThermalPropertyLink'
        elif nodeName_ == 'InternalFacesOpticalPropertyLink':
            obj_ = create_InternalFacesOpticalPropertyLink.factory()
            obj_.build(child_)
            self.set_InternalFacesOpticalPropertyLink(obj_)
            obj_.original_tagname_ = 'InternalFacesOpticalPropertyLink'
        elif nodeName_ == 'InternalFacesThermalPropertyLink':
            obj_ = create_InternalFacesThermalPropertyLink.factory()
            obj_.build(child_)
            self.set_InternalFacesThermalPropertyLink(obj_)
            obj_.original_tagname_ = 'InternalFacesThermalPropertyLink'
# end class create_SmallWall


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <createParser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DartFile'
        rootClass = createDartFile
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from urban import *\n\n')
        sys.stdout.write('import urban as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "createDartFile",
    "create_Building",
    "create_Buildings",
    "create_ExternalFacesOpticalPropertyLink",
    "create_ExternalFacesThermalPropertyLink",
    "create_House",
    "create_InnerOpticalProperties",
    "create_InnerThermalProperties",
    "create_InternalFacesOpticalPropertyLink",
    "create_InternalFacesThermalPropertyLink",
    "create_OpticalProperties",
    "create_OpticalPropertyLink",
    "create_Path2D",
    "create_Point2D",
    "create_Point3D",
    "create_Polygon3D",
    "create_Road",
    "create_Roads",
    "create_RoofClassic",
    "create_RoofComplex",
    "create_RoofNone",
    "create_RoofPlate",
    "create_RoofProperties",
    "create_SmallWall",
    "create_SmallWalls",
    "create_ThermalProperties",
    "create_ThermalPropertyLink",
    "create_Urban",
    "create_Wall",
    "create_WallProperties"
]
